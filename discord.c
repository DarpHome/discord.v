
#ifndef V_COMMIT_HASH
	#define V_COMMIT_HASH "140c838"
#endif

#define V_USE_SIGNAL_H

// V comptime_definitions:
// V compile time defines by -d or -define flags:
//     All custom defines      : gcboehm,gcboehm_full,gcboehm_opt
//     Turned ON custom defines: gcboehm,gcboehm_full,gcboehm_opt
#define CUSTOM_DEFINE_gcboehm
#define CUSTOM_DEFINE_gcboehm_full
#define CUSTOM_DEFINE_gcboehm_opt

#define __VTHREADS__ (1)
#define _VGCBOEHM (1)
#define _VAUTOFREE (0)

// V typedefs:
typedef struct IError IError;
typedef struct log__Logger log__Logger;
typedef struct discord__Component discord__Component;
typedef struct discord__Image discord__Image;
typedef struct io__Writer io__Writer;
typedef struct x__json2__Encodable x__json2__Encodable;
typedef struct x__json2__Decodable x__json2__Decodable;
typedef struct net__http__Handler net__http__Handler;
typedef struct io__Reader io__Reader;
typedef struct io__RandomReader io__RandomReader;
typedef struct io__ReaderWriter io__ReaderWriter;
typedef struct io__RandomWriter io__RandomWriter;
typedef struct rand__PRNG rand__PRNG;
typedef struct hash__Hasher hash__Hasher;
typedef struct hash__Hash32er hash__Hash32er;
typedef struct hash__Hash64er hash__Hash64er;
typedef struct none none;
typedef struct x__json2__Any x__json2__Any;
typedef struct _option_string _option_string;
typedef struct discord__DispatchEvent_T_discord__GatewayClient discord__DispatchEvent_T_discord__GatewayClient;
typedef struct _option_discord__Snowflake _option_discord__Snowflake;
typedef struct _option_int _option_int;
typedef struct _option_Array_discord__Snowflake _option_Array_discord__Snowflake;
typedef struct _option_Array_discord__DefaultValue _option_Array_discord__DefaultValue;
typedef struct _option_Array_discord__ChannelType _option_Array_discord__ChannelType;
typedef struct _option_bool _option_bool;
typedef struct _option_anon_fn_int_ierror _option_anon_fn_int_ierror;
typedef struct discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient;
typedef struct _option_anon_fn_mut_net__http__request__result_void _option_anon_fn_mut_net__http__request__result_void;
typedef struct _option_x__json2__Any _option_x__json2__Any;
typedef struct _option_discord__Image _option_discord__Image;
typedef struct discord__Chan_T_discord__DispatchEvent_T_discord__GatewayClient discord__Chan_T_discord__DispatchEvent_T_discord__GatewayClient;
typedef struct discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient;
typedef struct _option_anon_fn_discord__dispatchevent_t_discord__gatewayclient__bool _option_anon_fn_discord__dispatchevent_t_discord__gatewayclient__bool;
typedef struct discord__EventWaitParams_T_discord__DispatchEvent_T_discord__GatewayClient discord__EventWaitParams_T_discord__DispatchEvent_T_discord__GatewayClient;
typedef struct _option_time__Duration _option_time__Duration;
typedef struct _option_discord__Properties _option_discord__Properties;
typedef struct _option_discord__PartialEmoji _option_discord__PartialEmoji;
typedef struct _option_discord__UserFlags _option_discord__UserFlags;
typedef struct _option_discord__PremiumType _option_discord__PremiumType;
typedef struct _option_discord__AvatarDecorationData _option_discord__AvatarDecorationData;
typedef struct _option_time__Time _option_time__Time;
typedef struct _option_discord__RoleTags _option_discord__RoleTags;
typedef struct _option_discord__WelcomeScreen _option_discord__WelcomeScreen;
typedef struct _option_discord__User _option_discord__User;
typedef struct _option_discord__Permissions _option_discord__Permissions;

// BEGIN_array_fixed_return_typedefs
// END_array_fixed_return_typedefs


// BEGIN_multi_return_typedefs
typedef struct multi_return_u32_u32 multi_return_u32_u32;
typedef struct multi_return_string_string multi_return_string_string;
typedef struct multi_return_int_int multi_return_int_int;
typedef struct multi_return_u32_u32_u32 multi_return_u32_u32_u32;
typedef struct multi_return_strconv__ParserState_strconv__PrepNumber multi_return_strconv__ParserState_strconv__PrepNumber;
typedef struct multi_return_u64_int multi_return_u64_int;
typedef struct multi_return_strconv__Dec32_bool multi_return_strconv__Dec32_bool;
typedef struct multi_return_strconv__Dec64_bool multi_return_strconv__Dec64_bool;
typedef struct multi_return_string_x__json2__Any multi_return_string_x__json2__Any;
typedef struct multi_return_string_int multi_return_string_int;
typedef struct multi_return_int_bool multi_return_int_bool;
typedef struct multi_return_u64_u64 multi_return_u64_u64;
typedef struct multi_return_f64_int multi_return_f64_int;
typedef struct multi_return_int_int_int multi_return_int_int_int;
typedef struct multi_return_int_int_int_int_int_i64_bool multi_return_int_int_int_int_int_i64_bool;
typedef struct multi_return_net__http__Method_net__urllib__URL_net__http__Version multi_return_net__http__Method_net__urllib__URL_net__http__Version;
typedef struct multi_return_Map_string_string_Map_string_Array_net__http__FileData multi_return_Map_string_string_Map_string_Array_net__http__FileData;
typedef struct multi_return_string_int_string multi_return_string_int_string;
typedef struct multi_return_string_ref_net__websocket__ServerClient multi_return_string_ref_net__websocket__ServerClient;
typedef struct multi_return_int_net__Addr multi_return_int_net__Addr;
typedef struct multi_return_string_u16 multi_return_string_u16;
typedef struct multi_return_f64_f64 multi_return_f64_f64;
typedef struct multi_return_u64_u8 multi_return_u64_u8;
typedef struct multi_return_os__File_string multi_return_os__File_string;
typedef struct multi_return_ref_u16_ref_sync__Subscription multi_return_ref_u16_ref_sync__Subscription;
// END_multi_return_typedefs

typedef struct strconv__BF_param strconv__BF_param;
typedef struct strconv__PrepNumber strconv__PrepNumber;
typedef struct strconv__Dec32 strconv__Dec32;
typedef struct strconv__Dec64 strconv__Dec64;
typedef struct strconv__Uint128 strconv__Uint128;
typedef union strconv__Uf32 strconv__Uf32;
typedef union strconv__Uf64 strconv__Uf64;
typedef union strconv__Float64u strconv__Float64u;
typedef union strconv__Float32u strconv__Float32u;
typedef struct array array;
typedef struct SymbolInfo SymbolInfo;
typedef struct SymbolInfoContainer SymbolInfoContainer;
typedef struct Line64 Line64;
typedef struct GCHeapUsage GCHeapUsage;
typedef struct VCastTypeIndexName VCastTypeIndexName;
typedef struct VAssertMetaInfo VAssertMetaInfo;
typedef struct MethodArgs MethodArgs;
typedef struct FunctionData FunctionData;
typedef struct EnumData EnumData;
typedef struct FieldData FieldData;
typedef struct StructAttribute StructAttribute;
typedef struct ExceptionRecord ExceptionRecord;
typedef struct ContextRecord ContextRecord;
typedef struct ExceptionPointers ExceptionPointers;
typedef struct DenseArray DenseArray;
typedef struct map map;
typedef struct Option Option;
typedef struct _option _option;
typedef struct None__ None__;
typedef struct _result _result;
typedef struct Error Error;
typedef struct MessageError MessageError;
typedef struct SortedMap SortedMap;
typedef struct mapnode mapnode;
typedef struct string string;
typedef struct RepIndex RepIndex;
typedef union StrIntpMem StrIntpMem;
typedef struct StrIntpCgenData StrIntpCgenData;
typedef struct StrIntpData StrIntpData;
typedef struct net__urllib__URL net__urllib__URL;
typedef struct net__urllib__Userinfo net__urllib__Userinfo;
typedef struct net__urllib__ParseAuthorityRes net__urllib__ParseAuthorityRes;
typedef struct net__urllib__QueryValue net__urllib__QueryValue;
typedef struct net__urllib__Values net__urllib__Values;
typedef struct time__DateTimeParser time__DateTimeParser;
typedef struct time__TimeParseError time__TimeParseError;
typedef struct time__StopWatchOptions time__StopWatchOptions;
typedef struct time__StopWatch time__StopWatch;
typedef struct time__Time time__Time;
typedef struct time__SystemTime time__SystemTime;
typedef struct arrays__WindowAttribute arrays__WindowAttribute;
typedef struct arrays__Block arrays__Block;
typedef struct arrays__UnalignedBlock arrays__UnalignedBlock;
typedef union encoding__base64__B64_64_datablock encoding__base64__B64_64_datablock;
typedef union encoding__base64__B64_32_datablock encoding__base64__B64_32_datablock;
typedef struct strings__textscanner__TextScanner strings__textscanner__TextScanner;
typedef struct io__BufferedReader io__BufferedReader;
typedef struct io__BufferedReaderConfig io__BufferedReaderConfig;
typedef struct io__MultiWriter io__MultiWriter;
typedef struct io__Eof io__Eof;
typedef struct io__NotExpected io__NotExpected;
typedef struct io__ReadAllConfig io__ReadAllConfig;
typedef struct io__ReaderWriterImpl io__ReaderWriterImpl;
typedef struct net__http__chunked__ChunkScanner net__http__chunked__ChunkScanner;
typedef struct encoding__utf8__Utf8State encoding__utf8__Utf8State;
typedef struct encoding__utf8__RangeTable encoding__utf8__RangeTable;
typedef struct encoding__utf8__Range16 encoding__utf8__Range16;
typedef struct encoding__utf8__Range32 encoding__utf8__Range32;
typedef struct rand__buffer__PRNGBuffer rand__buffer__PRNGBuffer;
typedef struct os__Eof os__Eof;
typedef struct os__NotExpected os__NotExpected;
typedef struct os__File os__File;
typedef struct os__FileInfo os__FileInfo;
typedef struct os__FileNotOpenedError os__FileNotOpenedError;
typedef struct os__SizeOfTypeIs0Error os__SizeOfTypeIs0Error;
typedef struct os__FilePermission os__FilePermission;
typedef struct os__FileMode os__FileMode;
typedef struct os__PathKind os__PathKind;
typedef struct os__Result os__Result;
typedef struct os__Command os__Command;
typedef struct os__ExecutableNotFoundError os__ExecutableNotFoundError;
typedef struct os__MkdirParams os__MkdirParams;
typedef struct os__Uname os__Uname;
typedef struct os__Filetime os__Filetime;
typedef struct os__Win32finddata os__Win32finddata;
typedef struct os__ProcessInformation os__ProcessInformation;
typedef struct os__StartupInfo os__StartupInfo;
typedef struct os__SecurityAttributes os__SecurityAttributes;
typedef struct os__ExceptionRecord os__ExceptionRecord;
typedef struct os__ContextRecord os__ContextRecord;
typedef struct os__ExceptionPointers os__ExceptionPointers;
typedef struct os__Process os__Process;
typedef struct os__WProcess os__WProcess;
typedef struct x__json2__DecodeError x__json2__DecodeError;
typedef struct x__json2__InvalidTokenError x__json2__InvalidTokenError;
typedef struct x__json2__UnknownTokenError x__json2__UnknownTokenError;
typedef struct x__json2__Parser x__json2__Parser;
typedef struct x__json2__Encoder x__json2__Encoder;
typedef struct x__json2__CharLengthIterator x__json2__CharLengthIterator;
typedef struct x__json2__Scanner x__json2__Scanner;
typedef struct x__json2__Token x__json2__Token;
typedef struct x__json2__Null x__json2__Null;
typedef struct crypto__sha1__Digest crypto__sha1__Digest;
typedef struct term__Coord term__Coord;
typedef struct rand__config__PRNGConfigStruct rand__config__PRNGConfigStruct;
typedef struct rand__config__NormalConfigStruct rand__config__NormalConfigStruct;
typedef struct rand__config__ShuffleConfigStruct rand__config__ShuffleConfigStruct;
typedef struct rand__wyrand__WyRandRNG rand__wyrand__WyRandRNG;
typedef struct sync__Subscription sync__Subscription;
typedef struct sync__Channel sync__Channel;
typedef struct sync__ManyTimes sync__ManyTimes;
typedef struct sync__Once sync__Once;
typedef struct sync__Mutex sync__Mutex;
typedef struct sync__RwMutex sync__RwMutex;
typedef struct sync__Semaphore sync__Semaphore;
typedef struct sync__WaitGroup sync__WaitGroup;
typedef struct io__util__TempFileOptions io__util__TempFileOptions;
typedef struct io__util__TempDirOptions io__util__TempDirOptions;
typedef struct log__Log log__Log;
typedef struct log__ThreadSafeLog log__ThreadSafeLog;
typedef union net__AddrData net__AddrData;
typedef struct net__Ip6 net__Ip6;
typedef struct net__Ip net__Ip;
typedef struct net__Unix net__Unix;
typedef struct net__Addr net__Addr;
typedef struct net__ShutdownConfig net__ShutdownConfig;
typedef struct net__Socket net__Socket;
typedef struct net__TcpConn net__TcpConn;
typedef struct net__TcpListener net__TcpListener;
typedef struct net__ListenOptions net__ListenOptions;
typedef struct net__TcpSocket net__TcpSocket;
typedef struct net__UdpSocket net__UdpSocket;
typedef struct net__UdpConn net__UdpConn;
typedef struct net__mbedtls__SSLCerts net__mbedtls__SSLCerts;
typedef struct net__mbedtls__SSLConn net__mbedtls__SSLConn;
typedef struct net__mbedtls__SSLListener net__mbedtls__SSLListener;
typedef struct net__mbedtls__SSLConnectConfig net__mbedtls__SSLConnectConfig;
typedef struct net__ssl__SSLConn net__ssl__SSLConn;
typedef struct net__ssl__SSLConnectConfig net__ssl__SSLConnectConfig;
typedef struct net__http__Cookie net__http__Cookie;
typedef struct net__http__HeaderKV net__http__HeaderKV;
typedef struct net__http__Header net__http__Header;
typedef struct net__http__HeaderConfig net__http__HeaderConfig;
typedef struct net__http__HeaderCoerceConfig net__http__HeaderCoerceConfig;
typedef struct net__http__HeaderQueryConfig net__http__HeaderQueryConfig;
typedef struct net__http__HeaderRenderConfig net__http__HeaderRenderConfig;
typedef struct net__http__HeaderKeyError net__http__HeaderKeyError;
typedef struct net__http__FetchConfig net__http__FetchConfig;
typedef struct net__http__PostMultipartFormConfig net__http__PostMultipartFormConfig;
typedef struct net__http__HttpProxy net__http__HttpProxy;
typedef struct net__http__Request net__http__Request;
typedef struct net__http__FileData net__http__FileData;
typedef struct net__http__UnexpectedExtraAttributeError net__http__UnexpectedExtraAttributeError;
typedef struct net__http__MultiplePathAttributesError net__http__MultiplePathAttributesError;
typedef struct net__http__LineSegmentIndexes net__http__LineSegmentIndexes;
typedef struct net__http__Response net__http__Response;
typedef struct net__http__ResponseConfig net__http__ResponseConfig;
typedef struct net__http__Server net__http__Server;
typedef struct net__http__WaitTillRunningParams net__http__WaitTillRunningParams;
typedef struct net__http__HandlerWorker net__http__HandlerWorker;
typedef struct net__http__DebugHandler net__http__DebugHandler;
typedef struct net__websocket__MessageEventHandler net__websocket__MessageEventHandler;
typedef struct net__websocket__ErrorEventHandler net__websocket__ErrorEventHandler;
typedef struct net__websocket__OpenEventHandler net__websocket__OpenEventHandler;
typedef struct net__websocket__CloseEventHandler net__websocket__CloseEventHandler;
typedef struct net__websocket__Fragment net__websocket__Fragment;
typedef struct net__websocket__Frame net__websocket__Frame;
typedef struct net__websocket__Uri net__websocket__Uri;
typedef struct net__websocket__ClientState net__websocket__ClientState;
typedef struct net__websocket__Client net__websocket__Client;
typedef struct net__websocket__Message net__websocket__Message;
typedef struct net__websocket__ClientOpt net__websocket__ClientOpt;
typedef struct net__websocket__ServerState net__websocket__ServerState;
typedef struct net__websocket__Server net__websocket__Server;
typedef struct net__websocket__ServerClient net__websocket__ServerClient;
typedef struct net__websocket__ServerOpt net__websocket__ServerOpt;
typedef struct discord__WithReason discord__WithReason;
typedef struct discord__Properties discord__Properties;
typedef struct discord__DispatchEvent discord__DispatchEvent;
typedef struct discord__Client discord__Client;
typedef struct discord__ClientConfig discord__ClientConfig;
typedef struct discord__BotConfig discord__BotConfig;
typedef struct discord__ActionRow discord__ActionRow;
typedef struct discord__Button discord__Button;
typedef struct discord__SelectOption discord__SelectOption;
typedef struct discord__StringSelect discord__StringSelect;
typedef struct discord__UserSelect discord__UserSelect;
typedef struct discord__RoleSelect discord__RoleSelect;
typedef struct discord__DefaultValue discord__DefaultValue;
typedef struct discord__MentionableSelect discord__MentionableSelect;
typedef struct discord__ChannelSelect discord__ChannelSelect;
typedef struct discord__TextInput discord__TextInput;
typedef struct discord__CreateGroupDMParams discord__CreateGroupDMParams;
typedef struct discord__PartialEmoji discord__PartialEmoji;
typedef struct discord__Emoji discord__Emoji;
typedef struct discord__Entitlement discord__Entitlement;
typedef struct discord__ListEntitlementParams discord__ListEntitlementParams;
typedef struct discord__CreateTestEntitlementParams discord__CreateTestEntitlementParams;
typedef struct discord__RestError discord__RestError;
typedef struct discord__Unauthorized discord__Unauthorized;
typedef struct discord__Forbidden discord__Forbidden;
typedef struct discord__NotFound discord__NotFound;
typedef struct discord__InternalServerError discord__InternalServerError;
typedef struct discord__Ratelimit discord__Ratelimit;
typedef struct discord__Chan discord__Chan;
typedef struct discord__EventWaiter discord__EventWaiter;
typedef struct discord__EventController discord__EventController;
typedef struct discord__EmitOptions discord__EmitOptions;
typedef struct discord__EventWaitParams discord__EventWaitParams;
typedef struct discord__GatewayClient discord__GatewayClient;
typedef struct discord__PartialGuild discord__PartialGuild;
typedef struct discord__FetchMyGuildsParams discord__FetchMyGuildsParams;
typedef struct discord__RoleTags discord__RoleTags;
typedef struct discord__Role discord__Role;
typedef struct discord__WelcomeChannel discord__WelcomeChannel;
typedef struct discord__WelcomeScreen discord__WelcomeScreen;
typedef struct discord__Guild discord__Guild;
typedef struct discord__GuildMember discord__GuildMember;
typedef struct discord__RequestOptions discord__RequestOptions;
typedef struct discord__JpegImage discord__JpegImage;
typedef struct discord__PngImage discord__PngImage;
typedef struct discord__GifImage discord__GifImage;
typedef struct discord__Interaction discord__Interaction;
typedef struct discord__InteractionCreateEvent discord__InteractionCreateEvent;
typedef struct discord__Sku discord__Sku;
typedef struct discord__Sticker discord__Sticker;
typedef struct discord__AvatarDecorationData discord__AvatarDecorationData;
typedef struct discord__User discord__User;
typedef struct discord__MyUserEdit discord__MyUserEdit;
typedef struct discord__WSMessage discord__WSMessage;
typedef struct __shared__net__websocket__ServerState __shared__net__websocket__ServerState;
typedef struct __shared__net__websocket__ClientState __shared__net__websocket__ClientState;
typedef struct _result_void _result_void;
typedef struct _result_bool _result_bool;
typedef struct _result_int _result_int;
typedef struct _result_f64 _result_f64;
typedef struct _result_u64 _result_u64;
typedef struct _result_i64 _result_i64;
typedef struct _result_rune _result_rune;
typedef struct _result_string _result_string;
typedef struct _result_Array_string _result_Array_string;
typedef struct _result_net__urllib__URL _result_net__urllib__URL;
typedef struct _result_net__urllib__ParseAuthorityRes _result_net__urllib__ParseAuthorityRes;
typedef struct _result_net__urllib__Values _result_net__urllib__Values;
typedef struct _result_time__Time _result_time__Time;
typedef struct _result_multi_return_int_int_int _result_multi_return_int_int_int;
typedef struct _result_multi_return_int_int_int_int_int_i64_bool _result_multi_return_int_int_int_int_int_i64_bool;
typedef struct _result_voidptr _result_voidptr;
typedef struct _result_Array_u8 _result_Array_u8;
typedef struct _result_multi_return_u64_u8 _result_multi_return_u64_u8;
typedef struct _result_os__File _result_os__File;
typedef struct _result_FILE_ptr _result_FILE_ptr;
typedef struct _result_strings__Builder _result_strings__Builder;
typedef struct _result_os__Result _result_os__Result;
typedef struct _result_anon_fn_os__signal _result_anon_fn_os__signal;
typedef struct _result_x__json2__Any _result_x__json2__Any;
typedef struct _result_term__Coord _result_term__Coord;
typedef struct _result_u32 _result_u32;
typedef struct _result_f32 _result_f32;
typedef struct _result_multi_return_f64_f64 _result_multi_return_f64_f64;
typedef struct _result_multi_return_os__File_string _result_multi_return_os__File_string;
typedef struct _result_multi_return_string_string _result_multi_return_string_string;
typedef struct _result_net__Addr _result_net__Addr;
typedef struct _result_Array_net__Addr _result_Array_net__Addr;
typedef struct _result_multi_return_string_u16 _result_multi_return_string_u16;
typedef struct _result_net__TcpConn_ptr _result_net__TcpConn_ptr;
typedef struct _result_net__TcpSocket _result_net__TcpSocket;
typedef struct _result_net__TcpListener_ptr _result_net__TcpListener_ptr;
typedef struct _result_net__UdpConn_ptr _result_net__UdpConn_ptr;
typedef struct _result_net__UdpSocket_ptr _result_net__UdpSocket_ptr;
typedef struct _result_multi_return_int_net__Addr _result_multi_return_int_net__Addr;
typedef struct _result_u16 _result_u16;
typedef struct _result_net__mbedtls__SSLListener_ptr _result_net__mbedtls__SSLListener_ptr;
typedef struct _result_net__mbedtls__SSLConn_ptr _result_net__mbedtls__SSLConn_ptr;
typedef struct _result_net__ssl__SSLConn_ptr _result_net__ssl__SSLConn_ptr;
typedef struct _result_net__http__Response _result_net__http__Response;
typedef struct _result_net__http__Cookie _result_net__http__Cookie;
typedef struct _result_net__http__Header _result_net__http__Header;
typedef struct _result_net__http__HttpProxy_ptr _result_net__http__HttpProxy_ptr;
typedef struct _result_net__http__Request _result_net__http__Request;
typedef struct _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version;
typedef struct _result_multi_return_string_int_string _result_multi_return_string_int_string;
typedef struct _result_multi_return_int_int _result_multi_return_int_int;
typedef struct _result_multi_return_string_ref_net__websocket__ServerClient _result_multi_return_string_ref_net__websocket__ServerClient;
typedef struct _result_net__websocket__Message _result_net__websocket__Message;
typedef struct _result_net__websocket__Frame _result_net__websocket__Frame;
typedef struct _result_net__websocket__Client_ptr _result_net__websocket__Client_ptr;
typedef struct _result_net__websocket__Uri_ptr _result_net__websocket__Uri_ptr;
typedef struct _result_discord__Emoji _result_discord__Emoji;
typedef struct _result_discord__Snowflake _result_discord__Snowflake;
typedef struct _result_discord__User _result_discord__User;
typedef struct _result_discord__Entitlement _result_discord__Entitlement;
typedef struct _result_Array_discord__Entitlement _result_Array_discord__Entitlement;
typedef struct _result_discord__WSMessage _result_discord__WSMessage;
typedef struct _result_discord__PartialGuild _result_discord__PartialGuild;
typedef struct _result_discord__Permissions _result_discord__Permissions;
typedef struct _result_Array_discord__PartialGuild _result_Array_discord__PartialGuild;
typedef struct _result_discord__RoleTags _result_discord__RoleTags;
typedef struct _result_discord__Role _result_discord__Role;
typedef struct _result_discord__WelcomeChannel _result_discord__WelcomeChannel;
typedef struct _result_discord__WelcomeScreen _result_discord__WelcomeScreen;
typedef struct _result_discord__Guild _result_discord__Guild;
typedef struct _result_discord__Sticker _result_discord__Sticker;
typedef struct _result_discord__GuildMember _result_discord__GuildMember;
typedef struct _result_discord__Interaction _result_discord__Interaction;
typedef struct _result_discord__Sku _result_discord__Sku;
typedef struct _result_Array_discord__Sku _result_Array_discord__Sku;
typedef struct _result_discord__AvatarDecorationData _result_discord__AvatarDecorationData;
typedef struct _option_multi_return_string_string _option_multi_return_string_string;
typedef struct _option_u8 _option_u8;
typedef struct _option_rune _option_rune;
typedef struct _option_log__Level _option_log__Level;
typedef struct _option_log__LogTarget _option_log__LogTarget;
typedef struct _option_net__http__Cookie _option_net__http__Cookie;
typedef struct _option_net__TcpConn_ptr _option_net__TcpConn_ptr;
typedef struct _option_net__websocket__ServerClient_ptr _option_net__websocket__ServerClient_ptr;
typedef struct _option_discord__DispatchEvent_T_discord__GatewayClient _option_discord__DispatchEvent_T_discord__GatewayClient;
typedef struct _option_anon_fn_t__bool _option_anon_fn_t__bool;

 // V preincludes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

// V cheaders:
// Generated by the V compiler

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

#if defined(__has_include)

#if __has_include(<inttypes.h>)
#include <inttypes.h>
#else
#error VERROR_MESSAGE The C compiler can not find <inttypes.h>. Please install build-essentials
#endif

#else
#include <inttypes.h>
#endif


#if defined(__has_include)

#if __has_include(<stddef.h>)
#include <stddef.h>
#else
#error VERROR_MESSAGE The C compiler can not find <stddef.h>. Please install build-essentials
#endif

#else
#include <stddef.h>
#endif


//================================== builtin types ================================*/
typedef int64_t i64;
typedef int16_t i16;
typedef int8_t i8;
typedef uint64_t u64;
typedef uint32_t u32;
typedef uint8_t u8;
typedef uint16_t u16;
typedef u8 byte;
typedef int32_t i32;
typedef uint32_t rune;
typedef size_t usize;
typedef ptrdiff_t isize;
#ifndef VNOFLOAT
typedef float f32;
typedef double f64;
#else
typedef int32_t f32;
typedef int64_t f64;
#endif
typedef int64_t int_literal;
#ifndef VNOFLOAT
typedef double float_literal;
#else
typedef int64_t float_literal;
#endif
typedef unsigned char* byteptr;
typedef void* voidptr;
typedef char* charptr;
typedef u8 array_fixed_byte_300 [300];

typedef struct sync__Channel* chan;

#ifndef __cplusplus
	#ifndef bool
		#ifdef CUSTOM_DEFINE_4bytebool
			typedef int bool;
		#else
			typedef u8 bool;
		#endif
		#define true 1
		#define false 0
	#endif
#endif

typedef u64 (*MapHashFn)(voidptr);
typedef bool (*MapEqFn)(voidptr, voidptr);
typedef void (*MapCloneFn)(voidptr, voidptr);
typedef void (*MapFreeFn)(voidptr);

//============================== HELPER C MACROS =============================*/
// _SLIT0 is used as NULL string for literal arguments
// `"" s` is used to enforce a string literal argument
#define _SLIT0 (string){.str=(byteptr)(""), .len=0, .is_lit=1}
#define _SLIT(s) ((string){.str=(byteptr)("" s), .len=(sizeof(s)-1), .is_lit=1})
#define _SLEN(s, n) ((string){.str=(byteptr)("" s), .len=n, .is_lit=1})

// take the address of an rvalue
#define ADDR(type, expr) (&((type[]){expr}[0]))

// copy something to the heap
#define HEAP(type, expr) ((type*)memdup((void*)&((type[]){expr}[0]), sizeof(type)))
#define HEAP_noscan(type, expr) ((type*)memdup_noscan((void*)&((type[]){expr}[0]), sizeof(type)))

#define _PUSH_MANY(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many(arr, tmp.data, tmp.len);}
#define _PUSH_MANY_noscan(arr, val, tmp, tmp_typ) {tmp_typ tmp = (val); array_push_many_noscan(arr, tmp.data, tmp.len);}

// unsigned/signed comparisons
static inline bool _us32_gt(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a > b; }
static inline bool _us32_ge(uint32_t a, int32_t b) { return a >= INT32_MAX || (int32_t)a >= b; }
static inline bool _us32_eq(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a == b; }
static inline bool _us32_ne(uint32_t a, int32_t b) { return a > INT32_MAX || (int32_t)a != b; }
static inline bool _us32_le(uint32_t a, int32_t b) { return a <= INT32_MAX && (int32_t)a <= b; }
static inline bool _us32_lt(uint32_t a, int32_t b) { return a < INT32_MAX && (int32_t)a < b; }
static inline bool _us64_gt(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a > b; }
static inline bool _us64_ge(uint64_t a, int64_t b) { return a >= INT64_MAX || (int64_t)a >= b; }
static inline bool _us64_eq(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a == b; }
static inline bool _us64_ne(uint64_t a, int64_t b) { return a > INT64_MAX || (int64_t)a != b; }
static inline bool _us64_le(uint64_t a, int64_t b) { return a <= INT64_MAX && (int64_t)a <= b; }
static inline bool _us64_lt(uint64_t a, int64_t b) { return a < INT64_MAX && (int64_t)a < b; }

#define EMPTY_VARG_INITIALIZATION 0
#define EMPTY_STRUCT_DECLARATION
#define EMPTY_STRUCT_INITIALIZATION
// Due to a tcc bug, the length of an array needs to be specified, but GCC crashes if it is...
#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[])
#define TCCSKIP(x) x

#define __NOINLINE __attribute__((noinline))
#define __IRQHANDLER __attribute__((interrupt))

#define __V_architecture 0
#if defined(__x86_64__) || defined(_M_AMD64)
	#define __V_amd64  1
	#undef __V_architecture
	#define __V_architecture 1
#endif

#if defined(__aarch64__) || defined(__arm64__) || defined(_M_ARM64)
	#define __V_arm64  1
	#undef __V_architecture
	#define __V_architecture 2
#endif

#if defined(__arm__) || defined(_M_ARM)
	#define __V_arm32  1
	#undef __V_architecture
	#define __V_architecture 3
#endif

#if defined(__riscv) && __riscv_xlen == 64
	#define __V_rv64  1
	#undef __V_architecture
	#define __V_architecture 4
#endif

#if defined(__riscv) && __riscv_xlen == 32
	#define __V_rv32  1
	#undef __V_architecture
	#define __V_architecture 5
#endif

#if defined(__i386__) || defined(_M_IX86)
	#define __V_x86    1
	#undef __V_architecture
	#define __V_architecture 6
#endif

// Using just __GNUC__ for detecting gcc, is not reliable because other compilers define it too:
#ifdef __GNUC__
	#define __V_GCC__
#endif
#ifdef __TINYC__
	#undef __V_GCC__
#endif
#ifdef __cplusplus
	#undef __V_GCC__
#endif
#ifdef __clang__
	#undef __V_GCC__
#endif

#ifdef _MSC_VER
	#undef __V_GCC__
	#undef EMPTY_STRUCT_DECLARATION
	#undef EMPTY_STRUCT_INITIALIZATION
	#define EMPTY_STRUCT_DECLARATION unsigned char _dummy_pad
	#define EMPTY_STRUCT_INITIALIZATION 0
#endif

#ifndef _WIN32
	#if defined __has_include
		#if __has_include (<execinfo.h>)
			#include <execinfo.h>
		#else
			// On linux: int backtrace(void **__array, int __size);
			// On BSD: size_t backtrace(void **, size_t);
		#endif
	#endif
#endif

#ifdef __TINYC__
	#define _Atomic volatile
	#undef EMPTY_STRUCT_DECLARATION
	#undef EMPTY_STRUCT_INITIALIZATION
	#define EMPTY_STRUCT_DECLARATION unsigned char _dummy_pad
	#define EMPTY_STRUCT_INITIALIZATION 0
	#undef EMPTY_ARRAY_OF_ELEMS
	#define EMPTY_ARRAY_OF_ELEMS(x,n) (x[n])
	#undef __NOINLINE
	#undef __IRQHANDLER
	// tcc does not support inlining at all
	#define __NOINLINE
	#define __IRQHANDLER
	#undef TCCSKIP
	#define TCCSKIP(x)
	// #include <byteswap.h>
	#ifndef _WIN32
		int tcc_backtrace(const char *fmt, ...);
	#endif
#endif

// Use __offsetof_ptr instead of __offset_of, when you *do* have a valid pointer, to avoid UB:
#ifndef __offsetof_ptr
	#define __offsetof_ptr(ptr,PTYPE,FIELDNAME) ((size_t)((byte *)&((PTYPE *)ptr)->FIELDNAME - (byte *)ptr))
#endif

// for __offset_of
#ifndef __offsetof
	#define __offsetof(PTYPE,FIELDNAME) ((size_t)(&((PTYPE *)0)->FIELDNAME))
#endif

#define OPTION_CAST(x) (x)

#ifndef V64_PRINTFORMAT
	#ifdef PRIx64
		#define V64_PRINTFORMAT "0x%"PRIx64
	#elif defined(__WIN32__)
		#define V64_PRINTFORMAT "0x%I64x"
	#elif defined(__linux__) && defined(__LP64__)
		#define V64_PRINTFORMAT "0x%lx"
	#else
		#define V64_PRINTFORMAT "0x%llx"
	#endif
#endif

#if defined(_WIN32) || defined(__CYGWIN__)
	#define VV_EXPORTED_SYMBOL extern __declspec(dllexport)
	#define VV_LOCAL_SYMBOL static
#else
	// 4 < gcc < 5 is used by some older Ubuntu LTS and Centos versions,
	// and does not support __has_attribute(visibility) ...
	#ifndef __has_attribute
		#define __has_attribute(x) 0  // Compatibility with non-clang compilers.
	#endif
	#if (defined(__GNUC__) && (__GNUC__ >= 4)) || (defined(__clang__) && __has_attribute(visibility))
		#ifdef ARM
			#define VV_EXPORTED_SYMBOL  extern __attribute__((externally_visible,visibility("default")))
		#else
			#define VV_EXPORTED_SYMBOL  extern __attribute__((visibility("default")))
		#endif
		#if defined(__clang__) && (defined(_VUSECACHE) || defined(_VBUILDMODULE))
			#define VV_LOCAL_SYMBOL static
		#else
			#define VV_LOCAL_SYMBOL  __attribute__ ((visibility ("hidden")))
		#endif
	#else
		#define VV_EXPORTED_SYMBOL extern
		#define VV_LOCAL_SYMBOL static
	#endif
#endif

#ifdef __cplusplus
	#include <utility>
	#define _MOV std::move
#else
	#define _MOV
#endif

// tcc does not support has_include properly yet, turn it off completely
#if defined(__TINYC__) && defined(__has_include)
#undef __has_include
#endif


#if !defined(VWEAK)
	#define VWEAK __attribute__((weak))
	#ifdef _MSC_VER
		#undef VWEAK
		#define VWEAK
	#endif
	#if defined(__MINGW32__) || defined(__MINGW64__)
		#undef VWEAK
		#define VWEAK
	#endif
#endif

#if !defined(VNORETURN)
	#if defined(__TINYC__)
		#include <stdnoreturn.h>
		#define VNORETURN noreturn
	#endif
	# if !defined(__TINYC__) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
	#  define VNORETURN _Noreturn
	# elif !defined(VNORETURN) && defined(__GNUC__) && __GNUC__ >= 2
	#  define VNORETURN __attribute__((noreturn))
	# endif
	#ifndef VNORETURN
		#define VNORETURN
	#endif
#endif

#if !defined(VUNREACHABLE)
	#if defined(__GNUC__) && !defined(__clang__)
		#define V_GCC_VERSION  (__GNUC__ * 10000L + __GNUC_MINOR__ * 100L + __GNUC_PATCHLEVEL__)
		#if (V_GCC_VERSION >= 40500L) && !defined(__TINYC__)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#if defined(__clang__) && defined(__has_builtin) && !defined(__TINYC__)
		#if __has_builtin(__builtin_unreachable)
			#define VUNREACHABLE()  do { __builtin_unreachable(); } while (0)
		#endif
	#endif
	#ifndef VUNREACHABLE
		#define VUNREACHABLE() do { } while (0)
	#endif
#endif

//likely and unlikely macros
#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)
	#define _likely_(x)  __builtin_expect(x,1)
	#define _unlikely_(x)  __builtin_expect(x,0)
#else
	#define _likely_(x) (x)
	#define _unlikely_(x) (x)
#endif


// c_headers
typedef int (*qsort_callback_func)(const void*, const void*);
#include <stdio.h>  // TODO remove all these includes, define all function signatures and types manually
#include <stdlib.h>
#include <string.h>

#include <stdarg.h> // for va_list

//================================== GLOBALS =================================*/
int load_so(byteptr);
void _vinit(int ___argc, voidptr ___argv);
void _vcleanup(void);
#define sigaction_size sizeof(sigaction);
#define _ARR_LEN(a) ( (sizeof(a)) / (sizeof(a[0])) )

void v_free(voidptr ptr);
//voidptr memdup(voidptr src, isize sz);

#if INTPTR_MAX == INT32_MAX
	#define TARGET_IS_32BIT 1
#elif INTPTR_MAX == INT64_MAX
	#define TARGET_IS_64BIT 1
#else
	#error "The environment is not 32 or 64-bit."
#endif

#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || defined(__BIG_ENDIAN__) || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AARCH64EB__) || defined(_MIBSEB) || defined(__MIBSEB) || defined(__MIBSEB__)
	#define TARGET_ORDER_IS_BIG 1
#elif defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ || defined(__BYTE_ORDER) && __BYTE_ORDER == __LITTLE_ENDIAN || defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) || defined(_M_AMD64) || defined(_M_X64) || defined(_M_IX86)
	#define TARGET_ORDER_IS_LITTLE 1
#else
	#error "Unknown architecture endianness"
#endif

#ifndef _WIN32
	#include <ctype.h>
	#include <locale.h> // tolower
	#include <sys/time.h>
	#include <unistd.h> // sleep
	extern char **environ;
#endif

#if defined(__CYGWIN__) && !defined(_WIN32)
	#error Cygwin is not supported, please use MinGW or Visual Studio.
#endif

#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__DragonFly__) || defined(__vinix__) || defined(__serenity__) || defined(__sun) || defined(__plan9__)
	#include <sys/types.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __OpenBSD__
	#include <sys/types.h>
	#include <sys/resource.h>
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef __NetBSD__
	#include <sys/wait.h> // os__wait uses wait on nix
#endif

#ifdef _WIN32
	#define WINVER 0x0600
	#ifdef _WIN32_WINNT
		#undef _WIN32_WINNT
	#endif
	#define _WIN32_WINNT 0x0600
	#ifndef WIN32_FULL
	#define WIN32_LEAN_AND_MEAN
	#endif
	#ifndef _UNICODE
	#define _UNICODE
	#endif
	#ifndef UNICODE
	#define UNICODE
	#endif
	#include <windows.h>

	#include <io.h> // _waccess
	#include <direct.h> // _wgetcwd
	#ifdef V_USE_SIGNAL_H
	#include <signal.h> // signal and SIGSEGV for segmentation fault handler
	#endif

	#ifdef _MSC_VER
		// On MSVC these are the same (as long as /volatile:ms is passed)
		#define _Atomic volatile

		// MSVC cannot parse some things properly
		#undef OPTION_CAST
		#define OPTION_CAST(x)
		#undef __NOINLINE
		#undef __IRQHANDLER
		#define __NOINLINE __declspec(noinline)
		#define __IRQHANDLER __declspec(naked)

		#include <dbghelp.h>
		#pragma comment(lib, "Dbghelp")
	#endif
#else
	#include <pthread.h>
	#ifndef PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
		// musl does not have that
		#define pthread_rwlockattr_setkind_np(a, b)
	#endif
#endif

// g_live_info is used by live.info()
static void* g_live_info = NULL;

#if defined(__MINGW32__) || defined(__MINGW64__) || (defined(_WIN32) && defined(__TINYC__))
	#undef PRId64
	#undef PRIi64
	#undef PRIo64
	#undef PRIu64
	#undef PRIx64
	#undef PRIX64
	#define PRId64 "lld"
	#define PRIi64 "lli"
	#define PRIo64 "llo"
	#define PRIu64 "llu"
	#define PRIx64 "llx"
	#define PRIX64 "llX"
#endif

#ifdef _VFREESTANDING
#undef _VFREESTANDING
#endif


// ============== wyhash ==============
#ifndef wyhash_final_version_3
#define wyhash_final_version_3

#ifndef WYHASH_CONDOM
// protections that produce different results:
// 1: normal valid behavior
// 2: extra protection against entropy loss (probability=2^-63), aka. "blind multiplication"
#define WYHASH_CONDOM 1
#endif

#ifndef WYHASH_32BIT_MUM
// 0: normal version, slow on 32 bit systems
// 1: faster on 32 bit systems but produces different results, incompatible with wy2u0k function
#define WYHASH_32BIT_MUM 0
#endif

// includes
#include <stdint.h>
#if defined(_MSC_VER) && defined(_M_X64)
	#include <intrin.h>
	#pragma intrinsic(_umul128)
#endif

// 128bit multiply function
static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }
static inline void _wymum(uint64_t *A, uint64_t *B){
#if(WYHASH_32BIT_MUM)
	uint64_t hh=(*A>>32)*(*B>>32), hl=(*A>>32)*(uint32_t)*B, lh=(uint32_t)*A*(*B>>32), ll=(uint64_t)(uint32_t)*A*(uint32_t)*B;
	#if(WYHASH_CONDOM>1)
	*A^=_wyrot(hl)^hh; *B^=_wyrot(lh)^ll;
	#else
	*A=_wyrot(hl)^hh; *B=_wyrot(lh)^ll;
	#endif
#elif defined(__SIZEOF_INT128__) && !defined(VWASM)
	__uint128_t r=*A; r*=*B;
	#if(WYHASH_CONDOM>1)
	*A^=(uint64_t)r; *B^=(uint64_t)(r>>64);
	#else
	*A=(uint64_t)r; *B=(uint64_t)(r>>64);
	#endif
#elif defined(_MSC_VER) && defined(_M_X64)
	#if(WYHASH_CONDOM>1)
	uint64_t  a,  b;
	a=_umul128(*A,*B,&b);
	*A^=a;  *B^=b;
	#else
	*A=_umul128(*A,*B,B);
	#endif
#else
	uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;
	uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;
	lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;
	#if(WYHASH_CONDOM>1)
	*A^=lo;  *B^=hi;
	#else
	*A=lo;  *B=hi;
	#endif
#endif
}

// multiply and xor mix function, aka MUM
static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }

// endian macros
#ifndef WYHASH_LITTLE_ENDIAN
	#ifdef TARGET_ORDER_IS_LITTLE
		#define WYHASH_LITTLE_ENDIAN 1
	#else
		#define WYHASH_LITTLE_ENDIAN 0
	#endif
#endif

// read functions
#if (WYHASH_LITTLE_ENDIAN)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}
#elif !defined(__TINYC__) && (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__))
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}
#elif defined(_MSC_VER)
	static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return _byteswap_uint64(v);}
	static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return _byteswap_ulong(v);}
#else
	static inline uint64_t _wyr8(const uint8_t *p) {
		uint64_t v; memcpy(&v, p, 8);
		return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));
	}
	static inline uint64_t _wyr4(const uint8_t *p) {
		uint32_t v; memcpy(&v, p, 4);
		return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));
	}
#endif
static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}
// wyhash main function
static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){
	const uint8_t *p=(const uint8_t *)key; seed^=*secret;	uint64_t a, b;
	if (_likely_(len<=16)) {
		if (_likely_(len>=4)) { a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }
		else if (_likely_(len>0)) { a=_wyr3(p,len); b=0; }
		else a=b=0;
	} else {
		size_t i=len;
		if (_unlikely_(i>48)) {
			uint64_t see1=seed, see2=seed;
			do {
				seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);
				see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);
				see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);
				p+=48; i-=48;
			} while(_likely_(i>48));
			seed^=see1^see2;
		}
		while(_unlikely_(i>16)) { seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);  i-=16; p+=16; }
		a=_wyr8(p+i-16);  b=_wyr8(p+i-8);
	}
	return _wymix(secret[1]^len,_wymix(a^secret[1],b^seed));
}
// the default secret parameters
static const uint64_t _wyp[4] = {0xa0761d6478bd642full, 0xe7037ed1a0b428dbull, 0x8ebc6af09c88c6e3ull, 0x589965cc75374cc3ull};

// a useful 64bit-64bit mix function to produce deterministic pseudo random numbers that can pass BigCrush and PractRand
static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0xa0761d6478bd642full; B^=0xe7037ed1a0b428dbull; _wymum(&A,&B); return _wymix(A^0xa0761d6478bd642full,B^0xe7037ed1a0b428dbull);}

// the wyrand PRNG that pass BigCrush and PractRand
static inline uint64_t wyrand(uint64_t *seed){ *seed+=0xa0761d6478bd642full; return _wymix(*seed,*seed^0xe7037ed1a0b428dbull);}

#ifndef __vinix__
// convert any 64 bit pseudo random numbers to uniform distribution [0,1). It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2u01(uint64_t r){ const double _wynorm=1.0/(1ull<<52); return (r>>12)*_wynorm;}

// convert any 64 bit pseudo random numbers to APPROXIMATE Gaussian distribution. It can be combined with wyrand, wyhash64 or wyhash.
static inline double wy2gau(uint64_t r){ const double _wynorm=1.0/(1ull<<20); return ((r&0x1fffff)+((r>>21)&0x1fffff)+((r>>42)&0x1fffff))*_wynorm-3.0;}
#endif

#if(!WYHASH_32BIT_MUM)
// fast range integer random number generation on [0,k) credit to Daniel Lemire. May not work when WYHASH_32BIT_MUM=1. It can be combined with wyrand, wyhash64 or wyhash.
static inline uint64_t wy2u0k(uint64_t r, uint64_t k){ _wymum(&r,&k); return k; }
#endif
#endif

#define _IN_MAP(val, m) map_exists(m, val)



// V includes:

#if defined(__TINYC__) && defined(__has_include)
// tcc does not support has_include properly yet, turn it off completely
#undef __has_include
#endif

// added by module `builtin`, file: builtin_d_gcboehm.c.v:103:

#if defined(__has_include)

#if __has_include(<gc.h>)
#include <gc.h>
#else
#error VERROR_MESSAGE Header file <gc.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <gc.h>
#endif


// added by module `builtin`, file: float.c.v:10:

#if defined(__has_include)

#if __has_include(<float.h>)
#include <float.h>
#else
#error VERROR_MESSAGE Header file <float.h>, needed for module `builtin` was not found. Please install the corresponding development headers.
#endif

#else
#include <float.h>
#endif


// added by module `time`, file: time.c.v:6:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif


// added by module `time`, file: time_windows.c.v:6:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `time` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif

// inserted by module `sync.stdatomic`, file: 1.declarations.c.v:8:
/*
     * This file is part of FFmpeg.
     *
     * FFmpeg is free software; you can redistribute it and/or
     * modify it under the terms of the GNU Lesser General Public
     * License as published by the Free Software Foundation; either
     * version 2.1 of the License, or (at your option) any later version.
     *
     * FFmpeg is distributed in the hope that it will be useful,
     * but WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * Lesser General Public License for more details.
     *
     * You should have received a copy of the GNU Lesser General Public
     * License along with FFmpeg; if not, write to the Free Software
     * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
     */

#ifndef COMPAT_ATOMICS_WIN32_STDATOMIC_H
#define COMPAT_ATOMICS_WIN32_STDATOMIC_H

#define WIN32_LEAN_AND_MEAN
#include <stddef.h>
#include <stdint.h>
#include <windows.h>

#ifdef __TINYC__
#endif

#define ATOMIC_FLAG_INIT 0

#define ATOMIC_VAR_INIT(value) (value)

#define atomic_init(obj, value) \
    do                          \
    {                           \
        *(obj) = (value);       \
    } while (0)

#define kill_dependency(y) ((void)0)

#define atomic_thread_fence(order) \
    MemoryBarrier();

#define atomic_signal_fence(order) \
    ((void)0)

#define atomic_is_lock_free(obj) 0

typedef intptr_t atomic_flag;
typedef intptr_t atomic_bool;
typedef intptr_t atomic_char;
typedef intptr_t atomic_schar;
typedef intptr_t atomic_uchar;
typedef intptr_t atomic_short;
typedef intptr_t atomic_ushort;
typedef intptr_t atomic_int;
typedef intptr_t atomic_uint;
typedef intptr_t atomic_long;
typedef intptr_t atomic_ulong;
typedef intptr_t atomic_llong;
typedef intptr_t atomic_ullong;
typedef intptr_t atomic_wchar_t;
typedef intptr_t atomic_int_least8_t;
typedef intptr_t atomic_uint_least8_t;
typedef intptr_t atomic_int_least16_t;
typedef intptr_t atomic_uint_least16_t;
typedef intptr_t atomic_int_least32_t;
typedef intptr_t atomic_uint_least32_t;
typedef intptr_t atomic_int_least64_t;
typedef intptr_t atomic_uint_least64_t;
typedef intptr_t atomic_int_fast8_t;
typedef intptr_t atomic_uint_fast8_t;
typedef intptr_t atomic_int_fast16_t;
typedef intptr_t atomic_uint_fast16_t;
typedef intptr_t atomic_int_fast32_t;
typedef intptr_t atomic_uint_fast32_t;
typedef intptr_t atomic_int_fast64_t;
typedef intptr_t atomic_uint_fast64_t;
typedef intptr_t atomic_intptr_t;
typedef intptr_t atomic_uintptr_t;
typedef intptr_t atomic_size_t;
typedef intptr_t atomic_ptrdiff_t;
typedef intptr_t atomic_intmax_t;
typedef intptr_t atomic_uintmax_t;

#ifdef __TINYC__
/*
    For TCC it is missing the x64 version of _InterlockedExchangeAdd64 so we
    fake it (works the same) with InterlockedCompareExchange64 until it
    succeeds
*/
__CRT_INLINE LONGLONG _InterlockedExchangeAdd64(LONGLONG volatile *Addend, LONGLONG Value)
{
    LONGLONG Old;
    do
    {
        Old = *Addend;
    } while (InterlockedCompareExchange64(Addend, Old + Value, Old) != Old);
    return Old;
}

__CRT_INLINE LONG _InterlockedExchangeAdd(LONG volatile *Addend, LONG Value)
{
    LONG Old;
    do
    {
        Old = *Addend;
    } while (InterlockedCompareExchange(Addend, Old + Value, Old) != Old);
    return Old;
}

__CRT_INLINE SHORT _InterlockedExchangeAdd16(SHORT volatile *Addend, SHORT Value)
{
    SHORT Old;
    do
    {
        Old = *Addend;
    } while (InterlockedCompareExchange16(Addend, Old + Value, Old) != Old);
    return Old;
}

#define InterlockedIncrement64 _InterlockedExchangeAdd64

#endif

#define atomic_store(object, desired) \
    do                                \
    {                                 \
        *(object) = (desired);        \
        MemoryBarrier();              \
    } while (0)

#define atomic_store_explicit(object, desired, order) \
    atomic_store(object, desired)

#define atomic_load(object) \
    (MemoryBarrier(), *(object))

#define atomic_load_explicit(object, order) \
    atomic_load(object)

#define atomic_exchange(object, desired) \
    InterlockedExchangePointer(object, desired)

#define atomic_exchange_explicit(object, desired, order) \
    atomic_exchange(object, desired)

static inline int atomic_compare_exchange_strong(intptr_t *object, intptr_t *expected,
                                                 intptr_t desired)
{
    intptr_t old = *expected;
    *expected = (intptr_t)InterlockedCompareExchangePointer(
        (PVOID *)object, (PVOID)desired, (PVOID)old);
    return *expected == old;
}

#define atomic_compare_exchange_strong_explicit(object, expected, desired, success, failure) \
    atomic_compare_exchange_strong(object, expected, desired)

#define atomic_compare_exchange_weak(object, expected, desired) \
    atomic_compare_exchange_strong(object, expected, desired)

#define atomic_compare_exchange_weak_explicit(object, expected, desired, success, failure) \
    atomic_compare_exchange_weak(object, expected, desired)

#ifdef _WIN64

#define atomic_fetch_add(object, operand) \
    InterlockedExchangeAdd64(object, operand)

#define atomic_fetch_sub(object, operand) \
    InterlockedExchangeAdd64(object, -(operand))

#define atomic_fetch_or(object, operand) \
    InterlockedOr64(object, operand)

#define atomic_fetch_xor(object, operand) \
    InterlockedXor64(object, operand)

#define atomic_fetch_and(object, operand) \
    InterlockedAnd64(object, operand)
#else
#define atomic_fetch_add(object, operand) \
    InterlockedExchangeAdd(object, operand)

#define atomic_fetch_sub(object, operand) \
    InterlockedExchangeAdd(object, -(operand))

#define atomic_fetch_or(object, operand) \
    InterlockedOr(object, operand)

#define atomic_fetch_xor(object, operand) \
    InterlockedXor(object, operand)

#define atomic_fetch_and(object, operand) \
    InterlockedAnd(object, operand)
#endif /* _WIN64 */

/* specialized versions with explicit object size */

#define atomic_load_ptr atomic_load
#define atomic_store_ptr atomic_store
#define atomic_compare_exchange_weak_ptr atomic_compare_exchange_weak
#define atomic_compare_exchange_strong_ptr atomic_compare_exchange_strong
#define atomic_exchange_ptr atomic_exchange
#define atomic_fetch_add_ptr atomic_fetch_add
#define atomic_fetch_sub_ptr atomic_fetch_sub
#define atomic_fetch_and_ptr atomic_fetch_and
#define atomic_fetch_or_ptr atomic_fetch_or
#define atomic_fetch_xor_ptr atomic_fetch_xor

static inline void atomic_store_u64(unsigned long long* object, unsigned long long desired) {
    do {
        *(object) = (desired);
        MemoryBarrier();
    } while (0);
}

static inline unsigned long long atomic_load_u64(unsigned long long* object) {
    return (MemoryBarrier(), *(object));
}

#define atomic_exchange_u64(object, desired) \
    InterlockedExchange64(object, desired)

static inline int atomic_compare_exchange_strong_u64(unsigned long long* object, unsigned long long* expected,
                                                 unsigned long long desired)
{
	unsigned long long old = *expected;
    *expected = InterlockedCompareExchange64(object, desired, old);
    return *expected == old;
}

#define atomic_compare_exchange_weak_u64(object, expected, desired) \
    atomic_compare_exchange_strong_u64(object, expected, desired)

#define atomic_fetch_add_u64(object, operand) \
    InterlockedExchangeAdd64(object, operand)

#define atomic_fetch_sub_u64(object, operand) \
    InterlockedExchangeAdd64(object, -(operand))

#define atomic_fetch_or_u64(object, operand) \
    InterlockedOr64(object, operand)

#define atomic_fetch_xor_u64(object, operand) \
    InterlockedXor64(object, operand)

#define atomic_fetch_and_u64(object, operand) \
    InterlockedAnd64(object, operand)



static inline void atomic_store_u32(unsigned* object, unsigned desired) {
    do {
        *(object) = (desired);
        MemoryBarrier();
    } while (0);
}

static inline unsigned atomic_load_u32(unsigned* object) {
    return (MemoryBarrier(), *(object));
}

#define atomic_exchange_u32(object, desired) \
    InterlockedExchange(object, desired)

static inline int atomic_compare_exchange_strong_u32(unsigned* object, unsigned* expected,
                                                 unsigned desired)
{
	unsigned old = *expected;
    *expected = InterlockedCompareExchange(object, desired, old);
    return *expected == old;
}

#define atomic_compare_exchange_weak_u32(object, expected, desired) \
    atomic_compare_exchange_strong_u32(object, expected, desired)

#define atomic_fetch_add_u32(object, operand) \
    InterlockedExchangeAdd(object, operand)

#define atomic_fetch_sub_u32(object, operand) \
    InterlockedExchangeAdd(object, -(operand))

#define atomic_fetch_or_u32(object, operand) \
    InterlockedOr(object, operand)

#define atomic_fetch_xor_u32(object, operand) \
    InterlockedXor(object, operand)

#define atomic_fetch_and_u32(object, operand) \
    InterlockedAnd(object, operand)



static inline void atomic_store_u16(unsigned short* object, unsigned short desired) {
    do {
        *(object) = (desired);
        MemoryBarrier();
    } while (0);
}

static inline unsigned short atomic_load_u16(unsigned short* object) {
    return (MemoryBarrier(), *(object));
}

#define atomic_exchange_u16(object, desired) \
    InterlockedExchange16(object, desired)

static inline int atomic_compare_exchange_strong_u16(unsigned short* object, unsigned short* expected,
                                                 unsigned short desired)
{
	unsigned short old = *expected;
    *expected = InterlockedCompareExchange16(object, desired, old);
    return *expected == old;
}

#define atomic_compare_exchange_weak_u16(object, expected, desired) \
    atomic_compare_exchange_strong_u16(object, expected, desired)

#define atomic_fetch_add_u16(object, operand) \
    InterlockedExchangeAdd16(object, operand)

#define atomic_fetch_sub_u16(object, operand) \
    InterlockedExchangeAdd16(object, -(operand))

#define atomic_fetch_or_u16(object, operand) \
    InterlockedOr16(object, operand)

#define atomic_fetch_xor_u16(object, operand) \
    InterlockedXor16(object, operand)

#define atomic_fetch_and_u16(object, operand) \
    InterlockedAnd16(object, operand)



#define atomic_fetch_add_explicit(object, operand, order) \
    atomic_fetch_add(object, operand)

#define atomic_fetch_sub_explicit(object, operand, order) \
    atomic_fetch_sub(object, operand)

#define atomic_fetch_or_explicit(object, operand, order) \
    atomic_fetch_or(object, operand)

#define atomic_fetch_xor_explicit(object, operand, order) \
    atomic_fetch_xor(object, operand)

#define atomic_fetch_and_explicit(object, operand, order) \
    atomic_fetch_and(object, operand)

#define atomic_flag_test_and_set(object) \
    atomic_exchange(object, 1)

#define atomic_flag_test_and_set_explicit(object, order) \
    atomic_flag_test_and_set(object)

#define atomic_flag_clear(object) \
    atomic_store(object, 0)

#define atomic_flag_clear_explicit(object, order) \
    atomic_flag_clear(object)

#endif /* COMPAT_ATOMICS_WIN32_STDATOMIC_H */


// added by module `os`, file: fd.c.v:10:

#if defined(__has_include)

#if __has_include(<winsock2.h>)
#include <winsock2.h>
#else
#error VERROR_MESSAGE Header file <winsock2.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <winsock2.h>
#endif


// added by module `os`, file: os.c.v:5:

#if defined(__has_include)

#if __has_include(<sys/stat.h>)
#include <sys/stat.h>
#else
#error VERROR_MESSAGE Header file <sys/stat.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/stat.h>
#endif


// added by module `os`, file: os.c.v:6:
#include <errno.h>

// added by module `os`, file: os_windows.c.v:6:

#if defined(__has_include)

#if __has_include(<process.h>)
#include <process.h>
#else
#error VERROR_MESSAGE Header file <process.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <process.h>
#endif


// added by module `os`, file: os_windows.c.v:7:

#if defined(__has_include)

#if __has_include(<sys/utime.h>)
#include <sys/utime.h>
#else
#error VERROR_MESSAGE Header file <sys/utime.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <sys/utime.h>
#endif


// added by module `os`, file: password_windows.c.v:3:

#if defined(__has_include)

#if __has_include(<windows.h>)
#include <windows.h>
#else
#error VERROR_MESSAGE Header file <windows.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <windows.h>
#endif


// added by module `os`, file: signal.c.v:3:

#if defined(__has_include)

#if __has_include(<signal.h>)
#include <signal.h>
#else
#error VERROR_MESSAGE Header file <signal.h>, needed for module `os` was not found. Please install the corresponding development headers.
#endif

#else
#include <signal.h>
#endif


// added by module `sync`, file: sync_windows.c.v:8:

#if defined(__has_include)

#if __has_include(<synchapi.h>)
#include <synchapi.h>
#else
#error VERROR_MESSAGE Header file <synchapi.h>, needed for module `sync` was not found. Please install the corresponding development headers.
#endif

#else
#include <synchapi.h>
#endif


// added by module `sync`, file: sync_windows.c.v:9:

#if defined(__has_include)

#if __has_include(<time.h>)
#include <time.h>
#else
#error VERROR_MESSAGE Header file <time.h>, needed for module `sync` was not found. Please install the corresponding development headers.
#endif

#else
#include <time.h>
#endif


// added by module `net`, file: aasocket.c.v:6:

#if defined(__has_include)

#if __has_include("D:\Games\Proekti\V\v/vlib/net/ipv6_v6only.h")
#include "D:\Games\Proekti\V\v/vlib/net/ipv6_v6only.h"
#else
#error VERROR_MESSAGE Header file "D:\Games\Proekti\V\v/vlib/net/ipv6_v6only.h", needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include "D:\Games\Proekti\V\v/vlib/net/ipv6_v6only.h"
#endif


// added by module `net`, file: aasocket.c.v:16:

#if defined(__has_include)

#if __has_include("D:\Games\Proekti\V\v/vlib/net/afunix.h")
#include "D:\Games\Proekti\V\v/vlib/net/afunix.h"
#else
#error VERROR_MESSAGE Header file "D:\Games\Proekti\V\v/vlib/net/afunix.h", needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include "D:\Games\Proekti\V\v/vlib/net/afunix.h"
#endif


// added by module `net`, file: net_windows.c.v:747:

#if defined(__has_include)

#if __has_include(<winsock2.h>)
#include <winsock2.h>
#else
#error VERROR_MESSAGE Header file <winsock2.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <winsock2.h>
#endif


// added by module `net`, file: net_windows.c.v:748:

#if defined(__has_include)

#if __has_include(<ws2tcpip.h>)
#include <ws2tcpip.h>
#else
#error VERROR_MESSAGE Header file <ws2tcpip.h>, needed for module `net` was not found. Please install the corresponding development headers.
#endif

#else
#include <ws2tcpip.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:114:

#if defined(__has_include)

#if __has_include(<mbedtls/net_sockets.h>)
#include <mbedtls/net_sockets.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/net_sockets.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/net_sockets.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:115:

#if defined(__has_include)

#if __has_include(<mbedtls/ssl.h>)
#include <mbedtls/ssl.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/ssl.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/ssl.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:116:

#if defined(__has_include)

#if __has_include(<mbedtls/entropy.h>)
#include <mbedtls/entropy.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/entropy.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/entropy.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:117:

#if defined(__has_include)

#if __has_include(<mbedtls/ctr_drbg.h>)
#include <mbedtls/ctr_drbg.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/ctr_drbg.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/ctr_drbg.h>
#endif


// added by module `net.mbedtls`, file: mbedtls.c.v:118:

#if defined(__has_include)

#if __has_include(<mbedtls/error.h>)
#include <mbedtls/error.h>
#else
#error VERROR_MESSAGE Header file <mbedtls/error.h>, needed for module `net.mbedtls` was not found. Please install the corresponding development headers.
#endif

#else
#include <mbedtls/error.h>
#endif

// defined by module `net.http`
#define VSCHANNEL_REALLOC GC_REALLOC

// added by module `net.http`, file: backend_windows.c.v:12:

#if defined(__has_include)

#if __has_include("vschannel.c")
#include "vschannel.c"
#else
#error VERROR_MESSAGE Header file "vschannel.c", needed for module `net.http` was not found. Please install the corresponding development headers.
#endif

#else
#include "vschannel.c"
#endif


// added by module `net.http`, file: download_windows.c.v:9:

#if defined(__has_include)

#if __has_include(<urlmon.h>)
#include <urlmon.h>
#else
#error VERROR_MESSAGE Header file <urlmon.h>, needed for module `net.http` was not found. Please install the corresponding development headers.
#endif

#else
#include <urlmon.h>
#endif


// Enum definitions:

typedef enum {
	strconv__ParserState__ok, // 
	strconv__ParserState__pzero, // +1
	strconv__ParserState__mzero, // +2
	strconv__ParserState__pinf, // +3
	strconv__ParserState__minf, // +4
	strconv__ParserState__invalid_number, // +5
}  strconv__ParserState;

typedef enum {
	strconv__Align_text__right = 0, // 0
	strconv__Align_text__left, // 0+1
	strconv__Align_text__center, // 0+2
}  strconv__Align_text;

typedef enum {
	strconv__Char_parse_state__start, // 
	strconv__Char_parse_state__norm_char, // +1
	strconv__Char_parse_state__field_char, // +2
	strconv__Char_parse_state__pad_ch, // +3
	strconv__Char_parse_state__len_set_start, // +4
	strconv__Char_parse_state__len_set_in, // +5
	strconv__Char_parse_state__check_type, // +6
	strconv__Char_parse_state__check_float, // +7
	strconv__Char_parse_state__check_float_in, // +8
	strconv__Char_parse_state__reset_params, // +9
}  strconv__Char_parse_state;

typedef enum {
	ArrayFlags__noslices = 1U, // u64(1) << 0
	ArrayFlags__noshrink = 2U, // u64(1) << 1
	ArrayFlags__nogrow = 4U, // u64(1) << 2
	ArrayFlags__nofree = 8U, // u64(1) << 3
}  ArrayFlags;

typedef enum {
	AttributeKind__plain, // 
	AttributeKind__string, // +1
	AttributeKind__number, // +2
	AttributeKind__comptime_define, // +3
}  AttributeKind;

typedef enum {
	ChanState__success, // 
	ChanState__not_ready, // +1
	ChanState__closed, // +2
}  ChanState;

typedef enum {
	StrIntpType__si_no_str = 0, // 0
	StrIntpType__si_c, // 0+1
	StrIntpType__si_u8, // 0+2
	StrIntpType__si_i8, // 0+3
	StrIntpType__si_u16, // 0+4
	StrIntpType__si_i16, // 0+5
	StrIntpType__si_u32, // 0+6
	StrIntpType__si_i32, // 0+7
	StrIntpType__si_u64, // 0+8
	StrIntpType__si_i64, // 0+9
	StrIntpType__si_e32, // 0+10
	StrIntpType__si_e64, // 0+11
	StrIntpType__si_f32, // 0+12
	StrIntpType__si_f64, // 0+13
	StrIntpType__si_g32, // 0+14
	StrIntpType__si_g64, // 0+15
	StrIntpType__si_s, // 0+16
	StrIntpType__si_p, // 0+17
	StrIntpType__si_vp, // 0+18
}  StrIntpType;

typedef enum {
	net__urllib__EncodingMode__encode_path, // 
	net__urllib__EncodingMode__encode_path_segment, // +1
	net__urllib__EncodingMode__encode_host, // +2
	net__urllib__EncodingMode__encode_zone, // +3
	net__urllib__EncodingMode__encode_user_password, // +4
	net__urllib__EncodingMode__encode_query_component, // +5
	net__urllib__EncodingMode__encode_fragment, // +6
}  net__urllib__EncodingMode;

typedef enum {
	time__FormatTime__hhmm12, // 
	time__FormatTime__hhmm24, // +1
	time__FormatTime__hhmmss12, // +2
	time__FormatTime__hhmmss24, // +3
	time__FormatTime__hhmmss24_milli, // +4
	time__FormatTime__hhmmss24_micro, // +5
	time__FormatTime__hhmmss24_nano, // +6
	time__FormatTime__no_time, // +7
}  time__FormatTime;

typedef enum {
	time__FormatDate__ddmmyy, // 
	time__FormatDate__ddmmyyyy, // +1
	time__FormatDate__mmddyy, // +2
	time__FormatDate__mmddyyyy, // +3
	time__FormatDate__mmmd, // +4
	time__FormatDate__mmmdd, // +5
	time__FormatDate__mmmddyy, // +6
	time__FormatDate__mmmddyyyy, // +7
	time__FormatDate__no_date, // +8
	time__FormatDate__yyyymmdd, // +9
	time__FormatDate__yymmdd, // +10
}  time__FormatDate;

typedef enum {
	time__FormatDelimiter__dot, // 
	time__FormatDelimiter__hyphen, // +1
	time__FormatDelimiter__slash, // +2
	time__FormatDelimiter__space, // +3
	time__FormatDelimiter__no_delimiter, // +4
}  time__FormatDelimiter;

typedef enum {
	os__SeekMode__start, // 
	os__SeekMode__current, // +1
	os__SeekMode__end, // +2
}  os__SeekMode;

typedef enum {
	os__FileType__regular, // 
	os__FileType__directory, // +1
	os__FileType__character_device, // +2
	os__FileType__block_device, // +3
	os__FileType__fifo, // +4
	os__FileType__symbolic_link, // +5
	os__FileType__socket, // +6
}  os__FileType;

typedef enum {
	os__ChildProcessPipeKind__stdin, // 
	os__ChildProcessPipeKind__stdout, // +1
	os__ChildProcessPipeKind__stderr, // +2
}  os__ChildProcessPipeKind;

typedef enum {
	os__ProcessState__not_started, // 
	os__ProcessState__running, // +1
	os__ProcessState__stopped, // +2
	os__ProcessState__exited, // +3
	os__ProcessState__aborted, // +4
	os__ProcessState__closed, // +5
}  os__ProcessState;

typedef enum {
	os__Signal__hup = 1, // 1
	os__Signal__int = 2, // 2
	os__Signal__quit = 3, // 3
	os__Signal__ill = 4, // 4
	os__Signal__trap = 5, // 5
	os__Signal__abrt = 6, // 6
	os__Signal__bus = 7, // 7
	os__Signal__fpe = 8, // 8
	os__Signal__kill = 9, // 9
	os__Signal__usr1 = 10, // 10
	os__Signal__segv = 11, // 11
	os__Signal__usr2 = 12, // 12
	os__Signal__pipe = 13, // 13
	os__Signal__alrm = 14, // 14
	os__Signal__term = 15, // 15
	os__Signal__stkflt = 16, // 16
	os__Signal__chld = 17, // 17
	os__Signal__cont = 18, // 18
	os__Signal__stop = 19, // 19
	os__Signal__tstp = 20, // 20
	os__Signal__ttin = 21, // 21
	os__Signal__ttou = 22, // 22
	os__Signal__urg = 23, // 23
	os__Signal__xcpu = 24, // 24
	os__Signal__xfsz = 25, // 25
	os__Signal__vtalrm = 26, // 26
	os__Signal__prof = 27, // 27
	os__Signal__winch = 28, // 28
	os__Signal__poll = 29, // 29
	os__Signal__pwr = 30, // 30
	os__Signal__sys = 31, // 31
}  os__Signal;

typedef enum {
	x__json2__TokenKind__none_, // 
	x__json2__TokenKind__error, // +1
	x__json2__TokenKind__str_, // +2
	x__json2__TokenKind__float, // +3
	x__json2__TokenKind__int_, // +4
	x__json2__TokenKind__null, // +5
	x__json2__TokenKind__bool_, // +6
	x__json2__TokenKind__eof, // +7
	x__json2__TokenKind__comma = 44, // 44
	x__json2__TokenKind__colon = 58, // 58
	x__json2__TokenKind__lsbr = 91, // 91
	x__json2__TokenKind__rsbr = 93, // 93
	x__json2__TokenKind__lcbr = 123, // 123
	x__json2__TokenKind__rcbr = 125, // 125
}  x__json2__TokenKind;

typedef enum {
	x__json2__ValueKind__unknown, // 
	x__json2__ValueKind__array, // +1
	x__json2__ValueKind__object, // +2
	x__json2__ValueKind__string_, // +3
	x__json2__ValueKind__number, // +4
}  x__json2__ValueKind;

typedef enum {
	sync__BufferElemStat__unused = 0, // 0
	sync__BufferElemStat__writing, // 0+1
	sync__BufferElemStat__written, // 0+2
	sync__BufferElemStat__reading, // 0+3
}  sync__BufferElemStat;

typedef enum {
	sync__Direction__pop, // 
	sync__Direction__push, // +1
}  sync__Direction;

typedef enum {
	log__Level__disabled = 0, // 0
	log__Level__fatal, // 0+1
	log__Level__error, // 0+2
	log__Level__warn, // 0+3
	log__Level__info, // 0+4
	log__Level__debug, // 0+5
}  log__Level;

typedef enum {
	log__LogTarget__console, // 
	log__LogTarget__file, // +1
	log__LogTarget__both, // +2
}  log__LogTarget;

typedef enum {
	net__Select__read, // 
	net__Select__write, // +1
	net__Select__except, // +2
}  net__Select;

typedef enum {
	net__SocketType__udp = SOCK_DGRAM, // SOCK_DGRAM
	net__SocketType__tcp = SOCK_STREAM, // SOCK_STREAM
	net__SocketType__seqpacket = SOCK_SEQPACKET, // SOCK_SEQPACKET
}  net__SocketType;

typedef enum {
	net__AddrFamily__unix = AF_UNIX, // AF_UNIX
	net__AddrFamily__ip = AF_INET, // AF_INET
	net__AddrFamily__ip6 = AF_INET6, // AF_INET6
	net__AddrFamily__unspec = AF_UNSPEC, // AF_UNSPEC
}  net__AddrFamily;

typedef enum {
	net__ShutdownDirection__read, // 
	net__ShutdownDirection__write, // +1
	net__ShutdownDirection__read_and_write, // +2
}  net__ShutdownDirection;

typedef enum {
	net__WsaError__wsaeintr = 10004, // 10004
	net__WsaError__wsaebadf = 10009, // 10009
	net__WsaError__wsaeacces = 10013, // 10013
	net__WsaError__wsaefault = 10014, // 10014
	net__WsaError__wsaeinval = 10022, // 10022
	net__WsaError__wsaemfile = 10024, // 10024
	net__WsaError__wsaewouldblock = 10035, // 10035
	net__WsaError__wsaeinprogress = 10036, // 10036
	net__WsaError__wsaealready = 10037, // 10037
	net__WsaError__wsaenotsock = 10038, // 10038
	net__WsaError__wsaedestaddrreq = 10039, // 10039
	net__WsaError__wsaemsgsize = 10040, // 10040
	net__WsaError__wsaeprototype = 10041, // 10041
	net__WsaError__wsaenoprotoopt = 10042, // 10042
	net__WsaError__wsaeprotonosupport = 10043, // 10043
	net__WsaError__wsaesocktnosupport = 10044, // 10044
	net__WsaError__wsaeopnotsupp = 10045, // 10045
	net__WsaError__wsaepfnosupport = 10046, // 10046
	net__WsaError__wsaeafnosupport = 10047, // 10047
	net__WsaError__wsaeaddrinuse = 10048, // 10048
	net__WsaError__wsaeaddrnotavail = 10049, // 10049
	net__WsaError__wsaenetdown = 10050, // 10050
	net__WsaError__wsaenetunreach = 10051, // 10051
	net__WsaError__wsaenetreset = 10052, // 10052
	net__WsaError__wsaeconnaborted = 10053, // 10053
	net__WsaError__wsaeconnreset = 10054, // 10054
	net__WsaError__wsaenobufs = 10055, // 10055
	net__WsaError__wsaeisconn = 10056, // 10056
	net__WsaError__wsaenotconn = 10057, // 10057
	net__WsaError__wsaeshutdown = 10058, // 10058
	net__WsaError__wsaetoomanyrefs = 10059, // 10059
	net__WsaError__wsaetimedout = 10060, // 10060
	net__WsaError__wsaeconnrefused = 10061, // 10061
	net__WsaError__wsaeloop = 10062, // 10062
	net__WsaError__wsaenametoolong = 10063, // 10063
	net__WsaError__wsaehostdown = 10064, // 10064
	net__WsaError__wsaehostunreach = 10065, // 10065
	net__WsaError__wsaenotempty = 10066, // 10066
	net__WsaError__wsaeproclim = 10067, // 10067
	net__WsaError__wsaeusers = 10068, // 10068
	net__WsaError__wsaedquot = 10069, // 10069
	net__WsaError__wsaestale = 10070, // 10070
	net__WsaError__wsaeremote = 10071, // 10071
	net__WsaError__wsasysnotready = 10091, // 10091
	net__WsaError__wsavernotsupported = 10092, // 10092
	net__WsaError__wsanotinitialised = 10093, // 10093
	net__WsaError__wsaediscon = 10101, // 10101
	net__WsaError__wsaenomore = 10102, // 10102
	net__WsaError__wsaecancelled = 10103, // 10103
	net__WsaError__wsaeinvalidproctable = 10104, // 10104
	net__WsaError__wsaeinvalidprovider = 10105, // 10105
	net__WsaError__wsaeproviderfailedinit = 10106, // 10106
	net__WsaError__wsasyscallfailure = 10107, // 10107
	net__WsaError__wsaservice_not_found = 10108, // 10108
	net__WsaError__wsatype_not_found = 10109, // 10109
	net__WsaError__wsa_e_no_more = 10110, // 10110
	net__WsaError__wsa_e_cancelled = 10111, // 10111
	net__WsaError__wsaerefused = 10112, // 10112
	net__WsaError__wsahost_not_found = 11001, // 11001
	net__WsaError__wsatry_again = 11002, // 11002
	net__WsaError__wsano_recovery = 11003, // 11003
	net__WsaError__wsano_data = 11004, // 11004
	net__WsaError__wsa_qos_receivers = 11005, // 11005
	net__WsaError__wsa_qos_senders = 11006, // 11006
	net__WsaError__wsa_qos_no_senders = 11007, // 11007
	net__WsaError__wsa_qos_no_receivers = 11008, // 11008
	net__WsaError__wsa_qos_request_confirmed = 11009, // 11009
	net__WsaError__wsa_qos_admission_failure = 11010, // 11010
	net__WsaError__wsa_qos_policy_failure = 11011, // 11011
	net__WsaError__wsa_qos_bad_style = 11012, // 11012
	net__WsaError__wsa_qos_bad_object = 11013, // 11013
	net__WsaError__wsa_qos_traffic_ctrl_error = 11014, // 11014
	net__WsaError__wsa_qos_generic_error = 11015, // 11015
	net__WsaError__wsa_qos_eservicetype = 11016, // 11016
	net__WsaError__wsa_qos_eflowspec = 11017, // 11017
	net__WsaError__wsa_qos_eprovspecbuf = 11018, // 11018
	net__WsaError__wsa_qos_efilterstyle = 11019, // 11019
	net__WsaError__wsa_qos_efiltertype = 11020, // 11020
	net__WsaError__wsa_qos_efiltercount = 11021, // 11021
	net__WsaError__wsa_qos_eobjlength = 11022, // 11022
	net__WsaError__wsa_qos_eflowcount = 11023, // 11023
	net__WsaError__wsa_qos_eunkownpsobj = 11024, // 11024
	net__WsaError__wsa_qos_epolicyobj = 11025, // 11025
	net__WsaError__wsa_qos_eflowdesc = 11026, // 11026
	net__WsaError__wsa_qos_epsflowspec = 11027, // 11027
	net__WsaError__wsa_qos_epsfilterspec = 11028, // 11028
	net__WsaError__wsa_qos_esdmodeobj = 11029, // 11029
	net__WsaError__wsa_qos_eshaperateobj = 11030, // 11030
	net__WsaError__wsa_qos_reserved_petype = 11031, // 11031
	net__WsaError__wsa_secure_host_not_found = 11032, // 11032
	net__WsaError__wsa_ipsec_name_policy_error = 11033, // 11033
}  net__WsaError;

typedef enum {
	net__SocketOption__broadcast = SO_BROADCAST, // SO_BROADCAST
	net__SocketOption__debug = SO_DEBUG, // SO_DEBUG
	net__SocketOption__dont_route = SO_DONTROUTE, // SO_DONTROUTE
	net__SocketOption__error = SO_ERROR, // SO_ERROR
	net__SocketOption__keep_alive = SO_KEEPALIVE, // SO_KEEPALIVE
	net__SocketOption__linger = SO_LINGER, // SO_LINGER
	net__SocketOption__oob_inline = SO_OOBINLINE, // SO_OOBINLINE
	net__SocketOption__reuse_addr = SO_REUSEADDR, // SO_REUSEADDR
	net__SocketOption__receive_buf_size = SO_RCVBUF, // SO_RCVBUF
	net__SocketOption__receive_low_size = SO_RCVLOWAT, // SO_RCVLOWAT
	net__SocketOption__receive_timeout = SO_RCVTIMEO, // SO_RCVTIMEO
	net__SocketOption__send_buf_size = SO_SNDBUF, // SO_SNDBUF
	net__SocketOption__send_low_size = SO_SNDLOWAT, // SO_SNDLOWAT
	net__SocketOption__send_timeout = SO_SNDTIMEO, // SO_SNDTIMEO
	net__SocketOption__socket_type = SO_TYPE, // SO_TYPE
	net__SocketOption__ipv6_only = IPV6_V6ONLY, // IPV6_V6ONLY
}  net__SocketOption;

typedef enum {
	net__mbedtls__Select__read, // 
	net__mbedtls__Select__write, // +1
	net__mbedtls__Select__except, // +2
}  net__mbedtls__Select;

typedef enum {
	net__http__SameSite__same_site_not_set, // 
	net__http__SameSite__same_site_default_mode = 1, // 1
	net__http__SameSite__same_site_lax_mode, // 1+1
	net__http__SameSite__same_site_strict_mode, // 1+2
	net__http__SameSite__same_site_none_mode, // 1+3
}  net__http__SameSite;

typedef enum {
	net__http__CommonHeader__accept, // 
	net__http__CommonHeader__accept_ch, // +1
	net__http__CommonHeader__accept_charset, // +2
	net__http__CommonHeader__accept_ch_lifetime, // +3
	net__http__CommonHeader__accept_encoding, // +4
	net__http__CommonHeader__accept_language, // +5
	net__http__CommonHeader__accept_patch, // +6
	net__http__CommonHeader__accept_post, // +7
	net__http__CommonHeader__accept_ranges, // +8
	net__http__CommonHeader__access_control_allow_credentials, // +9
	net__http__CommonHeader__access_control_allow_headers, // +10
	net__http__CommonHeader__access_control_allow_methods, // +11
	net__http__CommonHeader__access_control_allow_origin, // +12
	net__http__CommonHeader__access_control_expose_headers, // +13
	net__http__CommonHeader__access_control_max_age, // +14
	net__http__CommonHeader__access_control_request_headers, // +15
	net__http__CommonHeader__access_control_request_method, // +16
	net__http__CommonHeader__age, // +17
	net__http__CommonHeader__allow, // +18
	net__http__CommonHeader__alt_svc, // +19
	net__http__CommonHeader__authorization, // +20
	net__http__CommonHeader__authority, // +21
	net__http__CommonHeader__cache_control, // +22
	net__http__CommonHeader__clear_site_data, // +23
	net__http__CommonHeader__connection, // +24
	net__http__CommonHeader__content_disposition, // +25
	net__http__CommonHeader__content_encoding, // +26
	net__http__CommonHeader__content_language, // +27
	net__http__CommonHeader__content_length, // +28
	net__http__CommonHeader__content_location, // +29
	net__http__CommonHeader__content_range, // +30
	net__http__CommonHeader__content_security_policy, // +31
	net__http__CommonHeader__content_security_policy_report_only, // +32
	net__http__CommonHeader__content_type, // +33
	net__http__CommonHeader__cookie, // +34
	net__http__CommonHeader__cross_origin_embedder_policy, // +35
	net__http__CommonHeader__cross_origin_opener_policy, // +36
	net__http__CommonHeader__cross_origin_resource_policy, // +37
	net__http__CommonHeader__date, // +38
	net__http__CommonHeader__device_memory, // +39
	net__http__CommonHeader__digest, // +40
	net__http__CommonHeader__dnt, // +41
	net__http__CommonHeader__early_data, // +42
	net__http__CommonHeader__etag, // +43
	net__http__CommonHeader__expect, // +44
	net__http__CommonHeader__expect_ct, // +45
	net__http__CommonHeader__expires, // +46
	net__http__CommonHeader__feature_policy, // +47
	net__http__CommonHeader__forwarded, // +48
	net__http__CommonHeader__from, // +49
	net__http__CommonHeader__host, // +50
	net__http__CommonHeader__if_match, // +51
	net__http__CommonHeader__if_modified_since, // +52
	net__http__CommonHeader__if_none_match, // +53
	net__http__CommonHeader__if_range, // +54
	net__http__CommonHeader__if_unmodified_since, // +55
	net__http__CommonHeader__index, // +56
	net__http__CommonHeader__keep_alive, // +57
	net__http__CommonHeader__large_allocation, // +58
	net__http__CommonHeader__last_modified, // +59
	net__http__CommonHeader__link, // +60
	net__http__CommonHeader__location, // +61
	net__http__CommonHeader__nel, // +62
	net__http__CommonHeader__origin, // +63
	net__http__CommonHeader__pragma, // +64
	net__http__CommonHeader__proxy_authenticate, // +65
	net__http__CommonHeader__proxy_authorization, // +66
	net__http__CommonHeader__range, // +67
	net__http__CommonHeader__referer, // +68
	net__http__CommonHeader__referrer_policy, // +69
	net__http__CommonHeader__retry_after, // +70
	net__http__CommonHeader__save_data, // +71
	net__http__CommonHeader__sec_fetch_dest, // +72
	net__http__CommonHeader__sec_fetch_mode, // +73
	net__http__CommonHeader__sec_fetch_site, // +74
	net__http__CommonHeader__sec_fetch_user, // +75
	net__http__CommonHeader__sec_websocket_accept, // +76
	net__http__CommonHeader__server, // +77
	net__http__CommonHeader__server_timing, // +78
	net__http__CommonHeader__set_cookie, // +79
	net__http__CommonHeader__sourcemap, // +80
	net__http__CommonHeader__strict_transport_security, // +81
	net__http__CommonHeader__te, // +82
	net__http__CommonHeader__timing_allow_origin, // +83
	net__http__CommonHeader__tk, // +84
	net__http__CommonHeader__trailer, // +85
	net__http__CommonHeader__transfer_encoding, // +86
	net__http__CommonHeader__upgrade, // +87
	net__http__CommonHeader__upgrade_insecure_requests, // +88
	net__http__CommonHeader__user_agent, // +89
	net__http__CommonHeader__vary, // +90
	net__http__CommonHeader__via, // +91
	net__http__CommonHeader__want_digest, // +92
	net__http__CommonHeader__warning, // +93
	net__http__CommonHeader__www_authenticate, // +94
	net__http__CommonHeader__x_content_type_options, // +95
	net__http__CommonHeader__x_dns_prefetch_control, // +96
	net__http__CommonHeader__x_forwarded_for, // +97
	net__http__CommonHeader__x_forwarded_host, // +98
	net__http__CommonHeader__x_forwarded_proto, // +99
	net__http__CommonHeader__x_frame_options, // +100
	net__http__CommonHeader__x_xss_protection, // +101
}  net__http__CommonHeader;

typedef enum {
	net__http__Method__get, // 
	net__http__Method__head, // +1
	net__http__Method__post, // +2
	net__http__Method__put, // +3
	net__http__Method__acl, // +4
	net__http__Method__baseline_control, // +5
	net__http__Method__bind, // +6
	net__http__Method__checkin, // +7
	net__http__Method__checkout, // +8
	net__http__Method__connect, // +9
	net__http__Method__copy, // +10
	net__http__Method__delete, // +11
	net__http__Method__label, // +12
	net__http__Method__link, // +13
	net__http__Method__lock, // +14
	net__http__Method__merge, // +15
	net__http__Method__mkactivity, // +16
	net__http__Method__mkcalendar, // +17
	net__http__Method__mkcol, // +18
	net__http__Method__mkredirectref, // +19
	net__http__Method__mkworkspace, // +20
	net__http__Method__move, // +21
	net__http__Method__options, // +22
	net__http__Method__orderpatch, // +23
	net__http__Method__patch, // +24
	net__http__Method__pri, // +25
	net__http__Method__propfind, // +26
	net__http__Method__proppatch, // +27
	net__http__Method__rebind, // +28
	net__http__Method__report, // +29
	net__http__Method__search, // +30
	net__http__Method__trace, // +31
	net__http__Method__unbind, // +32
	net__http__Method__uncheckout, // +33
	net__http__Method__unlink, // +34
	net__http__Method__unlock, // +35
	net__http__Method__update, // +36
	net__http__Method__updateredirectref, // +37
	net__http__Method__version_control, // +38
}  net__http__Method;

typedef enum {
	net__http__ServerStatus__closed, // 
	net__http__ServerStatus__running, // +1
	net__http__ServerStatus__stopped, // +2
}  net__http__ServerStatus;

typedef enum {
	net__http__Status__unknown = -1, // -1
	net__http__Status__unassigned = 0, // 0
	net__http__Status__cont = 100, // 100
	net__http__Status__switching_protocols = 101, // 101
	net__http__Status__processing = 102, // 102
	net__http__Status__checkpoint_draft = 103, // 103
	net__http__Status__ok = 200, // 200
	net__http__Status__created = 201, // 201
	net__http__Status__accepted = 202, // 202
	net__http__Status__non_authoritative_information = 203, // 203
	net__http__Status__no_content = 204, // 204
	net__http__Status__reset_content = 205, // 205
	net__http__Status__partial_content = 206, // 206
	net__http__Status__multi_status = 207, // 207
	net__http__Status__already_reported = 208, // 208
	net__http__Status__im_used = 226, // 226
	net__http__Status__multiple_choices = 300, // 300
	net__http__Status__moved_permanently = 301, // 301
	net__http__Status__found = 302, // 302
	net__http__Status__see_other = 303, // 303
	net__http__Status__not_modified = 304, // 304
	net__http__Status__use_proxy = 305, // 305
	net__http__Status__switch_proxy = 306, // 306
	net__http__Status__temporary_redirect = 307, // 307
	net__http__Status__permanent_redirect = 308, // 308
	net__http__Status__bad_request = 400, // 400
	net__http__Status__unauthorized = 401, // 401
	net__http__Status__payment_required = 402, // 402
	net__http__Status__forbidden = 403, // 403
	net__http__Status__not_found = 404, // 404
	net__http__Status__method_not_allowed = 405, // 405
	net__http__Status__not_acceptable = 406, // 406
	net__http__Status__proxy_authentication_required = 407, // 407
	net__http__Status__request_timeout = 408, // 408
	net__http__Status__conflict = 409, // 409
	net__http__Status__gone = 410, // 410
	net__http__Status__length_required = 411, // 411
	net__http__Status__precondition_failed = 412, // 412
	net__http__Status__request_entity_too_large = 413, // 413
	net__http__Status__request_uri_too_long = 414, // 414
	net__http__Status__unsupported_media_type = 415, // 415
	net__http__Status__requested_range_not_satisfiable = 416, // 416
	net__http__Status__expectation_failed = 417, // 417
	net__http__Status__im_a_teapot = 418, // 418
	net__http__Status__misdirected_request = 421, // 421
	net__http__Status__unprocessable_entity = 422, // 422
	net__http__Status__locked = 423, // 423
	net__http__Status__failed_dependency = 424, // 424
	net__http__Status__unordered_collection = 425, // 425
	net__http__Status__upgrade_required = 426, // 426
	net__http__Status__precondition_required = 428, // 428
	net__http__Status__too_many_requests = 429, // 429
	net__http__Status__request_header_fields_too_large = 431, // 431
	net__http__Status__unavailable_for_legal_reasons = 451, // 451
	net__http__Status__client_closed_request = 499, // 499
	net__http__Status__internal_server_error = 500, // 500
	net__http__Status__not_implemented = 501, // 501
	net__http__Status__bad_gateway = 502, // 502
	net__http__Status__service_unavailable = 503, // 503
	net__http__Status__gateway_timeout = 504, // 504
	net__http__Status__http_version_not_supported = 505, // 505
	net__http__Status__variant_also_negotiates = 506, // 506
	net__http__Status__insufficient_storage = 507, // 507
	net__http__Status__loop_detected = 508, // 508
	net__http__Status__bandwidth_limit_exceeded = 509, // 509
	net__http__Status__not_extended = 510, // 510
	net__http__Status__network_authentication_required = 511, // 511
}  net__http__Status;

typedef enum {
	net__http__Version__unknown, // 
	net__http__Version__v1_1, // +1
	net__http__Version__v2_0, // +2
	net__http__Version__v1_0, // +3
}  net__http__Version;

typedef enum {
	net__websocket__Flag__has_accept, // 
	net__websocket__Flag__has_connection, // +1
	net__websocket__Flag__has_upgrade, // +2
}  net__websocket__Flag;

typedef enum {
	net__websocket__State__connecting = 0, // 0
	net__websocket__State__open, // 0+1
	net__websocket__State__closing, // 0+2
	net__websocket__State__closed, // 0+3
}  net__websocket__State;

typedef enum {
	net__websocket__OPCode__continuation = 0x00, // 0x00
	net__websocket__OPCode__text_frame = 0x01, // 0x01
	net__websocket__OPCode__binary_frame = 0x02, // 0x02
	net__websocket__OPCode__close = 0x08, // 0x08
	net__websocket__OPCode__ping = 0x09, // 0x09
	net__websocket__OPCode__pong = 0x0A, // 0x0A
}  net__websocket__OPCode;

typedef enum {
	discord__ChannelType__guild_text = 0, // 0
	discord__ChannelType__dm = 1, // 1
	discord__ChannelType__guild_voice = 2, // 2
	discord__ChannelType__group_dm = 3, // 3
	discord__ChannelType__guild_category = 4, // 4
	discord__ChannelType__guild_announcement = 5, // 5
	discord__ChannelType__announcement_thread = 10, // 10
	discord__ChannelType__public_thread = 11, // 11
	discord__ChannelType__private_thread = 12, // 12
	discord__ChannelType__guild_stage_voice = 13, // 13
	discord__ChannelType__guild_directory = 14, // 14
	discord__ChannelType__guild_forum = 15, // 15
	discord__ChannelType__guild_media = 16, // 16
}  discord__ChannelType;

typedef enum {
	discord__ComponentType__action_row = 1, // 1
	discord__ComponentType__button = 2, // 2
	discord__ComponentType__string_select = 3, // 3
	discord__ComponentType__text_input = 4, // 4
	discord__ComponentType__user_select = 5, // 5
	discord__ComponentType__role_select = 6, // 6
	discord__ComponentType__mentionable_select = 7, // 7
	discord__ComponentType__channel_select = 8, // 8
}  discord__ComponentType;

typedef enum {
	discord__ButtonStyle__primary = 1, // 1
	discord__ButtonStyle__secondary = 2, // 2
	discord__ButtonStyle__success = 3, // 3
	discord__ButtonStyle__danger = 4, // 4
	discord__ButtonStyle__link = 5, // 5
}  discord__ButtonStyle;

typedef enum {
	discord__DefaultValueType__user, // 
	discord__DefaultValueType__role, // +1
	discord__DefaultValueType__channel, // +2
}  discord__DefaultValueType;

typedef enum {
	discord__TextInputStyle__short = 1, // 1
	discord__TextInputStyle__paragraph = 2, // 2
}  discord__TextInputStyle;

typedef enum {
	discord__EntitlementType__application_subscription = 8, // 8
}  discord__EntitlementType;

typedef enum {
	discord__OwnerType__guild = 1, // 1
	discord__OwnerType__user, // 1+1
}  discord__OwnerType;

typedef enum {
	discord__VerificationLevel__none_, // 
	discord__VerificationLevel__low, // +1
	discord__VerificationLevel__medium, // +2
	discord__VerificationLevel__high, // +3
	discord__VerificationLevel__very_high, // +4
}  discord__VerificationLevel;

typedef enum {
	discord__MessageNotificationsLevel__all_messages, // 
	discord__MessageNotificationsLevel__only_mentions, // +1
}  discord__MessageNotificationsLevel;

typedef enum {
	discord__ExplicitContentFilterLevel__disabled, // 
	discord__ExplicitContentFilterLevel__members_without_roles, // +1
	discord__ExplicitContentFilterLevel__all_members, // +2
}  discord__ExplicitContentFilterLevel;

typedef enum {
	discord__MFALevel__none_, // 
	discord__MFALevel__elevated, // +1
}  discord__MFALevel;

typedef enum {
	discord__RoleFlags__in_prompt = 1U, // u64(1) << 0
}  discord__RoleFlags;

typedef enum {
	discord__SystemChannelFlags__suppress_join_notifications = 1U, // u64(1) << 0
	discord__SystemChannelFlags__suppress_premium_subscriptions = 2U, // u64(1) << 1
	discord__SystemChannelFlags__suppress_guild_reminder_notifications = 4U, // u64(1) << 2
	discord__SystemChannelFlags__suppress_join_notification_replies = 8U, // u64(1) << 3
	discord__SystemChannelFlags__suppress_role_subscription_purchase_notifications = 16U, // u64(1) << 4
	discord__SystemChannelFlags__suppress_role_subscription_purchase_notifications_replies = 32U, // u64(1) << 5
}  discord__SystemChannelFlags;

typedef enum {
	discord__PremiumTier__none_, // 
	discord__PremiumTier__tier_1, // +1
	discord__PremiumTier__tier_2, // +2
	discord__PremiumTier__tier_3, // +3
}  discord__PremiumTier;

typedef enum {
	discord__NSFWLevel__default, // 
	discord__NSFWLevel__explicit, // +1
	discord__NSFWLevel__safe, // +2
	discord__NSFWLevel__age_restricted, // +3
}  discord__NSFWLevel;

typedef enum {
	discord__GuildMemberFlags__did_rejoin = 1U, // u64(1) << 0
	discord__GuildMemberFlags__completed_onboarding = 2U, // u64(1) << 1
	discord__GuildMemberFlags__bypasses_verification = 4U, // u64(1) << 2
	discord__GuildMemberFlags__started_onboarding = 8U, // u64(1) << 3
}  discord__GuildMemberFlags;

typedef enum {
	discord__Intents__guilds = 1U, // u64(1) << 0
	discord__Intents__guild_members = 2U, // u64(1) << 1
	discord__Intents__guild_moderation = 4U, // u64(1) << 2
	discord__Intents__guild_emojis_and_stickers = 8U, // u64(1) << 3
	discord__Intents__guild_integrations = 16U, // u64(1) << 4
	discord__Intents__guild_webhooks = 32U, // u64(1) << 5
	discord__Intents__guild_invites = 64U, // u64(1) << 6
	discord__Intents__guild_voice_states = 128U, // u64(1) << 7
	discord__Intents__guild_presences = 256U, // u64(1) << 8
	discord__Intents__guild_messages = 512U, // u64(1) << 9
	discord__Intents__guild_message_reactions = 1024U, // u64(1) << 10
	discord__Intents__guild_message_typing = 2048U, // u64(1) << 11
	discord__Intents__direct_messages = 4096U, // u64(1) << 12
	discord__Intents__direct_message_reactions = 8192U, // u64(1) << 13
	discord__Intents__direct_message_typing = 16384U, // u64(1) << 14
	discord__Intents__message_content = 32768U, // u64(1) << 15
	discord__Intents__guild_scheduled_events = 65536U, // u64(1) << 16
	discord__Intents__reserved_17 = 131072U, // u64(1) << 17
	discord__Intents__reserved_18 = 262144U, // u64(1) << 18
	discord__Intents__reserved_19 = 524288U, // u64(1) << 19
	discord__Intents__auto_moderation_configuration = 1048576U, // u64(1) << 20
	discord__Intents__auto_moderation_execution = 2097152U, // u64(1) << 21
}  discord__Intents;

typedef enum {
	discord__InteractionType__ping = 1, // 1
	discord__InteractionType__application_command = 2, // 2
	discord__InteractionType__message_component = 3, // 3
	discord__InteractionType__application_command_autocomplete = 4, // 4
	discord__InteractionType__modal_submit = 5, // 5
}  discord__InteractionType;

#pragma pack(push, 1)
typedef enum {
	discord__Permissions__create_instant_invite = 1U, // u64(1) << 0
	discord__Permissions__kick_members = 2U, // u64(1) << 1
	discord__Permissions__ban_members = 4U, // u64(1) << 2
	discord__Permissions__administrator = 8U, // u64(1) << 3
	discord__Permissions__manage_channels = 16U, // u64(1) << 4
	discord__Permissions__manage_guild = 32U, // u64(1) << 5
	discord__Permissions__add_reactions = 64U, // u64(1) << 6
	discord__Permissions__view_audit_log = 128U, // u64(1) << 7
	discord__Permissions__priority_speaker = 256U, // u64(1) << 8
	discord__Permissions__stream = 512U, // u64(1) << 9
	discord__Permissions__view_channel = 1024U, // u64(1) << 10
	discord__Permissions__send_messages = 2048U, // u64(1) << 11
	discord__Permissions__send_tts_messages = 4096U, // u64(1) << 12
	discord__Permissions__manage_messages = 8192U, // u64(1) << 13
	discord__Permissions__embed_links = 16384U, // u64(1) << 14
	discord__Permissions__attach_files = 32768U, // u64(1) << 15
	discord__Permissions__read_message_history = 65536U, // u64(1) << 16
	discord__Permissions__mention_everyone = 131072U, // u64(1) << 17
	discord__Permissions__use_external_emojis = 262144U, // u64(1) << 18
	discord__Permissions__view_guild_insights = 524288U, // u64(1) << 19
	discord__Permissions__connect = 1048576U, // u64(1) << 20
	discord__Permissions__speak = 2097152U, // u64(1) << 21
	discord__Permissions__mute_members = 4194304U, // u64(1) << 22
	discord__Permissions__deafen_members = 8388608U, // u64(1) << 23
	discord__Permissions__move_members = 16777216U, // u64(1) << 24
	discord__Permissions__use_vad = 33554432U, // u64(1) << 25
	discord__Permissions__change_nickname = 67108864U, // u64(1) << 26
	discord__Permissions__manage_nicknames = 134217728U, // u64(1) << 27
	discord__Permissions__manage_roles = 268435456U, // u64(1) << 28
	discord__Permissions__manage_webhooks = 536870912U, // u64(1) << 29
	discord__Permissions__manage_guild_expressions = 1073741824U, // u64(1) << 30
	discord__Permissions__use_application_commands = 2147483648U, // u64(1) << 31
	discord__Permissions__request_to_speak = 4294967296U, // u64(1) << 32
	discord__Permissions__manage_events = 8589934592U, // u64(1) << 33
	discord__Permissions__manage_threads = 17179869184U, // u64(1) << 34
	discord__Permissions__create_public_threads = 34359738368U, // u64(1) << 35
	discord__Permissions__create_private_threads = 68719476736U, // u64(1) << 36
	discord__Permissions__use_external_stickers = 137438953472U, // u64(1) << 37
	discord__Permissions__send_messages_in_threads = 274877906944U, // u64(1) << 38
	discord__Permissions__use_embedded_activities = 549755813888U, // u64(1) << 39
	discord__Permissions__moderate_members = 1099511627776U, // u64(1) << 40
	discord__Permissions__view_creator_monetization_analytics = 2199023255552U, // u64(1) << 41
	discord__Permissions__use_soundboard = 4398046511104U, // u64(1) << 42
	discord__Permissions__create_guild_expressions = 8796093022208U, // u64(1) << 43
	discord__Permissions__create_events = 17592186044416U, // u64(1) << 44
	discord__Permissions__use_external_sounds = 35184372088832U, // u64(1) << 45
	discord__Permissions__send_voice_messages = 70368744177664U, // u64(1) << 46
} __attribute__((packed)) discord__Permissions;
#pragma pack(pop)


typedef enum {
	discord__SkuType__subscription = 5, // 5
	discord__SkuType__subscription_group, // 5+1
}  discord__SkuType;

typedef enum {
	discord__SkuFlags__reserved_0, // 
	discord__SkuFlags__reserved_1, // +1
	discord__SkuFlags__available, // +2
	discord__SkuFlags__reserved_3, // +3
	discord__SkuFlags__reserved_4, // +4
	discord__SkuFlags__reserved_5, // +5
	discord__SkuFlags__reserved_6, // +6
	discord__SkuFlags__guild_subscription, // +7
	discord__SkuFlags__user_subscription, // +8
}  discord__SkuFlags;

typedef enum {
	discord__StickerType__standard, // 
	discord__StickerType__guild, // +1
}  discord__StickerType;

typedef enum {
	discord__StickerFormatType__png, // 
	discord__StickerFormatType__apng, // +1
	discord__StickerFormatType__lottie, // +2
	discord__StickerFormatType__gif, // +3
}  discord__StickerFormatType;

typedef enum {
	discord__UserFlags__staff = 1U, // u64(1) << 0
	discord__UserFlags__partner = 2U, // u64(1) << 1
	discord__UserFlags__hypesquad = 4U, // u64(1) << 2
	discord__UserFlags__bug_hunter_level_1 = 8U, // u64(1) << 3
	discord__UserFlags__reserved_4 = 16U, // u64(1) << 4
	discord__UserFlags__reserved_5 = 32U, // u64(1) << 5
	discord__UserFlags__hypesquad_online_house_1 = 64U, // u64(1) << 6
	discord__UserFlags__hypesquad_online_house_2 = 128U, // u64(1) << 7
	discord__UserFlags__hypesquad_online_house_3 = 256U, // u64(1) << 8
	discord__UserFlags__premium_early_supporter = 512U, // u64(1) << 9
	discord__UserFlags__team_pseudo_user = 1024U, // u64(1) << 10
	discord__UserFlags__reserved_11 = 2048U, // u64(1) << 11
	discord__UserFlags__reserved_12 = 4096U, // u64(1) << 12
	discord__UserFlags__reserved_13 = 8192U, // u64(1) << 13
	discord__UserFlags__bug_hunter_level_2 = 16384U, // u64(1) << 14
	discord__UserFlags__reserved_15 = 32768U, // u64(1) << 15
	discord__UserFlags__verified_bot = 65536U, // u64(1) << 16
	discord__UserFlags__verified_developer = 131072U, // u64(1) << 17
	discord__UserFlags__certified_moderator = 262144U, // u64(1) << 18
	discord__UserFlags__bot_http_interactions = 524288U, // u64(1) << 19
	discord__UserFlags__reserved_20 = 1048576U, // u64(1) << 20
	discord__UserFlags__reserved_21 = 2097152U, // u64(1) << 21
	discord__UserFlags__active_developer = 4194304U, // u64(1) << 22
}  discord__UserFlags;

typedef enum {
	discord__PremiumType__none_, // 
	discord__PremiumType__nitro_classic, // +1
	discord__PremiumType__nitro, // +2
	discord__PremiumType__nitro_basic, // +3
}  discord__PremiumType;

// Thread definitions:
typedef HANDLE __v_thread;
typedef struct {
	void* ret_ptr;
	HANDLE handle;
} __v_thread__result_void;
typedef struct {
	void* ret_ptr;
	HANDLE handle;
} __v_thread__result_int;

// V type definitions:
struct IError {
	union {
		void* _object;
		None__* _None__;
		voidptr* _voidptr;
		Error* _Error;
		MessageError* _MessageError;
		time__TimeParseError* _time__TimeParseError;
		io__Eof* _io__Eof;
		io__NotExpected* _io__NotExpected;
		os__Eof* _os__Eof;
		os__NotExpected* _os__NotExpected;
		os__FileNotOpenedError* _os__FileNotOpenedError;
		os__SizeOfTypeIs0Error* _os__SizeOfTypeIs0Error;
		os__ExecutableNotFoundError* _os__ExecutableNotFoundError;
		x__json2__DecodeError* _x__json2__DecodeError;
		x__json2__InvalidTokenError* _x__json2__InvalidTokenError;
		x__json2__UnknownTokenError* _x__json2__UnknownTokenError;
		net__http__HeaderKeyError* _net__http__HeaderKeyError;
		discord__InternalServerError* _discord__InternalServerError;
		discord__Unauthorized* _discord__Unauthorized;
		discord__Forbidden* _discord__Forbidden;
		discord__NotFound* _discord__NotFound;
		discord__Ratelimit* _discord__Ratelimit;
		discord__RestError* _discord__RestError;
	};
	int _typ;
	string* msg;
	int* code;
};

struct string {
	u8* str;
	int len;
	int is_lit;
};

struct array {
	voidptr data;
	int offset;
	int len;
	int cap;
	ArrayFlags flags;
	int element_size;
};

struct DenseArray {
	int key_bytes;
	int value_bytes;
	int cap;
	int len;
	u32 deletes;
	u8* all_deleted;
	u8* keys;
	u8* values;
};

struct map {
	int key_bytes;
	int value_bytes;
	u32 even_index;
	u8 cached_hashbits;
	u8 shift;
	DenseArray key_values;
	u32* metas;
	u32 extra_metas;
	bool has_string_keys;
	MapHashFn hash_fn;
	MapEqFn key_eq_fn;
	MapCloneFn clone_fn;
	MapFreeFn free_fn;
	int len;
};

struct Error {
	EMPTY_STRUCT_DECLARATION;
};

struct _option {
	u8 state;
	IError err;
};

struct _result {
	bool is_error;
	IError err;
};
typedef array Array_string;
typedef array Array_u8;
typedef array Array_voidptr;
typedef u64 Array_fixed_u64_2 [2];
typedef char Array_fixed_char_254 [254];
typedef array Array_VCastTypeIndexName;
typedef array Array_MethodArgs;
typedef array Array_u8_ptr;
typedef array Array_rune;
typedef string Array_fixed_string_11 [11];
typedef voidptr Array_fixed_voidptr_11 [11];
typedef array Array_int;
typedef array Array_RepIndex;
typedef map Map_string_int;
typedef array Array_discord__Component;
typedef array Array_discord__SelectOption;
typedef array Array_discord__Snowflake;
typedef array Array_discord__DefaultValue;
typedef array Array_discord__ChannelType;
typedef map Map_discord__Snowflake_string;
typedef map Map_string_x__json2__Any;
typedef array Array_x__json2__Any;
typedef array Array_discord__Entitlement;
typedef map Map_string_string;
typedef chan chan_T;
typedef map Map_int_discord__EventWaiter;
typedef map Map_int_discord__EventListener;
typedef array Array___v_thread;
typedef array Array_discord__GuildFeature;
typedef array Array_discord__PartialGuild;
typedef array Array_discord__WelcomeChannel;
typedef array Array_discord__Role;
typedef array Array_discord__Emoji;
typedef array Array_discord__Sticker;
typedef map Map_net__http__CommonHeader_string;
typedef array Array_discord__Intents;
typedef array Array_discord__Sku;
typedef array Array_char_ptr;
typedef u16 Array_fixed_u16_260 [260];
typedef u16 Array_fixed_u16_14 [14];
typedef int Array_fixed_int_3 [3];
typedef u8 Array_fixed_u8_65536 [65536];
typedef array Array_os__Signal;
typedef char Array_fixed_char_256 [256];
typedef array Array_net__urllib__QueryValue;
typedef map Map_string_Array_string;
typedef map Map_K_V;
typedef map Map_X_Y;
typedef map Map_V_K;
typedef map Map_int_T;
typedef map Map_K_Array_V;
typedef map Map_T_Array_int;
typedef map Map_T_int;
typedef array Array_net__http__Cookie_ptr;
typedef array Array_net__http__HeaderConfig;
typedef array Array_net__http__FileData;
typedef map Map_string_Array_net__http__FileData;
typedef array Array_net__http__LineSegmentIndexes;
typedef array Array_net__http__Cookie;
typedef chan chan_net__TcpConn_ptr;
typedef array Array_sync__Channel_ptr;
typedef array Array_sync__Direction;
typedef array Array_sync__Subscription;
typedef array Array_net__websocket__Flag;
typedef u8 Array_fixed_u8_4 [4];
typedef array Array_net__websocket__Fragment;
typedef array Array_net__websocket__MessageEventHandler;
typedef array Array_net__websocket__ErrorEventHandler;
typedef array Array_net__websocket__OpenEventHandler;
typedef array Array_net__websocket__CloseEventHandler;
typedef map Map_string_net__websocket__ServerClient_ptr;
typedef array Array_net__websocket__AcceptClientFn;
typedef u8 Array_fixed_u8_8 [8];
typedef array Array_io__Writer;
typedef u8 Array_fixed_u8_20 [20];
typedef u8 Array_fixed_u8_16 [16];
typedef array Array_net__Addr;
typedef u32 Array_fixed_u32_4 [4];
typedef char Array_fixed_char_108 [108];
typedef u8 Array_fixed_u8_108 [108];
typedef u8 Array_fixed_u8_257 [257];
typedef u8 Array_fixed_u8_129 [129];
typedef array Array_IError;
typedef array Array_u32;
typedef array Array_encoding__utf8__Range16;
typedef array Array_encoding__utf8__Range32;
typedef chan chan_discord__DispatchEvent_T_discord__GatewayClient;
typedef map Map_int_discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient;
typedef map Map_int_anon_fn_discord__dispatchevent_t_discord__gatewayclient__result_void;
typedef u8 Array_fixed_u8_5 [5];
typedef u8 Array_fixed_u8_25 [25];
typedef u8 Array_fixed_u8_32 [32];
typedef u8 Array_fixed_u8_64 [64];
typedef u8 Array_fixed_u8_256 [256];
typedef u64 Array_fixed_u64_309 [309];
typedef u64 Array_fixed_u64_324 [324];
typedef u32 Array_fixed_u32_12 [12];
typedef u64 Array_fixed_u64_20 [20];
typedef u64 Array_fixed_u64_584 [584];
typedef u64 Array_fixed_u64_652 [652];
typedef f64 Array_fixed_f64_20 [20];
typedef u8 Array_fixed_u8_26 [26];
typedef u64 Array_fixed_u64_18 [18];
typedef u64 Array_fixed_u64_47 [47];
typedef u64 Array_fixed_u64_31 [31];
typedef u8 Array_fixed_u8_17 [17];
typedef array Array_StrIntpType;
typedef char Array_fixed_char_1024 [1024];
typedef map Map_string_i64;
typedef int Array_fixed_int_123 [123];
typedef int Array_fixed_int_256 [256];
typedef u8 Array_fixed_u8_4096 [4096];
typedef u8 Array_fixed_u8_8192 [8192];
typedef u16 Array_fixed_u16_32768 [32768];
typedef u16 Array_fixed_u16_255 [255];
typedef u16 Array_fixed_u16_4096 [4096];
typedef array Array_os__ProcessState;
typedef array Array_Array_u8;
typedef map Map_int_rune;
typedef char Array_fixed_char_24 [24];
typedef char Array_fixed_char_46 [46];
typedef array Array_net__SocketOption;
typedef u8 Array_fixed_u8_400 [400];
typedef map Map_string_net__http__CommonHeader;
typedef array Array_net__http__Status;
typedef u8 Array_fixed_u8_1024 [1024];
typedef u8 Array_fixed_u8_1 [1];
typedef array Array_net__websocket__State;
typedef array Array_net__websocket__OPCode;
typedef array Array_void;
typedef int C__BOOL;
typedef voidptr C__HINSTANCE;
typedef voidptr C__HICON;
typedef voidptr C__HCURSOR;
typedef voidptr C__HBRUSH;
typedef voidptr C__HWND;
typedef voidptr C__HGLOBAL;
typedef voidptr C__HANDLE;
typedef voidptr C__LRESULT;
typedef voidptr C__intptr_t;
typedef Array_u8 strings__Builder;
typedef u64 discord__Snowflake;
typedef i64 time__Duration;
typedef string discord__GuildFeature;
typedef voidptr os__HANDLE;
typedef voidptr os__HMODULE;
typedef u32* os__PU32;
typedef i64 C__time_t;
typedef voidptr sync__MHANDLE;
typedef voidptr sync__SHANDLE;
typedef bool (*anon_fn_voidptr__bool)(voidptr);
typedef voidptr (*anon_fn_voidptr__voidptr)(voidptr);
typedef int (*anon_fn_voidptr_voidptr__int)(voidptr,voidptr);
typedef void (*FnExitCb)();
typedef int (*VectoredExceptionHandler)(ExceptionPointers*);
typedef int (*FnSortCB)(voidptr,voidptr);
typedef void (*anon_fn_int_ierror)(int,IError);
typedef _result_void (*discord__Prepare)(net__http__Request*);
typedef void (*os__ShellExecuteWin)(voidptr,u16*,u16*,u16*,u16*,int);
typedef void (*anon_fn_string)(string);
typedef void (*os__FnWalkContextCB)(voidptr,string);
typedef u32 (*os__VectoredExceptionHandler)(ExceptionPointers*);
typedef u64 (*os__FN_NTSuspendResume)(voidptr);
typedef void (*os__SignalHandler)(os__Signal);
typedef void (*os__FN_SA_Handler)(int);
typedef bool (*anon_fn_u8__bool)(u8);
typedef _result_void (*net__http__RequestRedirectFn)(net__http__Request*,int,string);
typedef _result_void (*net__http__RequestProgressFn)(net__http__Request*,Array_u8,u64);
typedef _result_void (*net__http__RequestFinishFn)(net__http__Request*,u64);
typedef void (*anon_fn_mut_net__http__server)(net__http__Server*);
typedef void (*anon_fn_)();
typedef void (*anon_fn_voidptr)(voidptr);
typedef _result_void (*net__websocket__SocketMessageFn)(net__websocket__Client*,net__websocket__Message*);
typedef _result_void (*net__websocket__SocketMessageFn2)(net__websocket__Client*,net__websocket__Message*,voidptr);
typedef _result_void (*net__websocket__SocketErrorFn)(net__websocket__Client*,string);
typedef _result_void (*net__websocket__SocketErrorFn2)(net__websocket__Client*,string,voidptr);
typedef _result_void (*net__websocket__SocketOpenFn)(net__websocket__Client*);
typedef _result_void (*net__websocket__SocketOpenFn2)(net__websocket__Client*,voidptr);
typedef _result_void (*net__websocket__SocketCloseFn)(net__websocket__Client*,int,string);
typedef _result_void (*net__websocket__SocketCloseFn2)(net__websocket__Client*,int,string,voidptr);
typedef _result_bool (*net__websocket__AcceptClientFn)(net__websocket__ServerClient*);
typedef string (*anon_fn_string__string)(string);
typedef int (*anon_fn_voidptr_u8_usize__int)(voidptr,u8*,usize);
typedef void (*anon_fn_voidptr_u8_usize)(voidptr,u8*,usize);
typedef bool (*anon_fn_discord__dispatchevent_t_discord__gatewayclient__bool)(discord__DispatchEvent_T_discord__GatewayClient);
typedef _result_void (*anon_fn_discord__dispatchevent_t_discord__gatewayclient__result_void)(discord__DispatchEvent_T_discord__GatewayClient);
typedef multi_return_string_x__json2__Any (*anon_fn_discord__snowflake_string__multi_return_string_x__json2__Any)(discord__Snowflake,string);
typedef string (*anon_fn_int_x__json2__any__string)(int,x__json2__Any);
typedef string (*anon_fn_string_string__string)(string,string);
typedef int (*anon_fn_int_discord__intents__int)(int,discord__Intents);
struct log__Logger {
	union {
		void* _object;
		log__ThreadSafeLog* _log__ThreadSafeLog;
		voidptr* _voidptr;
		log__Log* _log__Log;
	};
	int _typ;
};
struct discord__Component {
	union {
		void* _object;
		discord__ActionRow* _discord__ActionRow;
		voidptr* _voidptr;
		discord__Button* _discord__Button;
		discord__StringSelect* _discord__StringSelect;
		discord__UserSelect* _discord__UserSelect;
		discord__RoleSelect* _discord__RoleSelect;
		discord__MentionableSelect* _discord__MentionableSelect;
		discord__ChannelSelect* _discord__ChannelSelect;
		discord__TextInput* _discord__TextInput;
	};
	int _typ;
};
struct discord__Image {
	union {
		void* _object;
		discord__JpegImage* _discord__JpegImage;
		voidptr* _voidptr;
		discord__PngImage* _discord__PngImage;
		discord__GifImage* _discord__GifImage;
	};
	int _typ;
	Array_u8* data;
};
struct io__Writer {
	union {
		void* _object;
		io__MultiWriter* _io__MultiWriter;
		voidptr* _voidptr;
		strings__Builder* _strings__Builder;
		os__File* _os__File;
		net__TcpConn* _net__TcpConn;
		net__ssl__SSLConn* _net__ssl__SSLConn;
		io__ReaderWriterImpl* _io__ReaderWriterImpl;
		net__UdpConn* _net__UdpConn;
		net__mbedtls__SSLConn* _net__mbedtls__SSLConn;
		crypto__sha1__Digest* _crypto__sha1__Digest;
	};
	int _typ;
};
struct x__json2__Encodable {
	union {
		void* _object;
		x__json2__Any* _x__json2__Any;
		voidptr* _voidptr;
	};
	int _typ;
};
struct x__json2__Decodable {
	union {
		void* _object;
	};
	int _typ;
};
struct net__http__Handler {
	union {
		void* _object;
		net__http__DebugHandler* _net__http__DebugHandler;
		voidptr* _voidptr;
	};
	int _typ;
};
struct io__Reader {
	union {
		void* _object;
		net__TcpConn* _net__TcpConn;
		voidptr* _voidptr;
		os__File* _os__File;
		net__ssl__SSLConn* _net__ssl__SSLConn;
		io__BufferedReader* _io__BufferedReader;
		io__ReaderWriterImpl* _io__ReaderWriterImpl;
		net__mbedtls__SSLConn* _net__mbedtls__SSLConn;
	};
	int _typ;
};
struct io__RandomReader {
	union {
		void* _object;
		os__File* _os__File;
		voidptr* _voidptr;
	};
	int _typ;
};
struct io__ReaderWriter {
	union {
		void* _object;
		io__ReaderWriterImpl* _io__ReaderWriterImpl;
		voidptr* _voidptr;
	};
	int _typ;
};
struct io__RandomWriter {
	union {
		void* _object;
	};
	int _typ;
};
struct rand__PRNG {
	union {
		void* _object;
		rand__wyrand__WyRandRNG* _rand__wyrand__WyRandRNG;
		voidptr* _voidptr;
	};
	int _typ;
};
struct hash__Hasher {
	union {
		void* _object;
		crypto__sha1__Digest* _crypto__sha1__Digest;
		voidptr* _voidptr;
	};
	int _typ;
};
struct hash__Hash32er {
	union {
		void* _object;
	};
	int _typ;
};
struct hash__Hash64er {
	union {
		void* _object;
	};
	int _typ;
};
// #start sorted_symbols
struct none {
	EMPTY_STRUCT_DECLARATION;
};

struct ContextRecord {
	EMPTY_STRUCT_DECLARATION;
};

struct ExceptionPointers {
	ExceptionRecord* exception_record;
	ContextRecord* context_record;
};

struct None__ {
	Error Error;
};

struct StrIntpCgenData {
	string str;
	string fmt;
	string d;
};

struct discord__Properties {
	string os;
	string browser;
	string device;
};

// Union sum type x__json2__Any = 
//          |  170 = x__json2__Null      
//          |  174 = Array_x__json2__Any 
//          |   19 = bool                
//          |   16 = f32                 
//          |   17 = f64                 
//          |    6 = i16                 
//          |    9 = i64                 
//          |    5 = i8                  
//          |    8 = int                 
//          |  173 = Map_string_x__json2__Any
//          |   21 = string              
//          |  176 = time__Time          
//          |   12 = u16                 
//          |   13 = u32                 
//          |   14 = u64                 
//          |   11 = u8                  
struct x__json2__Any {
	union {
		x__json2__Null* _x__json2__Null;
		Array_x__json2__Any* _Array_x__json2__Any;
		bool* _bool;
		f32* _f32;
		f64* _f64;
		i16* _i16;
		i64* _i64;
		i8* _i8;
		int* _int;
		Map_string_x__json2__Any* _Map_string_x__json2__Any;
		string* _string;
		time__Time* _time__Time;
		u16* _u16;
		u32* _u32;
		u64* _u64;
		u8* _u8;
	};
	int _typ;
};
struct _option_string {
	byte state;
	IError err;
	byte data[sizeof(string) > 1 ? sizeof(string) : 1];
};

struct discord__WithReason {
	_option_string reason;
};

struct os__Eof {
	Error Error;
};

struct os__FileNotOpenedError {
	Error Error;
};

struct os__SizeOfTypeIs0Error {
	Error Error;
};

struct os__ExecutableNotFoundError {
	Error Error;
};

struct os__Uname {
	string sysname;
	string nodename;
	string release;
	string version;
	string machine;
};

struct os__ContextRecord {
	EMPTY_STRUCT_DECLARATION;
};

struct os__ExceptionPointers {
	ExceptionRecord* exception_record;
	ContextRecord* context_record;
};

struct net__urllib__ParseAuthorityRes {
	net__urllib__Userinfo* user;
	string host;
};

struct net__urllib__QueryValue {
	string key;
	string value;
};

struct net__http__HeaderKV {
	string key;
	string value;
};

struct net__http__FileData {
	string filename;
	string content_type;
	string data;
};

struct net__http__MultiplePathAttributesError {
	Error Error;
};

struct net__http__DebugHandler {
	EMPTY_STRUCT_DECLARATION;
};

struct sync__Subscription {
	sync__Semaphore* sem;
	sync__Subscription** prev;
	sync__Subscription* nxt;
};

struct net__websocket__ServerClient {
	string resource_name;
	string client_key;
	net__websocket__Server* server;
	net__websocket__Client* client;
};

struct net__websocket__Uri {
	string url;
	string hostname;
	string port;
	string resource;
	string querystring;
};

struct net__websocket__ServerOpt {
	log__Logger* logger;
};

struct io__Eof {
	Error Error;
};

struct io__util__TempFileOptions {
	string path;
	string pattern;
};

struct io__util__TempDirOptions {
	string path;
	string pattern;
};

struct Line64 {
	u32 f_size_of_struct;
	voidptr f_key;
	u32 f_line_number;
	u8* f_file_name;
	u64 f_address;
};

struct GCHeapUsage {
	usize heap_size;
	usize free_bytes;
	usize total_bytes;
	usize unmapped_bytes;
	usize bytes_since_gc;
};

struct VCastTypeIndexName {
	int tindex;
	string tname;
};

struct VAssertMetaInfo {
	string fpath;
	int line_nr;
	string fn_name;
	string src;
	string op;
	string llabel;
	string rlabel;
	string lvalue;
	string rvalue;
	string message;
	bool has_msg;
};

struct MethodArgs {
	int typ;
	string name;
};

struct FunctionData {
	string name;
	Array_string attrs;
	Array_MethodArgs args;
	int return_type;
	int typ;
};

struct EnumData {
	string name;
	i64 value;
	Array_string attrs;
};

struct FieldData {
	string name;
	int typ;
	int unaliased_typ;
	Array_string attrs;
	bool is_pub;
	bool is_mut;
	bool is_shared;
	bool is_atomic;
	bool is_option;
	bool is_array;
	bool is_map;
	bool is_chan;
	bool is_enum;
	bool is_struct;
	bool is_alias;
	u8 indirections;
};

struct StructAttribute {
	string name;
	bool has_arg;
	string arg;
	AttributeKind kind;
};

struct ExceptionRecord {
	u32 code;
	u32 flags;
	ExceptionRecord* record;
	voidptr address;
	u32 param_count;
};

union strconv__Float64u {
	f64 f;
	u64 u;
};

union strconv__Float32u {
	f32 f;
	u32 u;
};

struct Option {
	u8 state;
	IError err;
};

struct MessageError {
	string msg;
	int code;
};

struct SortedMap {
	int value_bytes;
	mapnode* root;
	int len;
};

struct RepIndex {
	int idx;
	int val_idx;
};

union StrIntpMem {
	u32 d_c;
	u8 d_u8;
	i8 d_i8;
	u16 d_u16;
	i16 d_i16;
	u32 d_u32;
	int d_i32;
	u64 d_u64;
	i64 d_i64;
	f32 d_f32;
	f64 d_f64;
	string d_s;
	voidptr d_p;
	voidptr d_vp;
};

struct strconv__BF_param {
	u8 pad_ch;
	int len0;
	int len1;
	bool positive;
	bool sign_flag;
	strconv__Align_text align;
	strconv__Align_text allign;
	bool rm_tail_zero;
};

struct discord__DispatchEvent_T_discord__GatewayClient {
	discord__GatewayClient* creator;
	string name;
	x__json2__Any data;
};

struct strconv__PrepNumber {
	bool negative;
	int exponent;
	u64 mantissa;
};

struct strconv__Dec32 {
	u32 m;
	int e;
};

union strconv__Uf32 {
	f32 f;
	u32 u;
};

struct strconv__Dec64 {
	u64 m;
	int e;
};

struct strconv__Uint128 {
	u64 lo;
	u64 hi;
};

union strconv__Uf64 {
	f64 f;
	u64 u;
};

struct discord__Client {
	string token;
	string base_url;
	string user_agent;
	log__Logger logger;
	voidptr user_data;
};

struct discord__ClientConfig {
	string user_agent;
	bool debug;
};

struct discord__ActionRow {
	Array_discord__Component components;
};
struct _option_discord__Snowflake {
	byte state;
	IError err;
	byte data[sizeof(discord__Snowflake) > 1 ? sizeof(discord__Snowflake) : 1];
};

struct discord__PartialEmoji {
	_option_discord__Snowflake id;
	string name;
	bool animated;
};
struct _option_int {
	byte state;
	IError err;
	byte data[sizeof(int) > 1 ? sizeof(int) : 1];
};

struct discord__StringSelect {
	string custom_id;
	Array_discord__SelectOption options;
	_option_string placeholder;
	_option_int min_values;
	_option_int max_values;
	bool disabled;
};
struct _option_Array_discord__Snowflake {
	byte state;
	IError err;
	byte data[sizeof(Array_discord__Snowflake) > 1 ? sizeof(Array_discord__Snowflake) : 1];
};

struct discord__UserSelect {
	string custom_id;
	_option_string placeholder;
	_option_Array_discord__Snowflake default_values;
	_option_int min_values;
	_option_int max_values;
	bool disabled;
};

struct discord__RoleSelect {
	string custom_id;
	_option_string placeholder;
	_option_Array_discord__Snowflake default_values;
	_option_int min_values;
	_option_int max_values;
	bool disabled;
};

struct discord__DefaultValue {
	discord__Snowflake id;
	discord__DefaultValueType typ;
};
struct _option_Array_discord__DefaultValue {
	byte state;
	IError err;
	byte data[sizeof(Array_discord__DefaultValue) > 1 ? sizeof(Array_discord__DefaultValue) : 1];
};

struct discord__MentionableSelect {
	string custom_id;
	_option_string placeholder;
	_option_Array_discord__DefaultValue default_values;
	_option_int min_values;
	_option_int max_values;
	bool disabled;
};
struct _option_Array_discord__ChannelType {
	byte state;
	IError err;
	byte data[sizeof(Array_discord__ChannelType) > 1 ? sizeof(Array_discord__ChannelType) : 1];
};

struct discord__ChannelSelect {
	string custom_id;
	_option_Array_discord__ChannelType channel_types;
	_option_string placeholder;
	_option_Array_discord__Snowflake default_values;
	_option_int min_values;
	_option_int max_values;
	bool disabled;
};

struct discord__TextInput {
	string custom_id;
	discord__TextInputStyle style;
	string label;
	_option_int min_length;
	_option_int max_length;
	bool required;
	_option_string value;
	_option_string placeholder;
};

struct discord__CreateGroupDMParams {
	Array_string access_tokens;
	Map_discord__Snowflake_string nicks;
};

struct x__json2__Null {
	bool is_null;
};

struct time__Time {
	int year;
	int month;
	int day;
	int hour;
	int minute;
	int second;
	int nanosecond;
	i64 __v_unix;
	bool is_local;
	int microsecond;
};
struct _option_bool {
	byte state;
	IError err;
	byte data[sizeof(bool) > 1 ? sizeof(bool) : 1];
};

struct discord__ListEntitlementParams {
	_option_discord__Snowflake user_id;
	_option_Array_discord__Snowflake sku_ids;
	_option_discord__Snowflake before;
	_option_discord__Snowflake after;
	_option_int limit;
	_option_discord__Snowflake guild_id;
	_option_bool exclude_ended;
};

struct discord__CreateTestEntitlementParams {
	discord__Snowflake sku_id;
	discord__Snowflake owner_id;
	discord__OwnerType owner_type;
};

struct discord__RestError {
	int code;
	Map_string_x__json2__Any errors;
	string message;
	net__http__Status status;
};
struct _option_anon_fn_int_ierror {
	byte state;
	IError err;
	byte data[sizeof(void*) > 1 ? sizeof(void*) : 1];
};

struct discord__EmitOptions {
	_option_anon_fn_int_ierror error_handler;
};

struct discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient {
	int id;
	Map_int_discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient wait_fors;
	Map_int_anon_fn_discord__dispatchevent_t_discord__gatewayclient__result_void listeners;
};

struct discord__WSMessage {
	int opcode;
	x__json2__Any data;
	_option_int seq;
	string event;
};

struct net__websocket__Message {
	net__websocket__OPCode opcode;
	Array_u8 payload;
};

struct discord__PartialGuild {
	discord__Snowflake id;
	string name;
	_option_string icon;
	bool owner;
	discord__Permissions permissions;
	Array_discord__GuildFeature features;
	_option_int approximate_member_count;
	_option_int approximate_presence_count;
};

struct discord__FetchMyGuildsParams {
	_option_discord__Snowflake before;
	_option_discord__Snowflake after;
	_option_int limit;
	_option_bool with_counts;
};

struct discord__RoleTags {
	_option_discord__Snowflake bot_id;
	_option_discord__Snowflake integration_id;
	bool premium_subscriber;
	_option_discord__Snowflake subscription_listing_id;
	bool available_for_purchase;
	bool guild_connections;
};

struct discord__WelcomeChannel {
	_option_discord__Snowflake channel_id;
	string description;
	_option_discord__Snowflake emoji_id;
	_option_string emoji_name;
};

struct discord__WelcomeScreen {
	_option_string description;
	Array_discord__WelcomeChannel welcome_channels;
};
struct _option_x__json2__Any {
	byte state;
	IError err;
	byte data[sizeof(x__json2__Any) > 1 ? sizeof(x__json2__Any) : 1];
};
struct _option_anon_fn_mut_net__http__request__result_void {
	byte state;
	IError err;
	byte data[sizeof(void*) > 1 ? sizeof(void*) : 1];
};

struct discord__RequestOptions {
	_option_anon_fn_mut_net__http__request__result_void prepare;
	bool authenticate;
	_option_string reason;
	_option_x__json2__Any json;
	_option_string body;
	Map_net__http__CommonHeader_string common_headers;
	Map_string_string headers;
};

struct discord__JpegImage {
	Array_u8 data;
};

struct discord__PngImage {
	Array_u8 data;
};

struct discord__GifImage {
	Array_u8 data;
};

struct discord__Sku {
	discord__Snowflake id;
	discord__SkuType typ;
	discord__Snowflake application_id;
	string name;
	string slug;
	discord__SkuFlags flags;
};

struct discord__AvatarDecorationData {
	string asset;
	discord__Snowflake sku_id;
};
struct _option_discord__Image {
	byte state;
	IError err;
	byte data[sizeof(discord__Image) > 1 ? sizeof(discord__Image) : 1];
};

struct discord__MyUserEdit {
	_option_string username;
	_option_discord__Image avatar;
};

struct os__NotExpected {
	string cause;
	int code;
};

struct os__File {
	voidptr cfile;
	int fd;
	bool is_opened;
};

struct os__FileInfo {
	string name;
	int size;
};

struct os__FilePermission {
	bool read;
	bool write;
	bool execute;
};

struct os__PathKind {
	bool is_dir;
	bool is_link;
};

struct os__Result {
	int exit_code;
	string output;
};

struct os__Command {
	voidptr f;
	bool eof;
	int exit_code;
	string path;
	bool redirect_stdout;
};

struct os__MkdirParams {
	u32 mode;
};

struct os__Filetime {
	u32 dw_low_date_time;
	u32 dw_high_date_time;
};

struct os__ProcessInformation {
	voidptr h_process;
	voidptr h_thread;
	u32 dw_process_id;
	u32 dw_thread_id;
};

struct os__StartupInfo {
	u32 cb;
	u16* lp_reserved;
	u16* lp_desktop;
	u16* lp_title;
	u32 dw_x;
	u32 dw_y;
	u32 dw_x_size;
	u32 dw_y_size;
	u32 dw_x_count_chars;
	u32 dw_y_count_chars;
	u32 dw_fill_attributes;
	u32 dw_flags;
	u16 w_show_window;
	u16 cb_reserved2;
	u8* lp_reserved2;
	voidptr h_std_input;
	voidptr h_std_output;
	voidptr h_std_error;
};

struct os__SecurityAttributes {
	u32 n_length;
	voidptr lp_security_descriptor;
	bool b_inherit_handle;
};

struct os__ExceptionRecord {
	u32 code;
	u32 flags;
	ExceptionRecord* record;
	voidptr address;
	u32 param_count;
};

struct x__json2__DecodeError {
	int line;
	int column;
	string message;
};

struct x__json2__Token {
	Array_u8 lit;
	x__json2__TokenKind kind;
	int line;
	int col;
};

struct x__json2__Scanner {
	Array_u8 text;
	int pos;
	int line;
	int col;
};

struct x__json2__Encoder {
	u8 newline;
	int newline_spaces_count;
	bool escape_unicode;
};

struct x__json2__CharLengthIterator {
	string text;
	int idx;
};

struct net__urllib__Userinfo {
	string username;
	string password;
	bool password_set;
};

struct net__urllib__URL {
	string scheme;
	string opaque;
	net__urllib__Userinfo* user;
	string host;
	string path;
	string raw_path;
	bool force_query;
	string raw_query;
	string fragment;
};

struct net__urllib__Values {
	Array_net__urllib__QueryValue data;
	int len;
};

struct sync__Mutex {
	SRWLOCK mx;
};

struct time__DateTimeParser {
	string datetime;
	string format;
	int current_pos_datetime;
};

struct time__TimeParseError {
	Error Error;
	int code;
	string message;
};

struct time__StopWatchOptions {
	bool auto_start;
};

struct time__StopWatch {
	u64 elapsed;
	u64 start;
	u64 end;
};

struct time__SystemTime {
	u16 year;
	u16 month;
	u16 day_of_week;
	u16 day;
	u16 hour;
	u16 minute;
	u16 second;
	u16 millisecond;
};

struct arrays__WindowAttribute {
	int size;
	int step;
};

struct arrays__Block {
	u64 x;
	u64 y;
	u64 z;
	u64 w;
};

struct arrays__UnalignedBlock {
	u64 x;
	u64 y;
	u64 z;
	u64 w;
};
typedef net__http__HeaderKV Array_fixed_net__http__HeaderKV_50 [50];

struct net__http__HeaderConfig {
	net__http__CommonHeader key;
	string value;
};

struct net__http__HeaderCoerceConfig {
	bool canonicalize;
};

struct net__http__HeaderQueryConfig {
	bool exact;
};

struct net__http__HeaderRenderConfig {
	net__http__Version version;
	bool coerce;
	bool canonicalize;
};

struct net__http__HeaderKeyError {
	Error Error;
	int code;
	string header;
	u8 invalid_char;
};

struct net__http__HttpProxy {
	string scheme;
	string username;
	string password;
	string host;
	string hostname;
	int port;
	string url;
};

struct io__BufferedReader {
	io__Reader reader;
	Array_u8 buf;
	int offset;
	int len;
	int fails;
	int mfails;
	bool end_of_stream;
	int total_read;
};

struct net__http__UnexpectedExtraAttributeError {
	Error Error;
	Array_string attributes;
};

struct net__http__LineSegmentIndexes {
	int start;
	int end;
};

struct net__http__WaitTillRunningParams {
	int max_retries;
	int retry_period_ms;
};

struct net__http__HandlerWorker {
	int id;
	chan_net__TcpConn_ptr ch;
	net__http__Handler handler;
};

struct sync__Semaphore {
	SRWLOCK mtx;
	CONDITION_VARIABLE cond;
	u32 count;
};

struct sync__RwMutex {
	SRWLOCK mx;
};

struct net__websocket__MessageEventHandler {
	net__websocket__SocketMessageFn handler;
	net__websocket__SocketMessageFn2 handler2;
	bool is_ref;
	voidptr ref;
};

struct net__websocket__ErrorEventHandler {
	net__websocket__SocketErrorFn handler;
	net__websocket__SocketErrorFn2 handler2;
	bool is_ref;
	voidptr ref;
};

struct net__websocket__OpenEventHandler {
	net__websocket__SocketOpenFn handler;
	net__websocket__SocketOpenFn2 handler2;
	bool is_ref;
	voidptr ref;
};

struct net__websocket__CloseEventHandler {
	net__websocket__SocketCloseFn handler;
	net__websocket__SocketCloseFn2 handler2;
	bool is_ref;
	voidptr ref;
};

struct net__websocket__Server {
	log__Logger* logger;
	net__TcpListener* ls;
	Array_net__websocket__AcceptClientFn accept_client_callbacks;
	Array_net__websocket__MessageEventHandler message_callbacks;
	Array_net__websocket__CloseEventHandler close_callbacks;
	net__AddrFamily family;
	int port;
	bool is_ssl;
	__shared__net__websocket__ServerState* server_state;
};

struct net__websocket__Fragment {
	Array_u8 data;
	net__websocket__OPCode opcode;
};

struct net__websocket__ClientState {
	net__websocket__State state;
};

struct net__websocket__ClientOpt {
	i64 read_timeout;
	i64 write_timeout;
	log__Logger* logger;
};

struct net__websocket__ServerState {
	int ping_interval;
	net__websocket__State state;
	Map_string_net__websocket__ServerClient_ptr clients;
};

struct strings__textscanner__TextScanner {
	string input;
	int ilen;
	int pos;
};

struct io__BufferedReaderConfig {
	io__Reader reader;
	int cap;
	int retries;
};

struct io__NotExpected {
	string cause;
	int code;
};

struct io__MultiWriter {
	Array_io__Writer writers;
};

struct io__ReadAllConfig {
	bool read_to_end_of_stream;
	io__Reader reader;
};

struct io__ReaderWriterImpl {
	io__Reader r;
	io__Writer w;
};

struct term__Coord {
	int x;
	int y;
};

struct net__ShutdownConfig {
	net__ShutdownDirection how;
};

struct net__Socket {
	int handle;
};

struct net__ListenOptions {
	bool dualstack;
	int backlog;
};

struct net__mbedtls__SSLConnectConfig {
	string verify;
	string cert;
	string cert_key;
	bool validate;
	bool in_memory_verification;
};

struct rand__config__NormalConfigStruct {
	f64 mu;
	f64 sigma;
};

struct rand__config__ShuffleConfigStruct {
	int start;
	int end;
};

struct rand__config__PRNGConfigStruct {
	Array_u32 seed_;
};

struct net__http__chunked__ChunkScanner {
	int pos;
	string text;
};

struct encoding__utf8__Utf8State {
	int index;
	int subindex;
	bool failed;
};

struct encoding__utf8__RangeTable {
	Array_encoding__utf8__Range16 r16;
	Array_encoding__utf8__Range32 r32;
	int latin_offset;
};

struct encoding__utf8__Range16 {
	u16 lo;
	u16 hi;
	u16 stride;
};

struct encoding__utf8__Range32 {
	u32 lo;
	u32 hi;
	u32 stride;
};

struct crypto__sha1__Digest {
	Array_u32 h;
	Array_u8 x;
	int nx;
	u64 len;
};

struct net__mbedtls__SSLCerts {
	mbedtls_x509_crt cacert;
	mbedtls_x509_crt client_cert;
	mbedtls_pk_context client_key;
};

struct rand__buffer__PRNGBuffer {
	int bytes_left;
	u64 buffer;
};

struct discord__Chan_T_discord__DispatchEvent_T_discord__GatewayClient {
	chan_discord__DispatchEvent_T_discord__GatewayClient c;
};
struct _option_anon_fn_discord__dispatchevent_t_discord__gatewayclient__bool {
	byte state;
	IError err;
	byte data[sizeof(void*) > 1 ? sizeof(void*) : 1];
};

struct discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient {
	_option_anon_fn_discord__dispatchevent_t_discord__gatewayclient__bool check;
	discord__Chan_T_discord__DispatchEvent_T_discord__GatewayClient* c;
};
struct _option_time__Duration {
	byte state;
	IError err;
	byte data[sizeof(time__Duration) > 1 ? sizeof(time__Duration) : 1];
};

struct discord__EventWaitParams_T_discord__DispatchEvent_T_discord__GatewayClient {
	_option_anon_fn_discord__dispatchevent_t_discord__gatewayclient__bool check;
	_option_time__Duration timeout;
};

struct SymbolInfo {
	u32 f_size_of_struct;
	u32 f_type_index;
	Array_fixed_u64_2 f_reserved;
	u32 f_index;
	u32 f_size;
	u64 f_mod_base;
	u32 f_flags;
	u64 f_value;
	u64 f_address;
	u32 f_register;
	u32 f_scope;
	u32 f_tag;
	u32 f_name_len;
	u32 f_max_name_len;
	u8 f_name;
};

struct mapnode {
	voidptr* children;
	int len;
	Array_fixed_string_11 keys;
	Array_fixed_voidptr_11 values;
};

struct StrIntpData {
	string str;
	u32 fmt;
	StrIntpMem d;
};
struct _option_discord__Properties {
	byte state;
	IError err;
	byte data[sizeof(discord__Properties) > 1 ? sizeof(discord__Properties) : 1];
};

struct discord__GatewayClient {
	discord__Client Client;
	int intents;
	_option_discord__Properties properties;
	string gateway_url;
	net__websocket__Client* ws;
	bool ready;
	_option_int sequence;
	discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient on_raw_event;
};

struct discord__BotConfig {
	discord__ClientConfig ClientConfig;
	discord__Properties properties;
	discord__Intents intents;
};

struct log__Log {
	log__Level level;
	string output_label;
	os__File ofile;
	log__LogTarget output_target;
	string output_file_name;
};
struct _option_discord__PartialEmoji {
	byte state;
	IError err;
	byte data[sizeof(discord__PartialEmoji) > 1 ? sizeof(discord__PartialEmoji) : 1];
};

struct discord__Button {
	discord__ButtonStyle style;
	_option_string label;
	_option_discord__PartialEmoji emoji;
	_option_string custom_id;
	_option_string url;
	_option_bool disabled;
};

struct discord__SelectOption {
	string label;
	string value;
	_option_string description;
	_option_discord__PartialEmoji emoji;
	_option_bool __v_default;
};
struct _option_discord__AvatarDecorationData {
	byte state;
	IError err;
	byte data[sizeof(discord__AvatarDecorationData) > 1 ? sizeof(discord__AvatarDecorationData) : 1];
};
struct _option_discord__PremiumType {
	byte state;
	IError err;
	byte data[sizeof(discord__PremiumType) > 1 ? sizeof(discord__PremiumType) : 1];
};
struct _option_discord__UserFlags {
	byte state;
	IError err;
	byte data[sizeof(discord__UserFlags) > 1 ? sizeof(discord__UserFlags) : 1];
};

struct discord__User {
	discord__Snowflake id;
	string username;
	string discriminator;
	_option_string global_name;
	_option_string avatar;
	_option_bool bot;
	_option_bool system;
	_option_bool mfa_enabled;
	_option_string banner;
	_option_int accent_color;
	_option_string locale;
	_option_bool verified;
	_option_string email;
	_option_discord__UserFlags flags;
	_option_discord__PremiumType premium_type;
	_option_discord__UserFlags public_flags;
	_option_discord__AvatarDecorationData avatar_decoration;
};
struct _option_time__Time {
	byte state;
	IError err;
	byte data[sizeof(time__Time) > 1 ? sizeof(time__Time) : 1];
};

struct discord__Entitlement {
	discord__Snowflake id;
	discord__Snowflake sku_id;
	discord__Snowflake application_id;
	_option_discord__Snowflake user_id;
	discord__EntitlementType typ;
	bool deleted;
	_option_time__Time starts_at;
	_option_time__Time ends_at;
	_option_discord__Snowflake guild_id;
};

struct discord__Unauthorized {
	discord__RestError RestError;
};

struct discord__Forbidden {
	discord__RestError RestError;
};

struct discord__NotFound {
	discord__RestError RestError;
};

struct discord__InternalServerError {
	discord__RestError RestError;
};

struct discord__Ratelimit {
	discord__RestError RestError;
	f32 retry_after;
};
struct _option_discord__RoleTags {
	byte state;
	IError err;
	byte data[sizeof(discord__RoleTags) > 1 ? sizeof(discord__RoleTags) : 1];
};

struct discord__Role {
	discord__Snowflake id;
	string name;
	int color;
	bool hoist;
	_option_string icon;
	_option_string unicode_emoji;
	int position;
	discord__Permissions permissions;
	bool managed;
	bool mentionable;
	_option_discord__RoleTags tags;
	discord__RoleFlags flags;
};
struct _option_discord__WelcomeScreen {
	byte state;
	IError err;
	byte data[sizeof(discord__WelcomeScreen) > 1 ? sizeof(discord__WelcomeScreen) : 1];
};

struct discord__Guild {
	discord__Snowflake id;
	string name;
	_option_string icon;
	_option_string icon_hash;
	_option_string splash;
	_option_string discovery_splash;
	discord__Snowflake owner_id;
	_option_discord__Snowflake afk_channel_id;
	time__Duration afk_timeout;
	_option_bool widget_enabled;
	_option_discord__Snowflake widget_channel_id;
	discord__VerificationLevel verification_level;
	discord__MessageNotificationsLevel default_message_notifications;
	discord__ExplicitContentFilterLevel explicit_content_filter;
	Array_discord__Role roles;
	Array_discord__Emoji emojis;
	Array_discord__GuildFeature features;
	discord__MFALevel mfa_level;
	_option_discord__Snowflake application_id;
	_option_discord__Snowflake system_channel_id;
	discord__SystemChannelFlags system_channel_flags;
	_option_discord__Snowflake rules_channel_id;
	_option_int max_presences;
	_option_int max_members;
	_option_string vanity_url_code;
	_option_string description;
	_option_string banner;
	discord__PremiumTier premium_tier;
	_option_int premium_subscription_count;
	string preferred_locale;
	_option_discord__Snowflake public_updates_channel_id;
	_option_int max_video_channel_users;
	_option_int max_stage_video_channel_users;
	_option_int approximate_member_count;
	_option_int approximate_presence_count;
	_option_discord__WelcomeScreen welcome_screen;
	discord__NSFWLevel nsfw_level;
	Array_discord__Sticker stickers;
	bool premium_progress_bar_enabled;
	_option_discord__Snowflake safety_alerts_channel_id;
};

struct net__http__Header {
	Array_fixed_net__http__HeaderKV_50 data;
	int cur_pos;
};

struct os__FileMode {
	os__FileType typ;
	os__FilePermission owner;
	os__FilePermission group;
	os__FilePermission others;
};

struct os__Win32finddata {
	u32 dw_file_attributes;
	os__Filetime ft_creation_time;
	os__Filetime ft_last_access_time;
	os__Filetime ft_last_write_time;
	u32 n_file_size_high;
	u32 n_file_size_low;
	u32 dw_reserved0;
	u32 dw_reserved1;
	Array_fixed_u16_260 c_file_name;
	Array_fixed_u16_14 c_alternate_file_name;
	u32 dw_file_type;
	u32 dw_creator_type;
	u16 w_finder_flags;
};

struct os__Process {
	string filename;
	int pid;
	int code;
	os__ProcessState status;
	string err;
	Array_string args;
	string work_folder;
	bool env_is_custom;
	Array_string env;
	bool use_stdio_ctl;
	bool use_pgroup;
	Array_fixed_int_3 stdio_fd;
	voidptr wdata;
	bool create_no_window;
};

struct os__WProcess {
	os__ProcessInformation proc_info;
	Array_fixed_u8_65536 command_line;
	u32* child_stdin;
	u32* child_stdout_read;
	u32* child_stdout_write;
	u32* child_stderr_read;
	u32* child_stderr_write;
};

struct x__json2__InvalidTokenError {
	x__json2__DecodeError DecodeError;
	x__json2__Token token;
	x__json2__TokenKind expected;
};

struct x__json2__UnknownTokenError {
	x__json2__DecodeError DecodeError;
	x__json2__Token token;
	x__json2__ValueKind kind;
};

struct x__json2__Parser {
	x__json2__Scanner* scanner;
	x__json2__Token prev_tok;
	x__json2__Token tok;
	x__json2__Token next_tok;
	int n_level;
	bool convert_type;
};

struct net__http__Cookie {
	string name;
	string value;
	string path;
	string domain;
	time__Time expires;
	string raw_expires;
	int max_age;
	bool secure;
	bool http_only;
	net__http__SameSite same_site;
	string raw;
	Array_string unparsed;
};

struct sync__Channel {
	u8* ringbuf;
	u8* statusbuf;
	u32 objsize;
	sync__Semaphore writesem;
	sync__Semaphore readsem;
	sync__Semaphore writesem_im;
	sync__Semaphore readsem_im;
	atomic_uintptr_t write_adr;
	atomic_uintptr_t read_adr;
	atomic_uintptr_t adr_read;
	atomic_uintptr_t adr_written;
	u32 write_free;
	u32 read_avail;
	u32 buf_elem_write_idx;
	u32 buf_elem_read_idx;
	sync__Subscription* write_subscriber;
	sync__Subscription* read_subscriber;
	u16 write_sub_mtx;
	u16 read_sub_mtx;
	u16 closed;
	u32 cap;
};

struct sync__ManyTimes {
	sync__RwMutex m;
	u64 times;
	u64 count;
};

struct sync__Once {
	sync__RwMutex m;
	u64 count;
};

struct sync__WaitGroup {
	u32 task_count;
	u32 wait_count;
	sync__Semaphore sem;
};

struct net__websocket__Frame {
	int header_len;
	int frame_size;
	bool fin;
	bool rsv1;
	bool rsv2;
	bool rsv3;
	net__websocket__OPCode opcode;
	bool has_mask;
	int payload_len;
	Array_fixed_u8_4 masking_key;
};

union encoding__base64__B64_64_datablock {
	u64 data;
	Array_fixed_u8_8 data_byte;
};

union encoding__base64__B64_32_datablock {
	u32 data;
	Array_fixed_u8_4 data_byte;
};

struct net__Unix {
	Array_fixed_u8_108 path;
};
#pragma pack(push, 1)

struct net__Ip {
	u16 port;
	Array_fixed_u8_4 addr;
	Array_fixed_u8_8 sin_pad;
};
#pragma pack(pop)
#pragma pack(push, 1)

struct net__Ip6 {
	u16 port;
	u32 flow_info;
	Array_fixed_u8_16 addr;
	u32 scope_id;
};
#pragma pack(pop)

struct net__TcpSocket {
	net__Socket Socket;
};

struct net__mbedtls__SSLConn {
	net__mbedtls__SSLConnectConfig config;
	mbedtls_net_context server_fd;
	mbedtls_ssl_context ssl;
	mbedtls_ssl_config conf;
	net__mbedtls__SSLCerts* certs;
	int handle;
	time__Duration duration;
	bool opened;
	bool owns_socket;
};

struct net__ssl__SSLConnectConfig {
	net__mbedtls__SSLConnectConfig SSLConnectConfig;
};

struct rand__wyrand__WyRandRNG {
	rand__buffer__PRNGBuffer PRNGBuffer;
	u64 state;
	int bytes_left;
	u64 buffer;
};

struct net__mbedtls__SSLListener {
	string saddr;
	net__mbedtls__SSLConnectConfig config;
	mbedtls_net_context server_fd;
	mbedtls_ssl_context ssl;
	mbedtls_ssl_config conf;
	net__mbedtls__SSLCerts* certs;
	bool opened;
};

struct SymbolInfoContainer {
	SymbolInfo syminfo;
	Array_fixed_char_254 f_name_rest;
};
struct _option_discord__User {
	byte state;
	IError err;
	byte data[sizeof(discord__User) > 1 ? sizeof(discord__User) : 1];
};

struct discord__Emoji {
	_option_discord__Snowflake id;
	_option_string name;
	_option_Array_discord__Snowflake roles;
	_option_discord__User user;
	_option_bool require_colons;
	_option_bool managed;
	_option_bool animated;
	_option_bool available;
};

struct net__websocket__Client {
	bool is_server;
	net__ssl__SSLConn* ssl_conn;
	Array_net__websocket__Flag flags;
	Array_net__websocket__Fragment fragments;
	Array_net__websocket__MessageEventHandler message_callbacks;
	Array_net__websocket__ErrorEventHandler error_callbacks;
	Array_net__websocket__OpenEventHandler open_callbacks;
	Array_net__websocket__CloseEventHandler close_callbacks;
	bool is_ssl;
	net__websocket__Uri uri;
	string id;
	i64 read_timeout;
	i64 write_timeout;
	net__http__Header header;
	net__TcpConn* conn;
	int nonce_size;
	bool panic_on_callback;
	__shared__net__websocket__ClientState* client_state;
	log__Logger* logger;
	string resource_name;
	i64 last_pong_ut;
};

struct discord__Sticker {
	discord__Snowflake id;
	_option_discord__Snowflake pack_id;
	string name;
	_option_string description;
	_option_string tags;
	discord__StickerType typ;
	discord__StickerFormatType format_type;
	_option_bool available;
	_option_discord__Snowflake guild_id;
	_option_discord__User user;
	_option_int sort_value;
};
struct _option_discord__Permissions {
	byte state;
	IError err;
	byte data[sizeof(discord__Permissions) > 1 ? sizeof(discord__Permissions) : 1];
};

struct discord__GuildMember {
	_option_discord__User user;
	_option_string nick;
	_option_string avatar;
	Array_discord__Snowflake roles;
	time__Time joined_at;
	_option_time__Time premium_since;
	bool deaf;
	bool mute;
	discord__GuildMemberFlags flags;
	_option_bool pending;
	_option_discord__Permissions permissions;
	_option_time__Time communication_disabled_until;
};

struct net__http__Request {
	net__http__Version version;
	net__http__Method method;
	net__http__Header header;
	string host;
	Map_string_string cookies;
	string data;
	string url;
	string user_agent;
	bool verbose;
	voidptr user_ptr;
	net__http__HttpProxy* proxy;
	i64 read_timeout;
	i64 write_timeout;
	bool validate;
	string verify;
	string cert;
	string cert_key;
	bool in_memory_verification;
	bool allow_redirect;
	int max_retries;
	net__http__RequestRedirectFn on_redirect;
	net__http__RequestProgressFn on_progress;
	net__http__RequestFinishFn on_finish;
};

struct net__http__Response {
	string body;
	net__http__Header header;
	int status_code;
	string status_msg;
	string http_version;
};

struct discord__Interaction {
	discord__Snowflake id;
	discord__Snowflake application_id;
	discord__InteractionType typ;
	x__json2__Any data;
	_option_discord__Snowflake guild_id;
	_option_discord__Snowflake channel_id;
	_option_discord__User user;
	string token;
	_option_discord__Permissions app_permissions;
	_option_string locale;
	_option_string guild_locale;
};

struct log__ThreadSafeLog {
	log__Log Log;
	sync__Mutex mu;
};

struct net__http__FetchConfig {
	string url;
	net__http__Method method;
	net__http__Header header;
	string data;
	Map_string_string params;
	Map_string_string cookies;
	string user_agent;
	voidptr user_ptr;
	bool verbose;
	net__http__HttpProxy* proxy;
	bool validate;
	string verify;
	string cert;
	string cert_key;
	bool in_memory_verification;
	bool allow_redirect;
	int max_retries;
	net__http__RequestRedirectFn on_redirect;
	net__http__RequestProgressFn on_progress;
	net__http__RequestFinishFn on_finish;
};

struct net__http__PostMultipartFormConfig {
	Map_string_string form;
	Map_string_Array_net__http__FileData files;
	net__http__Header header;
};

struct net__TcpConn {
	net__TcpSocket sock;
	int handle;
	time__Time write_deadline;
	time__Time read_deadline;
	time__Duration read_timeout;
	time__Duration write_timeout;
	bool is_blocking;
};

struct net__ssl__SSLConn {
	net__mbedtls__SSLConn SSLConn;
};

struct net__http__ResponseConfig {
	net__http__Version version;
	net__http__Status status;
	net__http__Header header;
	string body;
};

struct net__TcpListener {
	net__TcpSocket sock;
	time__Duration accept_timeout;
	time__Time accept_deadline;
};

union net__AddrData {
	net__Unix Unix;
	net__Ip Ip;
	net__Ip6 Ip6;
};

struct discord__InteractionCreateEvent {
	discord__Interaction interaction;
};

struct net__http__Server {
	net__http__ServerStatus state;
	string addr;
	int port;
	net__http__Handler handler;
	time__Duration read_timeout;
	time__Duration write_timeout;
	time__Duration accept_timeout;
	int pool_channel_slots;
	int worker_num;
	net__TcpListener listener;
	anon_fn_mut_net__http__server on_running;
	anon_fn_mut_net__http__server on_stopped;
	anon_fn_mut_net__http__server on_closed;
	bool show_startup_message;
};
#pragma pack(push, 1)

struct net__Addr {
	u16 f;
	net__AddrData addr;
};
#pragma pack(pop)

struct net__UdpSocket {
	net__Socket Socket;
	net__Addr l;
	bool has_r;
	net__Addr r;
};

struct net__UdpConn {
	net__UdpSocket sock;
	time__Time write_deadline;
	time__Time read_deadline;
	time__Duration read_timeout;
	time__Duration write_timeout;
};
// #end sorted_symbols

// BEGIN_array_fixed_return_structs
// END_array_fixed_return_structs


// BEGIN_multi_return_structs
struct multi_return_u32_u32 {
	u32 arg0;
	u32 arg1;
};

struct multi_return_string_string {
	string arg0;
	string arg1;
};

struct multi_return_int_int {
	int arg0;
	int arg1;
};

struct multi_return_u32_u32_u32 {
	u32 arg0;
	u32 arg1;
	u32 arg2;
};

struct multi_return_strconv__ParserState_strconv__PrepNumber {
	strconv__ParserState arg0;
	strconv__PrepNumber arg1;
};

struct multi_return_u64_int {
	u64 arg0;
	int arg1;
};

struct multi_return_strconv__Dec32_bool {
	strconv__Dec32 arg0;
	bool arg1;
};

struct multi_return_strconv__Dec64_bool {
	strconv__Dec64 arg0;
	bool arg1;
};

struct multi_return_string_x__json2__Any {
	string arg0;
	x__json2__Any arg1;
};

struct multi_return_string_int {
	string arg0;
	int arg1;
};

struct multi_return_int_bool {
	int arg0;
	bool arg1;
};

struct multi_return_u64_u64 {
	u64 arg0;
	u64 arg1;
};

struct multi_return_f64_int {
	f64 arg0;
	int arg1;
};

struct multi_return_int_int_int {
	int arg0;
	int arg1;
	int arg2;
};

struct multi_return_int_int_int_int_int_i64_bool {
	int arg0;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	i64 arg5;
	bool arg6;
};

struct multi_return_net__http__Method_net__urllib__URL_net__http__Version {
	net__http__Method arg0;
	net__urllib__URL arg1;
	net__http__Version arg2;
};

struct multi_return_Map_string_string_Map_string_Array_net__http__FileData {
	Map_string_string arg0;
	Map_string_Array_net__http__FileData arg1;
};

struct multi_return_string_int_string {
	string arg0;
	int arg1;
	string arg2;
};

struct multi_return_string_ref_net__websocket__ServerClient {
	string arg0;
	net__websocket__ServerClient* arg1;
};

struct multi_return_int_net__Addr {
	int arg0;
	net__Addr arg1;
};

struct multi_return_string_u16 {
	string arg0;
	u16 arg1;
};

struct multi_return_f64_f64 {
	f64 arg0;
	f64 arg1;
};

struct multi_return_u64_u8 {
	u64 arg0;
	u8 arg1;
};

struct multi_return_os__File_string {
	os__File arg0;
	string arg1;
};

struct multi_return_ref_u16_ref_sync__Subscription {
	u16* arg0;
	sync__Subscription** arg1;
};

// END_multi_return_structs


typedef struct thread_arg_net__http__HandlerWorker_process_requests {
	void (*fn) (net__http__HandlerWorker*);
	net__http__HandlerWorker* arg0;
} thread_arg_net__http__HandlerWorker_process_requests;
 u32 net__http__HandlerWorker_process_requests_thread_wrapper(thread_arg_net__http__HandlerWorker_process_requests *arg);

typedef struct thread_arg_net__websocket__Server_handle_ping {
	void (*fn) (net__websocket__Server*);
	net__websocket__Server* arg0;
} thread_arg_net__websocket__Server_handle_ping;
 u32 net__websocket__Server_handle_ping_thread_wrapper(thread_arg_net__websocket__Server_handle_ping *arg);

typedef struct thread_arg_net__websocket__Server_serve_client {
	_result_void (*fn) (net__websocket__Server*, net__websocket__Client*);
	net__websocket__Server* arg0;
	net__websocket__Client* arg1;
	void* ret_ptr;
} thread_arg_net__websocket__Server_serve_client;
 u32 net__websocket__Server_serve_client_thread_wrapper(thread_arg_net__websocket__Server_serve_client *arg);

typedef struct thread_arg_ {
	void (*fn) (_result_void (*) (discord__DispatchEvent_T_discord__GatewayClient), int, discord__DispatchEvent_T_discord__GatewayClient);
	_result_void (*arg1) (discord__DispatchEvent_T_discord__GatewayClient);
	int arg2;
	discord__DispatchEvent_T_discord__GatewayClient arg3;
} thread_arg_;
 u32 _thread_wrapper(thread_arg_ *arg);

typedef struct thread_arg_anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255 {
	_result_int (*fn) (discord__GatewayClient*, time__Duration);
	discord__GatewayClient* arg1;
	i64 arg2;
	void* ret_ptr;
} thread_arg_anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255;
 u32 anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255_thread_wrapper(thread_arg_anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255 *arg);
static bool Array_u8_contains(Array_u8 a, u8 v); // auto
static bool Array_string_contains(Array_string a, string v); // auto
static bool Array_rune_contains(Array_rune a, rune v); // auto
static bool Array_int_contains(Array_int a, int v); // auto
static int Array_string_index(Array_string a, string v); // auto

// V alias definitions:

// V shared types:
struct __shared__net__websocket__ServerState {
	sync__RwMutex mtx;
	net__websocket__ServerState val;
};
struct __shared__net__websocket__ClientState {
	sync__RwMutex mtx;
	net__websocket__ClientState val;
};

// V Option_xxx definitions:
struct _option_multi_return_string_string {
	byte state;
	IError err;
	byte data[sizeof(multi_return_string_string) > 1 ? sizeof(multi_return_string_string) : 1];
};

struct _option_u8 {
	byte state;
	IError err;
	byte data[sizeof(u8) > 1 ? sizeof(u8) : 1];
};

struct _option_rune {
	byte state;
	IError err;
	byte data[sizeof(rune) > 1 ? sizeof(rune) : 1];
};

struct _option_log__Level {
	byte state;
	IError err;
	byte data[sizeof(log__Level) > 1 ? sizeof(log__Level) : 1];
};

struct _option_log__LogTarget {
	byte state;
	IError err;
	byte data[sizeof(log__LogTarget) > 1 ? sizeof(log__LogTarget) : 1];
};

struct _option_net__http__Cookie {
	byte state;
	IError err;
	byte data[sizeof(net__http__Cookie) > 1 ? sizeof(net__http__Cookie) : 1];
};

struct _option_net__TcpConn_ptr {
	byte state;
	IError err;
	byte data[sizeof(net__TcpConn*) > 1 ? sizeof(net__TcpConn*) : 1];
};

struct _option_net__websocket__ServerClient_ptr {
	byte state;
	IError err;
	byte data[sizeof(net__websocket__ServerClient*) > 1 ? sizeof(net__websocket__ServerClient*) : 1];
};

struct _option_discord__DispatchEvent_T_discord__GatewayClient {
	byte state;
	IError err;
	byte data[sizeof(discord__DispatchEvent_T_discord__GatewayClient) > 1 ? sizeof(discord__DispatchEvent_T_discord__GatewayClient) : 1];
};

struct _option_anon_fn_t__bool {
	byte state;
	IError err;
	byte data[sizeof(void*) > 1 ? sizeof(void*) : 1];
};


// V result_xxx definitions:
struct _result_void {
	bool is_error;
	IError err;
	byte data[sizeof(u8) > 1 ? sizeof(u8) : 1];
};

struct _result_bool {
	bool is_error;
	IError err;
	byte data[sizeof(bool) > 1 ? sizeof(bool) : 1];
};

struct _result_int {
	bool is_error;
	IError err;
	byte data[sizeof(int) > 1 ? sizeof(int) : 1];
};

struct _result_f64 {
	bool is_error;
	IError err;
	byte data[sizeof(f64) > 1 ? sizeof(f64) : 1];
};

struct _result_u64 {
	bool is_error;
	IError err;
	byte data[sizeof(u64) > 1 ? sizeof(u64) : 1];
};

struct _result_i64 {
	bool is_error;
	IError err;
	byte data[sizeof(i64) > 1 ? sizeof(i64) : 1];
};

struct _result_rune {
	bool is_error;
	IError err;
	byte data[sizeof(rune) > 1 ? sizeof(rune) : 1];
};

struct _result_string {
	bool is_error;
	IError err;
	byte data[sizeof(string) > 1 ? sizeof(string) : 1];
};

struct _result_Array_string {
	bool is_error;
	IError err;
	byte data[sizeof(Array_string) > 1 ? sizeof(Array_string) : 1];
};

struct _result_net__urllib__URL {
	bool is_error;
	IError err;
	byte data[sizeof(net__urllib__URL) > 1 ? sizeof(net__urllib__URL) : 1];
};

struct _result_net__urllib__ParseAuthorityRes {
	bool is_error;
	IError err;
	byte data[sizeof(net__urllib__ParseAuthorityRes) > 1 ? sizeof(net__urllib__ParseAuthorityRes) : 1];
};

struct _result_net__urllib__Values {
	bool is_error;
	IError err;
	byte data[sizeof(net__urllib__Values) > 1 ? sizeof(net__urllib__Values) : 1];
};

struct _result_time__Time {
	bool is_error;
	IError err;
	byte data[sizeof(time__Time) > 1 ? sizeof(time__Time) : 1];
};

struct _result_multi_return_int_int_int {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_int_int_int) > 1 ? sizeof(multi_return_int_int_int) : 1];
};

struct _result_multi_return_int_int_int_int_int_i64_bool {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_int_int_int_int_int_i64_bool) > 1 ? sizeof(multi_return_int_int_int_int_int_i64_bool) : 1];
};

struct _result_voidptr {
	bool is_error;
	IError err;
	byte data[sizeof(voidptr) > 1 ? sizeof(voidptr) : 1];
};

struct _result_Array_u8 {
	bool is_error;
	IError err;
	byte data[sizeof(Array_u8) > 1 ? sizeof(Array_u8) : 1];
};

struct _result_multi_return_u64_u8 {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_u64_u8) > 1 ? sizeof(multi_return_u64_u8) : 1];
};

struct _result_os__File {
	bool is_error;
	IError err;
	byte data[sizeof(os__File) > 1 ? sizeof(os__File) : 1];
};

struct _result_FILE_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(FILE*) > 1 ? sizeof(FILE*) : 1];
};

struct _result_strings__Builder {
	bool is_error;
	IError err;
	byte data[sizeof(strings__Builder) > 1 ? sizeof(strings__Builder) : 1];
};

struct _result_os__Result {
	bool is_error;
	IError err;
	byte data[sizeof(os__Result) > 1 ? sizeof(os__Result) : 1];
};

struct _result_anon_fn_os__signal {
	bool is_error;
	IError err;
	byte data[sizeof(void*) > 1 ? sizeof(void*) : 1];
};

struct _result_x__json2__Any {
	bool is_error;
	IError err;
	byte data[sizeof(x__json2__Any) > 1 ? sizeof(x__json2__Any) : 1];
};

struct _result_term__Coord {
	bool is_error;
	IError err;
	byte data[sizeof(term__Coord) > 1 ? sizeof(term__Coord) : 1];
};

struct _result_u32 {
	bool is_error;
	IError err;
	byte data[sizeof(u32) > 1 ? sizeof(u32) : 1];
};

struct _result_f32 {
	bool is_error;
	IError err;
	byte data[sizeof(f32) > 1 ? sizeof(f32) : 1];
};

struct _result_multi_return_f64_f64 {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_f64_f64) > 1 ? sizeof(multi_return_f64_f64) : 1];
};

struct _result_multi_return_os__File_string {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_os__File_string) > 1 ? sizeof(multi_return_os__File_string) : 1];
};

struct _result_multi_return_string_string {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_string_string) > 1 ? sizeof(multi_return_string_string) : 1];
};

struct _result_net__Addr {
	bool is_error;
	IError err;
	byte data[sizeof(net__Addr) > 1 ? sizeof(net__Addr) : 1];
};

struct _result_Array_net__Addr {
	bool is_error;
	IError err;
	byte data[sizeof(Array_net__Addr) > 1 ? sizeof(Array_net__Addr) : 1];
};

struct _result_multi_return_string_u16 {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_string_u16) > 1 ? sizeof(multi_return_string_u16) : 1];
};

struct _result_net__TcpConn_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__TcpConn*) > 1 ? sizeof(net__TcpConn*) : 1];
};

struct _result_net__TcpSocket {
	bool is_error;
	IError err;
	byte data[sizeof(net__TcpSocket) > 1 ? sizeof(net__TcpSocket) : 1];
};

struct _result_net__TcpListener_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__TcpListener*) > 1 ? sizeof(net__TcpListener*) : 1];
};

struct _result_net__UdpConn_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__UdpConn*) > 1 ? sizeof(net__UdpConn*) : 1];
};

struct _result_net__UdpSocket_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__UdpSocket*) > 1 ? sizeof(net__UdpSocket*) : 1];
};

struct _result_multi_return_int_net__Addr {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_int_net__Addr) > 1 ? sizeof(multi_return_int_net__Addr) : 1];
};

struct _result_u16 {
	bool is_error;
	IError err;
	byte data[sizeof(u16) > 1 ? sizeof(u16) : 1];
};

struct _result_net__mbedtls__SSLListener_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__mbedtls__SSLListener*) > 1 ? sizeof(net__mbedtls__SSLListener*) : 1];
};

struct _result_net__mbedtls__SSLConn_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__mbedtls__SSLConn*) > 1 ? sizeof(net__mbedtls__SSLConn*) : 1];
};

struct _result_net__ssl__SSLConn_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__ssl__SSLConn*) > 1 ? sizeof(net__ssl__SSLConn*) : 1];
};

struct _result_net__http__Response {
	bool is_error;
	IError err;
	byte data[sizeof(net__http__Response) > 1 ? sizeof(net__http__Response) : 1];
};

struct _result_net__http__Cookie {
	bool is_error;
	IError err;
	byte data[sizeof(net__http__Cookie) > 1 ? sizeof(net__http__Cookie) : 1];
};

struct _result_net__http__Header {
	bool is_error;
	IError err;
	byte data[sizeof(net__http__Header) > 1 ? sizeof(net__http__Header) : 1];
};

struct _result_net__http__HttpProxy_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__http__HttpProxy*) > 1 ? sizeof(net__http__HttpProxy*) : 1];
};

struct _result_net__http__Request {
	bool is_error;
	IError err;
	byte data[sizeof(net__http__Request) > 1 ? sizeof(net__http__Request) : 1];
};

struct _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_net__http__Method_net__urllib__URL_net__http__Version) > 1 ? sizeof(multi_return_net__http__Method_net__urllib__URL_net__http__Version) : 1];
};

struct _result_multi_return_string_int_string {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_string_int_string) > 1 ? sizeof(multi_return_string_int_string) : 1];
};

struct _result_multi_return_int_int {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_int_int) > 1 ? sizeof(multi_return_int_int) : 1];
};

struct _result_multi_return_string_ref_net__websocket__ServerClient {
	bool is_error;
	IError err;
	byte data[sizeof(multi_return_string_ref_net__websocket__ServerClient) > 1 ? sizeof(multi_return_string_ref_net__websocket__ServerClient) : 1];
};

struct _result_net__websocket__Message {
	bool is_error;
	IError err;
	byte data[sizeof(net__websocket__Message) > 1 ? sizeof(net__websocket__Message) : 1];
};

struct _result_net__websocket__Frame {
	bool is_error;
	IError err;
	byte data[sizeof(net__websocket__Frame) > 1 ? sizeof(net__websocket__Frame) : 1];
};

struct _result_net__websocket__Client_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__websocket__Client*) > 1 ? sizeof(net__websocket__Client*) : 1];
};

struct _result_net__websocket__Uri_ptr {
	bool is_error;
	IError err;
	byte data[sizeof(net__websocket__Uri*) > 1 ? sizeof(net__websocket__Uri*) : 1];
};

struct _result_discord__Emoji {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Emoji) > 1 ? sizeof(discord__Emoji) : 1];
};

struct _result_discord__Snowflake {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Snowflake) > 1 ? sizeof(discord__Snowflake) : 1];
};

struct _result_discord__User {
	bool is_error;
	IError err;
	byte data[sizeof(discord__User) > 1 ? sizeof(discord__User) : 1];
};

struct _result_discord__Entitlement {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Entitlement) > 1 ? sizeof(discord__Entitlement) : 1];
};

struct _result_Array_discord__Entitlement {
	bool is_error;
	IError err;
	byte data[sizeof(Array_discord__Entitlement) > 1 ? sizeof(Array_discord__Entitlement) : 1];
};

struct _result_discord__WSMessage {
	bool is_error;
	IError err;
	byte data[sizeof(discord__WSMessage) > 1 ? sizeof(discord__WSMessage) : 1];
};

struct _result_discord__PartialGuild {
	bool is_error;
	IError err;
	byte data[sizeof(discord__PartialGuild) > 1 ? sizeof(discord__PartialGuild) : 1];
};

struct _result_discord__Permissions {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Permissions) > 1 ? sizeof(discord__Permissions) : 1];
};

struct _result_Array_discord__PartialGuild {
	bool is_error;
	IError err;
	byte data[sizeof(Array_discord__PartialGuild) > 1 ? sizeof(Array_discord__PartialGuild) : 1];
};

struct _result_discord__RoleTags {
	bool is_error;
	IError err;
	byte data[sizeof(discord__RoleTags) > 1 ? sizeof(discord__RoleTags) : 1];
};

struct _result_discord__Role {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Role) > 1 ? sizeof(discord__Role) : 1];
};

struct _result_discord__WelcomeChannel {
	bool is_error;
	IError err;
	byte data[sizeof(discord__WelcomeChannel) > 1 ? sizeof(discord__WelcomeChannel) : 1];
};

struct _result_discord__WelcomeScreen {
	bool is_error;
	IError err;
	byte data[sizeof(discord__WelcomeScreen) > 1 ? sizeof(discord__WelcomeScreen) : 1];
};

struct _result_discord__Guild {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Guild) > 1 ? sizeof(discord__Guild) : 1];
};

struct _result_discord__Sticker {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Sticker) > 1 ? sizeof(discord__Sticker) : 1];
};

struct _result_discord__GuildMember {
	bool is_error;
	IError err;
	byte data[sizeof(discord__GuildMember) > 1 ? sizeof(discord__GuildMember) : 1];
};

struct _result_discord__Interaction {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Interaction) > 1 ? sizeof(discord__Interaction) : 1];
};

struct _result_discord__Sku {
	bool is_error;
	IError err;
	byte data[sizeof(discord__Sku) > 1 ? sizeof(discord__Sku) : 1];
};

struct _result_Array_discord__Sku {
	bool is_error;
	IError err;
	byte data[sizeof(Array_discord__Sku) > 1 ? sizeof(Array_discord__Sku) : 1];
};

struct _result_discord__AvatarDecorationData {
	bool is_error;
	IError err;
	byte data[sizeof(discord__AvatarDecorationData) > 1 ? sizeof(discord__AvatarDecorationData) : 1];
};


// V json forward decls:

// V definitions:
static char * v_typeof_interface_IError(int sidx);
static char * v_typeof_interface_log__Logger(int sidx);
static char * v_typeof_interface_discord__Component(int sidx);
static char * v_typeof_interface_discord__Image(int sidx);
static char * v_typeof_interface_io__Writer(int sidx);
static char * v_typeof_interface_x__json2__Encodable(int sidx);
static char * v_typeof_interface_x__json2__Decodable(int sidx);
static char * v_typeof_interface_net__http__Handler(int sidx);
static char * v_typeof_interface_io__Reader(int sidx);
static char * v_typeof_interface_io__RandomReader(int sidx);
static char * v_typeof_interface_io__ReaderWriter(int sidx);
static char * v_typeof_interface_io__RandomWriter(int sidx);
static char * v_typeof_interface_rand__PRNG(int sidx);
static char * v_typeof_interface_hash__Hasher(int sidx);
static char * v_typeof_interface_hash__Hash32er(int sidx);
static char * v_typeof_interface_hash__Hash64er(int sidx);
// end of definitions #endif
strings__Builder strings__new_builder(int initial_size);
Array_u8 strings__Builder_reuse_as_plain_u8_array(strings__Builder* b);
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len);
void strings__Builder_write_rune(strings__Builder* b, rune r);
void strings__Builder_write_runes(strings__Builder* b, Array_rune runes);
void strings__Builder_clear(strings__Builder* b);
void strings__Builder_write_u8(strings__Builder* b, u8 data);
void strings__Builder_write_byte(strings__Builder* b, u8 data);
void strings__Builder_write_decimal(strings__Builder* b, i64 n);
_result_int strings__Builder_write(strings__Builder* b, Array_u8 data);
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap);
u8 strings__Builder_byte_at(strings__Builder* b, int n);
void strings__Builder_write_string(strings__Builder* b, string s);
void strings__Builder_writeln_string(strings__Builder* b, string s);
void strings__Builder_go_back(strings__Builder* b, int n);
VV_LOCAL_SYMBOL string strings__Builder_spart(strings__Builder* b, int start_pos, int n);
string strings__Builder_cut_last(strings__Builder* b, int n);
string strings__Builder_cut_to(strings__Builder* b, int pos);
void strings__Builder_go_back_to(strings__Builder* b, int pos);
void strings__Builder_writeln(strings__Builder* b, string s);
string strings__Builder_last_n(strings__Builder* b, int n);
string strings__Builder_after(strings__Builder* b, int n);
string strings__Builder_str(strings__Builder* b);
void strings__Builder_ensure_cap(strings__Builder* b, int n);
void strings__Builder_free(strings__Builder* b);
int strings__levenshtein_distance(string a, string b);
f32 strings__levenshtein_distance_percentage(string a, string b);
f32 strings__dice_coefficient(string s1, string s2);
string strings__repeat(u8 c, int n);
string strings__repeat_string(string s, int n);
string strings__find_between_pair_u8(string input, u8 start, u8 end);
string strings__find_between_pair_rune(string input, rune start, rune end);
string strings__find_between_pair_string(string input, string start, string end);
Array_string strings__split_capital(string s);
int math__bits__leading_zeros_8(u8 x);
int math__bits__leading_zeros_16(u16 x);
int math__bits__leading_zeros_32(u32 x);
int math__bits__leading_zeros_64(u64 x);
int math__bits__trailing_zeros_8(u8 x);
int math__bits__trailing_zeros_16(u16 x);
int math__bits__trailing_zeros_32(u32 x);
int math__bits__trailing_zeros_64(u64 x);
int math__bits__ones_count_8(u8 x);
int math__bits__ones_count_16(u16 x);
int math__bits__ones_count_32(u32 x);
int math__bits__ones_count_64(u64 x);
u8 math__bits__rotate_left_8(u8 x, int k);
u16 math__bits__rotate_left_16(u16 x, int k);
u32 math__bits__rotate_left_32(u32 x, int k);
u64 math__bits__rotate_left_64(u64 x, int k);
u8 math__bits__reverse_8(u8 x);
u16 math__bits__reverse_16(u16 x);
u32 math__bits__reverse_32(u32 x);
u64 math__bits__reverse_64(u64 x);
u16 math__bits__reverse_bytes_16(u16 x);
u32 math__bits__reverse_bytes_32(u32 x);
u64 math__bits__reverse_bytes_64(u64 x);
int math__bits__len_8(u8 x);
int math__bits__len_16(u16 x);
int math__bits__len_32(u32 x);
int math__bits__len_64(u64 x);
multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry);
multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry);
multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow);
multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow);
multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y);
multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y);
multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y);
multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1);
u32 math__bits__rem_32(u32 hi, u32 lo, u32 y);
u64 math__bits__rem_64(u64 hi, u64 lo, u64 y);
multi_return_f64_int math__bits__normalize(f64 x);
u32 math__bits__f32_bits(f32 f);
f32 math__bits__f32_from_bits(u32 b);
u64 math__bits__f64_bits(f64 f);
f64 math__bits__f64_from_bits(u64 b);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0);
VV_LOCAL_SYMBOL bool strconv__is_digit(u8 x);
VV_LOCAL_SYMBOL bool strconv__is_space(u8 x);
VV_LOCAL_SYMBOL bool strconv__is_exp(u8 x);
VV_LOCAL_SYMBOL multi_return_strconv__ParserState_strconv__PrepNumber strconv__parser(string s);
VV_LOCAL_SYMBOL u64 strconv__converter(strconv__PrepNumber* pn);
_result_f64 strconv__atof64(string s);
f64 strconv__atof_quick(string s);
u8 strconv__byte_to_lower(u8 c);
_result_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size);
_result_u64 strconv__parse_uint(string s, int _base, int _bit_size);
_result_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit);
_result_i64 strconv__parse_int(string _s, int base, int _bit_size);
_result_int strconv__atoi(string s);
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp);
VV_LOCAL_SYMBOL strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp);
string strconv__f32_to_str(f32 f, int n_digit);
string strconv__f32_to_str_pad(f32 f, int n_digit);
VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit);
VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp);
VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp);
string strconv__f64_to_str(f64 f, int n_digit);
string strconv__f64_to_str_pad(f64 f, int n_digit);
string strconv__format_str(string s, strconv__BF_param p);
void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb);
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res);
string strconv__f64_to_str_lnd1(f64 f, int dec_digit);
string strconv__format_fl(f64 f, strconv__BF_param p);
string strconv__format_es(f64 f, strconv__BF_param p);
string strconv__remove_tail_zeros(string s);
string strconv__ftoa_64(f64 f);
string strconv__ftoa_long_64(f64 f);
string strconv__ftoa_32(f32 f);
string strconv__ftoa_long_32(f32 f);
string strconv__format_int(i64 n, int radix);
string strconv__format_uint(u64 n, int radix);
string strconv__f32_to_str_l(f32 f);
string strconv__f32_to_str_l_with_dot(f32 f);
string strconv__f64_to_str_l(f64 f);
string strconv__f64_to_str_l_with_dot(f64 f);
string strconv__fxx_to_str_l_parse(string s);
string strconv__fxx_to_str_l_parse_with_dot(string s);
VV_LOCAL_SYMBOL int strconv__bool_to_int(bool b);
VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b);
VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b);
VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero);
VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j);
VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p);
VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e);
VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e);
VV_LOCAL_SYMBOL int strconv__pow5_bits(int e);
VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift);
VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift);
VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p);
VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p);
int strconv__dec_digits(u64 n);
void strconv__v_printf(string str, Array_voidptr pt);
string strconv__v_sprintf(string str, Array_voidptr pt);
VV_LOCAL_SYMBOL void strconv__v_sprintf_panic(int idx, int len);
VV_LOCAL_SYMBOL f64 strconv__fabs(f64 x);
string strconv__format_fl_old(f64 f, strconv__BF_param p);
VV_LOCAL_SYMBOL string strconv__format_es_old(f64 f, strconv__BF_param p);
VV_LOCAL_SYMBOL string strconv__remove_tail_zeros_old(string s);
string strconv__format_dec_old(u64 d, strconv__BF_param p);
VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size);
VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth);
VV_LOCAL_SYMBOL array __new_array_with_map_default(int mylen, int cap, int elm_size, map val);
VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required);
array array_repeat(array a, int count);
array array_repeat_to_depth(array a, int count, int depth);
void array_insert(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_insert_many(array* a, int i, voidptr val, int size);
void array_prepend(array* a, voidptr val);
VV_LOCAL_SYMBOL void array_prepend_many(array* a, voidptr val, int size);
void array_delete(array* a, int i);
void array_delete_many(array* a, int i, int size);
void array_clear(array* a);
void array_reset(array* a);
void array_trim(array* a, int index);
void array_drop(array* a, int num);
VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get(array a, int i);
VV_LOCAL_SYMBOL voidptr array_get_with_check(array a, int i);
voidptr array_first(array a);
voidptr array_last(array a);
voidptr array_pop(array* a);
void array_delete_last(array* a);
VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end);
VV_LOCAL_SYMBOL array array_slice_ni(array a, int _start, int _end);
VV_LOCAL_SYMBOL array array_clone_static_to_depth(array a, int depth);
array array_clone(array* a);
array array_clone_to_depth(array* a, int depth);
VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_push(array* a, voidptr val);
void array_push_many(array* a3, voidptr val, int size);
void array_reverse_in_place(array* a);
array array_reverse(array a);
void array_free(array* a);
array array_filter(array a, bool (*predicate)(voidptr ));
bool array_any(array a, bool (*predicate)(voidptr ));
bool array_all(array a, bool (*predicate)(voidptr ));
array array_map(array a, voidptr (*callback)(voidptr ));
void array_sort(array* a, int (*callback)(voidptr , voidptr ));
array array_sorted(array* a, int (*callback)(voidptr , voidptr ));
void array_sort_with_compare(array* a, int (*callback)(voidptr , voidptr ));
array array_sorted_with_compare(array* a, int (*callback)(voidptr , voidptr ));
bool array_contains(array a, voidptr value);
int array_index(array a, voidptr value);
void Array_string_free(Array_string* a);
string Array_string_str(Array_string a);
string Array_u8_hex(Array_u8 b);
int copy(Array_u8* dst, Array_u8 src);
void array_grow_cap(array* a, int amount);
void array_grow_len(array* a, int amount);
Array_voidptr array_pointers(array a);
Array_u8 voidptr_vbytes(voidptr data, int len);
Array_u8 u8_vbytes(u8* data, int len);
VV_LOCAL_SYMBOL array __new_array_noscan(int mylen, int cap, int elm_size);
VV_LOCAL_SYMBOL array __new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_multi_default_noscan(int mylen, int cap, int elm_size, voidptr val);
VV_LOCAL_SYMBOL array __new_array_with_array_default_noscan(int mylen, int cap, int elm_size, array val);
VV_LOCAL_SYMBOL array new_array_from_c_array_noscan(int len, int cap, int elm_size, voidptr c_array);
VV_LOCAL_SYMBOL void array_ensure_cap_noscan(array* a, int required);
VV_LOCAL_SYMBOL array array_repeat_to_depth_noscan(array a, int count, int depth);
VV_LOCAL_SYMBOL void array_insert_noscan(array* a, int i, voidptr val);
VV_LOCAL_SYMBOL void array_insert_many_noscan(array* a, int i, voidptr val, int size);
VV_LOCAL_SYMBOL void array_prepend_noscan(array* a, voidptr val);
VV_LOCAL_SYMBOL void array_prepend_many_noscan(array* a, voidptr val, int size);
VV_LOCAL_SYMBOL voidptr array_pop_noscan(array* a);
VV_LOCAL_SYMBOL array array_clone_static_to_depth_noscan(array a, int depth);
VV_LOCAL_SYMBOL array array_clone_to_depth_noscan(array* a, int depth);
VV_LOCAL_SYMBOL void array_push_noscan(array* a, voidptr val);
VV_LOCAL_SYMBOL void array_push_many_noscan(array* a3, voidptr val, int size);
VV_LOCAL_SYMBOL array array_reverse_noscan(array a);
VV_LOCAL_SYMBOL void array_grow_cap_noscan(array* a, int amount);
VV_LOCAL_SYMBOL void array_grow_len_noscan(array* a, int amount);
void print_backtrace(void);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_msvc(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_mingw(int skipframes);
VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_tcc(int skipframes);
VV_LOCAL_SYMBOL void vhalt(void);
VV_LOCAL_SYMBOL void v_segmentation_fault_handler(int signal_number);
void _v_exit(int code);
VV_LOCAL_SYMBOL void panic_debug(int line_no, string file, string mod, string fn_name, string s);
void panic_option_not_set(string s);
void panic_result_not_set(string s);
void _v_panic(string s);
string c_error_number_str(int errnum);
void panic_error_number(string basestr, int errnum);
void eprintln(string s);
void eprint(string s);
void flush_stdout(void);
void flush_stderr(void);
void print(string s);
void println(string s);
VV_LOCAL_SYMBOL void _writeln_to_fd(int fd, string s);
VV_LOCAL_SYMBOL void _write_buf_to_fd(int fd, u8* buf, int buf_len);
u8* _v_malloc(isize n);
u8* malloc_noscan(isize n);
VV_LOCAL_SYMBOL u64 __at_least_one(u64 how_many);
u8* malloc_uncollectable(isize n);
u8* v_realloc(u8* b, isize n);
u8* realloc_data(u8* old_data, int old_size, int new_size);
u8* vcalloc(isize n);
u8* vcalloc_noscan(isize n);
void _v_free(voidptr ptr);
voidptr memdup(voidptr src, isize sz);
voidptr memdup_noscan(voidptr src, isize sz);
voidptr memdup_uncollectable(voidptr src, isize sz);
GCHeapUsage gc_heap_usage(void);
usize gc_memory_use(void);
VV_LOCAL_SYMBOL int v_fixed_index(int i, int len);
bool isnil(voidptr v);
VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type);
void VAssertMetaInfo_free(VAssertMetaInfo* ami);
VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i);
void gc_check_leaks(void);
VV_LOCAL_SYMBOL void print_libbacktrace(int frames_to_skip);
VV_LOCAL_SYMBOL void eprint_libbacktrace(int frames_to_skip);
VV_LOCAL_SYMBOL void restore_codepage(void);
VV_LOCAL_SYMBOL int is_terminal(int fd);
VV_LOCAL_SYMBOL void builtin_init(void);
VV_LOCAL_SYMBOL void add_vectored_exception_handler(int (*handler)(ExceptionPointers* ));
VV_LOCAL_SYMBOL int __attribute__((stdcall)) unhandled_exception_handler(ExceptionPointers* e);
VV_LOCAL_SYMBOL void add_unhandled_exception_handler(void);
VV_LOCAL_SYMBOL void break_if_debugger_attached(void);
string winapi_lasterr_str(void);
void panic_lasterr(string base);
int proc_pidpath(int , voidptr , int );
int vstrlen(u8* s);
int vstrlen_char(char* s);
voidptr vmemcpy(voidptr dest, const voidptr const_src, isize n);
voidptr vmemmove(voidptr dest, const voidptr const_src, isize n);
int vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n);
voidptr vmemset(voidptr s, int c, isize n);
VV_LOCAL_SYMBOL void vqsort(voidptr base, usize nmemb, usize size, int (*sort_cb)(const voidptr const_a, const voidptr const_b));
void chan_close(chan ch);
ChanState chan_try_pop(chan ch, voidptr obj);
ChanState chan_try_push(chan ch, voidptr obj);
int input_character(void);
int print_character(u8 ch);
string f64_str(f64 x);
string f64_strg(f64 x);
string float_literal_str(float_literal d);
string f64_strsci(f64 x, int digit_num);
string f64_strlong(f64 x);
string f32_str(f32 x);
string f32_strg(f32 x);
string f32_strsci(f32 x, int digit_num);
string f32_strlong(f32 x);
f32 f32_abs(f32 a);
VV_LOCAL_SYMBOL f64 f64_abs(f64 a);
f32 f32_max(f32 a, f32 b);
f32 f32_min(f32 a, f32 b);
f64 f64_max(f64 a, f64 b);
VV_LOCAL_SYMBOL f64 f64_min(f64 a, f64 b);
bool f32_eq_epsilon(f32 a, f32 b);
bool f64_eq_epsilon(f64 a, f64 b);
VV_LOCAL_SYMBOL void float_test(void);
string ptr_str(voidptr ptr);
string isize_str(isize x);
string usize_str(usize x);
string char_str(char* cptr);
VV_LOCAL_SYMBOL string int_str_l(int nn, int max);
string i8_str(i8 n);
string i16_str(i16 n);
string u16_str(u16 n);
string i32_str(i32 n);
string int_hex_full(int nn);
string int_str(int n);
string u32_str(u32 nn);
string int_literal_str(int_literal n);
string i64_str(i64 nn);
string u64_str(u64 nn);
string bool_str(bool b);
VV_LOCAL_SYMBOL string u64_to_hex(u64 nn, u8 len);
VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, u8 len);
string u8_hex(u8 nn);
string i8_hex(i8 nn);
string u16_hex(u16 nn);
string i16_hex(i16 nn);
string u32_hex(u32 nn);
string int_hex(int nn);
string int_hex2(int n);
string u64_hex(u64 nn);
string i64_hex(i64 nn);
string int_literal_hex(int_literal nn);
string voidptr_str(voidptr nn);
string byteptr_str(byteptr nn);
string charptr_str(charptr nn);
string u8_hex_full(u8 nn);
string i8_hex_full(i8 nn);
string u16_hex_full(u16 nn);
string i16_hex_full(i16 nn);
string u32_hex_full(u32 nn);
string i64_hex_full(i64 nn);
string voidptr_hex_full(voidptr nn);
string int_literal_hex_full(int_literal nn);
string u64_hex_full(u64 nn);
string u8_str(u8 b);
string u8_ascii_str(u8 b);
string u8_str_escaped(u8 b);
bool u8_is_capital(u8 c);
Array_u8 Array_u8_clone(Array_u8 b);
string Array_u8_bytestr(Array_u8 b);
_result_rune Array_u8_byterune(Array_u8 b);
string u8_repeat(u8 b, int count);
VV_LOCAL_SYMBOL string _Atomic__int_str(int x);
VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b);
VV_LOCAL_SYMBOL u64 map_hash_string(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_1(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_2(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_4(voidptr pkey);
VV_LOCAL_SYMBOL u64 map_hash_int_8(voidptr pkey);
VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d);
VV_LOCAL_SYMBOL DenseArray new_dense_array(int key_bytes, int value_bytes);
VV_LOCAL_SYMBOL voidptr DenseArray_key(DenseArray* d, int i);
VV_LOCAL_SYMBOL voidptr DenseArray_value(DenseArray* d, int i);
VV_LOCAL_SYMBOL bool DenseArray_has_index(DenseArray* d, int i);
VV_LOCAL_SYMBOL int DenseArray_expand(DenseArray* d);
VV_LOCAL_SYMBOL bool map_eq_string(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_1(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_2(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_4(voidptr a, voidptr b);
VV_LOCAL_SYMBOL bool map_eq_int_8(voidptr a, voidptr b);
VV_LOCAL_SYMBOL void map_clone_string(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_1(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_2(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_4(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_clone_int_8(voidptr dest, voidptr pkey);
VV_LOCAL_SYMBOL void map_free_string(voidptr pkey);
VV_LOCAL_SYMBOL void map_free_nop(voidptr _d1);
VV_LOCAL_SYMBOL map new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
map map_move(map* m);
void map_clear(map* m);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey);
VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas);
VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi);
VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count);
VV_LOCAL_SYMBOL void map_set(map* m, voidptr key, voidptr value);
VV_LOCAL_SYMBOL void map_expand(map* m);
VV_LOCAL_SYMBOL void map_rehash(map* m);
void map_reserve(map* m, u32 meta_bytes);
VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap);
VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get(map* m, voidptr key, voidptr zero);
VV_LOCAL_SYMBOL voidptr map_get_check(map* m, voidptr key);
VV_LOCAL_SYMBOL bool map_exists(map* m, voidptr key);
VV_LOCAL_SYMBOL void DenseArray_delete(DenseArray* d, int i);
void map_delete(map* m, voidptr key);
array map_keys(map* m);
array map_values(map* m);
VV_LOCAL_SYMBOL DenseArray DenseArray_clone(DenseArray* d);
map map_clone(map* m);
void map_free(map* m);
VV_LOCAL_SYMBOL u8* __malloc_at_least_one(u64 how_many_bytes, bool noscan);
VV_LOCAL_SYMBOL DenseArray new_dense_array_noscan(int key_bytes, bool key_noscan, int value_bytes, bool value_noscan);
VV_LOCAL_SYMBOL map new_map_noscan_key(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_noscan_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_noscan_key_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ));
VV_LOCAL_SYMBOL map new_map_init_noscan_key(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
VV_LOCAL_SYMBOL map new_map_init_noscan_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
VV_LOCAL_SYMBOL map new_map_init_noscan_key_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values);
void IError_free(IError* ie);
VV_LOCAL_SYMBOL void _option_none(voidptr data, _option* option, int size);
VV_LOCAL_SYMBOL void _option_ok(voidptr data, _option* option, int size);
VV_LOCAL_SYMBOL string None___str(None__ _d1);
string none_str(none _d2);
VV_LOCAL_SYMBOL void _result_ok(voidptr data, _result* res, int size);
string IError_str(IError err);
string Error_msg(Error err);
int Error_code(Error err);
string MessageError_msg(MessageError err);
int MessageError_code(MessageError err);
void MessageError_free(MessageError* err);
IError _v_error(string message);
IError error_with_code(string message, int code);
string rune_str(rune c);
string Array_rune_string(Array_rune ra);
string rune_repeat(rune c, int count);
Array_u8 rune_bytes(rune c);
int rune_length_in_bytes(rune c);
VV_LOCAL_SYMBOL SortedMap new_sorted_map(int n, int value_bytes);
VV_LOCAL_SYMBOL SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values);
VV_LOCAL_SYMBOL mapnode* new_node(void);
VV_LOCAL_SYMBOL void SortedMap_set(SortedMap* m, string key, voidptr value);
VV_LOCAL_SYMBOL void mapnode_split_child(mapnode* n, int child_index, mapnode* y);
VV_LOCAL_SYMBOL bool SortedMap_get(SortedMap m, string key, voidptr out);
VV_LOCAL_SYMBOL bool SortedMap_exists(SortedMap m, string key);
VV_LOCAL_SYMBOL int mapnode_find_key(mapnode* n, string k);
VV_LOCAL_SYMBOL bool mapnode_remove_key(mapnode* n, string k);
VV_LOCAL_SYMBOL void mapnode_remove_from_leaf(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_remove_from_non_leaf(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_fill(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_borrow_from_prev(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_borrow_from_next(mapnode* n, int idx);
VV_LOCAL_SYMBOL void mapnode_merge(mapnode* n, int idx);
void SortedMap_delete(SortedMap* m, string key);
VV_LOCAL_SYMBOL int mapnode_subkeys(mapnode* n, Array_string* keys, int at);
Array_string SortedMap_keys(SortedMap* m);
VV_LOCAL_SYMBOL void mapnode_free(mapnode* n);
void SortedMap_free(SortedMap* m);
void SortedMap_print(SortedMap m);
Array_rune string_runes(string s);
string cstring_to_vstring(char* s);
string tos_clone(u8* s);
string tos(u8* s, int len);
string tos2(u8* s);
string tos3(char* s);
string tos4(u8* s);
string tos5(char* s);
string u8_vstring(u8* bp);
string u8_vstring_with_len(u8* bp, int len);
string char_vstring(char* cp);
string char_vstring_with_len(char* cp, int len);
string u8_vstring_literal(u8* bp);
string u8_vstring_literal_with_len(u8* bp, int len);
string char_vstring_literal(char* cp);
string char_vstring_literal_with_len(char* cp, int len);
int string_len_utf8(string s);
VV_LOCAL_SYMBOL string string_clone_static(string a);
string string_clone(string a);
string string_replace_once(string s, string rep, string with);
string string_replace(string s, string rep, string with);
string string_replace_each(string s, Array_string vals);
VV_LOCAL_SYMBOL  int compare_15661873927483343839_RepIndex_by_idx(RepIndex* a, RepIndex* b) {
	if (a->idx < b->idx) return -1;
	else return 1;
}

string string_replace_char(string s, u8 rep, u8 with, int repeat);
string string_normalize_tabs(string s, int tab_len);
bool string_bool(string s);
int string_int(string s);
i64 string_i64(string s);
i8 string_i8(string s);
i16 string_i16(string s);
f32 string_f32(string s);
f64 string_f64(string s);
u8 string_u8(string s);
u16 string_u16(string s);
u32 string_u32(string s);
u64 string_u64(string s);
_result_u64 string_parse_uint(string s, int _base, int _bit_size);
_result_i64 string_parse_int(string s, int _base, int _bit_size);
VV_LOCAL_SYMBOL bool string__eq(string s, string a);
int string_compare(string s, string a);
VV_LOCAL_SYMBOL bool string__lt(string s, string a);
VV_LOCAL_SYMBOL string string__plus(string s, string a);
Array_string string_split_any(string s, string delim);
Array_string string_rsplit_any(string s, string delim);
Array_string string_split(string s, string delim);
Array_string string_rsplit(string s, string delim);
_option_multi_return_string_string string_split_once(string s, string delim);
_option_multi_return_string_string string_rsplit_once(string s, string delim);
Array_string string_split_nth(string s, string delim, int nth);
Array_string string_rsplit_nth(string s, string delim, int nth);
Array_string string_split_into_lines(string s);
string string_substr(string s, int start, int _end);
string string_substr_unsafe(string s, int start, int _end);
_result_string string_substr_with_check(string s, int start, int _end);
string string_substr_ni(string s, int _start, int _end);
VV_LOCAL_SYMBOL int string_index_(string s, string p);
_option_int string_index(string s, string p);
_option_int string_index_last(string s, string needle);
_option_int string_last_index(string s, string needle);
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p);
int string_index_any(string s, string chars);
VV_LOCAL_SYMBOL int string_index_last_(string s, string p);
int string_index_after(string s, string p, int start);
int string_index_u8(string s, u8 c);
int string_index_u8_last(string s, u8 c);
int string_last_index_u8(string s, u8 c);
int string_count(string s, string substr);
bool string_contains_u8(string s, u8 x);
bool string_contains(string s, string substr);
bool string_contains_any(string s, string chars);
bool string_contains_only(string s, string chars);
bool string_contains_any_substr(string s, Array_string substrs);
bool string_starts_with(string s, string p);
bool string_ends_with(string s, string p);
string string_to_lower(string s);
bool string_is_lower(string s);
string string_to_upper(string s);
bool string_is_upper(string s);
string string_capitalize(string s);
string string_uncapitalize(string s);
bool string_is_capital(string s);
bool string_starts_with_capital(string s);
string string_title(string s);
bool string_is_title(string s);
string string_find_between(string s, string start, string end);
string string_trim_space(string s);
string string_trim(string s, string cutset);
multi_return_int_int string_trim_indexes(string s, string cutset);
string string_trim_left(string s, string cutset);
string string_trim_right(string s, string cutset);
string string_trim_string_left(string s, string str);
string string_trim_string_right(string s, string str);
int compare_strings(string* a, string* b);
VV_LOCAL_SYMBOL int compare_strings_by_len(string* a, string* b);
VV_LOCAL_SYMBOL int compare_lower_strings(string* a, string* b);
void Array_string_sort_ignore_case(Array_string* s);
void Array_string_sort_by_len(Array_string* s);
string string_str(string s);
VV_LOCAL_SYMBOL u8 string_at(string s, int idx);
VV_LOCAL_SYMBOL _option_u8 string_at_with_check(string s, int idx);
bool u8_is_space(u8 c);
bool u8_is_digit(u8 c);
bool u8_is_hex_digit(u8 c);
bool u8_is_oct_digit(u8 c);
bool u8_is_bin_digit(u8 c);
bool u8_is_letter(u8 c);
bool u8_is_alnum(u8 c);
void string_free(string* s);
string string_before(string s, string sub);
string string_all_before(string s, string sub);
string string_all_before_last(string s, string sub);
string string_all_after(string s, string sub);
string string_all_after_last(string s, string sub);
string string_all_after_first(string s, string sub);
string string_after(string s, string sub);
string string_after_char(string s, u8 sub);
string Array_string_join(Array_string a, string sep);
string Array_string_join_lines(Array_string s);
string string_reverse(string s);
string string_limit(string s, int max);
int string_hash(string s);
Array_u8 string_bytes(string s);
string string_repeat(string s, int count);
Array_string string_fields(string s);
string string_strip_margin(string s);
string string_strip_margin_custom(string s, u8 del);
string string_trim_indent(string s);
int string_indent_width(string s);
bool string_is_blank(string s);
bool string_match_glob(string name, string pattern);
bool string_is_ascii(string s);
Array_u8 byteptr_vbytes(byteptr data, int len);
string byteptr_vstring(byteptr bp);
string byteptr_vstring_with_len(byteptr bp, int len);
string charptr_vstring(charptr cp);
string charptr_vstring_with_len(charptr cp, int len);
string byteptr_vstring_literal(byteptr bp);
string byteptr_vstring_literal_with_len(byteptr bp, int len);
string charptr_vstring_literal(charptr cp);
string charptr_vstring_literal_with_len(charptr cp, int len);
string StrIntpType_str(StrIntpType x);
VV_LOCAL_SYMBOL f32 fabs32(f32 x);
VV_LOCAL_SYMBOL f64 fabs64(f64 x);
VV_LOCAL_SYMBOL u64 abs64(i64 x);
u64 get_str_intp_u64_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, u8 in_pad_ch, int in_base, bool in_upper_case);
u32 get_str_intp_u32_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, u8 in_pad_ch, int in_base, bool in_upper_case);
VV_LOCAL_SYMBOL void StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb);
string str_intp(int data_len, StrIntpData* input_base);
string str_intp_sq(string in_str);
string str_intp_rune(string in_str);
string str_intp_g32(string in_str);
string str_intp_g64(string in_str);
string str_intp_sub(string base_str, string in_str);
u16* string_to_wide(string _str);
string string_from_wide(u16* _wstr);
string string_from_wide2(u16* _wstr, int len);
int utf8_char_len(u8 b);
string utf32_to_str(u32 code);
string utf32_to_str_no_malloc(u32 code, u8* buf);
int utf32_decode_to_buffer(u32 code, u8* buf);
int string_utf32_code(string _rune);
_result_rune Array_u8_utf8_to_utf32(Array_u8 _bytes);
int utf8_str_visible_length(string s);
bool ArrayFlags_is_empty(ArrayFlags* e);
bool ArrayFlags_has(ArrayFlags* e, ArrayFlags flag);
bool ArrayFlags_all(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_set(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_set_all(ArrayFlags* e);
void ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag);
void ArrayFlags_clear_all(ArrayFlags* e);
void ArrayFlags_toggle(ArrayFlags* e, ArrayFlags flag);
VV_LOCAL_SYMBOL string net__urllib__error_msg(string message, string val);
VV_LOCAL_SYMBOL bool net__urllib__should_escape(u8 c, net__urllib__EncodingMode mode);
_result_string net__urllib__query_unescape(string s);
_result_string net__urllib__path_unescape(string s);
VV_LOCAL_SYMBOL _result_string net__urllib__unescape(string s_, net__urllib__EncodingMode mode);
string net__urllib__query_escape(string s);
string net__urllib__path_escape(string s);
VV_LOCAL_SYMBOL string net__urllib__escape(string s, net__urllib__EncodingMode mode);
string net__urllib__URL_debug(net__urllib__URL* url);
net__urllib__Userinfo* net__urllib__user(string username);
VV_LOCAL_SYMBOL net__urllib__Userinfo* net__urllib__user_password(string username, string password);
VV_LOCAL_SYMBOL bool net__urllib__Userinfo_empty(net__urllib__Userinfo* u);
VV_LOCAL_SYMBOL string net__urllib__Userinfo_str(net__urllib__Userinfo* u);
VV_LOCAL_SYMBOL _result_Array_string net__urllib__split_by_scheme(string rawurl);
VV_LOCAL_SYMBOL _result_string net__urllib__get_scheme(string rawurl);
VV_LOCAL_SYMBOL multi_return_string_string net__urllib__split(string s, u8 sep, bool cutc);
_result_net__urllib__URL net__urllib__parse(string rawurl);
VV_LOCAL_SYMBOL _result_net__urllib__URL net__urllib__parse_request_uri(string rawurl);
VV_LOCAL_SYMBOL _result_net__urllib__URL net__urllib__parse_url(string rawurl, bool via_request);
VV_LOCAL_SYMBOL _result_net__urllib__ParseAuthorityRes net__urllib__parse_authority(string authority);
VV_LOCAL_SYMBOL _result_string net__urllib__parse_host(string host);
_result_bool net__urllib__URL_set_path(net__urllib__URL* u, string p);
string net__urllib__URL_escaped_path(net__urllib__URL* u);
VV_LOCAL_SYMBOL bool net__urllib__valid_encoded_path(string s);
VV_LOCAL_SYMBOL bool net__urllib__valid_optional_port(string port);
string net__urllib__URL_str(net__urllib__URL* u);
_result_net__urllib__Values net__urllib__parse_query(string query);
VV_LOCAL_SYMBOL net__urllib__Values net__urllib__parse_query_silent(string query);
VV_LOCAL_SYMBOL _result_bool net__urllib__parse_query_values(net__urllib__Values* m, string query);
string net__urllib__Values_encode(net__urllib__Values v);
VV_LOCAL_SYMBOL string net__urllib__resolve_path(string base, string ref);
bool net__urllib__URL_is_abs(net__urllib__URL* u);
_result_net__urllib__URL net__urllib__URL_parse(net__urllib__URL* u, string ref);
_result_net__urllib__URL net__urllib__URL_resolve_reference(net__urllib__URL* u, net__urllib__URL* ref);
net__urllib__Values net__urllib__URL_query(net__urllib__URL* u);
string net__urllib__URL_request_uri(net__urllib__URL* u);
string net__urllib__URL_hostname(net__urllib__URL* u);
string net__urllib__URL_port(net__urllib__URL* u);
multi_return_string_string net__urllib__split_host_port(string hostport);
bool net__urllib__valid_userinfo(string s);
VV_LOCAL_SYMBOL bool net__urllib__string_contains_ctl_u8(string s);
bool net__urllib__ishex(u8 c);
VV_LOCAL_SYMBOL u8 net__urllib__unhex(u8 c);
net__urllib__Values net__urllib__new_values(void);
_option_string net__urllib__Values_get(net__urllib__Values* v, string key);
Array_string net__urllib__Values_get_all(net__urllib__Values* v, string key);
void net__urllib__Values_set(net__urllib__Values* v, string key, string value);
void net__urllib__Values_add(net__urllib__Values* v, string key, string value);
void net__urllib__Values_del(net__urllib__Values* v, string key);
Array_string net__urllib__Values_values(net__urllib__Values v);
Map_string_Array_string net__urllib__Values_to_map(net__urllib__Values v);
Array_string maps__to_array_T_string_string_string(Map_string_string m, string (*f)(string key, string val));
Map_string_x__json2__Any maps__to_map_T_discord__Snowflake_string_string_x__json2__Any(Map_discord__Snowflake_string m, multi_return_string_x__json2__Any (*f)(discord__Snowflake key, string val));
i64 time__portable_timegm(struct tm* t);
int time__days_from_unix_epoch(int year, int month, int day);
int time__Time_days_from_unix_epoch(time__Time t);
time__Time time__date_from_days_after_unix_epoch(int days);
VV_LOCAL_SYMBOL time__DateTimeParser time__new_date_time_parser(string datetime, string format);
VV_LOCAL_SYMBOL _result_string time__DateTimeParser_next(time__DateTimeParser* p, int length);
VV_LOCAL_SYMBOL _result_string time__DateTimeParser_peek(time__DateTimeParser* p, int length);
VV_LOCAL_SYMBOL _result_int time__DateTimeParser_must_be_int(time__DateTimeParser* p, int length);
VV_LOCAL_SYMBOL _result_int time__DateTimeParser_must_be_int_with_minimum_length(time__DateTimeParser* p, int min, int max, bool allow_leading_zero);
VV_LOCAL_SYMBOL _result_void time__DateTimeParser_must_be_string(time__DateTimeParser* p, string must);
VV_LOCAL_SYMBOL _result_string time__DateTimeParser_must_be_string_one_of(time__DateTimeParser* p, Array_string oneof);
VV_LOCAL_SYMBOL _result_int time__DateTimeParser_must_be_valid_month(time__DateTimeParser* p);
VV_LOCAL_SYMBOL _result_int time__DateTimeParser_must_be_valid_three_letter_month(time__DateTimeParser* p);
VV_LOCAL_SYMBOL _result_string time__DateTimeParser_must_be_valid_week_day(time__DateTimeParser* p, int letters);
VV_LOCAL_SYMBOL _result_Array_string time__extract_tokens(string s);
VV_LOCAL_SYMBOL _result_time__Time time__DateTimeParser_parse(time__DateTimeParser* p);
string time__Time_format(time__Time t);
string time__Time_format_ss(time__Time t);
string time__Time_format_ss_milli(time__Time t);
string time__Time_format_ss_micro(time__Time t);
string time__Time_format_ss_nano(time__Time t);
string time__Time_format_rfc3339(time__Time t);
string time__Time_format_rfc3339_nano(time__Time t);
string time__Time_hhmm(time__Time t);
string time__Time_hhmmss(time__Time t);
string time__Time_hhmm12(time__Time t);
string time__Time_ymmdd(time__Time t);
string time__Time_ddmmy(time__Time t);
string time__Time_md(time__Time t);
VV_LOCAL_SYMBOL string time__ordinal_suffix(int n);
string time__Time_custom_format(time__Time t, string s);
string time__Time_clean(time__Time t);
string time__Time_clean12(time__Time t);
string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time);
string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date);
string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date);
string time__Time_utc_string(time__Time t);
VV_LOCAL_SYMBOL f64 time__mceil(f64 x);
bool time__Time__eq(time__Time t1, time__Time t2);
bool time__Time__lt(time__Time t1, time__Time t2);
time__Duration time__Time__minus(time__Time lhs, time__Time rhs);
_result_time__Time time__parse_rfc3339(string s);
_result_time__Time time__parse(string s);
_result_time__Time time__parse_format(string s, string format);
_result_time__Time time__parse_iso8601(string s);
_result_time__Time time__parse_rfc2822(string s);
VV_LOCAL_SYMBOL _result_multi_return_int_int_int time__parse_iso8601_date(string s);
VV_LOCAL_SYMBOL _result_multi_return_int_int_int_int_int_i64_bool time__parse_iso8601_time(string s);
string time__TimeParseError_msg(time__TimeParseError err);
VV_LOCAL_SYMBOL IError time__error_invalid_time(int code, string message);
time__StopWatch time__new_stopwatch(time__StopWatchOptions opts);
void time__StopWatch_start(time__StopWatch* t);
void time__StopWatch_restart(time__StopWatch* t);
void time__StopWatch_stop(time__StopWatch* t);
void time__StopWatch_pause(time__StopWatch* t);
time__Duration time__StopWatch_elapsed(time__StopWatch t);
time__Time time__now(void);
time__Time time__utc(void);
time__Time time__new_time(time__Time t);
i64 time__ticks(void);
string time__Time_str(time__Time t);
VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int nanosecond);
string time__Time_strftime(time__Time t, string fmt);
int time__Duration_sys_milliseconds(time__Duration d);
time__Time time__Time__static__new(time__Time t);
string time__Time_smonth(time__Time* t);
i64 time__Time_unix_time(time__Time* t);
i64 time__Time_unix_time_milli(time__Time* t);
i64 time__Time_unix_time_micro(time__Time* t);
i64 time__Time_unix_time_nano(time__Time* t);
time__Time time__Time_add(time__Time* t, time__Duration d);
time__Time time__Time_add_seconds(time__Time* t, int seconds);
time__Time time__Time_add_days(time__Time* t, int days);
time__Duration time__since(time__Time t);
string time__Time_relative(time__Time* t);
string time__Time_relative_short(time__Time* t);
int time__day_of_week(int y, int m, int d);
int time__Time_day_of_week(time__Time* t);
int time__Time_year_day(time__Time* t);
string time__Time_weekday_str(time__Time* t);
string time__Time_long_weekday_str(time__Time* t);
bool time__is_leap_year(int year);
_result_int time__days_in_month(int month, int year);
string time__Time_debug(time__Time* t);
i64 time__Duration_nanoseconds(time__Duration d);
i64 time__Duration_microseconds(time__Duration d);
i64 time__Duration_milliseconds(time__Duration d);
f64 time__Duration_seconds(time__Duration d);
f64 time__Duration_minutes(time__Duration d);
f64 time__Duration_hours(time__Duration d);
f64 time__Duration_days(time__Duration d);
string time__Duration_str(time__Duration d);
string time__Duration_debug(time__Duration d);
int time__offset(void);
time__Time time__Time_local_to_utc(time__Time* t);
time__Time time__Time_utc_to_local(time__Time* u);
time__Time time__Time_as_local(time__Time* t);
time__Time time__Time_as_utc(time__Time* t);
bool time__Time_is_utc(time__Time* t);
VV_LOCAL_SYMBOL i64 time__make_unix_time(struct tm t);
VV_LOCAL_SYMBOL u64 time__init_win_time_freq(void);
VV_LOCAL_SYMBOL u64 time__init_win_time_start(void);
u64 time__sys_mono_now(void);
VV_LOCAL_SYMBOL u64 time__vpc_now(void);
VV_LOCAL_SYMBOL i64 time__local_as_unix_time(void);
time__Time time__Time_local(time__Time* t);
VV_LOCAL_SYMBOL time__Time time__win_now(void);
VV_LOCAL_SYMBOL time__Time time__win_utc(void);
VV_LOCAL_SYMBOL i64 time__SystemTime_unix_time(time__SystemTime st);
VV_LOCAL_SYMBOL time__Time time__darwin_now(void);
VV_LOCAL_SYMBOL time__Time time__linux_now(void);
VV_LOCAL_SYMBOL time__Time time__solaris_now(void);
VV_LOCAL_SYMBOL time__Time time__darwin_utc(void);
VV_LOCAL_SYMBOL time__Time time__linux_utc(void);
VV_LOCAL_SYMBOL time__Time time__solaris_utc(void);
void time__sleep(time__Duration duration);
time__Time time__unix(i64 abs);
time__Time time__unix2(i64 abs, int microsecond);
time__Time time__unix_microsecond(i64 abs, int microsecond);
time__Time time__unix_nanosecond(i64 abs, int nanosecond);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_offset(i64 day_offset_);
VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_offset(i64 second_offset_);
int arrays__fold_T_discord__Intents_int(Array_discord__Intents __v_array, int init, int (*fold_op)(int acc, discord__Intents elem));
Array_string arrays__map_indexed_T_x__json2__Any_string(Array_x__json2__Any __v_array, string (*transform)(int idx, x__json2__Any elem));
VV_LOCAL_SYMBOL void arrays__memswap(voidptr x, voidptr y, usize len);
Array_string arrays__uniq_T_string(Array_string a);
Array_string arrays__distinct_T_string(Array_string a);
VV_LOCAL_SYMBOL  int compare_6313278466669073374_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

int encoding__base64__encode_in_buffer(Array_u8 data, u8* buffer);
VV_LOCAL_SYMBOL int encoding__base64__encode_from_buffer(u8* dest, u8* src, int src_len);
int encoding__base64__decode_in_buffer(string* data, u8* buffer);
int encoding__base64__decode_in_buffer_bytes(Array_u8 data, u8* buffer);
VV_LOCAL_SYMBOL int encoding__base64__decode_from_buffer(u8* dest, u8* src, int src_len);
Array_u8 encoding__base64__decode(string data);
string encoding__base64__decode_str(string data);
string encoding__base64__encode(Array_u8 data);
string encoding__base64__encode_str(string data);
VV_LOCAL_SYMBOL string encoding__base64__alloc_and_encode(u8* src, int len);
Array_u8 encoding__base64__url_decode(string data);
string encoding__base64__url_decode_str(string data);
string encoding__base64__url_encode(Array_u8 data);
string encoding__base64__url_encode_str(string data);
VV_LOCAL_SYMBOL u64 encoding__base64__assemble64(u8 n1, u8 n2, u8 n3, u8 n4, u8 n5, u8 n6, u8 n7, u8 n8);
VV_LOCAL_SYMBOL u32 encoding__base64__assemble32(u8 n1, u8 n2, u8 n3, u8 n4);
strings__textscanner__TextScanner strings__textscanner__new(string input);
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_remaining(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_next(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_skip(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_skip_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_peek(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_peek_n(strings__textscanner__TextScanner* ss, int n);
void strings__textscanner__TextScanner_back(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_back_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_peek_back(strings__textscanner__TextScanner* ss);
int strings__textscanner__TextScanner_peek_back_n(strings__textscanner__TextScanner* ss, int n);
int strings__textscanner__TextScanner_current(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_reset(strings__textscanner__TextScanner* ss);
void strings__textscanner__TextScanner_goto_end(strings__textscanner__TextScanner* ss);
string dl__get_shared_library_extension(void);
string dl__get_libname(string libname);
_result_voidptr dl__open_opt(string filename, int flags);
_result_voidptr dl__sym_opt(voidptr shared_object_handle, string symbol);
voidptr dl__open(string filename, int flags);
bool dl__close(voidptr handle);
voidptr dl__sym(voidptr handle, string symbol);
string dl__dlerror(void);
io__BufferedReader* io__new_buffered_reader(io__BufferedReaderConfig o);
_result_int io__BufferedReader_read(io__BufferedReader* r, Array_u8* buf);
void io__BufferedReader_free(io__BufferedReader* r);
VV_LOCAL_SYMBOL bool io__BufferedReader_fill_buffer(io__BufferedReader* r);
VV_LOCAL_SYMBOL bool io__BufferedReader_needs_fill(io__BufferedReader r);
bool io__BufferedReader_end_of_stream(io__BufferedReader r);
_result_string io__BufferedReader_read_line(io__BufferedReader* r);
_result_void io__cp(io__Reader* src, io__Writer* dst);
io__Writer io__new_multi_writer(Array_io__Writer writers);
_result_int io__MultiWriter_write(io__MultiWriter* m, Array_u8 buf);
VV_LOCAL_SYMBOL string io__NotExpected_msg(io__NotExpected err);
VV_LOCAL_SYMBOL int io__NotExpected_code(io__NotExpected err);
_result_Array_u8 io__read_all(io__ReadAllConfig config);
_result_Array_u8 io__read_any(io__Reader* r);
_result_int io__ReaderWriterImpl_read(io__ReaderWriterImpl* r, Array_u8* buf);
_result_int io__ReaderWriterImpl_write(io__ReaderWriterImpl* r, Array_u8 buf);
io__ReaderWriterImpl io__make_readerwriter(io__Reader r, io__Writer w);
VV_LOCAL_SYMBOL u32 net__http__chunked__ChunkScanner_read_chunk_size(net__http__chunked__ChunkScanner* s);
VV_LOCAL_SYMBOL u8 net__http__chunked__unhex(u8 c);
VV_LOCAL_SYMBOL void net__http__chunked__ChunkScanner_skip_crlf(net__http__chunked__ChunkScanner* s);
VV_LOCAL_SYMBOL _result_string net__http__chunked__ChunkScanner_read_chunk(net__http__chunked__ChunkScanner* s, u32 chunksize);
_result_string net__http__chunked__decode(string text);
u64 sync__stdatomic__add_u64(u64* ptr, int delta);
u64 sync__stdatomic__sub_u64(u64* ptr, int delta);
i64 sync__stdatomic__add_i64(i64* ptr, int delta);
i64 sync__stdatomic__sub_i64(i64* ptr, int delta);
void sync__stdatomic__store_u64(u64* ptr, u64 val);
u64 sync__stdatomic__load_u64(u64* ptr);
void sync__stdatomic__store_i64(i64* ptr, i64 val);
i64 sync__stdatomic__load_i64(i64* ptr);
bool encoding__utf8__validate_str(string str);
bool encoding__utf8__validate(u8* data, int len);
VV_LOCAL_SYMBOL bool encoding__utf8__Utf8State_seq(encoding__utf8__Utf8State* s, bool r0, bool r1, bool is_tail);
VV_LOCAL_SYMBOL void encoding__utf8__Utf8State_next_state(encoding__utf8__Utf8State* s, u8 c);
VV_LOCAL_SYMBOL bool encoding__utf8__is_excluding_latin(encoding__utf8__RangeTable* table, rune r);
VV_LOCAL_SYMBOL bool encoding__utf8__is_16(Array_encoding__utf8__Range16 ranges, u16 r);
VV_LOCAL_SYMBOL bool encoding__utf8__is_32(Array_encoding__utf8__Range32 ranges, u32 r);
int encoding__utf8__len(string s);
int encoding__utf8__get_uchar(string s, int index);
string encoding__utf8__raw_index(string s, int index);
string encoding__utf8__reverse(string s);
string encoding__utf8__to_upper(string s);
string encoding__utf8__to_lower(string s);
bool encoding__utf8__is_punct(string s, int index);
bool encoding__utf8__is_control(rune r);
bool encoding__utf8__is_letter(rune r);
bool encoding__utf8__is_space(rune r);
bool encoding__utf8__is_number(rune r);
bool encoding__utf8__is_uchar_punct(int uchar);
bool encoding__utf8__is_global_punct(string s, int index);
bool encoding__utf8__is_uchar_global_punct(int uchar);
VV_LOCAL_SYMBOL int encoding__utf8__utf8_to_lower(int in_cp);
VV_LOCAL_SYMBOL int encoding__utf8__utf8_to_upper(int in_cp);
VV_LOCAL_SYMBOL string encoding__utf8__convert_case(string s, bool upper_flag);
VV_LOCAL_SYMBOL int encoding__utf8__find_punct_in_table(int in_code, Array_int in_table);
u16 encoding__binary__big_endian_u16(Array_u8 b);
u16 encoding__binary__big_endian_u16_at(Array_u8 b, int o);
u16 encoding__binary__big_endian_u16_end(Array_u8 b);
void encoding__binary__big_endian_put_u16(Array_u8* b, u16 v);
void encoding__binary__big_endian_put_u16_at(Array_u8* b, u16 v, int o);
void encoding__binary__big_endian_put_u16_end(Array_u8* b, u16 v);
u32 encoding__binary__big_endian_u32(Array_u8 b);
u32 encoding__binary__big_endian_u32_at(Array_u8 b, int o);
u32 encoding__binary__big_endian_u32_end(Array_u8 b);
void encoding__binary__big_endian_put_u32(Array_u8* b, u32 v);
void encoding__binary__big_endian_put_u32_at(Array_u8* b, u32 v, int o);
void encoding__binary__big_endian_put_u32_end(Array_u8* b, u32 v);
u64 encoding__binary__big_endian_u64(Array_u8 b);
u64 encoding__binary__big_endian_u64_at(Array_u8 b, int o);
u64 encoding__binary__big_endian_u64_end(Array_u8 b);
void encoding__binary__big_endian_put_u64(Array_u8* b, u64 v);
void encoding__binary__big_endian_put_u64_at(Array_u8* b, u64 v, int o);
void encoding__binary__big_endian_put_u64_end(Array_u8* b, u64 v);
u16 encoding__binary__little_endian_u16(Array_u8 b);
u16 encoding__binary__little_endian_u16_at(Array_u8 b, int o);
u16 encoding__binary__little_endian_u16_end(Array_u8 b);
void encoding__binary__little_endian_put_u16(Array_u8* b, u16 v);
void encoding__binary__little_endian_put_u16_at(Array_u8* b, u16 v, int o);
void encoding__binary__little_endian_put_u16_end(Array_u8* b, u16 v);
u32 encoding__binary__little_endian_u32(Array_u8 b);
u32 encoding__binary__little_endian_u32_at(Array_u8 b, int o);
u32 encoding__binary__little_endian_u32_end(Array_u8 b);
void encoding__binary__little_endian_put_u32(Array_u8* b, u32 v);
void encoding__binary__little_endian_put_u32_at(Array_u8* b, u32 v, int o);
void encoding__binary__little_endian_put_u32_end(Array_u8* b, u32 v);
u64 encoding__binary__little_endian_u64(Array_u8 b);
u64 encoding__binary__little_endian_u64_at(Array_u8 b, int o);
u64 encoding__binary__little_endian_u64_end(Array_u8 b);
void encoding__binary__little_endian_put_u64(Array_u8* b, u64 v);
void encoding__binary__little_endian_put_u64_at(Array_u8* b, u64 v, int o);
void encoding__binary__little_endian_put_u64_end(Array_u8* b, u64 v);
u64 net__conv__htn64(u64 host);
u64 net__conv__hton64(u64 host);
u32 net__conv__htn32(u32 host);
u32 net__conv__hton32(u32 host);
u16 net__conv__htn16(u16 host);
u16 net__conv__hton16(u16 host);
u64 net__conv__nth64(u64 net);
u64 net__conv__ntoh64(u64 net);
u32 net__conv__nth32(u32 net);
u32 net__conv__ntoh32(u32 net);
u16 net__conv__nth16(u16 net);
u16 net__conv__ntoh16(u16 net);
_result_Array_u8 net__conv__u64tovarint(u64 n);
_result_multi_return_u64_u8 net__conv__varinttou64(Array_u8 b);
u64 hash__wyhash_c(u8* key, u64 len, u64 seed);
u64 hash__wyhash64_c(u64 a, u64 b);
u64 hash__sum64_string(string key, u64 seed);
u64 hash__sum64(Array_u8 key, u64 seed);
VV_LOCAL_SYMBOL u64 hash__wyrotr(u64 v, u32 k);
u64 hash__wymum(u64 a, u64 b);
VV_LOCAL_SYMBOL u64 hash__wyr3(u8* p, u64 k);
VV_LOCAL_SYMBOL u64 hash__wyr4(u8* p);
VV_LOCAL_SYMBOL u64 hash__wyr8(u8* p);
Array_string os__args_after(string cut_word);
Array_string os__args_before(string cut_word);
bool os__debugger_present(void);
string os__getenv(string key);
_option_string os__getenv_opt(string key);
int os__setenv(string name, string value, bool overwrite);
int os__unsetenv(string name);
Map_string_string os__environ(void);
int os__fd_close(int fd);
void os__fd_write(int fd, string s);
Array_string os__fd_slurp(int fd);
multi_return_string_int os__fd_read(int fd, int maxbytes);
bool os__fd_is_pending(int fd);
VV_LOCAL_SYMBOL string os__NotExpected_msg(os__NotExpected err);
VV_LOCAL_SYMBOL int os__NotExpected_code(os__NotExpected err);
VV_LOCAL_SYMBOL string os__fix_windows_path(string path);
_result_os__File os__open_file(string path, string mode, Array_int options);
_result_os__File os__open(string path);
_result_os__File os__create(string path);
os__File os__stdin(void);
os__File os__stdout(void);
os__File os__stderr(void);
bool os__File_eof(os__File* f);
_result_void os__File_reopen(os__File* f, string path, string mode);
_result_int os__File_read(os__File* f, Array_u8* buf);
_result_int os__File_write(os__File* f, Array_u8 buf);
_result_int os__File_writeln(os__File* f, string s);
_result_int os__File_write_string(os__File* f, string s);
_result_int os__File_write_to(os__File* f, u64 pos, Array_u8 buf);
int os__File_write_ptr(os__File* f, voidptr data, int size);
_result_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len);
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos);
VV_LOCAL_SYMBOL _result_int os__fread(voidptr ptr, int item_size, int items, FILE* stream);
Array_u8 os__File_read_bytes(os__File* f, int size);
Array_u8 os__File_read_bytes_at(os__File* f, int size, u64 pos);
_result_int os__File_read_bytes_into_newline(os__File* f, Array_u8* buf);
_result_int os__File_read_bytes_into(os__File* f, u64 pos, Array_u8* buf);
_result_int os__File_read_from(os__File* f, u64 pos, Array_u8* buf);
_result_int os__File_read_into_ptr(os__File* f, u8* ptr, int max_size);
void os__File_flush(os__File* f);
string os__FileNotOpenedError_msg(os__FileNotOpenedError err);
string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err);
VV_LOCAL_SYMBOL IError os__error_file_not_opened(void);
VV_LOCAL_SYMBOL IError os__error_size_of_type_0(void);
_result_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode);
_result_i64 os__File_tell(os__File* f);
bool os__is_abs_path(string path);
string os__abs_path(string path);
string os__norm_path(string path);
_result_string os__existing_path(string path);
VV_LOCAL_SYMBOL string os__clean_path(string path);
string os__to_slash(string path);
string os__from_slash(string path);
VV_LOCAL_SYMBOL int os__win_volume_len(string path);
VV_LOCAL_SYMBOL bool os__is_slash(u8 b);
VV_LOCAL_SYMBOL bool os__is_unc_path(string path);
VV_LOCAL_SYMBOL bool os__has_drive_letter(string path);
VV_LOCAL_SYMBOL bool os__starts_w_slash_slash(string path);
VV_LOCAL_SYMBOL bool os__is_drive_rooted(string path);
VV_LOCAL_SYMBOL bool os__is_normal_path(string path);
VV_LOCAL_SYMBOL bool os__is_curr_dir_ref(int byte_one, int byte_two, int byte_three);
string os__windows_volume(string path);
u32 os__FilePermission_bitmask(os__FilePermission p);
u32 os__FileMode_bitmask(os__FileMode m);
os__FileMode os__inode(string path);
_result_void os__open_uri(string uri);
_result_Array_u8 os__read_bytes(string path);
VV_LOCAL_SYMBOL _result_int os__find_cfile_size(FILE* fp);
VV_LOCAL_SYMBOL _result_strings__Builder os__slurp_file_in_builder(FILE* fp);
_result_string os__read_file(string path);
_result_void os__truncate(string path, u64 len);
VV_LOCAL_SYMBOL void os__eprintln_unknown_file_size(void);
u64 os__file_size(string path);
_result_void os__rename_dir(string src, string dst);
_result_void os__rename(string src, string dst);
_result_void os__cp(string src, string dst);
_result_FILE_ptr os__vfopen(string path, string mode);
int os__fileno(voidptr cfile);
VV_LOCAL_SYMBOL voidptr os__vpopen(string path);
VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret);
string os__posix_get_error_msg(int code);
VV_LOCAL_SYMBOL int os__vpclose(voidptr f);
int os__system(string cmd);
bool os__exists(string path);
bool os__is_executable(string path);
bool os__is_writable(string path);
bool os__is_readable(string path);
_result_void os__rm(string path);
_result_void os__rmdir(string path);
VV_LOCAL_SYMBOL void os__print_c_errno(void);
string os__get_raw_line(void);
Array_u8 os__get_raw_stdin(void);
string os__executable(void);
bool os__is_dir(string path);
bool os__is_link(string path);
VV_LOCAL_SYMBOL os__PathKind os__kind_of_existing_path(string path);
_result_void os__chdir(string path);
string os__getwd(void);
string os__real_path(string fpath);
VV_LOCAL_SYMBOL void os__normalize_drive_letter(string path);
int os__fork(void);
int os__wait(void);
i64 os__file_last_mod_unix(string path);
void os__flush(void);
_result_void os__chmod(string path, int mode);
_result_void os__chown(string path, int owner, int group);
_result_os__File os__open_append(string path);
_result_void os__execvp(string cmdpath, Array_string cmdargs);
_result_void os__execve(string cmdpath, Array_string cmdargs, Array_string envs);
int os__is_atty(int fd);
_result_void os__write_file_array(string path, array buffer);
_result_Array_string os__glob(Array_string patterns);
VV_LOCAL_SYMBOL  int compare_7820091384837918046_string(string* a, string* b) {
	if (string__lt(*a, *b)) return -1;
	else return 1;
}

IError os__last_error(void);
void os__Result_free(os__Result* result);
VV_LOCAL_SYMBOL string os__executable_fallback(void);
_result_void os__cp_all(string src, string dst, bool overwrite);
_result_void os__mv_by_cp(string source, string target);
_result_void os__mv(string source, string target);
_result_Array_string os__read_lines(string path);
string os__sigint_to_signal_name(int si);
_result_void os__rmdir_all(string path);
bool os__is_dir_empty(string path);
string os__file_ext(string opath);
string os__dir(string opath);
string os__base(string opath);
string os__file_name(string opath);
_option_string os__input_opt(string prompt);
string os__input(string prompt);
string os__get_line(void);
Array_string os__get_lines(void);
string os__get_lines_joined(void);
string os__get_raw_lines_joined(void);
string os__user_os(void);
_result_Array_string os__user_names(void);
string os__home_dir(void);
string os__expand_tilde_to_home(string path);
_result_void os__write_file(string path, string text);
string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err);
VV_LOCAL_SYMBOL IError os__error_failed_to_find_executable(void);
_result_string os__find_abs_path_of_executable(string exepath);
bool os__exists_in_system_path(string prog);
bool os__is_file(string path);
string os__join_path(string base, Array_string dirs);
string os__join_path_single(string base, string elem);
Array_string os__walk_ext(string path, string ext);
VV_LOCAL_SYMBOL void os__impl_walk_ext(string path, string ext, Array_string* out);
void os__walk(string path, void (*f)(string ));
void os__walk_with_context(string path, voidptr context, void (*fcb)(voidptr , string ));
void os__log(string s);
_result_void os__mkdir_all(string opath, os__MkdirParams params);
string os__cache_dir(void);
string os__temp_dir(void);
string os__vtmp_dir(void);
VV_LOCAL_SYMBOL string os__default_vmodules_path(void);
string os__vmodules_dir(void);
Array_string os__vmodules_paths(void);
string os__resource_abs_path(string path);
os__Result os__execute_or_panic(string cmd);
os__Result os__execute_or_exit(string cmd);
_result_os__Result os__execute_opt(string cmd);
string os__quoted_path(string path);
_result_string os__config_dir(void);
VV_LOCAL_SYMBOL Array_string os__init_os_args_wide(int argc, u8** argv);
VV_LOCAL_SYMBOL _result_void os__native_glob_pattern(string pattern, Array_string* matches);
_result_void os__utime(string path, int actime, int modtime);
_result_Array_string os__ls(string path);
_result_void os__mkdir(string path, os__MkdirParams params);
os__HANDLE os__get_file_handle(string path);
_result_string os__get_module_filename(os__HANDLE handle);
VV_LOCAL_SYMBOL voidptr os__ptr_win_get_error_msg(u32 code);
string os__get_error_msg(int code);
os__Result os__execute(string cmd);
os__Result os__raw_execute(string cmd);
_result_void os__symlink(string origin, string target);
_result_void os__link(string origin, string target);
void os__File_close(os__File* f);
void os__add_vectored_exception_handler(bool first, int (*handler)(ExceptionPointers* ));
os__Uname os__uname(void);
_result_string os__hostname(void);
_result_string os__loginname(void);
_result_void os__ensure_folder_is_writable(string folder);
int os__getpid(void);
int os__getppid(void);
int os__getuid(void);
int os__geteuid(void);
int os__getgid(void);
int os__getegid(void);
void os__posix_set_permission_bit(string path_s, u32 mode, bool enable);
_result_void os__Command_start(os__Command* c);
string os__Command_read_line(os__Command* c);
_result_void os__Command_close(os__Command* c);
VV_LOCAL_SYMBOL _result_string os__get_long_path(string path);
int os__page_size(void);
_result_string os__input_password(string prompt);
void os__Process_signal_kill(os__Process* p);
void os__Process_signal_pgkill(os__Process* p);
void os__Process_signal_stop(os__Process* p);
void os__Process_signal_continue(os__Process* p);
void os__Process_wait(os__Process* p);
void os__Process_close(os__Process* p);
void os__Process_free(os__Process* p);
VV_LOCAL_SYMBOL int os__Process__spawn(os__Process* p);
bool os__Process_is_alive(os__Process* p);
void os__Process_set_redirect_stdio(os__Process* p);
void os__Process_stdin_write(os__Process* p, string s);
string os__Process_stdout_slurp(os__Process* p);
string os__Process_stderr_slurp(os__Process* p);
string os__Process_stdout_read(os__Process* p);
string os__Process_stderr_read(os__Process* p);
_option_string os__Process_pipe_read(os__Process* p, os__ChildProcessPipeKind pkind);
bool os__Process_is_pending(os__Process* p, os__ChildProcessPipeKind pkind);
VV_LOCAL_SYMBOL string os__Process__read_from(os__Process* p, os__ChildProcessPipeKind pkind);
VV_LOCAL_SYMBOL string os__Process__slurp_from(os__Process* p, os__ChildProcessPipeKind pkind);
VV_LOCAL_SYMBOL void os__Process__write_to(os__Process* p, os__ChildProcessPipeKind pkind, string s);
VV_LOCAL_SYMBOL bool os__Process__is_pending(os__Process* p, os__ChildProcessPipeKind pkind);
VV_LOCAL_SYMBOL void os__Process__check_redirection_call(os__Process* p, string fn_name);
VV_LOCAL_SYMBOL void os__Process__signal_stop(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_continue(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_kill(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__signal_pgkill(os__Process* p);
VV_LOCAL_SYMBOL void os__Process__wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process__is_alive(os__Process* p);
void os__Process_run(os__Process* p);
os__Process* os__new_process(string filename);
void os__Process_set_args(os__Process* p, Array_string pargs);
void os__Process_set_work_folder(os__Process* p, string path);
void os__Process_set_environment(os__Process* p, Map_string_string envs);
VV_LOCAL_SYMBOL os__FN_NTSuspendResume os__ntdll_fn(char* name);
VV_LOCAL_SYMBOL void os__failed_cfn_report_error(bool ok, string label);
VV_LOCAL_SYMBOL void os__close_valid_handle(voidptr p);
VV_LOCAL_SYMBOL int os__Process_win_spawn_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_stop_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_resume_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_kill_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_kill_pgroup(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process_win_is_alive(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_win_write_string(os__Process* p, int idx, string s);
VV_LOCAL_SYMBOL multi_return_string_int os__Process_win_read_string(os__Process* p, int idx, int maxbytes);
VV_LOCAL_SYMBOL string os__Process_win_slurp(os__Process* p, int idx);
VV_LOCAL_SYMBOL int os__Process_unix_spawn_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_stop_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_resume_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_kill_process(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_kill_pgroup(os__Process* p);
VV_LOCAL_SYMBOL void os__Process_unix_wait(os__Process* p);
VV_LOCAL_SYMBOL bool os__Process_unix_is_alive(os__Process* p);
_result_anon_fn_os__signal os__signal_opt(os__Signal signum, void (*handler)(os__Signal ));
VV_LOCAL_SYMBOL void os__ignore_signal_handler(os__Signal signal);
void os__signal_ignore(Array_os__Signal args);
bool os__is_main_thread(void);
VV_LOCAL_SYMBOL void os__signal_ignore_internal(Array_os__Signal args);
VV_LOCAL_SYMBOL string x__json2__format_message(string msg, int line, int column);
int x__json2__DecodeError_code(x__json2__DecodeError err);
string x__json2__DecodeError_msg(x__json2__DecodeError err);
int x__json2__InvalidTokenError_code(x__json2__InvalidTokenError err);
string x__json2__InvalidTokenError_msg(x__json2__InvalidTokenError err);
int x__json2__UnknownTokenError_code(x__json2__UnknownTokenError err);
string x__json2__UnknownTokenError_msg(x__json2__UnknownTokenError err);
VV_LOCAL_SYMBOL void x__json2__Parser_next(x__json2__Parser* p);
VV_LOCAL_SYMBOL _result_void x__json2__Parser_next_with_err(x__json2__Parser* p);
VV_LOCAL_SYMBOL string x__json2__skip_bom(string file_content);
VV_LOCAL_SYMBOL x__json2__Parser x__json2__new_parser(string srce, bool convert_type);
_result_x__json2__Any x__json2__Parser_decode(x__json2__Parser* p);
VV_LOCAL_SYMBOL _result_x__json2__Any x__json2__Parser_decode_value(x__json2__Parser* p);
VV_LOCAL_SYMBOL _result_x__json2__Any x__json2__Parser_decode_array(x__json2__Parser* p);
VV_LOCAL_SYMBOL _result_x__json2__Any x__json2__Parser_decode_object(x__json2__Parser* p);
_result_void x__json2__Encoder_encode_value_T_x__json2__Any(x__json2__Encoder* e, x__json2__Any val, io__Writer* wr);
_result_void x__json2__Encoder_encode_value_T_x__json2__Null(x__json2__Encoder* e, x__json2__Null val, io__Writer* wr);
VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_newline(x__json2__Encoder* e, int level, io__Writer* wr);
VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_any(x__json2__Encoder* e, x__json2__Any val, int level, io__Writer* wr);
VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_value_with_level_T_x__json2__Any(x__json2__Encoder* e, x__json2__Any val, int level, io__Writer* wr);
VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_value_with_level_T_x__json2__Null(x__json2__Encoder* e, x__json2__Null val, int level, io__Writer* wr);
VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_struct_T_x__json2__Null(x__json2__Encoder* e, x__json2__Null val, int level, io__Writer* wr);
string Map_string_x__json2__Any_str(Map_string_x__json2__Any f);
string Array_x__json2__Any_str(Array_x__json2__Any f);
string x__json2__Any_str(x__json2__Any f);
string x__json2__Any_json_str(x__json2__Any f);
string x__json2__Any_prettify_json_str(x__json2__Any f);
VV_LOCAL_SYMBOL _option_int x__json2__CharLengthIterator_next(x__json2__CharLengthIterator* iter);
VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_string(x__json2__Encoder* e, string s, io__Writer* wr);
_result_x__json2__Any x__json2__raw_decode(string src);
_result_x__json2__Any x__json2__fast_raw_decode(string src);
string x__json2__encode_T_x__json2__Any(x__json2__Any val);
i8 x__json2__Any_i8(x__json2__Any f);
i16 x__json2__Any_i16(x__json2__Any f);
int x__json2__Any_int(x__json2__Any f);
i64 x__json2__Any_i64(x__json2__Any f);
u64 x__json2__Any_u64(x__json2__Any f);
f32 x__json2__Any_f32(x__json2__Any f);
f64 x__json2__Any_f64(x__json2__Any f);
bool x__json2__Any_bool(x__json2__Any f);
Array_x__json2__Any x__json2__Any_arr(x__json2__Any f);
Map_string_x__json2__Any x__json2__Any_as_map(x__json2__Any f);
_result_time__Time x__json2__Any_to_time(x__json2__Any f);
int x__json2__Token_full_col(x__json2__Token t);
VV_LOCAL_SYMBOL void x__json2__Scanner_move(x__json2__Scanner* s);
VV_LOCAL_SYMBOL void x__json2__Scanner_move_pos_with_newlines(x__json2__Scanner* s);
VV_LOCAL_SYMBOL void x__json2__Scanner_move_pos(x__json2__Scanner* s, bool include_space, bool include_newlines);
VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_error(x__json2__Scanner s, string description);
VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_tokenize(x__json2__Scanner s, Array_u8 lit, x__json2__TokenKind kind);
VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_text_scan(x__json2__Scanner* s);
VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_num_scan(x__json2__Scanner* s);
VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_invalid_token(x__json2__Scanner s);
VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_scan(x__json2__Scanner* s);
string x__json2__ValueKind_str(x__json2__ValueKind k);
void crypto__sha1__Digest_free(crypto__sha1__Digest* d);
VV_LOCAL_SYMBOL void crypto__sha1__Digest_init(crypto__sha1__Digest* d);
void crypto__sha1__Digest_reset(crypto__sha1__Digest* d);
VV_LOCAL_SYMBOL crypto__sha1__Digest* crypto__sha1__Digest_clone(crypto__sha1__Digest* d);
crypto__sha1__Digest* crypto__sha1__new(void);
_result_int crypto__sha1__Digest_write(crypto__sha1__Digest* d, Array_u8 p_);
Array_u8 crypto__sha1__Digest_sum(crypto__sha1__Digest* d, Array_u8 b_in);
VV_LOCAL_SYMBOL Array_u8 crypto__sha1__Digest_checksum_internal(crypto__sha1__Digest* d);
Array_u8 crypto__sha1__Digest_checksum(crypto__sha1__Digest* d);
Array_u8 crypto__sha1__sum(Array_u8 data);
VV_LOCAL_SYMBOL void crypto__sha1__block(crypto__sha1__Digest* dig, Array_u8 p);
int crypto__sha1__Digest_size(crypto__sha1__Digest* d);
int crypto__sha1__Digest_block_size(crypto__sha1__Digest* d);
string crypto__sha1__hexhash(string s);
VV_LOCAL_SYMBOL void crypto__sha1__block_generic(crypto__sha1__Digest* dig, Array_u8 p_);
VV_LOCAL_SYMBOL u32 rand__seed__nr_next(u32 prev);
Array_u32 rand__seed__time_seed_array(int count);
u32 rand__seed__time_seed_32(void);
u64 rand__seed__time_seed_64(void);
string term__format_esc(string code);
string term__format(string msg, string open, string close);
string term__format_rgb(int r, int g, int b, string msg, string open, string close);
string term__rgb(int r, int g, int b, string msg);
string term__bg_rgb(int r, int g, int b, string msg);
string term__hex(int hex, string msg);
string term__bg_hex(int hex, string msg);
string term__reset(string msg);
string term__bold(string msg);
string term__dim(string msg);
string term__italic(string msg);
string term__underline(string msg);
string term__slow_blink(string msg);
string term__rapid_blink(string msg);
string term__inverse(string msg);
string term__hidden(string msg);
string term__strikethrough(string msg);
string term__black(string msg);
string term__red(string msg);
string term__green(string msg);
string term__yellow(string msg);
string term__blue(string msg);
string term__magenta(string msg);
string term__cyan(string msg);
string term__white(string msg);
string term__bg_black(string msg);
string term__bg_red(string msg);
string term__bg_green(string msg);
string term__bg_yellow(string msg);
string term__bg_blue(string msg);
string term__bg_magenta(string msg);
string term__bg_cyan(string msg);
string term__bg_white(string msg);
string term__gray(string msg);
string term__bright_black(string msg);
string term__bright_red(string msg);
string term__bright_green(string msg);
string term__bright_yellow(string msg);
string term__bright_blue(string msg);
string term__bright_magenta(string msg);
string term__bright_cyan(string msg);
string term__bright_white(string msg);
string term__bright_bg_black(string msg);
string term__bright_bg_red(string msg);
string term__bright_bg_green(string msg);
string term__bright_bg_yellow(string msg);
string term__bright_bg_blue(string msg);
string term__bright_bg_magenta(string msg);
string term__bright_bg_cyan(string msg);
string term__bright_bg_white(string msg);
string term__highlight_command(string command);
void term__set_cursor_position(term__Coord c);
void term__move(int n, string direction);
void term__cursor_up(int n);
void term__cursor_down(int n);
void term__cursor_forward(int n);
void term__cursor_back(int n);
void term__erase_display(string t);
void term__erase_toend(void);
void term__erase_tobeg(void);
void term__erase_clear(void);
void term__erase_del_clear(void);
void term__erase_line(string t);
void term__erase_line_toend(void);
void term__erase_line_tobeg(void);
void term__erase_line_clear(void);
void term__show_cursor(void);
void term__hide_cursor(void);
void term__clear_previous_line(void);
bool term__can_show_color_on_stdout(void);
bool term__can_show_color_on_stderr(void);
string term__failed(string s);
string term__ok_message(string s);
string term__fail_message(string s);
string term__warn_message(string s);
string term__colorize(string (*cfn)(string ), string s);
string term__ecolorize(string (*cfn)(string ), string s);
string term__strip_ansi(string text);
string term__h_divider(string divider);
string term__header_left(string text, string divider);
string term__header(string text, string divider);
VV_LOCAL_SYMBOL int term__imax(int x, int y);
VV_LOCAL_SYMBOL bool term__supports_escape_sequences(int fd);
multi_return_int_int term__get_terminal_size(void);
_result_term__Coord term__get_cursor_position(void);
bool term__set_terminal_title(string title);
bool term__set_tab_title(string title);
bool term__clear(void);
_option_rune term__utf8_getchar(void);
int term__utf8_len(u8 c);
int runtime__nr_jobs(void);
bool runtime__is_32bit(void);
bool runtime__is_64bit(void);
bool runtime__is_little_endian(void);
bool runtime__is_big_endian(void);
int runtime__nr_cpus(void);
usize runtime__total_memory(void);
usize runtime__free_memory(void);
VV_LOCAL_SYMBOL usize runtime__free_memory_impl(void);
void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data);
u8 rand__wyrand__WyRandRNG_u8(rand__wyrand__WyRandRNG* rng);
u16 rand__wyrand__WyRandRNG_u16(rand__wyrand__WyRandRNG* rng);
u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng);
u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng);
int rand__wyrand__WyRandRNG_block_size(rand__wyrand__WyRandRNG* rng);
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng);
VV_LOCAL_SYMBOL f64 rand__msqrt(f64 a);
VV_LOCAL_SYMBOL f64 rand__mlog(f64 a);
VV_LOCAL_SYMBOL multi_return_f64_int rand__frexp(f64 x);
VV_LOCAL_SYMBOL f64 rand__scalbn(f64 x, int n_);
VV_LOCAL_SYMBOL f64 rand__f64_from_bits(u64 b);
VV_LOCAL_SYMBOL u64 rand__f64_bits(f64 f);
string rand__uuid_v4(void);
VV_LOCAL_SYMBOL string rand__internal_uuid_v4(rand__PRNG* rng);
VV_LOCAL_SYMBOL string rand__internal_ulid_at_millisecond(rand__PRNG* rng, u64 unix_time_milli);
VV_LOCAL_SYMBOL string rand__internal_string_from_set(rand__PRNG* rng, string charset, int len);
VV_LOCAL_SYMBOL void rand__deinit(void);
VV_LOCAL_SYMBOL void rand__init(void);
VV_LOCAL_SYMBOL void rand__read_32(rand__PRNG* rng, Array_u8* buf);
VV_LOCAL_SYMBOL void rand__read_64(rand__PRNG* rng, Array_u8* buf);
VV_LOCAL_SYMBOL void rand__read_internal(rand__PRNG* rng, Array_u8* buf);
_result_Array_u8 rand__PRNG_bytes(rand__PRNG* rng, int bytes_needed);
void rand__PRNG_read(rand__PRNG* rng, Array_u8* buf);
_result_u32 rand__PRNG_u32n(rand__PRNG* rng, u32 max);
_result_u64 rand__PRNG_u64n(rand__PRNG* rng, u64 max);
_result_u32 rand__PRNG_u32_in_range(rand__PRNG* rng, u32 min, u32 max);
_result_u64 rand__PRNG_u64_in_range(rand__PRNG* rng, u64 min, u64 max);
i8 rand__PRNG_i8(rand__PRNG* rng);
i16 rand__PRNG_i16(rand__PRNG* rng);
int rand__PRNG_int(rand__PRNG* rng);
i64 rand__PRNG_i64(rand__PRNG* rng);
int rand__PRNG_int31(rand__PRNG* rng);
i64 rand__PRNG_int63(rand__PRNG* rng);
_result_int rand__PRNG_intn(rand__PRNG* rng, int max);
_result_i64 rand__PRNG_i64n(rand__PRNG* rng, i64 max);
_result_int rand__PRNG_int_in_range(rand__PRNG* rng, int min, int max);
_result_i64 rand__PRNG_i64_in_range(rand__PRNG* rng, i64 min, i64 max);
f32 rand__PRNG_f32(rand__PRNG* rng);
f32 rand__PRNG_f32cp(rand__PRNG* rng);
f64 rand__PRNG_f64(rand__PRNG* rng);
f64 rand__PRNG_f64cp(rand__PRNG* rng);
_result_f32 rand__PRNG_f32n(rand__PRNG* rng, f32 max);
_result_f64 rand__PRNG_f64n(rand__PRNG* rng, f64 max);
_result_f32 rand__PRNG_f32_in_range(rand__PRNG* rng, f32 min, f32 max);
_result_f64 rand__PRNG_f64_in_range(rand__PRNG* rng, f64 min, f64 max);
string rand__PRNG_ulid(rand__PRNG* rng);
string rand__PRNG_ulid_at_millisecond(rand__PRNG* rng, u64 unix_time_milli);
string rand__PRNG_string_from_set(rand__PRNG* rng, string charset, int len);
string rand__PRNG_string(rand__PRNG* rng, int len);
string rand__PRNG_hex(rand__PRNG* rng, int len);
string rand__PRNG_ascii(rand__PRNG* rng, int len);
_result_bool rand__PRNG_bernoulli(rand__PRNG* rng, f64 p);
_result_f64 rand__PRNG_normal(rand__PRNG* rng, rand__config__NormalConfigStruct conf);
_result_multi_return_f64_f64 rand__PRNG_normal_pair(rand__PRNG* rng, rand__config__NormalConfigStruct conf);
_result_int rand__PRNG_binomial(rand__PRNG* rng, int n, f64 p);
f64 rand__PRNG_exponential(rand__PRNG* rng, f64 lambda);
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config_);
rand__PRNG* rand__get_current_rng(void);
void rand__set_rng(rand__PRNG* rng);
void rand__seed(Array_u32 seed);
u8 rand__u8(void);
u16 rand__u16(void);
u32 rand__u32(void);
u64 rand__u64(void);
_result_u32 rand__u32n(u32 max);
_result_u64 rand__u64n(u64 max);
_result_u32 rand__u32_in_range(u32 min, u32 max);
_result_u64 rand__u64_in_range(u64 min, u64 max);
i16 rand__i16(void);
int rand__int(void);
_result_int rand__intn(int max);
_result_int rand__int_in_range(int min, int max);
int rand__int31(void);
i64 rand__i64(void);
_result_i64 rand__i64n(i64 max);
_result_i64 rand__i64_in_range(i64 min, i64 max);
i64 rand__int63(void);
f32 rand__f32(void);
f32 rand__f32cp(void);
f64 rand__f64(void);
f64 rand__f64cp(void);
_result_f32 rand__f32n(f32 max);
_result_f64 rand__f64n(f64 max);
_result_f32 rand__f32_in_range(f32 min, f32 max);
_result_f64 rand__f64_in_range(f64 min, f64 max);
_result_Array_u8 rand__bytes(int bytes_needed);
void rand__read(Array_u8* buf);
string rand__ulid(void);
string rand__ulid_at_millisecond(u64 unix_time_milli);
string rand__string_from_set(string charset, int len);
string rand__string(int len);
string rand__hex(int len);
string rand__ascii(int len);
_result_bool rand__bernoulli(f64 p);
_result_f64 rand__normal(rand__config__NormalConfigStruct config_);
_result_multi_return_f64_f64 rand__normal_pair(rand__config__NormalConfigStruct config_);
_result_int rand__binomial(int n, f64 p);
f64 rand__exponential(f64 lambda);
VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st(u32 n, u32 st);
VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st_noscan(u32 n, u32 st);
string sync__Channel_auto_str(sync__Channel* ch, string __v_typename);
void sync__Channel_close(sync__Channel* ch);
int sync__Channel_len(sync__Channel* ch);
bool sync__Channel_closed(sync__Channel* ch);
void sync__Channel_push(sync__Channel* ch, voidptr src);
ChanState sync__Channel_try_push(sync__Channel* ch, voidptr src);
VV_LOCAL_SYMBOL ChanState sync__Channel_try_push_priv(sync__Channel* ch, voidptr src, bool no_block);
bool sync__Channel_pop(sync__Channel* ch, voidptr dest);
ChanState sync__Channel_try_pop(sync__Channel* ch, voidptr dest);
VV_LOCAL_SYMBOL ChanState sync__Channel_try_pop_priv(sync__Channel* ch, voidptr dest, bool no_block);
int sync__channel_select(Array_sync__Channel_ptr* channels, Array_sync__Direction dir, Array_voidptr* objrefs, time__Duration timeout);
string sync__Mutex_str(sync__Mutex* m);
string sync__RwMutex_str(sync__RwMutex* m);
sync__ManyTimes* sync__new_many_times(u64 times);
void sync__ManyTimes_do(sync__ManyTimes* m, void (*f)());
VV_LOCAL_SYMBOL void sync__ManyTimes_do_slow(sync__ManyTimes* m, void (*f)());
sync__Once* sync__new_once(void);
void sync__Once_do(sync__Once* o, void (*f)());
VV_LOCAL_SYMBOL void sync__Once_do_slow(sync__Once* o, void (*f)());
void sync__Once_do_with_param(sync__Once* o, void (*f)(voidptr ), voidptr param);
VV_LOCAL_SYMBOL void sync__Once_do_slow_with_param(sync__Once* o, void (*f)(voidptr ), voidptr param);
VV_LOCAL_SYMBOL void sync__cpanic(int res);
VV_LOCAL_SYMBOL void sync__cpanic_errno(void);
sync__Mutex* sync__new_mutex(void);
sync__RwMutex* sync__new_rwmutex(void);
void sync__Mutex_init(sync__Mutex* m);
void sync__RwMutex_init(sync__RwMutex* m);
void sync__Mutex_lock(sync__Mutex* m);
void sync__Mutex_unlock(sync__Mutex* m);
void sync__RwMutex_rlock(sync__RwMutex* m);
void sync__RwMutex_lock(sync__RwMutex* m);
void sync__RwMutex_runlock(sync__RwMutex* m);
void sync__RwMutex_unlock(sync__RwMutex* m);
sync__Semaphore* sync__new_semaphore(void);
sync__Semaphore* sync__new_semaphore_init(u32 n);
void sync__Semaphore_init(sync__Semaphore* sem, u32 n);
void sync__Semaphore_post(sync__Semaphore* sem);
void sync__Semaphore_wait(sync__Semaphore* sem);
bool sync__Semaphore_try_wait(sync__Semaphore* sem);
bool sync__Semaphore_timed_wait(sync__Semaphore* sem, time__Duration timeout);
void sync__RwMutex_destroy(sync__RwMutex* m);
void sync__Mutex_destroy(sync__Mutex* m);
void sync__Semaphore_destroy(sync__Semaphore _v_toheap_s);
u64 sync__thread_id(void);
sync__WaitGroup* sync__new_waitgroup(void);
void sync__WaitGroup_init(sync__WaitGroup* wg);
void sync__WaitGroup_add(sync__WaitGroup* wg, int delta);
void sync__WaitGroup_done(sync__WaitGroup* wg);
void sync__WaitGroup_wait(sync__WaitGroup* wg);
_result_multi_return_os__File_string io__util__temp_file(io__util__TempFileOptions tfo);
VV_LOCAL_SYMBOL _result_string io__util__error_for_temporary_folder(string fn_name, string d);
_result_string io__util__temp_dir(io__util__TempFileOptions tdo);
VV_LOCAL_SYMBOL string io__util__random_number(void);
VV_LOCAL_SYMBOL _result_multi_return_string_string io__util__prefix_and_suffix(string pattern);
VV_LOCAL_SYMBOL string log__tag_to_cli(log__Level l);
VV_LOCAL_SYMBOL string log__tag_to_file(log__Level l);
_option_log__Level log__level_from_tag(string tag);
_option_log__LogTarget log__target_from_label(string label);
void log__set_logger(log__Logger* logger);
log__Logger* log__get_logger(void);
log__Level log__get_level(void);
void log__set_level(log__Level level);
void log__fatal(string s);
void log__error(string s);
void log__warn(string s);
void log__info(string s);
void log__debug(string s);
log__Level log__Log_get_level(log__Log* l);
void log__Log_set_level(log__Log* l, log__Level level);
void log__Log_set_output_level(log__Log* l, log__Level level);
void log__Log_set_full_logpath(log__Log* l, string full_log_path);
void log__Log_set_output_label(log__Log* l, string label);
void log__Log_set_output_path(log__Log* l, string output_file_path);
void log__Log_log_to_console_too(log__Log* l);
void log__Log_flush(log__Log* l);
void log__Log_close(log__Log* l);
_result_void log__Log_reopen(log__Log* l);
VV_LOCAL_SYMBOL void log__Log_log_file(log__Log* l, string s, log__Level level);
VV_LOCAL_SYMBOL void log__Log_log_cli(log__Log* l, string s, log__Level level);
void log__Log_send_output(log__Log* l, string* s, log__Level level);
void log__Log_fatal(log__Log* l, string s);
void log__Log_error(log__Log* l, string s);
void log__Log_warn(log__Log* l, string s);
void log__Log_info(log__Log* l, string s);
void log__Log_debug(log__Log* l, string s);
void log__Log_free(log__Log* f);
log__ThreadSafeLog* log__new_thread_safe_log(void);
void log__ThreadSafeLog_free(log__ThreadSafeLog* x);
void log__ThreadSafeLog_set_level(log__ThreadSafeLog* x, log__Level level);
void log__ThreadSafeLog_debug(log__ThreadSafeLog* x, string s);
void log__ThreadSafeLog_info(log__ThreadSafeLog* x, string s);
void log__ThreadSafeLog_warn(log__ThreadSafeLog* x, string s);
void log__ThreadSafeLog_error(log__ThreadSafeLog* x, string s);
void log__ThreadSafeLog_fatal(log__ThreadSafeLog* x, string s);
VV_LOCAL_SYMBOL void log__init(void);
VV_LOCAL_SYMBOL void log__deinit(void);
VV_LOCAL_SYMBOL void log__free_logger(log__Logger* logger);
net__Addr net__new_ip6(u16 port, Array_fixed_u8_16 addr);
net__Addr net__new_ip(u16 port, Array_fixed_u8_4 addr);
VV_LOCAL_SYMBOL _result_net__Addr net__temp_unix(void);
net__AddrFamily net__Addr_family(net__Addr a);
string net__Ip_str(net__Ip a);
string net__Ip6_str(net__Ip6 a);
u32 net__Addr_len(net__Addr a);
_result_Array_net__Addr net__resolve_addrs(string addr, net__AddrFamily family, net__SocketType type);
_result_Array_net__Addr net__resolve_addrs_fuzzy(string addr, net__SocketType type);
_result_Array_net__Addr net__resolve_ipaddrs(string addr, net__AddrFamily family, net__SocketType typ);
string net__Addr_str(net__Addr a);
net__Addr net__addr_from_socket_handle(int handle);
_result_net__Addr net__peer_addr_from_socket_handle(int handle);
int net__shutdown(int handle, net__ShutdownConfig config);
_result_void net__close(int handle);
VV_LOCAL_SYMBOL _result_bool net__select(int handle, net__Select test, time__Duration timeout);
VV_LOCAL_SYMBOL _result_bool net__select_deadline(int handle, net__Select test, time__Time deadline);
VV_LOCAL_SYMBOL _result_void net__wait_for_common(int handle, time__Time deadline, time__Duration timeout, net__Select test);
VV_LOCAL_SYMBOL _result_void net__wait_for_write(int handle, time__Time deadline, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__wait_for_read(int handle, time__Time deadline, time__Duration timeout);
_result_int net__socket_error_message(int potential_code, string s);
_result_int net__socket_error(int potential_code);
_result_void net__wrap_error(int error_code);
VV_LOCAL_SYMBOL _result_int net__wrap_read_result(int result);
VV_LOCAL_SYMBOL _result_int net__wrap_write_result(int result);
net__WsaError net__wsa_error(int code);
int net__error_code(void);
VV_LOCAL_SYMBOL void net__init(void);
_result_net__Addr net__Socket_address(net__Socket* s);
_result_net__TcpConn_ptr net__dial_tcp(string oaddress);
_result_net__TcpConn_ptr net__dial_tcp_with_bind(string saddr, string laddr);
_result_void net__TcpConn_close(net__TcpConn* c);
_result_int net__TcpConn_read_ptr(net__TcpConn _v_toheap_c, u8* buf_ptr, int len);
_result_int net__TcpConn_read(net__TcpConn _v_toheap_c, Array_u8* buf);
_result_time__Time net__TcpConn_read_deadline(net__TcpConn* c);
_result_int net__TcpConn_write_ptr(net__TcpConn* c, u8* b, int len);
_result_int net__TcpConn_write(net__TcpConn* c, Array_u8 bytes);
_result_int net__TcpConn_write_string(net__TcpConn* c, string s);
void net__TcpConn_set_read_deadline(net__TcpConn* c, time__Time deadline);
_result_time__Time net__TcpConn_write_deadline(net__TcpConn* c);
void net__TcpConn_set_write_deadline(net__TcpConn* c, time__Time deadline);
time__Duration net__TcpConn_read_timeout(net__TcpConn* c);
void net__TcpConn_set_read_timeout(net__TcpConn* c, time__Duration t);
time__Duration net__TcpConn_write_timeout(net__TcpConn* c);
void net__TcpConn_set_write_timeout(net__TcpConn* c, time__Duration t);
_result_void net__TcpConn_wait_for_read(net__TcpConn _v_toheap_c);
_result_void net__TcpConn_wait_for_write(net__TcpConn* c);
_result_void net__TcpConn_set_sock(net__TcpConn* c);
_result_net__Addr net__TcpConn_peer_addr(net__TcpConn* c);
_result_string net__TcpConn_peer_ip(net__TcpConn* c);
_result_net__Addr net__TcpConn_addr(net__TcpConn* c);
string net__TcpConn_str(net__TcpConn _v_toheap_c);
_result_net__TcpListener_ptr net__listen_tcp(net__AddrFamily family, string saddr, net__ListenOptions options);
_result_net__TcpConn_ptr net__TcpListener_accept(net__TcpListener* l);
_result_net__TcpConn_ptr net__TcpListener_accept_only(net__TcpListener* l);
_result_time__Time net__TcpListener_accept_deadline(net__TcpListener* c);
void net__TcpListener_set_accept_deadline(net__TcpListener* c, time__Time deadline);
time__Duration net__TcpListener_accept_timeout(net__TcpListener* c);
void net__TcpListener_set_accept_timeout(net__TcpListener* c, time__Duration t);
_result_void net__TcpListener_wait_for_accept(net__TcpListener* c);
_result_void net__TcpListener_close(net__TcpListener* c);
_result_net__Addr net__TcpListener_addr(net__TcpListener* c);
VV_LOCAL_SYMBOL _result_net__TcpSocket net__new_tcp_socket(net__AddrFamily family);
VV_LOCAL_SYMBOL _result_net__TcpSocket net__tcp_socket_from_handle(int sockfd);
net__TcpSocket net__tcp_socket_from_handle_raw(int sockfd);
VV_LOCAL_SYMBOL _result_void net__TcpSocket_set_option(net__TcpSocket* s, int level, int opt, int value);
_result_void net__TcpSocket_set_option_bool(net__TcpSocket* s, net__SocketOption opt, bool value);
_result_void net__TcpSocket_set_option_int(net__TcpSocket* s, net__SocketOption opt, int value);
_result_void net__TcpSocket_set_dualstack(net__TcpSocket* s, bool on);
VV_LOCAL_SYMBOL _result_void net__TcpSocket_set_default_options(net__TcpSocket* s);
_result_void net__TcpSocket_bind(net__TcpSocket* s, string addr);
VV_LOCAL_SYMBOL _result_void net__TcpSocket_close(net__TcpSocket* s);
VV_LOCAL_SYMBOL _result_bool net__TcpSocket_select(net__TcpSocket* s, net__Select test, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__TcpSocket_connect(net__TcpSocket* s, net__Addr a);
bool net__TcpConn_get_blocking(net__TcpConn* con);
_result_void net__TcpConn_set_blocking(net__TcpConn* con, bool state);
string net__TcpConn_read_line(net__TcpConn* con);
string net__TcpConn_read_line_max(net__TcpConn* con, int max_line_len);
_result_net__UdpConn_ptr net__dial_udp(string raddr);
_result_int net__UdpConn_write_ptr(net__UdpConn* c, u8* b, int len);
_result_int net__UdpConn_write(net__UdpConn* c, Array_u8 buf);
_result_int net__UdpConn_write_string(net__UdpConn* c, string s);
_result_int net__UdpConn_write_to_ptr(net__UdpConn* c, net__Addr addr, u8* b, int len);
_result_int net__UdpConn_write_to(net__UdpConn* c, net__Addr addr, Array_u8 buf);
_result_int net__UdpConn_write_to_string(net__UdpConn* c, net__Addr addr, string s);
_result_multi_return_int_net__Addr net__UdpConn_read(net__UdpConn* c, Array_u8* buf);
_result_time__Time net__UdpConn_read_deadline(net__UdpConn* c);
void net__UdpConn_set_read_deadline(net__UdpConn* c, time__Time deadline);
_result_time__Time net__UdpConn_write_deadline(net__UdpConn* c);
void net__UdpConn_set_write_deadline(net__UdpConn* c, time__Time deadline);
time__Duration net__UdpConn_read_timeout(net__UdpConn* c);
void net__UdpConn_set_read_timeout(net__UdpConn* c, time__Duration t);
time__Duration net__UdpConn_write_timeout(net__UdpConn* c);
void net__UdpConn_set_write_timeout(net__UdpConn* c, time__Duration t);
_result_void net__UdpConn_wait_for_read(net__UdpConn* c);
_result_void net__UdpConn_wait_for_write(net__UdpConn* c);
string net__UdpConn_str(net__UdpConn* c);
_result_void net__UdpConn_close(net__UdpConn* c);
_result_net__UdpConn_ptr net__listen_udp(string laddr);
VV_LOCAL_SYMBOL _result_net__UdpSocket_ptr net__new_udp_socket(net__Addr local_addr);
VV_LOCAL_SYMBOL _result_net__UdpSocket_ptr net__new_udp_socket_for_remote(net__Addr raddr);
_result_void net__UdpSocket_set_option_bool(net__UdpSocket* s, net__SocketOption opt, bool value);
_result_void net__UdpSocket_set_dualstack(net__UdpSocket* s, bool on);
VV_LOCAL_SYMBOL _result_void net__UdpSocket_close(net__UdpSocket* s);
VV_LOCAL_SYMBOL _result_bool net__UdpSocket_select(net__UdpSocket* s, net__Select test, time__Duration timeout);
VV_LOCAL_SYMBOL _result_net__Addr net__UdpSocket_remote(net__UdpSocket* s);
_result_u16 net__validate_port(int port);
_result_multi_return_string_u16 net__split_address(string addr);
VV_LOCAL_SYMBOL void net__mbedtls__init(void);
_result_net__mbedtls__SSLListener_ptr net__mbedtls__new_ssl_listener(string saddr, net__mbedtls__SSLConnectConfig config);
_result_void net__mbedtls__SSLListener_shutdown(net__mbedtls__SSLListener* l);
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLListener_init(net__mbedtls__SSLListener* l);
_result_net__mbedtls__SSLConn_ptr net__mbedtls__SSLListener_accept(net__mbedtls__SSLListener* l);
_result_net__mbedtls__SSLConn_ptr net__mbedtls__new_ssl_conn(net__mbedtls__SSLConnectConfig config);
_result_void net__mbedtls__SSLConn_shutdown(net__mbedtls__SSLConn* s);
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_init(net__mbedtls__SSLConn* s);
_result_void net__mbedtls__SSLConn_connect(net__mbedtls__SSLConn* s, net__TcpConn* tcp_conn, string hostname);
_result_void net__mbedtls__SSLConn_dial(net__mbedtls__SSLConn* s, string hostname, int port);
_result_net__Addr net__mbedtls__SSLConn_peer_addr(net__mbedtls__SSLConn* s);
_result_int net__mbedtls__SSLConn_socket_read_into_ptr(net__mbedtls__SSLConn* s, u8* buf_ptr, int len);
_result_int net__mbedtls__SSLConn_read(net__mbedtls__SSLConn* s, Array_u8* buffer);
_result_int net__mbedtls__SSLConn_write_ptr(net__mbedtls__SSLConn* s, u8* bytes, int len);
_result_int net__mbedtls__SSLConn_write(net__mbedtls__SSLConn* s, Array_u8 bytes);
_result_int net__mbedtls__SSLConn_write_string(net__mbedtls__SSLConn* s, string str);
VV_LOCAL_SYMBOL _result_bool net__mbedtls__select(int handle, net__mbedtls__Select test, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__mbedtls__wait_for(int handle, net__mbedtls__Select what, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_wait_for_write(net__mbedtls__SSLConn* s, time__Duration timeout);
VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_wait_for_read(net__mbedtls__SSLConn* s, time__Duration timeout);
_result_net__ssl__SSLConn_ptr net__ssl__new_ssl_conn(net__ssl__SSLConnectConfig config);
_result_net__TcpConn_ptr net__socks__socks5_dial(string proxy_url, string host, string username, string password);
_result_net__ssl__SSLConn_ptr net__socks__socks5_ssl_dial(string proxy_url, string host, string username, string password);
VV_LOCAL_SYMBOL _result_net__TcpConn_ptr net__socks__handshake(net__TcpConn* con, string host, string username, string password);
VV_LOCAL_SYMBOL string net__socks__reply(u8 code);
VV_LOCAL_SYMBOL _result_Array_u8 net__socks__parse_ipv4(string addr);
VV_LOCAL_SYMBOL _result_net__http__Response net__http__Request_ssl_do(net__http__Request* req, int port, net__http__Method method, string host_name, string path);
Array_net__http__Cookie_ptr net__http__read_set_cookies(Map_string_Array_string h);
Array_net__http__Cookie_ptr net__http__read_cookies(net__http__Header h, string filter);
string net__http__Cookie_str(net__http__Cookie* c);
VV_LOCAL_SYMBOL string net__http__sanitize(bool (*valid)(u8 ), string v);
VV_LOCAL_SYMBOL string net__http__sanitize_cookie_name(string name);
string net__http__sanitize_cookie_value(string v);
VV_LOCAL_SYMBOL string net__http__sanitize_cookie_path(string v);
VV_LOCAL_SYMBOL bool net__http__valid_cookie_value_byte(u8 b);
VV_LOCAL_SYMBOL bool net__http__valid_cookie_path_byte(u8 b);
VV_LOCAL_SYMBOL bool net__http__valid_cookie_domain(string v);
bool net__http__is_cookie_domain_name(string _s);
VV_LOCAL_SYMBOL _result_string net__http__parse_cookie_value(string _raw, bool allow_double_quote);
VV_LOCAL_SYMBOL bool net__http__is_cookie_name_valid(string name);
VV_LOCAL_SYMBOL _result_net__http__Cookie net__http__parse_cookie(string line);
_result_void net__http__download_file(string url, string out_file_path);
string net__http__CommonHeader_str(net__http__CommonHeader h);
void net__http__Header_free(net__http__Header* h);
net__http__Header net__http__new_header(Array_net__http__HeaderConfig kvs);
net__http__Header net__http__new_header_from_map(Map_net__http__CommonHeader_string kvs);
_result_net__http__Header net__http__new_custom_header_from_map(Map_string_string kvs);
void net__http__Header_add(net__http__Header* h, net__http__CommonHeader key, string value);
_result_void net__http__Header_add_custom(net__http__Header* h, string key, string value);
void net__http__Header_add_map(net__http__Header* h, Map_net__http__CommonHeader_string kvs);
_result_void net__http__Header_add_custom_map(net__http__Header* h, Map_string_string kvs);
void net__http__Header_set(net__http__Header* h, net__http__CommonHeader key, string value);
_result_void net__http__Header_set_custom(net__http__Header* h, string key, string value);
void net__http__Header_delete(net__http__Header* h, net__http__CommonHeader key);
void net__http__Header_delete_custom(net__http__Header* h, string key);
void net__http__Header_coerce(net__http__Header* h, net__http__HeaderCoerceConfig flags);
bool net__http__Header_contains(net__http__Header h, net__http__CommonHeader key);
bool net__http__Header_contains_custom(net__http__Header h, string key, net__http__HeaderQueryConfig flags);
_result_string net__http__Header_get(net__http__Header h, net__http__CommonHeader key);
_result_string net__http__Header_get_custom(net__http__Header h, string key, net__http__HeaderQueryConfig flags);
_result_string net__http__Header_starting_with(net__http__Header h, string key);
Array_string net__http__Header_values(net__http__Header h, net__http__CommonHeader key);
Array_string net__http__Header_custom_values(net__http__Header h, string key, net__http__HeaderQueryConfig flags);
Array_string net__http__Header_keys(net__http__Header h);
string net__http__Header_render(net__http__Header h, net__http__HeaderRenderConfig flags);
void net__http__Header_render_into_sb(net__http__Header h, strings__Builder* sb, net__http__HeaderRenderConfig flags);
net__http__Header net__http__Header_join(net__http__Header h, net__http__Header other);
VV_LOCAL_SYMBOL string net__http__canonicalize(string name);
string net__http__HeaderKeyError_msg(net__http__HeaderKeyError err);
int net__http__HeaderKeyError_code(net__http__HeaderKeyError err);
VV_LOCAL_SYMBOL _result_void net__http__is_valid(string header);
VV_LOCAL_SYMBOL bool net__http__is_token(u8 b);
string net__http__Header_str(net__http__Header h);
VV_LOCAL_SYMBOL _result_net__http__Header net__http__parse_headers(string s);
VV_LOCAL_SYMBOL _result_multi_return_string_string net__http__parse_header(string s);
VV_LOCAL_SYMBOL _result_int net__http__parse_header_fast(string s);
net__http__Request net__http__new_request(net__http__Method method, string url_, string data);
_result_net__http__Response net__http__get(string url);
_result_net__http__Response net__http__post(string url, string data);
_result_net__http__Response net__http__post_json(string url, string data);
_result_net__http__Response net__http__post_form(string url, Map_string_string data);
_result_net__http__Response net__http__post_multipart_form(string url, net__http__PostMultipartFormConfig conf);
_result_net__http__Response net__http__put(string url, string data);
_result_net__http__Response net__http__patch(string url, string data);
_result_net__http__Response net__http__head(string url);
_result_net__http__Response net__http__delete(string url);
_result_net__http__Response net__http__fetch(net__http__FetchConfig config);
string net__http__get_text(string url);
string net__http__url_encode_form_data(Map_string_string data);
VV_LOCAL_SYMBOL _result_string net__http__build_url_from_fetch(net__http__FetchConfig config);
_result_net__http__HttpProxy_ptr net__http__new_http_proxy(string raw_url);
VV_LOCAL_SYMBOL string net__http__HttpProxy_build_proxy_headers(net__http__HttpProxy* pr, string host);
VV_LOCAL_SYMBOL _result_net__http__Response net__http__HttpProxy_http_do(net__http__HttpProxy* pr, net__urllib__URL host, net__http__Method method, string path, net__http__Request* req);
VV_LOCAL_SYMBOL _result_net__TcpConn_ptr net__http__HttpProxy_dial(net__http__HttpProxy* pr, string host);
VV_LOCAL_SYMBOL _result_net__ssl__SSLConn_ptr net__http__HttpProxy_ssl_dial(net__http__HttpProxy* pr, string host);
string net__http__Method_str(net__http__Method m);
net__http__Method net__http__method_from_str(string m);
VV_LOCAL_SYMBOL void net__http__Request_free(net__http__Request* req);
void net__http__Request_add_header(net__http__Request* req, net__http__CommonHeader key, string val);
_result_void net__http__Request_add_custom_header(net__http__Request* req, string key, string val);
void net__http__Request_add_cookie(net__http__Request* req, net__http__Cookie c);
_option_net__http__Cookie net__http__Request_cookie(net__http__Request* req, string name);
_result_net__http__Response net__http__Request_do(net__http__Request* req);
VV_LOCAL_SYMBOL _result_net__http__Response net__http__Request_method_and_url_to_response(net__http__Request* req, net__http__Method method, net__urllib__URL url);
VV_LOCAL_SYMBOL string net__http__Request_build_request_headers(net__http__Request* req, net__http__Method method, string host_name, string path);
VV_LOCAL_SYMBOL string net__http__Request_build_request_cookies_header(net__http__Request* req);
VV_LOCAL_SYMBOL _result_net__http__Response net__http__Request_http_do(net__http__Request* req, string host, net__http__Method method, string path);
VV_LOCAL_SYMBOL _result_Array_u8 net__http__Request_read_all_from_client_connection(net__http__Request* req, net__TcpConn* r);
string net__http__Request_referer(net__http__Request* req);
_result_net__http__Request net__http__parse_request(io__BufferedReader* reader);
_result_net__http__Request net__http__parse_request_head(io__BufferedReader* reader);
VV_LOCAL_SYMBOL _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version net__http__parse_request_line(string s);
Map_string_string net__http__parse_form(string body);
string net__http__UnexpectedExtraAttributeError_msg(net__http__UnexpectedExtraAttributeError err);
string net__http__MultiplePathAttributesError_msg(net__http__MultiplePathAttributesError err);
VV_LOCAL_SYMBOL multi_return_string_string net__http__multipart_form_body(Map_string_string form, Map_string_Array_net__http__FileData files);
multi_return_Map_string_string_Map_string_Array_net__http__FileData net__http__parse_multipart_form(string body, string boundary);
VV_LOCAL_SYMBOL Map_string_string net__http__parse_disposition(string line);
VV_LOCAL_SYMBOL bool net__http__is_no_need_retry_error(int err_code);
VV_LOCAL_SYMBOL void net__http__Response_free(net__http__Response* resp);
Array_u8 net__http__Response_bytes(net__http__Response resp);
string net__http__Response_bytestr(net__http__Response resp);
_result_net__http__Response net__http__parse_response(string resp);
VV_LOCAL_SYMBOL _result_multi_return_string_int_string net__http__parse_status_line(string line);
Array_net__http__Cookie net__http__Response_cookies(net__http__Response r);
net__http__Status net__http__Response_status(net__http__Response r);
void net__http__Response_set_status(net__http__Response* r, net__http__Status s);
net__http__Version net__http__Response_version(net__http__Response r);
void net__http__Response_set_version(net__http__Response* r, net__http__Version v);
net__http__Response net__http__new_response(net__http__ResponseConfig conf);
VV_LOCAL_SYMBOL _result_multi_return_int_int net__http__find_headers_range(string data);
void net__http__Server_listen_and_serve(net__http__Server* s);
void net__http__Server_stop(net__http__Server* s);
void net__http__Server_close(net__http__Server* s);
net__http__ServerStatus net__http__Server_status(net__http__Server* s);
_result_int net__http__Server_wait_till_running(net__http__Server* s, net__http__WaitTillRunningParams params);
VV_LOCAL_SYMBOL __v_thread net__http__new_handler_worker(int wid, chan_net__TcpConn_ptr ch, net__http__Handler handler);
VV_LOCAL_SYMBOL void net__http__HandlerWorker_process_requests(net__http__HandlerWorker* w);
VV_LOCAL_SYMBOL void net__http__HandlerWorker_handle_conn(net__http__HandlerWorker* w, net__TcpConn* conn);
VV_LOCAL_SYMBOL net__http__Response net__http__DebugHandler_handle(net__http__DebugHandler d, net__http__Request req);
net__http__Status net__http__status_from_int(int code);
string net__http__Status_str(net__http__Status code);
int net__http__Status_int(net__http__Status code);
bool net__http__Status_is_valid(net__http__Status code);
bool net__http__Status_is_error(net__http__Status code);
bool net__http__Status_is_success(net__http__Status code);
VV_LOCAL_SYMBOL multi_return_int_int net__http__fast_request_words(string line);
string net__http__Version_str(net__http__Version v);
net__http__Version net__http__version_from_str(string v);
multi_return_int_int net__http__Version_protos(net__http__Version v);
_result_void net__websocket__Server_on_connect(net__websocket__Server* s, _result_bool (*fun)(net__websocket__ServerClient* c));
void net__websocket__Server_on_message(net__websocket__Server* s, _result_void (*fun)(net__websocket__Client* c, net__websocket__Message* msg));
void net__websocket__Server_on_message_ref(net__websocket__Server* s, _result_void (*fun)(net__websocket__Client* c, net__websocket__Message* msg, voidptr v), voidptr ref);
void net__websocket__Server_on_close(net__websocket__Server* s, _result_void (*fun)(net__websocket__Client* c, int code, string reason));
void net__websocket__Server_on_close_ref(net__websocket__Server* s, _result_void (*fun)(net__websocket__Client* c, int code, string reason, voidptr v), voidptr ref);
void net__websocket__Client_on_message(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, net__websocket__Message* msg));
void net__websocket__Client_on_message_ref(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, net__websocket__Message* msg, voidptr v), voidptr ref);
void net__websocket__Client_on_error(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, string err));
void net__websocket__Client_on_error_ref(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, string err, voidptr v), voidptr ref);
void net__websocket__Client_on_open(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c));
void net__websocket__Client_on_open_ref(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, voidptr v), voidptr ref);
void net__websocket__Client_on_close(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, int code, string reason));
void net__websocket__Client_on_close_ref(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, int code, string reason, voidptr v), voidptr ref);
VV_LOCAL_SYMBOL _result_bool net__websocket__Server_send_connect_event(net__websocket__Server* s, net__websocket__ServerClient* c);
VV_LOCAL_SYMBOL void net__websocket__Client_send_message_event(net__websocket__Client* ws, net__websocket__Message* msg);
VV_LOCAL_SYMBOL void net__websocket__Client_send_error_event(net__websocket__Client* ws, string __v_error);
VV_LOCAL_SYMBOL void net__websocket__Client_send_close_event(net__websocket__Client* ws, int code, string reason);
VV_LOCAL_SYMBOL void net__websocket__Client_send_open_event(net__websocket__Client* ws);
VV_LOCAL_SYMBOL _result_void net__websocket__Client_handshake(net__websocket__Client* ws);
VV_LOCAL_SYMBOL _result_multi_return_string_ref_net__websocket__ServerClient net__websocket__Server_handle_server_handshake(net__websocket__Server* s, net__websocket__Client* c);
VV_LOCAL_SYMBOL _result_multi_return_string_ref_net__websocket__ServerClient net__websocket__Server_parse_client_handshake(net__websocket__Server* s, string client_handshake, net__websocket__Client* c);
VV_LOCAL_SYMBOL _result_string net__websocket__Client_read_handshake_str(net__websocket__Client* ws);
VV_LOCAL_SYMBOL _result_void net__websocket__Client_read_handshake(net__websocket__Client* ws, string seckey);
VV_LOCAL_SYMBOL _result_void net__websocket__Client_check_handshake_response(net__websocket__Client* ws, string handshake_response, string seckey);
VV_LOCAL_SYMBOL _result_int net__websocket__Client_socket_read(net__websocket__Client* ws, Array_u8* buffer);
VV_LOCAL_SYMBOL _result_int net__websocket__Client_socket_read_ptr(net__websocket__Client* ws, u8* buf_ptr, int len);
VV_LOCAL_SYMBOL _result_int net__websocket__Client_socket_write(net__websocket__Client* ws, Array_u8 bytes);
VV_LOCAL_SYMBOL _result_void net__websocket__Client_shutdown_socket(net__websocket__Client* ws);
VV_LOCAL_SYMBOL _result_net__TcpConn_ptr net__websocket__Client_dial_socket(net__websocket__Client* ws);
_result_void net__websocket__Client_validate_frame(net__websocket__Client* ws, net__websocket__Frame* frame);
VV_LOCAL_SYMBOL bool net__websocket__is_control_frame(net__websocket__OPCode opcode);
VV_LOCAL_SYMBOL bool net__websocket__is_data_frame(net__websocket__OPCode opcode);
VV_LOCAL_SYMBOL _result_Array_u8 net__websocket__Client_read_payload(net__websocket__Client* ws, net__websocket__Frame* frame);
VV_LOCAL_SYMBOL _result_void net__websocket__Client_validate_utf_8(net__websocket__Client* ws, net__websocket__OPCode opcode, Array_u8 payload);
_result_net__websocket__Message net__websocket__Client_read_next_message(net__websocket__Client* ws);
VV_LOCAL_SYMBOL _result_Array_u8 net__websocket__Client_payload_from_fragments(net__websocket__Client ws, Array_u8 fin_payload);
VV_LOCAL_SYMBOL net__websocket__OPCode net__websocket__Client_opcode_from_fragments(net__websocket__Client ws);
_result_net__websocket__Frame net__websocket__Client_parse_frame_header(net__websocket__Client* ws);
VV_LOCAL_SYMBOL void net__websocket__Frame_unmask_sequence(net__websocket__Frame* f, Array_u8* buffer);
string net__websocket__Uri_str(net__websocket__Uri u);
VV_LOCAL_SYMBOL Array_u8 net__websocket__htonl64(u64 payload_len);
VV_LOCAL_SYMBOL Array_u8 net__websocket__create_masking_key(void);
VV_LOCAL_SYMBOL _result_string net__websocket__create_key_challenge_response(string seckey);
VV_LOCAL_SYMBOL string net__websocket__get_nonce(int nonce_size);
_result_net__websocket__Client_ptr net__websocket__new_client(string address, net__websocket__ClientOpt opt);
_result_void net__websocket__Client_connect(net__websocket__Client* ws);
_result_void net__websocket__Client_listen(net__websocket__Client* ws);
VV_LOCAL_SYMBOL void net__websocket__Client_manage_clean_close(net__websocket__Client* ws);
_result_void net__websocket__Client_ping(net__websocket__Client* ws);
_result_void net__websocket__Client_pong(net__websocket__Client* ws);
_result_int net__websocket__Client_write_ptr(net__websocket__Client* ws, u8* bytes, int payload_len, net__websocket__OPCode code);
_result_int net__websocket__Client_write(net__websocket__Client* ws, Array_u8 bytes, net__websocket__OPCode code);
_result_int net__websocket__Client_write_string(net__websocket__Client* ws, string str);
_result_void net__websocket__Client_close(net__websocket__Client* ws, int code, string message);
VV_LOCAL_SYMBOL _result_void net__websocket__Client_send_control_frame(net__websocket__Client* ws, net__websocket__OPCode code, string frame_typ, Array_u8 payload);
VV_LOCAL_SYMBOL _result_net__websocket__Uri_ptr net__websocket__parse_uri(string url);
void net__websocket__Client_set_state(net__websocket__Client* ws, net__websocket__State state);
net__websocket__State net__websocket__Client_get_state(net__websocket__Client* ws);
VV_LOCAL_SYMBOL _result_void net__websocket__Client_assert_not_connected(net__websocket__Client* ws);
_result_void net__websocket__Client_reset_state(net__websocket__Client* ws);
VV_LOCAL_SYMBOL void net__websocket__Client_debug_log(net__websocket__Client* ws, string text);
void net__websocket__Message_free(net__websocket__Message* m);
void net__websocket__Client_free(net__websocket__Client* c);
net__websocket__Server* net__websocket__new_server(net__AddrFamily family, int port, string route, net__websocket__ServerOpt opt);
void net__websocket__Server_set_ping_interval(net__websocket__Server* s, int seconds);
int net__websocket__Server_get_ping_interval(net__websocket__Server* s);
_result_void net__websocket__Server_listen(net__websocket__Server* s);
VV_LOCAL_SYMBOL void net__websocket__Server_close(net__websocket__Server* s);
VV_LOCAL_SYMBOL void net__websocket__Server_handle_ping(net__websocket__Server* s);
VV_LOCAL_SYMBOL _result_void net__websocket__Server_serve_client(net__websocket__Server* s, net__websocket__Client* c);
VV_LOCAL_SYMBOL void net__websocket__Server_setup_callbacks(net__websocket__Server* s, net__websocket__ServerClient* sc);
VV_LOCAL_SYMBOL _result_void anon_fn_f5aad9dbbbe573d0_mut_net__websocket__client_int_string_mut_net__websocket__serverclient__result_void_5147(net__websocket__Client* c, int code, string reason, net__websocket__ServerClient* sc);
VV_LOCAL_SYMBOL _result_net__websocket__Client_ptr net__websocket__Server_accept_new_client(net__websocket__Server* s);
void net__websocket__Server_set_state(net__websocket__Server* s, net__websocket__State state);
net__websocket__State net__websocket__Server_get_state(net__websocket__Server* s);
void net__websocket__Server_free(net__websocket__Server* s);
VV_LOCAL_SYMBOL int net__websocket__error_code(void);
_result_void discord__Client_delete_channel(discord__Client _v_toheap_c, discord__Snowflake id, discord__WithReason config);
VV_LOCAL_SYMBOL log__Level discord__ClientConfig_get_level(discord__ClientConfig config);
discord__GatewayClient discord__bot(string token, discord__BotConfig config);
discord__Client discord__bearer(string token, discord__ClientConfig config);
x__json2__Any discord__ComponentType_build(discord__ComponentType ct);
VV_LOCAL_SYMBOL void discord__ActionRow_is_component(discord__ActionRow _d1);
x__json2__Any discord__ActionRow_build(discord__ActionRow ar);
x__json2__Any discord__ButtonStyle_build(discord__ButtonStyle bs);
VV_LOCAL_SYMBOL void discord__Button_is_component(discord__Button _d2);
x__json2__Any discord__Button_build(discord__Button b);
x__json2__Any discord__SelectOption_build(discord__SelectOption so);
VV_LOCAL_SYMBOL void discord__StringSelect_is_component(discord__StringSelect _d3);
x__json2__Any discord__StringSelect_build(discord__StringSelect ss);
VV_LOCAL_SYMBOL void discord__UserSelect_is_component(discord__UserSelect _d4);
x__json2__Any discord__UserSelect_build(discord__UserSelect us);
VV_LOCAL_SYMBOL void discord__RoleSelect_is_component(discord__RoleSelect _d5);
x__json2__Any discord__RoleSelect_build(discord__RoleSelect rs);
x__json2__Any discord__DefaultValue_build(discord__DefaultValue dv);
VV_LOCAL_SYMBOL void discord__MentionableSelect_is_component(discord__MentionableSelect _d6);
x__json2__Any discord__MentionableSelect_build(discord__MentionableSelect ms);
VV_LOCAL_SYMBOL void discord__ChannelSelect_is_component(discord__ChannelSelect _d7);
x__json2__Any discord__ChannelSelect_build(discord__ChannelSelect cs);
x__json2__Any discord__TextInputStyle_build(discord__TextInputStyle tis);
VV_LOCAL_SYMBOL void discord__TextInput_is_component(discord__TextInput _d8);
x__json2__Any discord__TextInput_build(discord__TextInput ti);
_result_void discord__Client_create_dm(discord__Client _v_toheap_c, discord__Snowflake recipient_id);
_result_void discord__Client_create_group_dm(discord__Client _v_toheap_c, discord__CreateGroupDMParams params);
VV_LOCAL_SYMBOL multi_return_string_x__json2__Any anon_fn_741189b08a0d001a_discord__snowflake_string__multi_return_string_x__json2__Any_630(discord__Snowflake k, string v);
x__json2__Any discord__PartialEmoji_build(discord__PartialEmoji pe);
_result_discord__Emoji discord__Emoji__static__parse(x__json2__Any j);
_result_discord__Entitlement discord__Entitlement__static__parse(x__json2__Any j);
_result_Array_discord__Entitlement discord__Client_list_entitlements(discord__Client _v_toheap_c, discord__Snowflake application_id, discord__ListEntitlementParams params);
_result_discord__Entitlement discord__Client_create_test_entitlement(discord__Client _v_toheap_c, discord__Snowflake application_id, discord__CreateTestEntitlementParams params);
_result_void discord__Client_delete_test_entitlement(discord__Client _v_toheap_c, discord__Snowflake application_id, discord__Snowflake entitlement_id);
int discord__RestError_code(discord__RestError re);
VV_LOCAL_SYMBOL Map_string_string discord__flatten_error_dict(Map_string_x__json2__Any d, string key);
VV_LOCAL_SYMBOL string anon_fn_d9dbe34f3e4698d6_int_x__json2__any__string_753(int _d1, x__json2__Any er);
string discord__RestError_msg(discord__RestError re);
VV_LOCAL_SYMBOL string anon_fn_d9dbe34f3e4698d6_string_string__string_1411(string k, string m);
VV_LOCAL_SYMBOL int discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_generate_id_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec);
void discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_emit_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec, discord__DispatchEvent_T_discord__GatewayClient e, discord__EmitOptions options);
struct _V_anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient_Ctx;
VV_LOCAL_SYMBOL void anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient(_result_void (*f)(discord__DispatchEvent_T_discord__GatewayClient ), int j, discord__DispatchEvent_T_discord__GatewayClient e);
_option_discord__DispatchEvent_T_discord__GatewayClient discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_wait_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec, discord__EventWaitParams_T_discord__DispatchEvent_T_discord__GatewayClient params);
discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_override_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec, _result_void (*listener)(discord__DispatchEvent_T_discord__GatewayClient ));
discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_listen_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec, _result_void (*listener)(discord__DispatchEvent_T_discord__GatewayClient ));
VV_LOCAL_SYMBOL _result_discord__WSMessage discord__GatewayClient_recv(discord__GatewayClient* c);
VV_LOCAL_SYMBOL _result_void discord__GatewayClient_send(discord__GatewayClient* c, discord__WSMessage message);
VV_LOCAL_SYMBOL _result_void discord__GatewayClient_heartbeat(discord__GatewayClient* c);
VV_LOCAL_SYMBOL anon_fn_int_ierror discord__GatewayClient_error_logger(discord__GatewayClient* c);
struct _V_anon_fn_263669e3d870cc7d_int_ierror_862_Ctx;
VV_LOCAL_SYMBOL void anon_fn_263669e3d870cc7d_int_ierror_862(int i, IError e);
VV_LOCAL_SYMBOL _result_void discord__GatewayClient_raw_dispatch(discord__GatewayClient* c, string name, x__json2__Any data);
VV_LOCAL_SYMBOL void discord__GatewayClient_spawn_heart(discord__GatewayClient* c, i64 interval);
VV_LOCAL_SYMBOL _result_int anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255(discord__GatewayClient* client, time__Duration heartbeat_interval);
_result_void discord__GatewayClient_init(discord__GatewayClient* c);
VV_LOCAL_SYMBOL _result_void anon_fn_263669e3d870cc7d_mut_net__websocket__client_int_string_voidptr__result_void_1828(net__websocket__Client* _d1, int code, string reason, voidptr r);
VV_LOCAL_SYMBOL _result_void anon_fn_263669e3d870cc7d_mut_net__websocket__client_net__websocket__message_voidptr__result_void_2034(net__websocket__Client* _d2, net__websocket__Message* m, voidptr r);
_result_void discord__GatewayClient_run(discord__GatewayClient* c);
_result_void discord__GatewayClient_launch(discord__GatewayClient* c);
VV_LOCAL_SYMBOL _result_string discord__Client_fetch_gateway_url(discord__Client _v_toheap_c);
_result_discord__PartialGuild discord__PartialGuild__static__parse(x__json2__Any j);
_result_Array_discord__PartialGuild discord__Client_fetch_my_guilds(discord__Client _v_toheap_c, discord__FetchMyGuildsParams params);
_result_discord__RoleTags discord__RoleTags__static__parse(x__json2__Any j);
_result_discord__Role discord__Role__static__parse(x__json2__Any j);
_result_discord__WelcomeChannel discord__WelcomeChannel__static__parse(x__json2__Any j);
_result_discord__WelcomeScreen discord__WelcomeScreen__static__parse(x__json2__Any j);
_result_discord__Guild discord__Guild__static__parse(x__json2__Any j);
_result_discord__Guild discord__Client_fetch_guild(discord__Client _v_toheap_c, discord__Snowflake guild_id);
_result_discord__GuildMember discord__GuildMember__static__parse(x__json2__Any j);
_result_net__http__Response discord__Client_request(discord__Client _v_toheap_c, net__http__Method method, string route, discord__RequestOptions options);
VV_LOCAL_SYMBOL void discord__JpegImage_is_image(discord__JpegImage _d1);
string discord__JpegImage_build(discord__JpegImage ji);
VV_LOCAL_SYMBOL void discord__PngImage_is_image(discord__PngImage _d2);
string discord__PngImage_build(discord__PngImage pi);
VV_LOCAL_SYMBOL void discord__GifImage_is_image(discord__GifImage _d3);
string discord__GifImage_build(discord__GifImage gi);
int discord__combine_intents(Array_discord__Intents list);
VV_LOCAL_SYMBOL int anon_fn_8ca92943f0af0818_int_discord__intents__int_585(int x, discord__Intents y);
_result_discord__Interaction discord__Interaction__static__parse(x__json2__Any j);
_result_void discord__Client_delete_message(discord__Client _v_toheap_c, discord__Snowflake channel_id, discord__Snowflake id, discord__WithReason config);
discord__Permissions discord__Permissions__static__zero(void);
discord__Permissions discord__Permissions__static__all(void);
discord__Permissions discord__Permissions__static__all_except(discord__Permissions permissions);
_result_discord__Permissions discord__Permissions__static__parse(x__json2__Any j);
_result_discord__Sku discord__Sku__static__parse(x__json2__Any j);
_result_Array_discord__Sku discord__Client_list_skus(discord__Client _v_toheap_c, discord__Snowflake application_id);
u64 discord__Snowflake_raw_timestamp(discord__Snowflake s);
time__Time discord__Snowflake_timestamp(discord__Snowflake s);
discord__Snowflake discord__Snowflake__static__from(time__Time t);
discord__Snowflake discord__Snowflake__static__now(void);
string discord__Snowflake_build(discord__Snowflake s);
_result_discord__Snowflake discord__Snowflake__static__parse(x__json2__Any j);
_result_discord__Sticker discord__Sticker__static__parse(x__json2__Any j);
_result_discord__AvatarDecorationData discord__AvatarDecorationData__static__parse(x__json2__Any j);
_result_discord__User discord__User__static__parse(x__json2__Any j);
_result_discord__User discord__Client_fetch_my_user(discord__Client _v_toheap_c);
_result_discord__User discord__Client_fetch_user(discord__Client _v_toheap_c, discord__Snowflake user_id);
x__json2__Any discord__MyUserEdit_build(discord__MyUserEdit mue);
_result_discord__User discord__Client_edit_my_user(discord__Client _v_toheap_c, discord__MyUserEdit params);
_result_discord__GuildMember discord__Client_fetch_my_guild_member(discord__Client _v_toheap_c, discord__Snowflake guild_id);
_result_void discord__Client_leave_guild(discord__Client _v_toheap_c, discord__Snowflake guild_id);
VV_LOCAL_SYMBOL _result_discord__WSMessage discord__decode_message(x__json2__Any payload);
VV_LOCAL_SYMBOL _result_x__json2__Any discord__encode_message(discord__WSMessage message);
VV_LOCAL_SYMBOL _result_discord__WSMessage discord__decode_websocket_message(net__websocket__Message message);
VV_LOCAL_SYMBOL _result_discord__WSMessage discord__ws_recv_message(net__websocket__Client* client);
VV_LOCAL_SYMBOL _result_void discord__ws_send_message(net__websocket__Client* client, discord__WSMessage message);
bool discord__RoleFlags_is_empty(discord__RoleFlags* e);
bool discord__RoleFlags_has(discord__RoleFlags* e, discord__RoleFlags flag);
bool discord__RoleFlags_all(discord__RoleFlags* e, discord__RoleFlags flag);
void discord__RoleFlags_set(discord__RoleFlags* e, discord__RoleFlags flag);
void discord__RoleFlags_set_all(discord__RoleFlags* e);
void discord__RoleFlags_clear(discord__RoleFlags* e, discord__RoleFlags flag);
void discord__RoleFlags_clear_all(discord__RoleFlags* e);
void discord__RoleFlags_toggle(discord__RoleFlags* e, discord__RoleFlags flag);
bool discord__SystemChannelFlags_is_empty(discord__SystemChannelFlags* e);
bool discord__SystemChannelFlags_has(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag);
bool discord__SystemChannelFlags_all(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag);
void discord__SystemChannelFlags_set(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag);
void discord__SystemChannelFlags_set_all(discord__SystemChannelFlags* e);
void discord__SystemChannelFlags_clear(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag);
void discord__SystemChannelFlags_clear_all(discord__SystemChannelFlags* e);
void discord__SystemChannelFlags_toggle(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag);
bool discord__GuildMemberFlags_is_empty(discord__GuildMemberFlags* e);
bool discord__GuildMemberFlags_has(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag);
bool discord__GuildMemberFlags_all(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag);
void discord__GuildMemberFlags_set(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag);
void discord__GuildMemberFlags_set_all(discord__GuildMemberFlags* e);
void discord__GuildMemberFlags_clear(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag);
void discord__GuildMemberFlags_clear_all(discord__GuildMemberFlags* e);
void discord__GuildMemberFlags_toggle(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag);
bool discord__Intents_is_empty(discord__Intents* e);
bool discord__Intents_has(discord__Intents* e, discord__Intents flag);
bool discord__Intents_all(discord__Intents* e, discord__Intents flag);
void discord__Intents_set(discord__Intents* e, discord__Intents flag);
void discord__Intents_set_all(discord__Intents* e);
void discord__Intents_clear(discord__Intents* e, discord__Intents flag);
void discord__Intents_clear_all(discord__Intents* e);
void discord__Intents_toggle(discord__Intents* e, discord__Intents flag);
bool discord__Permissions_is_empty(discord__Permissions* e);
bool discord__Permissions_has(discord__Permissions* e, discord__Permissions flag);
bool discord__Permissions_all(discord__Permissions* e, discord__Permissions flag);
void discord__Permissions_set(discord__Permissions* e, discord__Permissions flag);
void discord__Permissions_set_all(discord__Permissions* e);
void discord__Permissions_clear(discord__Permissions* e, discord__Permissions flag);
void discord__Permissions_clear_all(discord__Permissions* e);
void discord__Permissions_toggle(discord__Permissions* e, discord__Permissions flag);
bool discord__UserFlags_is_empty(discord__UserFlags* e);
bool discord__UserFlags_has(discord__UserFlags* e, discord__UserFlags flag);
bool discord__UserFlags_all(discord__UserFlags* e, discord__UserFlags flag);
void discord__UserFlags_set(discord__UserFlags* e, discord__UserFlags flag);
void discord__UserFlags_set_all(discord__UserFlags* e);
void discord__UserFlags_clear(discord__UserFlags* e, discord__UserFlags flag);
void discord__UserFlags_clear_all(discord__UserFlags* e);
void discord__UserFlags_toggle(discord__UserFlags* e, discord__UserFlags flag);
VV_LOCAL_SYMBOL void main__main(void);
VV_LOCAL_SYMBOL _result_void anon_fn_f860512d614a01ac_discord__dispatchevent_t_discord__gatewayclient__result_void_345(discord__DispatchEvent_T_discord__GatewayClient event);
x__json2__Any _v_dump_expr_x__json2__Any(string fpath, int line, string sexpr, x__json2__Any dump_arg);
discord__Guild _v_dump_expr_discord__Guild(string fpath, int line, string sexpr, discord__Guild dump_arg);
bool _v_dump_expr_bool(string fpath, int line, string sexpr, bool dump_arg);

static string time__FormatTime_str(time__FormatTime it); // auto
static string time__FormatDate_str(time__FormatDate it); // auto
static string x__json2__TokenKind_str(x__json2__TokenKind it); // auto
static string Array_u8_str(Array_u8 a); // auto
static string indent_Array_u8_str(Array_u8 a, int indent_count); // auto
static string net__WsaError_str(net__WsaError it); // auto
static string net__TcpSocket_str(net__TcpSocket it); // auto
static string indent_net__TcpSocket_str(net__TcpSocket it, int indent_count); // auto
static string net__websocket__Frame_str(net__websocket__Frame it); // auto
static string indent_net__websocket__Frame_str(net__websocket__Frame it, int indent_count); // auto
static string net__websocket__OPCode_str(net__websocket__OPCode it); // auto
static string net__websocket__State_str(net__websocket__State it); // auto
static string discord__WSMessage_str(discord__WSMessage it); // auto
static string indent_discord__WSMessage_str(discord__WSMessage it, int indent_count); // auto
static string discord__Guild_str(discord__Guild it); // auto
static string indent_discord__Guild_str(discord__Guild it, int indent_count); // auto
static string net__Socket_str(net__Socket it); // auto
static string indent_net__Socket_str(net__Socket it, int indent_count); // auto
static string Array_fixed_u8_4_str(); // auto
static string indent_Array_fixed_u8_4_str(Array_fixed_u8_4 a, int indent_count); // auto
string _option_int_str(_option_int it); // auto
string indent__option_int_str(_option_int it, int indent_count); // auto
static string discord__Snowflake_str(discord__Snowflake it); // auto
static string indent_discord__Snowflake_str(discord__Snowflake it, int indent_count); // auto
string _option_string_str(_option_string it); // auto
string indent__option_string_str(_option_string it, int indent_count); // auto
string _option_discord__Snowflake_str(_option_discord__Snowflake it); // auto
string indent__option_discord__Snowflake_str(_option_discord__Snowflake it, int indent_count); // auto
string _option_bool_str(_option_bool it); // auto
string indent__option_bool_str(_option_bool it, int indent_count); // auto
static string discord__VerificationLevel_str(discord__VerificationLevel it); // auto
static string discord__MessageNotificationsLevel_str(discord__MessageNotificationsLevel it); // auto
static string discord__ExplicitContentFilterLevel_str(discord__ExplicitContentFilterLevel it); // auto
static string Array_discord__Role_str(Array_discord__Role a); // auto
static string indent_Array_discord__Role_str(Array_discord__Role a, int indent_count); // auto
static string Array_discord__Emoji_str(Array_discord__Emoji a); // auto
static string indent_Array_discord__Emoji_str(Array_discord__Emoji a, int indent_count); // auto
static string Array_discord__GuildFeature_str(Array_discord__GuildFeature a); // auto
static string indent_Array_discord__GuildFeature_str(Array_discord__GuildFeature a, int indent_count); // auto
static string discord__MFALevel_str(discord__MFALevel it); // auto
static string discord__SystemChannelFlags_str(discord__SystemChannelFlags it); // auto
static string discord__PremiumTier_str(discord__PremiumTier it); // auto
string _option_discord__WelcomeScreen_str(_option_discord__WelcomeScreen it); // auto
string indent__option_discord__WelcomeScreen_str(_option_discord__WelcomeScreen it, int indent_count); // auto
static string discord__NSFWLevel_str(discord__NSFWLevel it); // auto
static string Array_discord__Sticker_str(Array_discord__Sticker a); // auto
static string indent_Array_discord__Sticker_str(Array_discord__Sticker a, int indent_count); // auto
static string discord__Role_str(discord__Role it); // auto
static string indent_discord__Role_str(discord__Role it, int indent_count); // auto
static string discord__Emoji_str(discord__Emoji it); // auto
static string indent_discord__Emoji_str(discord__Emoji it, int indent_count); // auto
static string discord__WelcomeScreen_str(discord__WelcomeScreen it); // auto
static string indent_discord__WelcomeScreen_str(discord__WelcomeScreen it, int indent_count); // auto
static string discord__Sticker_str(discord__Sticker it); // auto
static string indent_discord__Sticker_str(discord__Sticker it, int indent_count); // auto
static string discord__Permissions_str(discord__Permissions it); // auto
string _option_discord__RoleTags_str(_option_discord__RoleTags it); // auto
string indent__option_discord__RoleTags_str(_option_discord__RoleTags it, int indent_count); // auto
static string discord__RoleFlags_str(discord__RoleFlags it); // auto
string _option_Array_discord__Snowflake_str(_option_Array_discord__Snowflake it); // auto
string indent__option_Array_discord__Snowflake_str(_option_Array_discord__Snowflake it, int indent_count); // auto
string _option_discord__User_str(_option_discord__User it); // auto
string indent__option_discord__User_str(_option_discord__User it, int indent_count); // auto
static string Array_discord__WelcomeChannel_str(Array_discord__WelcomeChannel a); // auto
static string indent_Array_discord__WelcomeChannel_str(Array_discord__WelcomeChannel a, int indent_count); // auto
static string discord__StickerType_str(discord__StickerType it); // auto
static string discord__StickerFormatType_str(discord__StickerFormatType it); // auto
static string discord__RoleTags_str(discord__RoleTags it); // auto
static string indent_discord__RoleTags_str(discord__RoleTags it, int indent_count); // auto
static string Array_discord__Snowflake_str(Array_discord__Snowflake a); // auto
static string indent_Array_discord__Snowflake_str(Array_discord__Snowflake a, int indent_count); // auto
static string discord__User_str(discord__User it); // auto
static string indent_discord__User_str(discord__User it, int indent_count); // auto
static string discord__WelcomeChannel_str(discord__WelcomeChannel it); // auto
static string indent_discord__WelcomeChannel_str(discord__WelcomeChannel it, int indent_count); // auto
string _option_discord__UserFlags_str(_option_discord__UserFlags it); // auto
string indent__option_discord__UserFlags_str(_option_discord__UserFlags it, int indent_count); // auto
string _option_discord__PremiumType_str(_option_discord__PremiumType it); // auto
string indent__option_discord__PremiumType_str(_option_discord__PremiumType it, int indent_count); // auto
string _option_discord__AvatarDecorationData_str(_option_discord__AvatarDecorationData it); // auto
string indent__option_discord__AvatarDecorationData_str(_option_discord__AvatarDecorationData it, int indent_count); // auto
static string discord__UserFlags_str(discord__UserFlags it); // auto
static string discord__PremiumType_str(discord__PremiumType it); // auto
static string discord__AvatarDecorationData_str(discord__AvatarDecorationData it); // auto
static string indent_discord__AvatarDecorationData_str(discord__AvatarDecorationData it, int indent_count); // auto
static bool Array_rune_arr_eq(Array_rune a, Array_rune b); // auto
static bool time__Duration_alias_eq(time__Duration a, time__Duration b); // auto

// V global/const definitions:
string _const_math__bits__overflow_error; // a string literal, inited later
string _const_math__bits__divide_error; // a string literal, inited later
#define _const_strconv__digits 18
#define _const_strconv__int_size 32
#define _const_strconv__bias32 127
#define _const_strconv__maxexp32 255
#define _const_strconv__bias64 1023
#define _const_strconv__maxexp64 2047
#define _const_strconv__max_size_f64_char 32
string _const_strconv__digit_pairs; // a string literal, inited later
string _const_strconv__base_digits; // a string literal, inited later
#define _const_strconv__pow5_num_bits_32 61
#define _const_strconv__pow5_inv_num_bits_32 59
#define _const_strconv__pow5_num_bits_64 121
#define _const_strconv__pow5_inv_num_bits_64 122
#define _const_symopt_undname 2
#define _const_symopt_deferred_loads 4
#define _const_symopt_no_cpp 8
#define _const_symopt_load_lines 16
#define _const_symopt_include_32bit_modules 8192
#define _const_symopt_allow_zero_address 16777216
#define _const_std_output_handle -11
#define _const_std_error_handle -12
#define _const_enable_processed_output 1
#define _const_enable_wrap_at_eol_output 2
#define _const_evable_virtual_terminal_processing 4
#define _const_format_message_allocate_buffer 256
#define _const_format_message_argument_array 8192
#define _const_format_message_from_hmodule 2048
#define _const_format_message_from_string 1024
#define _const_format_message_from_system 4096
#define _const_format_message_ignore_inserts 512
string _const_digit_pairs; // a string literal, inited later
#define _const_hashbits 24
#define _const_max_cached_hashbits 16
#define _const_init_log_capicity 5
#define _const_init_capicity 32
#define _const_init_even_index 30
#define _const_extra_metas_inc 4
#define _const_degree 6
#define _const_mid_index 5
#define _const_max_len 11
string _const_si_s_code; // a string literal, inited later
string _const_si_g32_code; // a string literal, inited later
string _const_si_g64_code; // a string literal, inited later
#define _const_cp_utf8 65001
string _const_net__urllib__err_msg_escape; // a string literal, inited later
string _const_net__urllib__err_msg_parse; // a string literal, inited later
string _const_time__days_string; // a string literal, inited later
string _const_time__months_string; // a string literal, inited later
#define _const_time__seconds_per_minute 60
#define _const_time__seconds_per_hour 3600
#define _const_time__seconds_per_day 86400
#define _const_time__seconds_per_week 604800
#define _const_time__days_per_400_years 146097
#define _const_time__days_per_100_years 36524
#define _const_time__days_per_4_years 1461
#define _const_time__days_in_year 365
string _const_encoding__base64__enc_table; // a string literal, inited later
#define _const_dl__version 1
#define _const_dl__rtld_now 0
#define _const_dl__rtld_lazy 0
#define _const_dl__rtld_global 0
#define _const_dl__rtld_local 0
#define _const_dl__rtld_nodelete 0
#define _const_dl__rtld_noload 0
#define _const_io__buf_max_len 1024
#define _const_io__read_all_len 10240
#define _const_io__read_all_grow_len 1024
#define _const_sync__stdatomic__used 1
#define _const_encoding__utf8__p_c 1
#define _const_encoding__utf8__p_p 2
#define _const_encoding__utf8__p_n 4
#define _const_encoding__utf8__p_s 8
#define _const_encoding__utf8__p_z 16
#define _const_encoding__utf8__p_lu 32
#define _const_encoding__utf8__p_ll 64
#define _const_encoding__utf8__p_pr 128
#define _const_encoding__utf8__p_g 144
#define _const_encoding__utf8__p_lo 96
#define _const_encoding__utf8__p_l_mask 96
#define _const_encoding__utf8__linear_max 18
#define _const_os__max_path_buffer_size 8192
#define _const_os__success 0
#define _const_os__error_insufficient_buffer 130
#define _const_os__handle_open_existing 3
#define _const_os__file_share_read 1
#define _const_os__file_share_write 2
#define _const_os__file_share_delete 4
#define _const_os__file_notify_change_file_name 1
#define _const_os__file_notify_change_dir_name 2
#define _const_os__file_notify_change_attributes 4
#define _const_os__file_notify_change_size 8
#define _const_os__file_notify_change_last_write 16
#define _const_os__file_notify_change_last_access 32
#define _const_os__file_notify_change_creation 64
#define _const_os__file_notify_change_security 128
#define _const_os__file_action_added 1
#define _const_os__file_action_removed 2
#define _const_os__file_action_modified 3
#define _const_os__file_action_renamed_old_name 4
#define _const_os__file_action_renamed_new_name 5
#define _const_os__file_attr_readonly 1
#define _const_os__file_attr_hidden 2
#define _const_os__file_attr_system 4
#define _const_os__file_attr_directory 16
#define _const_os__file_attr_archive 32
#define _const_os__file_attr_device 64
#define _const_os__file_attr_normal 128
#define _const_os__file_attr_temporary 256
#define _const_os__file_attr_sparse_file 512
#define _const_os__file_attr_reparse_point 1024
#define _const_os__file_attr_compressed 2048
#define _const_os__file_attr_offline 4096
#define _const_os__file_attr_not_content_indexed 8192
#define _const_os__file_attr_encrypted 16384
#define _const_os__file_attr_integrity_stream 32768
#define _const_os__file_attr_virtual 65536
#define _const_os__file_attr_no_scrub_data 131072
#define _const_os__file_type_unknown 0
#define _const_os__file_type_disk 1
#define _const_os__file_type_char 2
#define _const_os__file_type_pipe 3
#define _const_os__file_invalid_file_id -1
#define _const_os__enable_echo_input 4
#define _const_os__enable_extended_flags 128
#define _const_os__enable_insert_mode 32
#define _const_os__enable_line_input 2
#define _const_os__enable_mouse_input 16
#define _const_os__enable_processed_input 1
#define _const_os__enable_quick_edit_mode 64
#define _const_os__enable_window_input 8
#define _const_os__enable_virtual_terminal_input 512
#define _const_os__enable_processed_output 1
#define _const_os__enable_wrap_at_eol_output 2
#define _const_os__enable_virtual_terminal_processing 4
#define _const_os__disable_newline_auto_return 8
#define _const_os__enable_lvb_grid_worldwide 16
#define _const_os__o_rdonly 0
#define _const_os__o_wronly 1
#define _const_os__o_rdwr 2
#define _const_os__o_append 8
#define _const_os__o_create 256
#define _const_os__o_binary 32768
#define _const_os__o_trunc 512
#define _const_os__o_excl 1024
#define _const_os__o_sync 0
#define _const_os__o_noctty 0
#define _const_os__o_nonblock 0
#define _const_os__key_query_value 1
#define _const_os__key_set_value 2
#define _const_os__key_enumerate_sub_keys 8
#define _const_os__key_wow64_32key 512
#define _const_os__wm_settingchange 26
#define _const_os__smto_abortifhung 2
#define _const_os__bslash '\\'
string _const_os__fslash_str; // a string literal, inited later
string _const_os__dot_dot; // a string literal, inited later
string _const_os__empty_str; // a string literal, inited later
string _const_os__dot_str; // a string literal, inited later
#define _const_os__buf_size 4096
#define _const_os__max_path_len 4096
#define _const_os__f_ok 0
#define _const_os__x_ok 1
#define _const_os__w_ok 2
#define _const_os__r_ok 4
string _const_os__path_separator; // a string literal, inited later
string _const_os__path_delimiter; // a string literal, inited later
#define _const_os__format_message_allocate_buffer 256
#define _const_os__format_message_argument_array 8192
#define _const_os__format_message_from_hmodule 2048
#define _const_os__format_message_from_string 1024
#define _const_os__format_message_from_system 4096
#define _const_os__format_message_ignore_inserts 512
#define _const_os__sublang_neutral 0
#define _const_os__sublang_default 1
#define _const_os__lang_neutral 0
#define _const_os__max_error_code 15841
#define _const_crypto__sha1__size 20
#define _const_crypto__sha1__block_size 64
#define _const_crypto__sha1__chunk 64
#define _const_crypto__sha1__init0 1732584193
#define _const_crypto__sha1__init3 271733878
#define _const_crypto__sha1___k0 1518500249
#define _const_crypto__sha1___k1 1859775393
#define _const_term__default_columns_size 80
#define _const_term__default_rows_size 25
#define _const_rand__wyrand__seed_len 2
string _const_rand__ulid_encoding; // a string literal, inited later
string _const_rand__english_letters; // a string literal, inited later
string _const_rand__hex_chars; // a string literal, inited later
string _const_rand__ascii_chars; // a string literal, inited later
#define _const_sync__aops_used 1
#define _const_sync__spinloops 750
#define _const_sync__spinloops_sem 4000
#define _const_io__util__retries 10000
#define _const_net__max_ip_len 24
#define _const_net__max_ip6_len 46
#define _const_net__max_unix_path 108
#define _const_net__errors_base 0
#define _const_net__err_timed_out_code 9
#define _const_net__msg_nosignal 0
#define _const_net__wsa_v22 514
string _const_net__crlf; // a string literal, inited later
#define _const_net__msg_peek 2
#define _const_net__max_read 400
#define _const_net__max_read_line_len 1048576
#define _const_net__mbedtls__is_used 1
#define _const_net__http__max_headers 50
#define _const_net__http__max_redirects 16
string _const_net__http__content_type_default; // a string literal, inited later
#define _const_net__http__bufsize 1536
#define _const_net__websocket__header_len_offset 2
#define _const_net__websocket__buffer_size 256
#define _const_net__websocket__extended_payload16_end_byte 4
#define _const_net__websocket__extended_payload64_end_byte 10
 const u32 _const_math__bits__de_bruijn32 = 125613361; // precomputed2
Array_fixed_u8_32 _const_math__bits__de_bruijn32tab = {((u8)(0)), 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9}; // fixed array const
 const u64 _const_math__bits__de_bruijn64 = 285870213051353865U; // precomputed2
Array_fixed_u8_64 _const_math__bits__de_bruijn64tab = {((u8)(0)), 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6}; // fixed array const
 const u64 _const_math__bits__m0 = 6148914691236517205U; // precomputed2
 const u64 _const_math__bits__m1 = 3689348814741910323U; // precomputed2
 const u64 _const_math__bits__m2 = 1085102592571150095U; // precomputed2
 const u64 _const_math__bits__m3 = 71777214294589695U; // precomputed2
 const u64 _const_math__bits__m4 = 281470681808895U; // precomputed2
 const u32 _const_math__bits__max_u32 = 4294967295; // precomputed2
 const u64 _const_math__bits__max_u64 = 18446744073709551615U; // precomputed2
 const u8 _const_math__bits__n8 = 8; // precomputed2
 const u16 _const_math__bits__n16 = 16; // precomputed2
 const u32 _const_math__bits__n32 = 32; // precomputed2
 const u64 _const_math__bits__n64 = 64U; // precomputed2
 const u64 _const_math__bits__two32 = 4294967296U; // precomputed2
 const u64 _const_math__bits__mask32 = 4294967295U; // precomputed2
Array_fixed_u8_256 _const_math__bits__ntz_8_tab = {((u8)(0x08)), 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x07, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x04, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x00}; // fixed array const
Array_fixed_u8_256 _const_math__bits__pop_8_tab = {((u8)(0x00)), 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08}; // fixed array const
Array_fixed_u8_256 _const_math__bits__rev_8_tab = {((u8)(0x00)), 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff}; // fixed array const
Array_fixed_u8_256 _const_math__bits__len_8_tab = {((u8)(0x00)), 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08}; // fixed array const
 const u32 _const_strconv__single_plus_zero = 0; // precomputed2
 const u32 _const_strconv__single_minus_zero = 2147483648; // precomputed2
 const u32 _const_strconv__single_plus_infinity = 2139095040; // precomputed2
 const u32 _const_strconv__single_minus_infinity = 4286578688; // precomputed2
 const u64 _const_strconv__double_plus_zero = 0U; // precomputed2
 const u64 _const_strconv__double_minus_zero = 9223372036854775808U; // precomputed2
 const u64 _const_strconv__double_plus_infinity = 9218868437227405312U; // precomputed2
 const u64 _const_strconv__double_minus_infinity = 18442240474082181120U; // precomputed2
 const rune _const_strconv__c_dpoint = '.'; // precomputed2
 const rune _const_strconv__c_plus = '+'; // precomputed2
 const rune _const_strconv__c_minus = '-'; // precomputed2
 const rune _const_strconv__c_zero = '0'; // precomputed2
 const rune _const_strconv__c_nine = '9'; // precomputed2
 const u32 _const_strconv__c_ten = 10; // precomputed2
Array_fixed_u64_309 _const_strconv__pos_exp = {((u64)(0x3ff0000000000000U)), ((u64)(0x4024000000000000U)), ((u64)(0x4059000000000000U)), ((u64)(0x408f400000000000U)), ((u64)(0x40c3880000000000U)), ((u64)(0x40f86a0000000000U)), ((u64)(0x412e848000000000U)), ((u64)(0x416312d000000000U)), ((u64)(0x4197d78400000000U)), ((u64)(0x41cdcd6500000000U)), ((u64)(0x4202a05f20000000U)), ((u64)(0x42374876e8000000U)), ((u64)(0x426d1a94a2000000U)), ((u64)(0x42a2309ce5400000U)), ((u64)(0x42d6bcc41e900000U)), ((u64)(0x430c6bf526340000U)), ((u64)(0x4341c37937e08000U)), ((u64)(0x4376345785d8a000U)), ((u64)(0x43abc16d674ec800U)), ((u64)(0x43e158e460913d00U)), ((u64)(0x4415af1d78b58c40U)), ((u64)(0x444b1ae4d6e2ef50U)), ((u64)(0x4480f0cf064dd592U)), ((u64)(0x44b52d02c7e14af6U)), ((u64)(0x44ea784379d99db4U)), ((u64)(0x45208b2a2c280291U)), ((u64)(0x4554adf4b7320335U)), ((u64)(0x4589d971e4fe8402U)), ((u64)(0x45c027e72f1f1281U)), ((u64)(0x45f431e0fae6d721U)), ((u64)(0x46293e5939a08ceaU)), ((u64)(0x465f8def8808b024U)), ((u64)(0x4693b8b5b5056e17U)), ((u64)(0x46c8a6e32246c99cU)), ((u64)(0x46fed09bead87c03U)), ((u64)(0x4733426172c74d82U)), ((u64)(0x476812f9cf7920e3U)), ((u64)(0x479e17b84357691bU)), ((u64)(0x47d2ced32a16a1b1U)), ((u64)(0x48078287f49c4a1dU)), ((u64)(0x483d6329f1c35ca5U)), ((u64)(0x48725dfa371a19e7U)), ((u64)(0x48a6f578c4e0a061U)), ((u64)(0x48dcb2d6f618c879U)), ((u64)(0x4911efc659cf7d4cU)), ((u64)(0x49466bb7f0435c9eU)), ((u64)(0x497c06a5ec5433c6U)), ((u64)(0x49b18427b3b4a05cU)), ((u64)(0x49e5e531a0a1c873U)), ((u64)(0x4a1b5e7e08ca3a8fU)), ((u64)(0x4a511b0ec57e649aU)), ((u64)(0x4a8561d276ddfdc0U)), ((u64)(0x4ababa4714957d30U)), ((u64)(0x4af0b46c6cdd6e3eU)), ((u64)(0x4b24e1878814c9ceU)), ((u64)(0x4b5a19e96a19fc41U)), ((u64)(0x4b905031e2503da9U)), ((u64)(0x4bc4643e5ae44d13U)), ((u64)(0x4bf97d4df19d6057U)), ((u64)(0x4c2fdca16e04b86dU)), ((u64)(0x4c63e9e4e4c2f344U)), ((u64)(0x4c98e45e1df3b015U)), ((u64)(0x4ccf1d75a5709c1bU)), ((u64)(0x4d03726987666191U)), ((u64)(0x4d384f03e93ff9f5U)), ((u64)(0x4d6e62c4e38ff872U)), ((u64)(0x4da2fdbb0e39fb47U)), ((u64)(0x4dd7bd29d1c87a19U)), ((u64)(0x4e0dac74463a989fU)), ((u64)(0x4e428bc8abe49f64U)), ((u64)(0x4e772ebad6ddc73dU)), ((u64)(0x4eacfa698c95390cU)), ((u64)(0x4ee21c81f7dd43a7U)), ((u64)(0x4f16a3a275d49491U)), ((u64)(0x4f4c4c8b1349b9b5U)), ((u64)(0x4f81afd6ec0e1411U)), ((u64)(0x4fb61bcca7119916U)), ((u64)(0x4feba2bfd0d5ff5bU)), ((u64)(0x502145b7e285bf99U)), ((u64)(0x50559725db272f7fU)), ((u64)(0x508afcef51f0fb5fU)), ((u64)(0x50c0de1593369d1bU)), ((u64)(0x50f5159af8044462U)), ((u64)(0x512a5b01b605557bU)), ((u64)(0x516078e111c3556dU)), ((u64)(0x5194971956342ac8U)), ((u64)(0x51c9bcdfabc1357aU)), ((u64)(0x5200160bcb58c16cU)), ((u64)(0x52341b8ebe2ef1c7U)), ((u64)(0x526922726dbaae39U)), ((u64)(0x529f6b0f092959c7U)), ((u64)(0x52d3a2e965b9d81dU)), ((u64)(0x53088ba3bf284e24U)), ((u64)(0x533eae8caef261adU)), ((u64)(0x53732d17ed577d0cU)), ((u64)(0x53a7f85de8ad5c4fU)), ((u64)(0x53ddf67562d8b363U)), ((u64)(0x5412ba095dc7701eU)), ((u64)(0x5447688bb5394c25U)), ((u64)(0x547d42aea2879f2eU)), ((u64)(0x54b249ad2594c37dU)), ((u64)(0x54e6dc186ef9f45cU)), ((u64)(0x551c931e8ab87173U)), ((u64)(0x5551dbf316b346e8U)), ((u64)(0x558652efdc6018a2U)), ((u64)(0x55bbe7abd3781ecaU)), ((u64)(0x55f170cb642b133fU)), ((u64)(0x5625ccfe3d35d80eU)), ((u64)(0x565b403dcc834e12U)), ((u64)(0x569108269fd210cbU)), ((u64)(0x56c54a3047c694feU)), ((u64)(0x56fa9cbc59b83a3dU)), ((u64)(0x5730a1f5b8132466U)), ((u64)(0x5764ca732617ed80U)), ((u64)(0x5799fd0fef9de8e0U)), ((u64)(0x57d03e29f5c2b18cU)), ((u64)(0x58044db473335defU)), ((u64)(0x583961219000356bU)), ((u64)(0x586fb969f40042c5U)), ((u64)(0x58a3d3e2388029bbU)), ((u64)(0x58d8c8dac6a0342aU)), ((u64)(0x590efb1178484135U)), ((u64)(0x59435ceaeb2d28c1U)), ((u64)(0x59783425a5f872f1U)), ((u64)(0x59ae412f0f768fadU)), ((u64)(0x59e2e8bd69aa19ccU)), ((u64)(0x5a17a2ecc414a03fU)), ((u64)(0x5a4d8ba7f519c84fU)), ((u64)(0x5a827748f9301d32U)), ((u64)(0x5ab7151b377c247eU)), ((u64)(0x5aecda62055b2d9eU)), ((u64)(0x5b22087d4358fc82U)), ((u64)(0x5b568a9c942f3ba3U)), ((u64)(0x5b8c2d43b93b0a8cU)), ((u64)(0x5bc19c4a53c4e697U)), ((u64)(0x5bf6035ce8b6203dU)), ((u64)(0x5c2b843422e3a84dU)), ((u64)(0x5c6132a095ce4930U)), ((u64)(0x5c957f48bb41db7cU)), ((u64)(0x5ccadf1aea12525bU)), ((u64)(0x5d00cb70d24b7379U)), ((u64)(0x5d34fe4d06de5057U)), ((u64)(0x5d6a3de04895e46dU)), ((u64)(0x5da066ac2d5daec4U)), ((u64)(0x5dd4805738b51a75U)), ((u64)(0x5e09a06d06e26112U)), ((u64)(0x5e400444244d7cabU)), ((u64)(0x5e7405552d60dbd6U)), ((u64)(0x5ea906aa78b912ccU)), ((u64)(0x5edf485516e7577fU)), ((u64)(0x5f138d352e5096afU)), ((u64)(0x5f48708279e4bc5bU)), ((u64)(0x5f7e8ca3185deb72U)), ((u64)(0x5fb317e5ef3ab327U)), ((u64)(0x5fe7dddf6b095ff1U)), ((u64)(0x601dd55745cbb7edU)), ((u64)(0x6052a5568b9f52f4U)), ((u64)(0x60874eac2e8727b1U)), ((u64)(0x60bd22573a28f19dU)), ((u64)(0x60f2357684599702U)), ((u64)(0x6126c2d4256ffcc3U)), ((u64)(0x615c73892ecbfbf4U)), ((u64)(0x6191c835bd3f7d78U)), ((u64)(0x61c63a432c8f5cd6U)), ((u64)(0x61fbc8d3f7b3340cU)), ((u64)(0x62315d847ad00087U)), ((u64)(0x6265b4e5998400a9U)), ((u64)(0x629b221effe500d4U)), ((u64)(0x62d0f5535fef2084U)), ((u64)(0x630532a837eae8a5U)), ((u64)(0x633a7f5245e5a2cfU)), ((u64)(0x63708f936baf85c1U)), ((u64)(0x63a4b378469b6732U)), ((u64)(0x63d9e056584240feU)), ((u64)(0x64102c35f729689fU)), ((u64)(0x6444374374f3c2c6U)), ((u64)(0x647945145230b378U)), ((u64)(0x64af965966bce056U)), ((u64)(0x64e3bdf7e0360c36U)), ((u64)(0x6518ad75d8438f43U)), ((u64)(0x654ed8d34e547314U)), ((u64)(0x6583478410f4c7ecU)), ((u64)(0x65b819651531f9e8U)), ((u64)(0x65ee1fbe5a7e7861U)), ((u64)(0x6622d3d6f88f0b3dU)), ((u64)(0x665788ccb6b2ce0cU)), ((u64)(0x668d6affe45f818fU)), ((u64)(0x66c262dfeebbb0f9U)), ((u64)(0x66f6fb97ea6a9d38U)), ((u64)(0x672cba7de5054486U)), ((u64)(0x6761f48eaf234ad4U)), ((u64)(0x679671b25aec1d89U)), ((u64)(0x67cc0e1ef1a724ebU)), ((u64)(0x680188d357087713U)), ((u64)(0x6835eb082cca94d7U)), ((u64)(0x686b65ca37fd3a0dU)), ((u64)(0x68a11f9e62fe4448U)), ((u64)(0x68d56785fbbdd55aU)), ((u64)(0x690ac1677aad4ab1U)), ((u64)(0x6940b8e0acac4eafU)), ((u64)(0x6974e718d7d7625aU)), ((u64)(0x69aa20df0dcd3af1U)), ((u64)(0x69e0548b68a044d6U)), ((u64)(0x6a1469ae42c8560cU)), ((u64)(0x6a498419d37a6b8fU)), ((u64)(0x6a7fe52048590673U)), ((u64)(0x6ab3ef342d37a408U)), ((u64)(0x6ae8eb0138858d0aU)), ((u64)(0x6b1f25c186a6f04cU)), ((u64)(0x6b537798f4285630U)), ((u64)(0x6b88557f31326bbbU)), ((u64)(0x6bbe6adefd7f06aaU)), ((u64)(0x6bf302cb5e6f642aU)), ((u64)(0x6c27c37e360b3d35U)), ((u64)(0x6c5db45dc38e0c82U)), ((u64)(0x6c9290ba9a38c7d1U)), ((u64)(0x6cc734e940c6f9c6U)), ((u64)(0x6cfd022390f8b837U)), ((u64)(0x6d3221563a9b7323U)), ((u64)(0x6d66a9abc9424febU)), ((u64)(0x6d9c5416bb92e3e6U)), ((u64)(0x6dd1b48e353bce70U)), ((u64)(0x6e0621b1c28ac20cU)), ((u64)(0x6e3baa1e332d728fU)), ((u64)(0x6e714a52dffc6799U)), ((u64)(0x6ea59ce797fb817fU)), ((u64)(0x6edb04217dfa61dfU)), ((u64)(0x6f10e294eebc7d2cU)), ((u64)(0x6f451b3a2a6b9c76U)), ((u64)(0x6f7a6208b5068394U)), ((u64)(0x6fb07d457124123dU)), ((u64)(0x6fe49c96cd6d16ccU)), ((u64)(0x7019c3bc80c85c7fU)), ((u64)(0x70501a55d07d39cfU)), ((u64)(0x708420eb449c8843U)), ((u64)(0x70b9292615c3aa54U)), ((u64)(0x70ef736f9b3494e9U)), ((u64)(0x7123a825c100dd11U)), ((u64)(0x7158922f31411456U)), ((u64)(0x718eb6bafd91596bU)), ((u64)(0x71c33234de7ad7e3U)), ((u64)(0x71f7fec216198ddcU)), ((u64)(0x722dfe729b9ff153U)), ((u64)(0x7262bf07a143f6d4U)), ((u64)(0x72976ec98994f489U)), ((u64)(0x72cd4a7bebfa31abU)), ((u64)(0x73024e8d737c5f0bU)), ((u64)(0x7336e230d05b76cdU)), ((u64)(0x736c9abd04725481U)), ((u64)(0x73a1e0b622c774d0U)), ((u64)(0x73d658e3ab795204U)), ((u64)(0x740bef1c9657a686U)), ((u64)(0x74417571ddf6c814U)), ((u64)(0x7475d2ce55747a18U)), ((u64)(0x74ab4781ead1989eU)), ((u64)(0x74e10cb132c2ff63U)), ((u64)(0x75154fdd7f73bf3cU)), ((u64)(0x754aa3d4df50af0bU)), ((u64)(0x7580a6650b926d67U)), ((u64)(0x75b4cffe4e7708c0U)), ((u64)(0x75ea03fde214caf1U)), ((u64)(0x7620427ead4cfed6U)), ((u64)(0x7654531e58a03e8cU)), ((u64)(0x768967e5eec84e2fU)), ((u64)(0x76bfc1df6a7a61bbU)), ((u64)(0x76f3d92ba28c7d15U)), ((u64)(0x7728cf768b2f9c5aU)), ((u64)(0x775f03542dfb8370U)), ((u64)(0x779362149cbd3226U)), ((u64)(0x77c83a99c3ec7eb0U)), ((u64)(0x77fe494034e79e5cU)), ((u64)(0x7832edc82110c2f9U)), ((u64)(0x7867a93a2954f3b8U)), ((u64)(0x789d9388b3aa30a5U)), ((u64)(0x78d27c35704a5e67U)), ((u64)(0x79071b42cc5cf601U)), ((u64)(0x793ce2137f743382U)), ((u64)(0x79720d4c2fa8a031U)), ((u64)(0x79a6909f3b92c83dU)), ((u64)(0x79dc34c70a777a4dU)), ((u64)(0x7a11a0fc668aac70U)), ((u64)(0x7a46093b802d578cU)), ((u64)(0x7a7b8b8a6038ad6fU)), ((u64)(0x7ab137367c236c65U)), ((u64)(0x7ae585041b2c477fU)), ((u64)(0x7b1ae64521f7595eU)), ((u64)(0x7b50cfeb353a97dbU)), ((u64)(0x7b8503e602893dd2U)), ((u64)(0x7bba44df832b8d46U)), ((u64)(0x7bf06b0bb1fb384cU)), ((u64)(0x7c2485ce9e7a065fU)), ((u64)(0x7c59a742461887f6U)), ((u64)(0x7c9008896bcf54faU)), ((u64)(0x7cc40aabc6c32a38U)), ((u64)(0x7cf90d56b873f4c7U)), ((u64)(0x7d2f50ac6690f1f8U)), ((u64)(0x7d63926bc01a973bU)), ((u64)(0x7d987706b0213d0aU)), ((u64)(0x7dce94c85c298c4cU)), ((u64)(0x7e031cfd3999f7b0U)), ((u64)(0x7e37e43c8800759cU)), ((u64)(0x7e6ddd4baa009303U)), ((u64)(0x7ea2aa4f4a405be2U)), ((u64)(0x7ed754e31cd072daU)), ((u64)(0x7f0d2a1be4048f90U)), ((u64)(0x7f423a516e82d9baU)), ((u64)(0x7f76c8e5ca239029U)), ((u64)(0x7fac7b1f3cac7433U)), ((u64)(0x7fe1ccf385ebc8a0U))}; // fixed array const
Array_fixed_u64_324 _const_strconv__neg_exp = {((u64)(0x3ff0000000000000U)), ((u64)(0x3fb999999999999aU)), ((u64)(0x3f847ae147ae147bU)), ((u64)(0x3f50624dd2f1a9fcU)), ((u64)(0x3f1a36e2eb1c432dU)), ((u64)(0x3ee4f8b588e368f1U)), ((u64)(0x3eb0c6f7a0b5ed8dU)), ((u64)(0x3e7ad7f29abcaf48U)), ((u64)(0x3e45798ee2308c3aU)), ((u64)(0x3e112e0be826d695U)), ((u64)(0x3ddb7cdfd9d7bdbbU)), ((u64)(0x3da5fd7fe1796495U)), ((u64)(0x3d719799812dea11U)), ((u64)(0x3d3c25c268497682U)), ((u64)(0x3d06849b86a12b9bU)), ((u64)(0x3cd203af9ee75616U)), ((u64)(0x3c9cd2b297d889bcU)), ((u64)(0x3c670ef54646d497U)), ((u64)(0x3c32725dd1d243acU)), ((u64)(0x3bfd83c94fb6d2acU)), ((u64)(0x3bc79ca10c924223U)), ((u64)(0x3b92e3b40a0e9b4fU)), ((u64)(0x3b5e392010175ee6U)), ((u64)(0x3b282db34012b251U)), ((u64)(0x3af357c299a88ea7U)), ((u64)(0x3abef2d0f5da7dd9U)), ((u64)(0x3a88c240c4aecb14U)), ((u64)(0x3a53ce9a36f23c10U)), ((u64)(0x3a1fb0f6be506019U)), ((u64)(0x39e95a5efea6b347U)), ((u64)(0x39b4484bfeebc2a0U)), ((u64)(0x398039d665896880U)), ((u64)(0x3949f623d5a8a733U)), ((u64)(0x3914c4e977ba1f5cU)), ((u64)(0x38e09d8792fb4c49U)), ((u64)(0x38aa95a5b7f87a0fU)), ((u64)(0x38754484932d2e72U)), ((u64)(0x3841039d428a8b8fU)), ((u64)(0x380b38fb9daa78e4U)), ((u64)(0x37d5c72fb1552d83U)), ((u64)(0x37a16c262777579cU)), ((u64)(0x376be03d0bf225c7U)), ((u64)(0x37364cfda3281e39U)), ((u64)(0x3701d7314f534b61U)), ((u64)(0x36cc8b8218854567U)), ((u64)(0x3696d601ad376ab9U)), ((u64)(0x366244ce242c5561U)), ((u64)(0x362d3ae36d13bbceU)), ((u64)(0x35f7624f8a762fd8U)), ((u64)(0x35c2b50c6ec4f313U)), ((u64)(0x358dee7a4ad4b81fU)), ((u64)(0x3557f1fb6f10934cU)), ((u64)(0x352327fc58da0f70U)), ((u64)(0x34eea6608e29b24dU)), ((u64)(0x34b8851a0b548ea4U)), ((u64)(0x34839dae6f76d883U)), ((u64)(0x344f62b0b257c0d2U)), ((u64)(0x34191bc08eac9a41U)), ((u64)(0x33e41633a556e1ceU)), ((u64)(0x33b011c2eaabe7d8U)), ((u64)(0x3379b604aaaca626U)), ((u64)(0x3344919d5556eb52U)), ((u64)(0x3310747ddddf22a8U)), ((u64)(0x32da53fc9631d10dU)), ((u64)(0x32a50ffd44f4a73dU)), ((u64)(0x3270d9976a5d5297U)), ((u64)(0x323af5bf109550f2U)), ((u64)(0x32059165a6ddda5bU)), ((u64)(0x31d1411e1f17e1e3U)), ((u64)(0x319b9b6364f30304U)), ((u64)(0x316615e91d8f359dU)), ((u64)(0x3131ab20e472914aU)), ((u64)(0x30fc45016d841baaU)), ((u64)(0x30c69d9abe034955U)), ((u64)(0x309217aefe690777U)), ((u64)(0x305cf2b1970e7258U)), ((u64)(0x3027288e1271f513U)), ((u64)(0x2ff286d80ec190dcU)), ((u64)(0x2fbda48ce468e7c7U)), ((u64)(0x2f87b6d71d20b96cU)), ((u64)(0x2f52f8ac174d6123U)), ((u64)(0x2f1e5aacf2156838U)), ((u64)(0x2ee8488a5b445360U)), ((u64)(0x2eb36d3b7c36a91aU)), ((u64)(0x2e7f152bf9f10e90U)), ((u64)(0x2e48ddbcc7f40ba6U)), ((u64)(0x2e13e497065cd61fU)), ((u64)(0x2ddfd424d6faf031U)), ((u64)(0x2da97683df2f268dU)), ((u64)(0x2d745ecfe5bf520bU)), ((u64)(0x2d404bd984990e6fU)), ((u64)(0x2d0a12f5a0f4e3e5U)), ((u64)(0x2cd4dbf7b3f71cb7U)), ((u64)(0x2ca0aff95cc5b092U)), ((u64)(0x2c6ab328946f80eaU)), ((u64)(0x2c355c2076bf9a55U)), ((u64)(0x2c0116805effaeaaU)), ((u64)(0x2bcb5733cb32b111U)), ((u64)(0x2b95df5ca28ef40dU)), ((u64)(0x2b617f7d4ed8c33eU)), ((u64)(0x2b2bff2ee48e0530U)), ((u64)(0x2af665bf1d3e6a8dU)), ((u64)(0x2ac1eaff4a98553dU)), ((u64)(0x2a8cab3210f3bb95U)), ((u64)(0x2a56ef5b40c2fc77U)), ((u64)(0x2a225915cd68c9f9U)), ((u64)(0x29ed5b561574765bU)), ((u64)(0x29b77c44ddf6c516U)), ((u64)(0x2982c9d0b1923745U)), ((u64)(0x294e0fb44f50586eU)), ((u64)(0x29180c903f7379f2U)), ((u64)(0x28e33d4032c2c7f5U)), ((u64)(0x28aec866b79e0cbaU)), ((u64)(0x2878a0522c7e7095U)), ((u64)(0x2843b374f06526deU)), ((u64)(0x280f8587e7083e30U)), ((u64)(0x27d9379fec069826U)), ((u64)(0x27a42c7ff0054685U)), ((u64)(0x277023998cd10537U)), ((u64)(0x2739d28f47b4d525U)), ((u64)(0x2704a8729fc3ddb7U)), ((u64)(0x26d086c219697e2cU)), ((u64)(0x269a71368f0f3047U)), ((u64)(0x2665275ed8d8f36cU)), ((u64)(0x2630ec4be0ad8f89U)), ((u64)(0x25fb13ac9aaf4c0fU)), ((u64)(0x25c5a956e225d672U)), ((u64)(0x2591544581b7dec2U)), ((u64)(0x255bba08cf8c979dU)), ((u64)(0x25262e6d72d6dfb0U)), ((u64)(0x24f1bebdf578b2f4U)), ((u64)(0x24bc6463225ab7ecU)), ((u64)(0x2486b6b5b5155ff0U)), ((u64)(0x24522bc490dde65aU)), ((u64)(0x241d12d41afca3c3U)), ((u64)(0x23e7424348ca1c9cU)), ((u64)(0x23b29b69070816e3U)), ((u64)(0x237dc574d80cf16bU)), ((u64)(0x2347d12a4670c123U)), ((u64)(0x23130dbb6b8d674fU)), ((u64)(0x22de7c5f127bd87eU)), ((u64)(0x22a8637f41fcad32U)), ((u64)(0x227382cc34ca2428U)), ((u64)(0x223f37ad21436d0cU)), ((u64)(0x2208f9574dcf8a70U)), ((u64)(0x21d3faac3e3fa1f3U)), ((u64)(0x219ff779fd329cb9U)), ((u64)(0x216992c7fdc216faU)), ((u64)(0x2134756ccb01abfbU)), ((u64)(0x21005df0a267bcc9U)), ((u64)(0x20ca2fe76a3f9475U)), ((u64)(0x2094f31f8832dd2aU)), ((u64)(0x2060c27fa028b0efU)), ((u64)(0x202ad0cc33744e4bU)), ((u64)(0x1ff573d68f903ea2U)), ((u64)(0x1fc1297872d9cbb5U)), ((u64)(0x1f8b758d848fac55U)), ((u64)(0x1f55f7a46a0c89ddU)), ((u64)(0x1f2192e9ee706e4bU)), ((u64)(0x1eec1e43171a4a11U)), ((u64)(0x1eb67e9c127b6e74U)), ((u64)(0x1e81fee341fc585dU)), ((u64)(0x1e4ccb0536608d61U)), ((u64)(0x1e1708d0f84d3de7U)), ((u64)(0x1de26d73f9d764b9U)), ((u64)(0x1dad7becc2f23ac2U)), ((u64)(0x1d779657025b6235U)), ((u64)(0x1d42deac01e2b4f7U)), ((u64)(0x1d0e3113363787f2U)), ((u64)(0x1cd8274291c6065bU)), ((u64)(0x1ca3529ba7d19eafU)), ((u64)(0x1c6eea92a61c3118U)), ((u64)(0x1c38bba884e35a7aU)), ((u64)(0x1c03c9539d82aec8U)), ((u64)(0x1bcfa885c8d117a6U)), ((u64)(0x1b99539e3a40dfb8U)), ((u64)(0x1b6442e4fb671960U)), ((u64)(0x1b303583fc527ab3U)), ((u64)(0x1af9ef3993b72ab8U)), ((u64)(0x1ac4bf6142f8eefaU)), ((u64)(0x1a90991a9bfa58c8U)), ((u64)(0x1a5a8e90f9908e0dU)), ((u64)(0x1a253eda614071a4U)), ((u64)(0x19f0ff151a99f483U)), ((u64)(0x19bb31bb5dc320d2U)), ((u64)(0x1985c162b168e70eU)), ((u64)(0x1951678227871f3eU)), ((u64)(0x191bd8d03f3e9864U)), ((u64)(0x18e6470cff6546b6U)), ((u64)(0x18b1d270cc51055fU)), ((u64)(0x187c83e7ad4e6efeU)), ((u64)(0x1846cfec8aa52598U)), ((u64)(0x18123ff06eea847aU)), ((u64)(0x17dd331a4b10d3f6U)), ((u64)(0x17a75c1508da432bU)), ((u64)(0x1772b010d3e1cf56U)), ((u64)(0x173de6815302e556U)), ((u64)(0x1707eb9aa8cf1ddeU)), ((u64)(0x16d322e220a5b17eU)), ((u64)(0x169e9e369aa2b597U)), ((u64)(0x16687e92154ef7acU)), ((u64)(0x16339874ddd8c623U)), ((u64)(0x15ff5a549627a36cU)), ((u64)(0x15c91510781fb5f0U)), ((u64)(0x159410d9f9b2f7f3U)), ((u64)(0x15600d7b2e28c65cU)), ((u64)(0x1529af2b7d0e0a2dU)), ((u64)(0x14f48c22ca71a1bdU)), ((u64)(0x14c0701bd527b498U)), ((u64)(0x148a4cf9550c5426U)), ((u64)(0x14550a6110d6a9b8U)), ((u64)(0x1420d51a73deee2dU)), ((u64)(0x13eaee90b964b047U)), ((u64)(0x13b58ba6fab6f36cU)), ((u64)(0x13813c85955f2923U)), ((u64)(0x134b9408eefea839U)), ((u64)(0x1316100725988694U)), ((u64)(0x12e1a66c1e139eddU)), ((u64)(0x12ac3d79c9b8fe2eU)), ((u64)(0x12769794a160cb58U)), ((u64)(0x124212dd4de70913U)), ((u64)(0x120ceafbafd80e85U)), ((u64)(0x11d72262f3133ed1U)), ((u64)(0x11a281e8c275cbdaU)), ((u64)(0x116d9ca79d89462aU)), ((u64)(0x1137b08617a104eeU)), ((u64)(0x1102f39e794d9d8bU)), ((u64)(0x10ce5297287c2f45U)), ((u64)(0x1098421286c9bf6bU)), ((u64)(0x1063680ed23aff89U)), ((u64)(0x102f0ce4839198dbU)), ((u64)(0x0ff8d71d360e13e2U)), ((u64)(0x0fc3df4a91a4dcb5U)), ((u64)(0x0f8fcbaa82a16121U)), ((u64)(0x0f596fbb9bb44db4U)), ((u64)(0x0f245962e2f6a490U)), ((u64)(0x0ef047824f2bb6daU)), ((u64)(0x0eba0c03b1df8af6U)), ((u64)(0x0e84d6695b193bf8U)), ((u64)(0x0e50ab877c142ffaU)), ((u64)(0x0e1aac0bf9b9e65cU)), ((u64)(0x0de5566ffafb1eb0U)), ((u64)(0x0db111f32f2f4bc0U)), ((u64)(0x0d7b4feb7eb212cdU)), ((u64)(0x0d45d98932280f0aU)), ((u64)(0x0d117ad428200c08U)), ((u64)(0x0cdbf7b9d9cce00dU)), ((u64)(0x0ca65fc7e170b33eU)), ((u64)(0x0c71e6398126f5cbU)), ((u64)(0x0c3ca38f350b22dfU)), ((u64)(0x0c06e93f5da2824cU)), ((u64)(0x0bd25432b14ecea3U)), ((u64)(0x0b9d53844ee47dd1U)), ((u64)(0x0b677603725064a8U)), ((u64)(0x0b32c4cf8ea6b6ecU)), ((u64)(0x0afe07b27dd78b14U)), ((u64)(0x0ac8062864ac6f43U)), ((u64)(0x0a9338205089f29cU)), ((u64)(0x0a5ec033b40fea93U)), ((u64)(0x0a2899c2f6732210U)), ((u64)(0x09f3ae3591f5b4d9U)), ((u64)(0x09bf7d228322baf5U)), ((u64)(0x098930e868e89591U)), ((u64)(0x0954272053ed4474U)), ((u64)(0x09201f4d0ff10390U)), ((u64)(0x08e9cbae7fe805b3U)), ((u64)(0x08b4a2f1ffecd15cU)), ((u64)(0x0880825b3323dab0U)), ((u64)(0x084a6a2b85062ab3U)), ((u64)(0x081521bc6a6b555cU)), ((u64)(0x07e0e7c9eebc444aU)), ((u64)(0x07ab0c764ac6d3a9U)), ((u64)(0x0775a391d56bdc87U)), ((u64)(0x07414fa7ddefe3a0U)), ((u64)(0x070bb2a62fe638ffU)), ((u64)(0x06d62884f31e93ffU)), ((u64)(0x06a1ba03f5b21000U)), ((u64)(0x066c5cd322b67fffU)), ((u64)(0x0636b0a8e891ffffU)), ((u64)(0x060226ed86db3333U)), ((u64)(0x05cd0b15a491eb84U)), ((u64)(0x05973c115074bc6aU)), ((u64)(0x05629674405d6388U)), ((u64)(0x052dbd86cd6238d9U)), ((u64)(0x04f7cad23de82d7bU)), ((u64)(0x04c308a831868ac9U)), ((u64)(0x048e74404f3daadbU)), ((u64)(0x04585d003f6488afU)), ((u64)(0x04237d99cc506d59U)), ((u64)(0x03ef2f5c7a1a488eU)), ((u64)(0x03b8f2b061aea072U)), ((u64)(0x0383f559e7bee6c1U)), ((u64)(0x034feef63f97d79cU)), ((u64)(0x03198bf832dfdfb0U)), ((u64)(0x02e46ff9c24cb2f3U)), ((u64)(0x02b059949b708f29U)), ((u64)(0x027a28edc580e50eU)), ((u64)(0x0244ed8b04671da5U)), ((u64)(0x0210be08d0527e1dU)), ((u64)(0x01dac9a7b3b7302fU)), ((u64)(0x01a56e1fc2f8f359U)), ((u64)(0x017124e63593f5e1U)), ((u64)(0x013b6e3d22865634U)), ((u64)(0x0105f1ca820511c3U)), ((u64)(0x00d18e3b9b374169U)), ((u64)(0x009c16c5c5253575U)), ((u64)(0x0066789e3750f791U)), ((u64)(0x0031fa182c40c60dU)), ((u64)(0x000730d67819e8d2U)), ((u64)(0x0000b8157268fdafU)), ((u64)(0x000012688b70e62bU)), ((u64)(0x000001d74124e3d1U)), ((u64)(0x0000002f201d49fbU)), ((u64)(0x00000004b6695433U)), ((u64)(0x0000000078a42205U)), ((u64)(0x000000000c1069cdU)), ((u64)(0x000000000134d761U)), ((u64)(0x00000000001ee257U)), ((u64)(0x00000000000316a2U)), ((u64)(0x0000000000004f10U)), ((u64)(0x00000000000007e8U)), ((u64)(0x00000000000000caU)), ((u64)(0x0000000000000014U)), ((u64)(0x0000000000000002U))}; // fixed array const
 const u64 _const_strconv__max_u64 = 18446744073709551615U; // precomputed2
Array_fixed_u32_12 _const_strconv__ten_pow_table_32 = {((u32)(1U)), ((u32)(10U)), ((u32)(100U)), ((u32)(1000U)), ((u32)(10000U)), ((u32)(100000U)), ((u32)(1000000U)), ((u32)(10000000U)), ((u32)(100000000U)), ((u32)(1000000000U)), ((u32)(10000000000U)), ((u32)(100000000000U))}; // fixed array const
 const u32 _const_strconv__mantbits32 = 23; // precomputed2
 const u32 _const_strconv__expbits32 = 8; // precomputed2
Array_fixed_u64_20 _const_strconv__ten_pow_table_64 = {((u64)(1U)), ((u64)(10U)), ((u64)(100U)), ((u64)(1000U)), ((u64)(10000U)), ((u64)(100000U)), ((u64)(1000000U)), ((u64)(10000000U)), ((u64)(100000000U)), ((u64)(1000000000U)), ((u64)(10000000000U)), ((u64)(100000000000U)), ((u64)(1000000000000U)), ((u64)(10000000000000U)), ((u64)(100000000000000U)), ((u64)(1000000000000000U)), ((u64)(10000000000000000U)), ((u64)(100000000000000000U)), ((u64)(1000000000000000000U)), ((u64)(10000000000000000000U))}; // fixed array const
 const u32 _const_strconv__mantbits64 = 52; // precomputed2
 const u32 _const_strconv__expbits64 = 11; // precomputed2
Array_fixed_f64_20 _const_strconv__dec_round = {((f64)(0.5)), 0.05, 0.005, 0.0005, 0.00005, 0.000005, 0.0000005, 0.00000005, 0.000000005, 0.0000000005, 0.00000000005, 0.000000000005, 0.0000000000005, 0.00000000000005, 0.000000000000005, 0.0000000000000005, 0.00000000000000005, 0.000000000000000005, 0.0000000000000000005, 0.00000000000000000005}; // fixed array const
Array_fixed_u64_18 _const_strconv__powers_of_10 = {((u64)(1e0)), ((u64)(1e1)), ((u64)(1e2)), ((u64)(1e3)), ((u64)(1e4)), ((u64)(1e5)), ((u64)(1e6)), ((u64)(1e7)), ((u64)(1e8)), ((u64)(1e9)), ((u64)(1e10)), ((u64)(1e11)), ((u64)(1e12)), ((u64)(1e13)), ((u64)(1e14)), ((u64)(1e15)), ((u64)(1e16)), ((u64)(1e17))}; // fixed array const
Array_fixed_u64_47 _const_strconv__pow5_split_32 = {((u64)(1152921504606846976U)), ((u64)(1441151880758558720U)), ((u64)(1801439850948198400U)), ((u64)(2251799813685248000U)), ((u64)(1407374883553280000U)), ((u64)(1759218604441600000U)), ((u64)(2199023255552000000U)), ((u64)(1374389534720000000U)), ((u64)(1717986918400000000U)), ((u64)(2147483648000000000U)), ((u64)(1342177280000000000U)), ((u64)(1677721600000000000U)), ((u64)(2097152000000000000U)), ((u64)(1310720000000000000U)), ((u64)(1638400000000000000U)), ((u64)(2048000000000000000U)), ((u64)(1280000000000000000U)), ((u64)(1600000000000000000U)), ((u64)(2000000000000000000U)), ((u64)(1250000000000000000U)), ((u64)(1562500000000000000U)), ((u64)(1953125000000000000U)), ((u64)(1220703125000000000U)), ((u64)(1525878906250000000U)), ((u64)(1907348632812500000U)), ((u64)(1192092895507812500U)), ((u64)(1490116119384765625U)), ((u64)(1862645149230957031U)), ((u64)(1164153218269348144U)), ((u64)(1455191522836685180U)), ((u64)(1818989403545856475U)), ((u64)(2273736754432320594U)), ((u64)(1421085471520200371U)), ((u64)(1776356839400250464U)), ((u64)(2220446049250313080U)), ((u64)(1387778780781445675U)), ((u64)(1734723475976807094U)), ((u64)(2168404344971008868U)), ((u64)(1355252715606880542U)), ((u64)(1694065894508600678U)), ((u64)(2117582368135750847U)), ((u64)(1323488980084844279U)), ((u64)(1654361225106055349U)), ((u64)(2067951531382569187U)), ((u64)(1292469707114105741U)), ((u64)(1615587133892632177U)), ((u64)(2019483917365790221U))}; // fixed array const
Array_fixed_u64_31 _const_strconv__pow5_inv_split_32 = {((u64)(576460752303423489U)), ((u64)(461168601842738791U)), ((u64)(368934881474191033U)), ((u64)(295147905179352826U)), ((u64)(472236648286964522U)), ((u64)(377789318629571618U)), ((u64)(302231454903657294U)), ((u64)(483570327845851670U)), ((u64)(386856262276681336U)), ((u64)(309485009821345069U)), ((u64)(495176015714152110U)), ((u64)(396140812571321688U)), ((u64)(316912650057057351U)), ((u64)(507060240091291761U)), ((u64)(405648192073033409U)), ((u64)(324518553658426727U)), ((u64)(519229685853482763U)), ((u64)(415383748682786211U)), ((u64)(332306998946228969U)), ((u64)(531691198313966350U)), ((u64)(425352958651173080U)), ((u64)(340282366920938464U)), ((u64)(544451787073501542U)), ((u64)(435561429658801234U)), ((u64)(348449143727040987U)), ((u64)(557518629963265579U)), ((u64)(446014903970612463U)), ((u64)(356811923176489971U)), ((u64)(570899077082383953U)), ((u64)(456719261665907162U)), ((u64)(365375409332725730U))}; // fixed array const
Array_fixed_u64_652 _const_strconv__pow5_split_64_x = {((u64)(0x0000000000000000U)), ((u64)(0x0100000000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0140000000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0190000000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01f4000000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0138800000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0186a00000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01e8480000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01312d0000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x017d784000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01dcd65000000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x012a05f200000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x0174876e80000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01d1a94a20000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x012309ce54000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x016bcc41e9000000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01c6bf5263400000U)), ((u64)(0x0000000000000000U)), ((u64)(0x011c37937e080000U)), ((u64)(0x0000000000000000U)), ((u64)(0x016345785d8a0000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01bc16d674ec8000U)), ((u64)(0x0000000000000000U)), ((u64)(0x01158e460913d000U)), ((u64)(0x0000000000000000U)), ((u64)(0x015af1d78b58c400U)), ((u64)(0x0000000000000000U)), ((u64)(0x01b1ae4d6e2ef500U)), ((u64)(0x0000000000000000U)), ((u64)(0x010f0cf064dd5920U)), ((u64)(0x0000000000000000U)), ((u64)(0x0152d02c7e14af68U)), ((u64)(0x0000000000000000U)), ((u64)(0x01a784379d99db42U)), ((u64)(0x4000000000000000U)), ((u64)(0x0108b2a2c2802909U)), ((u64)(0x9000000000000000U)), ((u64)(0x014adf4b7320334bU)), ((u64)(0x7400000000000000U)), ((u64)(0x019d971e4fe8401eU)), ((u64)(0x0880000000000000U)), ((u64)(0x01027e72f1f12813U)), ((u64)(0xcaa0000000000000U)), ((u64)(0x01431e0fae6d7217U)), ((u64)(0xbd48000000000000U)), ((u64)(0x0193e5939a08ce9dU)), ((u64)(0x2c9a000000000000U)), ((u64)(0x01f8def8808b0245U)), ((u64)(0x3be0400000000000U)), ((u64)(0x013b8b5b5056e16bU)), ((u64)(0x0ad8500000000000U)), ((u64)(0x018a6e32246c99c6U)), ((u64)(0x8d8e640000000000U)), ((u64)(0x01ed09bead87c037U)), ((u64)(0xb878fe8000000000U)), ((u64)(0x013426172c74d822U)), ((u64)(0x66973e2000000000U)), ((u64)(0x01812f9cf7920e2bU)), ((u64)(0x403d0da800000000U)), ((u64)(0x01e17b84357691b6U)), ((u64)(0xe826288900000000U)), ((u64)(0x012ced32a16a1b11U)), ((u64)(0x622fb2ab40000000U)), ((u64)(0x0178287f49c4a1d6U)), ((u64)(0xfabb9f5610000000U)), ((u64)(0x01d6329f1c35ca4bU)), ((u64)(0x7cb54395ca000000U)), ((u64)(0x0125dfa371a19e6fU)), ((u64)(0x5be2947b3c800000U)), ((u64)(0x016f578c4e0a060bU)), ((u64)(0x32db399a0ba00000U)), ((u64)(0x01cb2d6f618c878eU)), ((u64)(0xdfc9040047440000U)), ((u64)(0x011efc659cf7d4b8U)), ((u64)(0x17bb450059150000U)), ((u64)(0x0166bb7f0435c9e7U)), ((u64)(0xddaa16406f5a4000U)), ((u64)(0x01c06a5ec5433c60U)), ((u64)(0x8a8a4de845986800U)), ((u64)(0x0118427b3b4a05bcU)), ((u64)(0xad2ce16256fe8200U)), ((u64)(0x015e531a0a1c872bU)), ((u64)(0x987819baecbe2280U)), ((u64)(0x01b5e7e08ca3a8f6U)), ((u64)(0x1f4b1014d3f6d590U)), ((u64)(0x0111b0ec57e6499aU)), ((u64)(0xa71dd41a08f48af4U)), ((u64)(0x01561d276ddfdc00U)), ((u64)(0xd0e549208b31adb1U)), ((u64)(0x01aba4714957d300U)), ((u64)(0x828f4db456ff0c8eU)), ((u64)(0x010b46c6cdd6e3e0U)), ((u64)(0xa33321216cbecfb2U)), ((u64)(0x014e1878814c9cd8U)), ((u64)(0xcbffe969c7ee839eU)), ((u64)(0x01a19e96a19fc40eU)), ((u64)(0x3f7ff1e21cf51243U)), ((u64)(0x0105031e2503da89U)), ((u64)(0x8f5fee5aa43256d4U)), ((u64)(0x014643e5ae44d12bU)), ((u64)(0x7337e9f14d3eec89U)), ((u64)(0x0197d4df19d60576U)), ((u64)(0x1005e46da08ea7abU)), ((u64)(0x01fdca16e04b86d4U)), ((u64)(0x8a03aec4845928cbU)), ((u64)(0x013e9e4e4c2f3444U)), ((u64)(0xac849a75a56f72fdU)), ((u64)(0x018e45e1df3b0155U)), ((u64)(0x17a5c1130ecb4fbdU)), ((u64)(0x01f1d75a5709c1abU)), ((u64)(0xeec798abe93f11d6U)), ((u64)(0x013726987666190aU)), ((u64)(0xaa797ed6e38ed64bU)), ((u64)(0x0184f03e93ff9f4dU)), ((u64)(0x1517de8c9c728bdeU)), ((u64)(0x01e62c4e38ff8721U)), ((u64)(0xad2eeb17e1c7976bU)), ((u64)(0x012fdbb0e39fb474U)), ((u64)(0xd87aa5ddda397d46U)), ((u64)(0x017bd29d1c87a191U)), ((u64)(0x4e994f5550c7dc97U)), ((u64)(0x01dac74463a989f6U)), ((u64)(0xf11fd195527ce9deU)), ((u64)(0x0128bc8abe49f639U)), ((u64)(0x6d67c5faa71c2456U)), ((u64)(0x0172ebad6ddc73c8U)), ((u64)(0x88c1b77950e32d6cU)), ((u64)(0x01cfa698c95390baU)), ((u64)(0x957912abd28dfc63U)), ((u64)(0x0121c81f7dd43a74U)), ((u64)(0xbad75756c7317b7cU)), ((u64)(0x016a3a275d494911U)), ((u64)(0x298d2d2c78fdda5bU)), ((u64)(0x01c4c8b1349b9b56U)), ((u64)(0xd9f83c3bcb9ea879U)), ((u64)(0x011afd6ec0e14115U)), ((u64)(0x50764b4abe865297U)), ((u64)(0x0161bcca7119915bU)), ((u64)(0x2493de1d6e27e73dU)), ((u64)(0x01ba2bfd0d5ff5b2U)), ((u64)(0x56dc6ad264d8f086U)), ((u64)(0x01145b7e285bf98fU)), ((u64)(0x2c938586fe0f2ca8U)), ((u64)(0x0159725db272f7f3U)), ((u64)(0xf7b866e8bd92f7d2U)), ((u64)(0x01afcef51f0fb5efU)), ((u64)(0xfad34051767bdae3U)), ((u64)(0x010de1593369d1b5U)), ((u64)(0x79881065d41ad19cU)), ((u64)(0x015159af80444623U)), ((u64)(0x57ea147f49218603U)), ((u64)(0x01a5b01b605557acU)), ((u64)(0xb6f24ccf8db4f3c1U)), ((u64)(0x01078e111c3556cbU)), ((u64)(0xa4aee003712230b2U)), ((u64)(0x014971956342ac7eU)), ((u64)(0x4dda98044d6abcdfU)), ((u64)(0x019bcdfabc13579eU)), ((u64)(0xf0a89f02b062b60bU)), ((u64)(0x010160bcb58c16c2U)), ((u64)(0xacd2c6c35c7b638eU)), ((u64)(0x0141b8ebe2ef1c73U)), ((u64)(0x98077874339a3c71U)), ((u64)(0x01922726dbaae390U)), ((u64)(0xbe0956914080cb8eU)), ((u64)(0x01f6b0f092959c74U)), ((u64)(0xf6c5d61ac8507f38U)), ((u64)(0x013a2e965b9d81c8U)), ((u64)(0x34774ba17a649f07U)), ((u64)(0x0188ba3bf284e23bU)), ((u64)(0x01951e89d8fdc6c8U)), ((u64)(0x01eae8caef261acaU)), ((u64)(0x40fd3316279e9c3dU)), ((u64)(0x0132d17ed577d0beU)), ((u64)(0xd13c7fdbb186434cU)), ((u64)(0x017f85de8ad5c4edU)), ((u64)(0x458b9fd29de7d420U)), ((u64)(0x01df67562d8b3629U)), ((u64)(0xcb7743e3a2b0e494U)), ((u64)(0x012ba095dc7701d9U)), ((u64)(0x3e5514dc8b5d1db9U)), ((u64)(0x017688bb5394c250U)), ((u64)(0x4dea5a13ae346527U)), ((u64)(0x01d42aea2879f2e4U)), ((u64)(0xb0b2784c4ce0bf38U)), ((u64)(0x01249ad2594c37ceU)), ((u64)(0x5cdf165f6018ef06U)), ((u64)(0x016dc186ef9f45c2U)), ((u64)(0xf416dbf7381f2ac8U)), ((u64)(0x01c931e8ab871732U)), ((u64)(0xd88e497a83137abdU)), ((u64)(0x011dbf316b346e7fU)), ((u64)(0xceb1dbd923d8596cU)), ((u64)(0x01652efdc6018a1fU)), ((u64)(0xc25e52cf6cce6fc7U)), ((u64)(0x01be7abd3781eca7U)), ((u64)(0xd97af3c1a40105dcU)), ((u64)(0x01170cb642b133e8U)), ((u64)(0x0fd9b0b20d014754U)), ((u64)(0x015ccfe3d35d80e3U)), ((u64)(0xd3d01cde90419929U)), ((u64)(0x01b403dcc834e11bU)), ((u64)(0x6462120b1a28ffb9U)), ((u64)(0x01108269fd210cb1U)), ((u64)(0xbd7a968de0b33fa8U)), ((u64)(0x0154a3047c694fddU)), ((u64)(0x2cd93c3158e00f92U)), ((u64)(0x01a9cbc59b83a3d5U)), ((u64)(0x3c07c59ed78c09bbU)), ((u64)(0x010a1f5b81324665U)), ((u64)(0x8b09b7068d6f0c2aU)), ((u64)(0x014ca732617ed7feU)), ((u64)(0x2dcc24c830cacf34U)), ((u64)(0x019fd0fef9de8dfeU)), ((u64)(0xdc9f96fd1e7ec180U)), ((u64)(0x0103e29f5c2b18beU)), ((u64)(0x93c77cbc661e71e1U)), ((u64)(0x0144db473335deeeU)), ((u64)(0x38b95beb7fa60e59U)), ((u64)(0x01961219000356aaU)), ((u64)(0xc6e7b2e65f8f91efU)), ((u64)(0x01fb969f40042c54U)), ((u64)(0xfc50cfcffbb9bb35U)), ((u64)(0x013d3e2388029bb4U)), ((u64)(0x3b6503c3faa82a03U)), ((u64)(0x018c8dac6a0342a2U)), ((u64)(0xca3e44b4f9523484U)), ((u64)(0x01efb1178484134aU)), ((u64)(0xbe66eaf11bd360d2U)), ((u64)(0x0135ceaeb2d28c0eU)), ((u64)(0x6e00a5ad62c83907U)), ((u64)(0x0183425a5f872f12U)), ((u64)(0x0980cf18bb7a4749U)), ((u64)(0x01e412f0f768fad7U)), ((u64)(0x65f0816f752c6c8dU)), ((u64)(0x012e8bd69aa19cc6U)), ((u64)(0xff6ca1cb527787b1U)), ((u64)(0x017a2ecc414a03f7U)), ((u64)(0xff47ca3e2715699dU)), ((u64)(0x01d8ba7f519c84f5U)), ((u64)(0xbf8cde66d86d6202U)), ((u64)(0x0127748f9301d319U)), ((u64)(0x2f7016008e88ba83U)), ((u64)(0x017151b377c247e0U)), ((u64)(0x3b4c1b80b22ae923U)), ((u64)(0x01cda62055b2d9d8U)), ((u64)(0x250f91306f5ad1b6U)), ((u64)(0x012087d4358fc827U)), ((u64)(0xee53757c8b318623U)), ((u64)(0x0168a9c942f3ba30U)), ((u64)(0x29e852dbadfde7acU)), ((u64)(0x01c2d43b93b0a8bdU)), ((u64)(0x3a3133c94cbeb0ccU)), ((u64)(0x0119c4a53c4e6976U)), ((u64)(0xc8bd80bb9fee5cffU)), ((u64)(0x016035ce8b6203d3U)), ((u64)(0xbaece0ea87e9f43eU)), ((u64)(0x01b843422e3a84c8U)), ((u64)(0x74d40c9294f238a7U)), ((u64)(0x01132a095ce492fdU)), ((u64)(0xd2090fb73a2ec6d1U)), ((u64)(0x0157f48bb41db7bcU)), ((u64)(0x068b53a508ba7885U)), ((u64)(0x01adf1aea12525acU)), ((u64)(0x8417144725748b53U)), ((u64)(0x010cb70d24b7378bU)), ((u64)(0x651cd958eed1ae28U)), ((u64)(0x014fe4d06de5056eU)), ((u64)(0xfe640faf2a8619b2U)), ((u64)(0x01a3de04895e46c9U)), ((u64)(0x3efe89cd7a93d00fU)), ((u64)(0x01066ac2d5daec3eU)), ((u64)(0xcebe2c40d938c413U)), ((u64)(0x014805738b51a74dU)), ((u64)(0x426db7510f86f518U)), ((u64)(0x019a06d06e261121U)), ((u64)(0xc9849292a9b4592fU)), ((u64)(0x0100444244d7cab4U)), ((u64)(0xfbe5b73754216f7aU)), ((u64)(0x01405552d60dbd61U)), ((u64)(0x7adf25052929cb59U)), ((u64)(0x01906aa78b912cbaU)), ((u64)(0x1996ee4673743e2fU)), ((u64)(0x01f485516e7577e9U)), ((u64)(0xaffe54ec0828a6ddU)), ((u64)(0x0138d352e5096af1U)), ((u64)(0x1bfdea270a32d095U)), ((u64)(0x018708279e4bc5aeU)), ((u64)(0xa2fd64b0ccbf84baU)), ((u64)(0x01e8ca3185deb719U)), ((u64)(0x05de5eee7ff7b2f4U)), ((u64)(0x01317e5ef3ab3270U)), ((u64)(0x0755f6aa1ff59fb1U)), ((u64)(0x017dddf6b095ff0cU)), ((u64)(0x092b7454a7f3079eU)), ((u64)(0x01dd55745cbb7ecfU)), ((u64)(0x65bb28b4e8f7e4c3U)), ((u64)(0x012a5568b9f52f41U)), ((u64)(0xbf29f2e22335ddf3U)), ((u64)(0x0174eac2e8727b11U)), ((u64)(0x2ef46f9aac035570U)), ((u64)(0x01d22573a28f19d6U)), ((u64)(0xdd58c5c0ab821566U)), ((u64)(0x0123576845997025U)), ((u64)(0x54aef730d6629ac0U)), ((u64)(0x016c2d4256ffcc2fU)), ((u64)(0x29dab4fd0bfb4170U)), ((u64)(0x01c73892ecbfbf3bU)), ((u64)(0xfa28b11e277d08e6U)), ((u64)(0x011c835bd3f7d784U)), ((u64)(0x38b2dd65b15c4b1fU)), ((u64)(0x0163a432c8f5cd66U)), ((u64)(0xc6df94bf1db35de7U)), ((u64)(0x01bc8d3f7b3340bfU)), ((u64)(0xdc4bbcf772901ab0U)), ((u64)(0x0115d847ad000877U)), ((u64)(0xd35eac354f34215cU)), ((u64)(0x015b4e5998400a95U)), ((u64)(0x48365742a30129b4U)), ((u64)(0x01b221effe500d3bU)), ((u64)(0x0d21f689a5e0ba10U)), ((u64)(0x010f5535fef20845U)), ((u64)(0x506a742c0f58e894U)), ((u64)(0x01532a837eae8a56U)), ((u64)(0xe4851137132f22b9U)), ((u64)(0x01a7f5245e5a2cebU)), ((u64)(0x6ed32ac26bfd75b4U)), ((u64)(0x0108f936baf85c13U)), ((u64)(0x4a87f57306fcd321U)), ((u64)(0x014b378469b67318U)), ((u64)(0x5d29f2cfc8bc07e9U)), ((u64)(0x019e056584240fdeU)), ((u64)(0xfa3a37c1dd7584f1U)), ((u64)(0x0102c35f729689eaU)), ((u64)(0xb8c8c5b254d2e62eU)), ((u64)(0x014374374f3c2c65U)), ((u64)(0x26faf71eea079fb9U)), ((u64)(0x01945145230b377fU)), ((u64)(0xf0b9b4e6a48987a8U)), ((u64)(0x01f965966bce055eU)), ((u64)(0x5674111026d5f4c9U)), ((u64)(0x013bdf7e0360c35bU)), ((u64)(0x2c111554308b71fbU)), ((u64)(0x018ad75d8438f432U)), ((u64)(0xb7155aa93cae4e7aU)), ((u64)(0x01ed8d34e547313eU)), ((u64)(0x326d58a9c5ecf10cU)), ((u64)(0x013478410f4c7ec7U)), ((u64)(0xff08aed437682d4fU)), ((u64)(0x01819651531f9e78U)), ((u64)(0x3ecada89454238a3U)), ((u64)(0x01e1fbe5a7e78617U)), ((u64)(0x873ec895cb496366U)), ((u64)(0x012d3d6f88f0b3ceU)), ((u64)(0x290e7abb3e1bbc3fU)), ((u64)(0x01788ccb6b2ce0c2U)), ((u64)(0xb352196a0da2ab4fU)), ((u64)(0x01d6affe45f818f2U)), ((u64)(0xb0134fe24885ab11U)), ((u64)(0x01262dfeebbb0f97U)), ((u64)(0x9c1823dadaa715d6U)), ((u64)(0x016fb97ea6a9d37dU)), ((u64)(0x031e2cd19150db4bU)), ((u64)(0x01cba7de5054485dU)), ((u64)(0x21f2dc02fad2890fU)), ((u64)(0x011f48eaf234ad3aU)), ((u64)(0xaa6f9303b9872b53U)), ((u64)(0x01671b25aec1d888U)), ((u64)(0xd50b77c4a7e8f628U)), ((u64)(0x01c0e1ef1a724eaaU)), ((u64)(0xc5272adae8f199d9U)), ((u64)(0x01188d357087712aU)), ((u64)(0x7670f591a32e004fU)), ((u64)(0x015eb082cca94d75U)), ((u64)(0xd40d32f60bf98063U)), ((u64)(0x01b65ca37fd3a0d2U)), ((u64)(0xc4883fd9c77bf03eU)), ((u64)(0x0111f9e62fe44483U)), ((u64)(0xb5aa4fd0395aec4dU)), ((u64)(0x0156785fbbdd55a4U)), ((u64)(0xe314e3c447b1a760U)), ((u64)(0x01ac1677aad4ab0dU)), ((u64)(0xaded0e5aaccf089cU)), ((u64)(0x010b8e0acac4eae8U)), ((u64)(0xd96851f15802cac3U)), ((u64)(0x014e718d7d7625a2U)), ((u64)(0x8fc2666dae037d74U)), ((u64)(0x01a20df0dcd3af0bU)), ((u64)(0x39d980048cc22e68U)), ((u64)(0x010548b68a044d67U)), ((u64)(0x084fe005aff2ba03U)), ((u64)(0x01469ae42c8560c1U)), ((u64)(0x4a63d8071bef6883U)), ((u64)(0x0198419d37a6b8f1U)), ((u64)(0x9cfcce08e2eb42a4U)), ((u64)(0x01fe52048590672dU)), ((u64)(0x821e00c58dd309a7U)), ((u64)(0x013ef342d37a407cU)), ((u64)(0xa2a580f6f147cc10U)), ((u64)(0x018eb0138858d09bU)), ((u64)(0x8b4ee134ad99bf15U)), ((u64)(0x01f25c186a6f04c2U)), ((u64)(0x97114cc0ec80176dU)), ((u64)(0x0137798f428562f9U)), ((u64)(0xfcd59ff127a01d48U)), ((u64)(0x018557f31326bbb7U)), ((u64)(0xfc0b07ed7188249aU)), ((u64)(0x01e6adefd7f06aa5U)), ((u64)(0xbd86e4f466f516e0U)), ((u64)(0x01302cb5e6f642a7U)), ((u64)(0xace89e3180b25c98U)), ((u64)(0x017c37e360b3d351U)), ((u64)(0x1822c5bde0def3beU)), ((u64)(0x01db45dc38e0c826U)), ((u64)(0xcf15bb96ac8b5857U)), ((u64)(0x01290ba9a38c7d17U)), ((u64)(0xc2db2a7c57ae2e6dU)), ((u64)(0x01734e940c6f9c5dU)), ((u64)(0x3391f51b6d99ba08U)), ((u64)(0x01d022390f8b8375U)), ((u64)(0x403b393124801445U)), ((u64)(0x01221563a9b73229U)), ((u64)(0x904a077d6da01956U)), ((u64)(0x016a9abc9424feb3U)), ((u64)(0x745c895cc9081facU)), ((u64)(0x01c5416bb92e3e60U)), ((u64)(0x48b9d5d9fda513cbU)), ((u64)(0x011b48e353bce6fcU)), ((u64)(0x5ae84b507d0e58beU)), ((u64)(0x01621b1c28ac20bbU)), ((u64)(0x31a25e249c51eeeeU)), ((u64)(0x01baa1e332d728eaU)), ((u64)(0x5f057ad6e1b33554U)), ((u64)(0x0114a52dffc67992U)), ((u64)(0xf6c6d98c9a2002aaU)), ((u64)(0x0159ce797fb817f6U)), ((u64)(0xb4788fefc0a80354U)), ((u64)(0x01b04217dfa61df4U)), ((u64)(0xf0cb59f5d8690214U)), ((u64)(0x010e294eebc7d2b8U)), ((u64)(0x2cfe30734e83429aU)), ((u64)(0x0151b3a2a6b9c767U)), ((u64)(0xf83dbc9022241340U)), ((u64)(0x01a6208b50683940U)), ((u64)(0x9b2695da15568c08U)), ((u64)(0x0107d457124123c8U)), ((u64)(0xc1f03b509aac2f0aU)), ((u64)(0x0149c96cd6d16cbaU)), ((u64)(0x726c4a24c1573acdU)), ((u64)(0x019c3bc80c85c7e9U)), ((u64)(0xe783ae56f8d684c0U)), ((u64)(0x0101a55d07d39cf1U)), ((u64)(0x616499ecb70c25f0U)), ((u64)(0x01420eb449c8842eU)), ((u64)(0xf9bdc067e4cf2f6cU)), ((u64)(0x019292615c3aa539U)), ((u64)(0x782d3081de02fb47U)), ((u64)(0x01f736f9b3494e88U)), ((u64)(0x4b1c3e512ac1dd0cU)), ((u64)(0x013a825c100dd115U)), ((u64)(0x9de34de57572544fU)), ((u64)(0x018922f31411455aU)), ((u64)(0x455c215ed2cee963U)), ((u64)(0x01eb6bafd91596b1U)), ((u64)(0xcb5994db43c151deU)), ((u64)(0x0133234de7ad7e2eU)), ((u64)(0x7e2ffa1214b1a655U)), ((u64)(0x017fec216198ddbaU)), ((u64)(0x1dbbf89699de0febU)), ((u64)(0x01dfe729b9ff1529U)), ((u64)(0xb2957b5e202ac9f3U)), ((u64)(0x012bf07a143f6d39U)), ((u64)(0x1f3ada35a8357c6fU)), ((u64)(0x0176ec98994f4888U)), ((u64)(0x270990c31242db8bU)), ((u64)(0x01d4a7bebfa31aaaU)), ((u64)(0x5865fa79eb69c937U)), ((u64)(0x0124e8d737c5f0aaU)), ((u64)(0xee7f791866443b85U)), ((u64)(0x016e230d05b76cd4U)), ((u64)(0x2a1f575e7fd54a66U)), ((u64)(0x01c9abd04725480aU)), ((u64)(0x5a53969b0fe54e80U)), ((u64)(0x011e0b622c774d06U)), ((u64)(0xf0e87c41d3dea220U)), ((u64)(0x01658e3ab7952047U)), ((u64)(0xed229b5248d64aa8U)), ((u64)(0x01bef1c9657a6859U)), ((u64)(0x3435a1136d85eea9U)), ((u64)(0x0117571ddf6c8138U)), ((u64)(0x4143095848e76a53U)), ((u64)(0x015d2ce55747a186U)), ((u64)(0xd193cbae5b2144e8U)), ((u64)(0x01b4781ead1989e7U)), ((u64)(0xe2fc5f4cf8f4cb11U)), ((u64)(0x0110cb132c2ff630U)), ((u64)(0x1bbb77203731fdd5U)), ((u64)(0x0154fdd7f73bf3bdU)), ((u64)(0x62aa54e844fe7d4aU)), ((u64)(0x01aa3d4df50af0acU)), ((u64)(0xbdaa75112b1f0e4eU)), ((u64)(0x010a6650b926d66bU)), ((u64)(0xad15125575e6d1e2U)), ((u64)(0x014cffe4e7708c06U)), ((u64)(0x585a56ead360865bU)), ((u64)(0x01a03fde214caf08U)), ((u64)(0x37387652c41c53f8U)), ((u64)(0x010427ead4cfed65U)), ((u64)(0x850693e7752368f7U)), ((u64)(0x014531e58a03e8beU)), ((u64)(0x264838e1526c4334U)), ((u64)(0x01967e5eec84e2eeU)), ((u64)(0xafda4719a7075402U)), ((u64)(0x01fc1df6a7a61ba9U)), ((u64)(0x0de86c7008649481U)), ((u64)(0x013d92ba28c7d14aU)), ((u64)(0x9162878c0a7db9a1U)), ((u64)(0x018cf768b2f9c59cU)), ((u64)(0xb5bb296f0d1d280aU)), ((u64)(0x01f03542dfb83703U)), ((u64)(0x5194f9e568323906U)), ((u64)(0x01362149cbd32262U)), ((u64)(0xe5fa385ec23ec747U)), ((u64)(0x0183a99c3ec7eafaU)), ((u64)(0x9f78c67672ce7919U)), ((u64)(0x01e494034e79e5b9U)), ((u64)(0x03ab7c0a07c10bb0U)), ((u64)(0x012edc82110c2f94U)), ((u64)(0x04965b0c89b14e9cU)), ((u64)(0x017a93a2954f3b79U)), ((u64)(0x45bbf1cfac1da243U)), ((u64)(0x01d9388b3aa30a57U)), ((u64)(0x8b957721cb92856aU)), ((u64)(0x0127c35704a5e676U)), ((u64)(0x2e7ad4ea3e7726c4U)), ((u64)(0x0171b42cc5cf6014U)), ((u64)(0x3a198a24ce14f075U)), ((u64)(0x01ce2137f7433819U)), ((u64)(0xc44ff65700cd1649U)), ((u64)(0x0120d4c2fa8a030fU)), ((u64)(0xb563f3ecc1005bdbU)), ((u64)(0x016909f3b92c83d3U)), ((u64)(0xa2bcf0e7f14072d2U)), ((u64)(0x01c34c70a777a4c8U)), ((u64)(0x65b61690f6c847c3U)), ((u64)(0x011a0fc668aac6fdU)), ((u64)(0xbf239c35347a59b4U)), ((u64)(0x016093b802d578bcU)), ((u64)(0xeeec83428198f021U)), ((u64)(0x01b8b8a6038ad6ebU)), ((u64)(0x7553d20990ff9615U)), ((u64)(0x01137367c236c653U)), ((u64)(0x52a8c68bf53f7b9aU)), ((u64)(0x01585041b2c477e8U)), ((u64)(0x6752f82ef28f5a81U)), ((u64)(0x01ae64521f7595e2U)), ((u64)(0x8093db1d57999890U)), ((u64)(0x010cfeb353a97dadU)), ((u64)(0xe0b8d1e4ad7ffeb4U)), ((u64)(0x01503e602893dd18U)), ((u64)(0x18e7065dd8dffe62U)), ((u64)(0x01a44df832b8d45fU)), ((u64)(0x6f9063faa78bfefdU)), ((u64)(0x0106b0bb1fb384bbU)), ((u64)(0x4b747cf9516efebcU)), ((u64)(0x01485ce9e7a065eaU)), ((u64)(0xde519c37a5cabe6bU)), ((u64)(0x019a742461887f64U)), ((u64)(0x0af301a2c79eb703U)), ((u64)(0x01008896bcf54f9fU)), ((u64)(0xcdafc20b798664c4U)), ((u64)(0x0140aabc6c32a386U)), ((u64)(0x811bb28e57e7fdf5U)), ((u64)(0x0190d56b873f4c68U)), ((u64)(0xa1629f31ede1fd72U)), ((u64)(0x01f50ac6690f1f82U)), ((u64)(0xa4dda37f34ad3e67U)), ((u64)(0x013926bc01a973b1U)), ((u64)(0x0e150c5f01d88e01U)), ((u64)(0x0187706b0213d09eU)), ((u64)(0x919a4f76c24eb181U)), ((u64)(0x01e94c85c298c4c5U)), ((u64)(0x7b0071aa39712ef1U)), ((u64)(0x0131cfd3999f7afbU)), ((u64)(0x59c08e14c7cd7aadU)), ((u64)(0x017e43c8800759baU)), ((u64)(0xf030b199f9c0d958U)), ((u64)(0x01ddd4baa0093028U)), ((u64)(0x961e6f003c1887d7U)), ((u64)(0x012aa4f4a405be19U)), ((u64)(0xfba60ac04b1ea9cdU)), ((u64)(0x01754e31cd072d9fU)), ((u64)(0xfa8f8d705de65440U)), ((u64)(0x01d2a1be4048f907U)), ((u64)(0xfc99b8663aaff4a8U)), ((u64)(0x0123a516e82d9ba4U)), ((u64)(0x3bc0267fc95bf1d2U)), ((u64)(0x016c8e5ca239028eU)), ((u64)(0xcab0301fbbb2ee47U)), ((u64)(0x01c7b1f3cac74331U)), ((u64)(0x1eae1e13d54fd4ecU)), ((u64)(0x011ccf385ebc89ffU)), ((u64)(0xe659a598caa3ca27U)), ((u64)(0x01640306766bac7eU)), ((u64)(0x9ff00efefd4cbcb1U)), ((u64)(0x01bd03c81406979eU)), ((u64)(0x23f6095f5e4ff5efU)), ((u64)(0x0116225d0c841ec3U)), ((u64)(0xecf38bb735e3f36aU)), ((u64)(0x015baaf44fa52673U)), ((u64)(0xe8306ea5035cf045U)), ((u64)(0x01b295b1638e7010U)), ((u64)(0x911e4527221a162bU)), ((u64)(0x010f9d8ede39060aU)), ((u64)(0x3565d670eaa09bb6U)), ((u64)(0x015384f295c7478dU)), ((u64)(0x82bf4c0d2548c2a3U)), ((u64)(0x01a8662f3b391970U)), ((u64)(0x51b78f88374d79a6U)), ((u64)(0x01093fdd8503afe6U)), ((u64)(0xe625736a4520d810U)), ((u64)(0x014b8fd4e6449bdfU)), ((u64)(0xdfaed044d6690e14U)), ((u64)(0x019e73ca1fd5c2d7U)), ((u64)(0xebcd422b0601a8ccU)), ((u64)(0x0103085e53e599c6U)), ((u64)(0xa6c092b5c78212ffU)), ((u64)(0x0143ca75e8df0038U)), ((u64)(0xd070b763396297bfU)), ((u64)(0x0194bd136316c046U)), ((u64)(0x848ce53c07bb3dafU)), ((u64)(0x01f9ec583bdc7058U)), ((u64)(0x52d80f4584d5068dU)), ((u64)(0x013c33b72569c637U)), ((u64)(0x278e1316e60a4831U)), ((u64)(0x018b40a4eec437c5U))}; // fixed array const
Array_fixed_u64_584 _const_strconv__pow5_inv_split_64_x = {((u64)(0x0000000000000001U)), ((u64)(0x0400000000000000U)), ((u64)(0x3333333333333334U)), ((u64)(0x0333333333333333U)), ((u64)(0x28f5c28f5c28f5c3U)), ((u64)(0x028f5c28f5c28f5cU)), ((u64)(0xed916872b020c49cU)), ((u64)(0x020c49ba5e353f7cU)), ((u64)(0xaf4f0d844d013a93U)), ((u64)(0x0346dc5d63886594U)), ((u64)(0x8c3f3e0370cdc876U)), ((u64)(0x029f16b11c6d1e10U)), ((u64)(0xd698fe69270b06c5U)), ((u64)(0x0218def416bdb1a6U)), ((u64)(0xf0f4ca41d811a46eU)), ((u64)(0x035afe535795e90aU)), ((u64)(0xf3f70834acdae9f1U)), ((u64)(0x02af31dc4611873bU)), ((u64)(0x5cc5a02a23e254c1U)), ((u64)(0x0225c17d04dad296U)), ((u64)(0xfad5cd10396a2135U)), ((u64)(0x036f9bfb3af7b756U)), ((u64)(0xfbde3da69454e75eU)), ((u64)(0x02bfaffc2f2c92abU)), ((u64)(0x2fe4fe1edd10b918U)), ((u64)(0x0232f33025bd4223U)), ((u64)(0x4ca19697c81ac1bfU)), ((u64)(0x0384b84d092ed038U)), ((u64)(0x3d4e1213067bce33U)), ((u64)(0x02d09370d4257360U)), ((u64)(0x643e74dc052fd829U)), ((u64)(0x024075f3dceac2b3U)), ((u64)(0x6d30baf9a1e626a7U)), ((u64)(0x039a5652fb113785U)), ((u64)(0x2426fbfae7eb5220U)), ((u64)(0x02e1dea8c8da92d1U)), ((u64)(0x1cebfcc8b9890e80U)), ((u64)(0x024e4bba3a487574U)), ((u64)(0x94acc7a78f41b0ccU)), ((u64)(0x03b07929f6da5586U)), ((u64)(0xaa23d2ec729af3d7U)), ((u64)(0x02f394219248446bU)), ((u64)(0xbb4fdbf05baf2979U)), ((u64)(0x025c768141d369efU)), ((u64)(0xc54c931a2c4b758dU)), ((u64)(0x03c7240202ebdcb2U)), ((u64)(0x9dd6dc14f03c5e0bU)), ((u64)(0x0305b66802564a28U)), ((u64)(0x4b1249aa59c9e4d6U)), ((u64)(0x026af8533511d4edU)), ((u64)(0x44ea0f76f60fd489U)), ((u64)(0x03de5a1ebb4fbb15U)), ((u64)(0x6a54d92bf80caa07U)), ((u64)(0x0318481895d96277U)), ((u64)(0x21dd7a89933d54d2U)), ((u64)(0x0279d346de4781f9U)), ((u64)(0x362f2a75b8622150U)), ((u64)(0x03f61ed7ca0c0328U)), ((u64)(0xf825bb91604e810dU)), ((u64)(0x032b4bdfd4d668ecU)), ((u64)(0xc684960de6a5340bU)), ((u64)(0x0289097fdd7853f0U)), ((u64)(0xd203ab3e521dc33cU)), ((u64)(0x02073accb12d0ff3U)), ((u64)(0xe99f7863b696052cU)), ((u64)(0x033ec47ab514e652U)), ((u64)(0x87b2c6b62bab3757U)), ((u64)(0x02989d2ef743eb75U)), ((u64)(0xd2f56bc4efbc2c45U)), ((u64)(0x0213b0f25f69892aU)), ((u64)(0x1e55793b192d13a2U)), ((u64)(0x0352b4b6ff0f41deU)), ((u64)(0x4b77942f475742e8U)), ((u64)(0x02a8909265a5ce4bU)), ((u64)(0xd5f9435905df68baU)), ((u64)(0x022073a8515171d5U)), ((u64)(0x565b9ef4d6324129U)), ((u64)(0x03671f73b54f1c89U)), ((u64)(0xdeafb25d78283421U)), ((u64)(0x02b8e5f62aa5b06dU)), ((u64)(0x188c8eb12cecf681U)), ((u64)(0x022d84c4eeeaf38bU)), ((u64)(0x8dadb11b7b14bd9bU)), ((u64)(0x037c07a17e44b8deU)), ((u64)(0x7157c0e2c8dd647cU)), ((u64)(0x02c99fb46503c718U)), ((u64)(0x8ddfcd823a4ab6caU)), ((u64)(0x023ae629ea696c13U)), ((u64)(0x1632e269f6ddf142U)), ((u64)(0x0391704310a8acecU)), ((u64)(0x44f581ee5f17f435U)), ((u64)(0x02dac035a6ed5723U)), ((u64)(0x372ace584c1329c4U)), ((u64)(0x024899c4858aac1cU)), ((u64)(0xbeaae3c079b842d3U)), ((u64)(0x03a75c6da27779c6U)), ((u64)(0x6555830061603576U)), ((u64)(0x02ec49f14ec5fb05U)), ((u64)(0xb7779c004de6912bU)), ((u64)(0x0256a18dd89e626aU)), ((u64)(0xf258f99a163db512U)), ((u64)(0x03bdcf495a9703ddU)), ((u64)(0x5b7a614811caf741U)), ((u64)(0x02fe3f6de212697eU)), ((u64)(0xaf951aa00e3bf901U)), ((u64)(0x0264ff8b1b41edfeU)), ((u64)(0x7f54f7667d2cc19bU)), ((u64)(0x03d4cc11c5364997U)), ((u64)(0x32aa5f8530f09ae3U)), ((u64)(0x0310a3416a91d479U)), ((u64)(0xf55519375a5a1582U)), ((u64)(0x0273b5cdeedb1060U)), ((u64)(0xbbbb5b8bc3c3559dU)), ((u64)(0x03ec56164af81a34U)), ((u64)(0x2fc916096969114aU)), ((u64)(0x03237811d593482aU)), ((u64)(0x596dab3ababa743cU)), ((u64)(0x0282c674aadc39bbU)), ((u64)(0x478aef622efb9030U)), ((u64)(0x0202385d557cfafcU)), ((u64)(0xd8de4bd04b2c19e6U)), ((u64)(0x0336c0955594c4c6U)), ((u64)(0xad7ea30d08f014b8U)), ((u64)(0x029233aaaadd6a38U)), ((u64)(0x24654f3da0c01093U)), ((u64)(0x020e8fbbbbe454faU)), ((u64)(0x3a3bb1fc346680ebU)), ((u64)(0x034a7f92c63a2190U)), ((u64)(0x94fc8e635d1ecd89U)), ((u64)(0x02a1ffa89e94e7a6U)), ((u64)(0xaa63a51c4a7f0ad4U)), ((u64)(0x021b32ed4baa52ebU)), ((u64)(0xdd6c3b607731aaedU)), ((u64)(0x035eb7e212aa1e45U)), ((u64)(0x1789c919f8f488bdU)), ((u64)(0x02b22cb4dbbb4b6bU)), ((u64)(0xac6e3a7b2d906d64U)), ((u64)(0x022823c3e2fc3c55U)), ((u64)(0x13e390c515b3e23aU)), ((u64)(0x03736c6c9e606089U)), ((u64)(0xdcb60d6a77c31b62U)), ((u64)(0x02c2bd23b1e6b3a0U)), ((u64)(0x7d5e7121f968e2b5U)), ((u64)(0x0235641c8e52294dU)), ((u64)(0xc8971b698f0e3787U)), ((u64)(0x0388a02db0837548U)), ((u64)(0xa078e2bad8d82c6cU)), ((u64)(0x02d3b357c0692aa0U)), ((u64)(0xe6c71bc8ad79bd24U)), ((u64)(0x0242f5dfcd20eee6U)), ((u64)(0x0ad82c7448c2c839U)), ((u64)(0x039e5632e1ce4b0bU)), ((u64)(0x3be023903a356cfaU)), ((u64)(0x02e511c24e3ea26fU)), ((u64)(0x2fe682d9c82abd95U)), ((u64)(0x0250db01d8321b8cU)), ((u64)(0x4ca4048fa6aac8eeU)), ((u64)(0x03b4919c8d1cf8e0U)), ((u64)(0x3d5003a61eef0725U)), ((u64)(0x02f6dae3a4172d80U)), ((u64)(0x9773361e7f259f51U)), ((u64)(0x025f1582e9ac2466U)), ((u64)(0x8beb89ca6508fee8U)), ((u64)(0x03cb559e42ad070aU)), ((u64)(0x6fefa16eb73a6586U)), ((u64)(0x0309114b688a6c08U)), ((u64)(0xf3261abef8fb846bU)), ((u64)(0x026da76f86d52339U)), ((u64)(0x51d691318e5f3a45U)), ((u64)(0x03e2a57f3e21d1f6U)), ((u64)(0x0e4540f471e5c837U)), ((u64)(0x031bb798fe8174c5U)), ((u64)(0xd8376729f4b7d360U)), ((u64)(0x027c92e0cb9ac3d0U)), ((u64)(0xf38bd84321261effU)), ((u64)(0x03fa849adf5e061aU)), ((u64)(0x293cad0280eb4bffU)), ((u64)(0x032ed07be5e4d1afU)), ((u64)(0xedca240200bc3cccU)), ((u64)(0x028bd9fcb7ea4158U)), ((u64)(0xbe3b50019a3030a4U)), ((u64)(0x02097b309321cde0U)), ((u64)(0xc9f88002904d1a9fU)), ((u64)(0x03425eb41e9c7c9aU)), ((u64)(0x3b2d3335403daee6U)), ((u64)(0x029b7ef67ee396e2U)), ((u64)(0x95bdc291003158b8U)), ((u64)(0x0215ff2b98b6124eU)), ((u64)(0x892f9db4cd1bc126U)), ((u64)(0x035665128df01d4aU)), ((u64)(0x07594af70a7c9a85U)), ((u64)(0x02ab840ed7f34aa2U)), ((u64)(0x6c476f2c0863aed1U)), ((u64)(0x0222d00bdff5d54eU)), ((u64)(0x13a57eacda3917b4U)), ((u64)(0x036ae67966562217U)), ((u64)(0x0fb7988a482dac90U)), ((u64)(0x02bbeb9451de81acU)), ((u64)(0xd95fad3b6cf156daU)), ((u64)(0x022fefa9db1867bcU)), ((u64)(0xf565e1f8ae4ef15cU)), ((u64)(0x037fe5dc91c0a5faU)), ((u64)(0x911e4e608b725ab0U)), ((u64)(0x02ccb7e3a7cd5195U)), ((u64)(0xda7ea51a0928488dU)), ((u64)(0x023d5fe9530aa7aaU)), ((u64)(0xf7310829a8407415U)), ((u64)(0x039566421e7772aaU)), ((u64)(0x2c2739baed005cdeU)), ((u64)(0x02ddeb68185f8eefU)), ((u64)(0xbcec2e2f24004a4bU)), ((u64)(0x024b22b9ad193f25U)), ((u64)(0x94ad16b1d333aa11U)), ((u64)(0x03ab6ac2ae8ecb6fU)), ((u64)(0xaa241227dc2954dbU)), ((u64)(0x02ef889bbed8a2bfU)), ((u64)(0x54e9a81fe35443e2U)), ((u64)(0x02593a163246e899U)), ((u64)(0x2175d9cc9eed396aU)), ((u64)(0x03c1f689ea0b0dc2U)), ((u64)(0xe7917b0a18bdc788U)), ((u64)(0x03019207ee6f3e34U)), ((u64)(0xb9412f3b46fe393aU)), ((u64)(0x0267a8065858fe90U)), ((u64)(0xf535185ed7fd285cU)), ((u64)(0x03d90cd6f3c1974dU)), ((u64)(0xc42a79e57997537dU)), ((u64)(0x03140a458fce12a4U)), ((u64)(0x03552e512e12a931U)), ((u64)(0x02766e9e0ca4dbb7U)), ((u64)(0x9eeeb081e3510eb4U)), ((u64)(0x03f0b0fce107c5f1U)), ((u64)(0x4bf226ce4f740bc3U)), ((u64)(0x0326f3fd80d304c1U)), ((u64)(0xa3281f0b72c33c9cU)), ((u64)(0x02858ffe00a8d09aU)), ((u64)(0x1c2018d5f568fd4aU)), ((u64)(0x020473319a20a6e2U)), ((u64)(0xf9ccf48988a7fba9U)), ((u64)(0x033a51e8f69aa49cU)), ((u64)(0xfb0a5d3ad3b99621U)), ((u64)(0x02950e53f87bb6e3U)), ((u64)(0x2f3b7dc8a96144e7U)), ((u64)(0x0210d8432d2fc583U)), ((u64)(0xe52bfc7442353b0cU)), ((u64)(0x034e26d1e1e608d1U)), ((u64)(0xb756639034f76270U)), ((u64)(0x02a4ebdb1b1e6d74U)), ((u64)(0x2c451c735d92b526U)), ((u64)(0x021d897c15b1f12aU)), ((u64)(0x13a1c71efc1deea3U)), ((u64)(0x0362759355e981ddU)), ((u64)(0x761b05b2634b2550U)), ((u64)(0x02b52adc44bace4aU)), ((u64)(0x91af37c1e908eaa6U)), ((u64)(0x022a88b036fbd83bU)), ((u64)(0x82b1f2cfdb417770U)), ((u64)(0x03774119f192f392U)), ((u64)(0xcef4c23fe29ac5f3U)), ((u64)(0x02c5cdae5adbf60eU)), ((u64)(0x3f2a34ffe87bd190U)), ((u64)(0x0237d7beaf165e72U)), ((u64)(0x984387ffda5fb5b2U)), ((u64)(0x038c8c644b56fd83U)), ((u64)(0xe0360666484c915bU)), ((u64)(0x02d6d6b6a2abfe02U)), ((u64)(0x802b3851d3707449U)), ((u64)(0x024578921bbccb35U)), ((u64)(0x99dec082ebe72075U)), ((u64)(0x03a25a835f947855U)), ((u64)(0xae4bcd358985b391U)), ((u64)(0x02e8486919439377U)), ((u64)(0xbea30a913ad15c74U)), ((u64)(0x02536d20e102dc5fU)), ((u64)(0xfdd1aa81f7b560b9U)), ((u64)(0x03b8ae9b019e2d65U)), ((u64)(0x97daeece5fc44d61U)), ((u64)(0x02fa2548ce182451U)), ((u64)(0xdfe258a51969d781U)), ((u64)(0x0261b76d71ace9daU)), ((u64)(0x996a276e8f0fbf34U)), ((u64)(0x03cf8be24f7b0fc4U)), ((u64)(0xe121b9253f3fcc2aU)), ((u64)(0x030c6fe83f95a636U)), ((u64)(0xb41afa8432997022U)), ((u64)(0x02705986994484f8U)), ((u64)(0xecf7f739ea8f19cfU)), ((u64)(0x03e6f5a4286da18dU)), ((u64)(0x23f99294bba5ae40U)), ((u64)(0x031f2ae9b9f14e0bU)), ((u64)(0x4ffadbaa2fb7be99U)), ((u64)(0x027f5587c7f43e6fU)), ((u64)(0x7ff7c5dd1925fdc2U)), ((u64)(0x03feef3fa6539718U)), ((u64)(0xccc637e4141e649bU)), ((u64)(0x033258ffb842df46U)), ((u64)(0xd704f983434b83afU)), ((u64)(0x028ead9960357f6bU)), ((u64)(0x126a6135cf6f9c8cU)), ((u64)(0x020bbe144cf79923U)), ((u64)(0x83dd685618b29414U)), ((u64)(0x0345fced47f28e9eU)), ((u64)(0x9cb12044e08edcddU)), ((u64)(0x029e63f1065ba54bU)), ((u64)(0x16f419d0b3a57d7dU)), ((u64)(0x02184ff405161dd6U)), ((u64)(0x8b20294dec3bfbfbU)), ((u64)(0x035a19866e89c956U)), ((u64)(0x3c19baa4bcfcc996U)), ((u64)(0x02ae7ad1f207d445U)), ((u64)(0xc9ae2eea30ca3adfU)), ((u64)(0x02252f0e5b39769dU)), ((u64)(0x0f7d17dd1add2afdU)), ((u64)(0x036eb1b091f58a96U)), ((u64)(0x3f97464a7be42264U)), ((u64)(0x02bef48d41913babU)), ((u64)(0xcc790508631ce850U)), ((u64)(0x02325d3dce0dc955U)), ((u64)(0xe0c1a1a704fb0d4dU)), ((u64)(0x0383c862e3494222U)), ((u64)(0x4d67b4859d95a43eU)), ((u64)(0x02cfd3824f6dce82U)), ((u64)(0x711fc39e17aae9cbU)), ((u64)(0x023fdc683f8b0b9bU)), ((u64)(0xe832d2968c44a945U)), ((u64)(0x039960a6cc11ac2bU)), ((u64)(0xecf575453d03ba9eU)), ((u64)(0x02e11a1f09a7bcefU)), ((u64)(0x572ac4376402fbb1U)), ((u64)(0x024dae7f3aec9726U)), ((u64)(0x58446d256cd192b5U)), ((u64)(0x03af7d985e47583dU)), ((u64)(0x79d0575123dadbc4U)), ((u64)(0x02f2cae04b6c4697U)), ((u64)(0x94a6ac40e97be303U)), ((u64)(0x025bd5803c569edfU)), ((u64)(0x8771139b0f2c9e6cU)), ((u64)(0x03c62266c6f0fe32U)), ((u64)(0x9f8da948d8f07ebdU)), ((u64)(0x0304e85238c0cb5bU)), ((u64)(0xe60aedd3e0c06564U)), ((u64)(0x026a5374fa33d5e2U)), ((u64)(0xa344afb9679a3bd2U)), ((u64)(0x03dd5254c3862304U)), ((u64)(0xe903bfc78614fca8U)), ((u64)(0x031775109c6b4f36U)), ((u64)(0xba6966393810ca20U)), ((u64)(0x02792a73b055d8f8U)), ((u64)(0x2a423d2859b4769aU)), ((u64)(0x03f510b91a22f4c1U)), ((u64)(0xee9b642047c39215U)), ((u64)(0x032a73c7481bf700U)), ((u64)(0xbee2b680396941aaU)), ((u64)(0x02885c9f6ce32c00U)), ((u64)(0xff1bc53361210155U)), ((u64)(0x0206b07f8a4f5666U)), ((u64)(0x31c6085235019bbbU)), ((u64)(0x033de73276e5570bU)), ((u64)(0x27d1a041c4014963U)), ((u64)(0x0297ec285f1ddf3cU)), ((u64)(0xeca7b367d0010782U)), ((u64)(0x021323537f4b18fcU)), ((u64)(0xadd91f0c8001a59dU)), ((u64)(0x0351d21f3211c194U)), ((u64)(0xf17a7f3d3334847eU)), ((u64)(0x02a7db4c280e3476U)), ((u64)(0x279532975c2a0398U)), ((u64)(0x021fe2a3533e905fU)), ((u64)(0xd8eeb75893766c26U)), ((u64)(0x0366376bb8641a31U)), ((u64)(0x7a5892ad42c52352U)), ((u64)(0x02b82c562d1ce1c1U)), ((u64)(0xfb7a0ef102374f75U)), ((u64)(0x022cf044f0e3e7cdU)), ((u64)(0xc59017e8038bb254U)), ((u64)(0x037b1a07e7d30c7cU)), ((u64)(0x37a67986693c8eaaU)), ((u64)(0x02c8e19feca8d6caU)), ((u64)(0xf951fad1edca0bbbU)), ((u64)(0x023a4e198a20abd4U)), ((u64)(0x28832ae97c76792bU)), ((u64)(0x03907cf5a9cddfbbU)), ((u64)(0x2068ef21305ec756U)), ((u64)(0x02d9fd9154a4b2fcU)), ((u64)(0x19ed8c1a8d189f78U)), ((u64)(0x0247fe0ddd508f30U)), ((u64)(0x5caf4690e1c0ff26U)), ((u64)(0x03a66349621a7eb3U)), ((u64)(0x4a25d20d81673285U)), ((u64)(0x02eb82a11b48655cU)), ((u64)(0x3b5174d79ab8f537U)), ((u64)(0x0256021a7c39eab0U)), ((u64)(0x921bee25c45b21f1U)), ((u64)(0x03bcd02a605caab3U)), ((u64)(0xdb498b5169e2818eU)), ((u64)(0x02fd735519e3bbc2U)), ((u64)(0x15d46f7454b53472U)), ((u64)(0x02645c4414b62fcfU)), ((u64)(0xefba4bed545520b6U)), ((u64)(0x03d3c6d35456b2e4U)), ((u64)(0xf2fb6ff110441a2bU)), ((u64)(0x030fd242a9def583U)), ((u64)(0x8f2f8cc0d9d014efU)), ((u64)(0x02730e9bbb18c469U)), ((u64)(0xb1e5ae015c80217fU)), ((u64)(0x03eb4a92c4f46d75U)), ((u64)(0xc1848b344a001accU)), ((u64)(0x0322a20f03f6bdf7U)), ((u64)(0xce03a2903b3348a3U)), ((u64)(0x02821b3f365efe5fU)), ((u64)(0xd802e873628f6d4fU)), ((u64)(0x0201af65c518cb7fU)), ((u64)(0x599e40b89db2487fU)), ((u64)(0x0335e56fa1c14599U)), ((u64)(0xe14b66fa17c1d399U)), ((u64)(0x029184594e3437adU)), ((u64)(0x81091f2e7967dc7aU)), ((u64)(0x020e037aa4f692f1U)), ((u64)(0x9b41cb7d8f0c93f6U)), ((u64)(0x03499f2aa18a84b5U)), ((u64)(0xaf67d5fe0c0a0ff8U)), ((u64)(0x02a14c221ad536f7U)), ((u64)(0xf2b977fe70080cc7U)), ((u64)(0x021aa34e7bddc592U)), ((u64)(0x1df58cca4cd9ae0bU)), ((u64)(0x035dd2172c9608ebU)), ((u64)(0xe4c470a1d7148b3cU)), ((u64)(0x02b174df56de6d88U)), ((u64)(0x83d05a1b1276d5caU)), ((u64)(0x022790b2abe5246dU)), ((u64)(0x9fb3c35e83f1560fU)), ((u64)(0x0372811ddfd50715U)), ((u64)(0xb2f635e5365aab3fU)), ((u64)(0x02c200e4b310d277U)), ((u64)(0xf591c4b75eaeef66U)), ((u64)(0x0234cd83c273db92U)), ((u64)(0xef4fa125644b18a3U)), ((u64)(0x0387af39371fc5b7U)), ((u64)(0x8c3fb41de9d5ad4fU)), ((u64)(0x02d2f2942c196af9U)), ((u64)(0x3cffc34b2177bdd9U)), ((u64)(0x02425ba9bce12261U)), ((u64)(0x94cc6bab68bf9628U)), ((u64)(0x039d5f75fb01d09bU)), ((u64)(0x10a38955ed6611b9U)), ((u64)(0x02e44c5e6267da16U)), ((u64)(0xda1c6dde5784dafbU)), ((u64)(0x02503d184eb97b44U)), ((u64)(0xf693e2fd58d49191U)), ((u64)(0x03b394f3b128c53aU)), ((u64)(0xc5431bfde0aa0e0eU)), ((u64)(0x02f610c2f4209dc8U)), ((u64)(0x6a9c1664b3bb3e72U)), ((u64)(0x025e73cf29b3b16dU)), ((u64)(0x10f9bd6dec5eca4fU)), ((u64)(0x03ca52e50f85e8afU)), ((u64)(0xda616457f04bd50cU)), ((u64)(0x03084250d937ed58U)), ((u64)(0xe1e783798d09773dU)), ((u64)(0x026d01da475ff113U)), ((u64)(0x030c058f480f252eU)), ((u64)(0x03e19c9072331b53U)), ((u64)(0x68d66ad906728425U)), ((u64)(0x031ae3a6c1c27c42U)), ((u64)(0x8711ef14052869b7U)), ((u64)(0x027be952349b969bU)), ((u64)(0x0b4fe4ecd50d75f2U)), ((u64)(0x03f97550542c242cU)), ((u64)(0xa2a650bd773df7f5U)), ((u64)(0x032df7737689b689U)), ((u64)(0xb551da312c31932aU)), ((u64)(0x028b2c5c5ed49207U)), ((u64)(0x5ddb14f4235adc22U)), ((u64)(0x0208f049e576db39U)), ((u64)(0x2fc4ee536bc49369U)), ((u64)(0x034180763bf15ec2U)), ((u64)(0xbfd0bea92303a921U)), ((u64)(0x029acd2b63277f01U)), ((u64)(0x9973cbba8269541aU)), ((u64)(0x021570ef8285ff34U)), ((u64)(0x5bec792a6a42202aU)), ((u64)(0x0355817f373ccb87U)), ((u64)(0xe3239421ee9b4cefU)), ((u64)(0x02aacdff5f63d605U)), ((u64)(0xb5b6101b25490a59U)), ((u64)(0x02223e65e5e97804U)), ((u64)(0x22bce691d541aa27U)), ((u64)(0x0369fd6fd64259a1U)), ((u64)(0xb563eba7ddce21b9U)), ((u64)(0x02bb31264501e14dU)), ((u64)(0xf78322ecb171b494U)), ((u64)(0x022f5a850401810aU)), ((u64)(0x259e9e47824f8753U)), ((u64)(0x037ef73b399c01abU)), ((u64)(0x1e187e9f9b72d2a9U)), ((u64)(0x02cbf8fc2e1667bcU)), ((u64)(0x4b46cbb2e2c24221U)), ((u64)(0x023cc73024deb963U)), ((u64)(0x120adf849e039d01U)), ((u64)(0x039471e6a1645bd2U)), ((u64)(0xdb3be603b19c7d9aU)), ((u64)(0x02dd27ebb4504974U)), ((u64)(0x7c2feb3627b0647cU)), ((u64)(0x024a865629d9d45dU)), ((u64)(0x2d197856a5e7072cU)), ((u64)(0x03aa7089dc8fba2fU)), ((u64)(0x8a7ac6abb7ec05bdU)), ((u64)(0x02eec06e4a0c94f2U)), ((u64)(0xd52f05562cbcd164U)), ((u64)(0x025899f1d4d6dd8eU)), ((u64)(0x21e4d556adfae8a0U)), ((u64)(0x03c0f64fbaf1627eU)), ((u64)(0xe7ea444557fbed4dU)), ((u64)(0x0300c50c958de864U)), ((u64)(0xecbb69d1132ff10aU)), ((u64)(0x0267040a113e5383U)), ((u64)(0xadf8a94e851981aaU)), ((u64)(0x03d8067681fd526cU)), ((u64)(0x8b2d543ed0e13488U)), ((u64)(0x0313385ece6441f0U)), ((u64)(0xd5bddcff0d80f6d3U)), ((u64)(0x0275c6b23eb69b26U)), ((u64)(0x892fc7fe7c018aebU)), ((u64)(0x03efa45064575ea4U)), ((u64)(0x3a8c9ffec99ad589U)), ((u64)(0x03261d0d1d12b21dU)), ((u64)(0xc8707fff07af113bU)), ((u64)(0x0284e40a7da88e7dU)), ((u64)(0x39f39998d2f2742fU)), ((u64)(0x0203e9a1fe2071feU)), ((u64)(0x8fec28f484b7204bU)), ((u64)(0x033975cffd00b663U)), ((u64)(0xd989ba5d36f8e6a2U)), ((u64)(0x02945e3ffd9a2b82U)), ((u64)(0x47a161e42bfa521cU)), ((u64)(0x02104b66647b5602U)), ((u64)(0x0c35696d132a1cf9U)), ((u64)(0x034d4570a0c5566aU)), ((u64)(0x09c454574288172dU)), ((u64)(0x02a4378d4d6aab88U)), ((u64)(0xa169dd129ba0128bU)), ((u64)(0x021cf93dd7888939U)), ((u64)(0x0242fb50f9001dabU)), ((u64)(0x03618ec958da7529U)), ((u64)(0x9b68c90d940017bcU)), ((u64)(0x02b4723aad7b90edU)), ((u64)(0x4920a0d7a999ac96U)), ((u64)(0x0229f4fbbdfc73f1U)), ((u64)(0x750101590f5c4757U)), ((u64)(0x037654c5fcc71fe8U)), ((u64)(0x2a6734473f7d05dfU)), ((u64)(0x02c5109e63d27fedU)), ((u64)(0xeeb8f69f65fd9e4cU)), ((u64)(0x0237407eb641fff0U)), ((u64)(0xe45b24323cc8fd46U)), ((u64)(0x038b9a6456cfffe7U)), ((u64)(0xb6af502830a0ca9fU)), ((u64)(0x02d6151d123fffecU)), ((u64)(0xf88c402026e7087fU)), ((u64)(0x0244ddb0db666656U)), ((u64)(0x2746cd003e3e73feU)), ((u64)(0x03a162b4923d708bU)), ((u64)(0x1f6bd73364fec332U)), ((u64)(0x02e7822a0e978d3cU)), ((u64)(0xe5efdf5c50cbcf5bU)), ((u64)(0x0252ce880bac70fcU)), ((u64)(0x3cb2fefa1adfb22bU)), ((u64)(0x03b7b0d9ac471b2eU)), ((u64)(0x308f3261af195b56U)), ((u64)(0x02f95a47bd05af58U)), ((u64)(0x5a0c284e25ade2abU)), ((u64)(0x0261150630d15913U)), ((u64)(0x29ad0d49d5e30445U)), ((u64)(0x03ce8809e7b55b52U)), ((u64)(0x548a7107de4f369dU)), ((u64)(0x030ba007ec9115dbU)), ((u64)(0xdd3b8d9fe50c2bb1U)), ((u64)(0x026fb3398a0dab15U)), ((u64)(0x952c15cca1ad12b5U)), ((u64)(0x03e5eb8f434911bcU)), ((u64)(0x775677d6e7bda891U)), ((u64)(0x031e560c35d40e30U)), ((u64)(0xc5dec645863153a7U)), ((u64)(0x027eab3cf7dcd826U))}; // fixed array const
 const u32 _const_symopt_debug = 2147483648; // precomputed2
 i64  total_m = ((i64)(0)); // global4

 int  g_main_argc = ((int)(0)); // global4

 voidptr  g_main_argv = ((void*)0); // global4

 Array_VCastTypeIndexName  as_cast_type_indexes; // global4

 u32  g_original_codepage = ((u32)(0U)); // global4

 const i8 _const_min_i8 = -128; // precomputed2
 const i8 _const_max_i8 = 127; // precomputed2
 const i16 _const_min_i16 = -32768; // precomputed2
 const i16 _const_max_i16 = 32767; // precomputed2
 const i32 _const_min_i32 = -2147483648; // precomputed2
 const i32 _const_max_i32 = 2147483647; // precomputed2
 const i32 _const_min_int = -2147483648; // precomputed2
 const i32 _const_max_int = 2147483647; // precomputed2
i64 _const_min_i64; // inited later
i64 _const_max_i64; // inited later
 const u8 _const_min_u8 = 0; // precomputed2
 const u8 _const_max_u8 = 255; // precomputed2
 const u16 _const_min_u16 = 0; // precomputed2
 const u16 _const_max_u16 = 65535; // precomputed2
 const u32 _const_min_u32 = 0; // precomputed2
 const u32 _const_max_u32 = 4294967295; // precomputed2
 const u64 _const_min_u64 = 0U; // precomputed2
 const u64 _const_max_u64 = 18446744073709551615U; // precomputed2
 const f64 _const_max_load_factor = 0.8; // precomputed2
 const u32 _const_hash_mask = 16777215; // precomputed2
 const u32 _const_probe_inc = 16777216; // precomputed2
IError _const_none__; // inited later
 const u32 _const_children_bytes = 96; // precomputed2
Array_string _const_time__tokens_2; // inited later
Array_string _const_time__tokens_3; // inited later
Array_string _const_time__tokens_4; // inited later
Array_string _const_time__long_days; // inited later
Array_int _const_time__month_days; // inited later
Array_string _const_time__long_months; // inited later
i64 _const_time__absolute_zero_year; // inited later
Array_int _const_time__days_before; // inited later
time__Duration _const_time__nanosecond; // inited later
time__Duration _const_time__infinite; // inited later
u64 _const_time__start_time; // inited later
u64 _const_time__freq_time; // inited later
i64 _const_time__start_local_time; // inited later
isize _const_arrays__extra_size; // inited later
Array_fixed_int_123 _const_encoding__base64__index = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51}; // fixed array const
Array_fixed_int_3 _const_encoding__base64__ending_table = {0, 2, 1}; // fixed array const
string _const_dl__dl_ext; // inited later
 const voidptr _const_dl__rtld_next = (voidptr)(0xffffffffffffffff); // precomputed2
rune _const_encoding__utf8__max_latin_1; // inited later
encoding__utf8__RangeTable _const_encoding__utf8__letter_table; // inited later
encoding__utf8__RangeTable _const_encoding__utf8__white_space_table; // inited later
encoding__utf8__RangeTable _const_encoding__utf8__number_table; // inited later
Array_int _const_encoding__utf8__unicode_punct_western; // inited later
Array_int _const_encoding__utf8__unicode_punct; // inited later
 const u64 _const_rand__constants__lower_mask = 4294967295U; // precomputed2
 const u32 _const_rand__constants__max_u32 = 4294967295; // precomputed2
 const u64 _const_rand__constants__max_u64 = 18446744073709551615U; // precomputed2
 const u32 _const_rand__constants__u31_mask = 2147483647; // precomputed2
 const u64 _const_rand__constants__u63_mask = 9223372036854775807U; // precomputed2
u32 _const_rand__constants__ieee754_mantissa_f32_mask; // inited later
 const u64 _const_rand__constants__ieee754_mantissa_f64_mask = 4503599627370495U; // precomputed2
f64 _const_rand__constants__reciprocal_2_23rd; // inited later
f64 _const_rand__constants__reciprocal_2_52nd; // inited later
 const u64 _const_hash__wyp0 = 11562461410679940143U; // precomputed2
 const u64 _const_hash__wyp1 = 16646288086500911323U; // precomputed2
 const u64 _const_hash__wyp2 = 10285213230658275043U; // precomputed2
 const u64 _const_hash__wyp3 = 6384245875588680899U; // precomputed2
 const u64 _const_hash__wyp4 = 2129725606500045391U; // precomputed2
 const u32 _const_os__handle_generic_read = 2147483648; // precomputed2
 const voidptr _const_os__invalid_handle_value = (voidptr)(0xffffffffffffffff); // precomputed2
 const u32 _const_os__status_access_violation = 3221225477; // precomputed2
 const u32 _const_os__status_in_page_error = 3221225478; // precomputed2
 const u32 _const_os__status_invalid_handle = 3221225480; // precomputed2
 const u32 _const_os__status_invalid_parameter = 3221225485; // precomputed2
 const u32 _const_os__status_no_memory = 3221225495; // precomputed2
 const u32 _const_os__status_illegal_instruction = 3221225501; // precomputed2
 const u32 _const_os__status_noncontinuable_exception = 3221225509; // precomputed2
 const u32 _const_os__status_invalid_disposition = 3221225510; // precomputed2
 const u32 _const_os__status_array_bounds_exceeded = 3221225612; // precomputed2
 const u32 _const_os__status_float_denormal_operand = 3221225613; // precomputed2
 const u32 _const_os__status_float_divide_by_zero = 3221225614; // precomputed2
 const u32 _const_os__status_float_inexact_result = 3221225615; // precomputed2
 const u32 _const_os__status_float_invalid_operation = 3221225616; // precomputed2
 const u32 _const_os__status_float_overflow = 3221225617; // precomputed2
 const u32 _const_os__status_float_stack_check = 3221225618; // precomputed2
 const u32 _const_os__status_float_underflow = 3221225619; // precomputed2
 const u32 _const_os__status_integer_divide_by_zero = 3221225620; // precomputed2
 const u32 _const_os__status_integer_overflow = 3221225621; // precomputed2
 const u32 _const_os__status_privileged_instruction = 3221225622; // precomputed2
 const u32 _const_os__status_stack_overflow = 3221225725; // precomputed2
 const u32 _const_os__status_dll_not_found = 3221225781; // precomputed2
 const u32 _const_os__status_ordinal_not_found = 3221225784; // precomputed2
 const u32 _const_os__status_entrypoint_not_found = 3221225785; // precomputed2
 const u32 _const_os__status_control_c_exit = 3221225786; // precomputed2
 const u32 _const_os__status_dll_init_failed = 3221225794; // precomputed2
 const u32 _const_os__status_float_multiple_faults = 3221226164; // precomputed2
 const u32 _const_os__status_float_multiple_traps = 3221226165; // precomputed2
 const u32 _const_os__status_reg_nat_consumption = 3221226185; // precomputed2
 const u32 _const_os__status_heap_corruption = 3221226356; // precomputed2
 const u32 _const_os__status_stack_buffer_overrun = 3221226505; // precomputed2
 const u32 _const_os__status_invalid_cruntime_parameter = 3221226519; // precomputed2
 const u32 _const_os__status_assertion_failure = 3221226528; // precomputed2
 const voidptr _const_os__hkey_local_machine = (voidptr)(0x80000002); // precomputed2
 const voidptr _const_os__hkey_current_user = (voidptr)(0x80000001); // precomputed2
 const voidptr _const_os__hwnd_broadcast = (voidptr)(0xffff); // precomputed2
 const rune _const_os__fslash = '/'; // precomputed2
 const rune _const_os__dot = '.'; // precomputed2
 const rune _const_os__qmark = '?'; // precomputed2
Array_string _const_os__args; // inited later
string _const_os__wd_at_startup; // inited later
Array_string _const_os__executable_suffixes; // inited later
 u64  g_main_thread_id; // global4

x__json2__Encoder _const_x__json2__default_encoder; // inited later
Array_u8 _const_x__json2__null_in_bytes; // inited later
Array_u8 _const_x__json2__true_in_bytes; // inited later
Array_u8 _const_x__json2__false_in_bytes; // inited later
Array_u8 _const_x__json2__zero_in_bytes; // inited later
Array_u8 _const_x__json2__comma_bytes; // inited later
Array_u8 _const_x__json2__colon_bytes; // inited later
Array_u8 _const_x__json2__space_bytes; // inited later
Array_u8 _const_x__json2__unicode_escape_chars; // inited later
Array_u8 _const_x__json2__quote_bytes; // inited later
Array_Array_u8 _const_x__json2__escaped_chars; // inited later
Array_u8 _const_x__json2__curly_open; // inited later
Array_u8 _const_x__json2__curly_close; // inited later
Array_rune _const_x__json2__char_list; // inited later
Array_rune _const_x__json2__newlines; // inited later
Array_rune _const_x__json2__important_escapable_chars; // inited later
Array_rune _const_x__json2__valid_unicode_escapes; // inited later
Map_int_rune _const_x__json2__unicode_transform_escapes; // inited later
Array_u8 _const_x__json2__exp_signs; // inited later
x__json2__Null _const_x__json2__null; // inited later
 const u32 _const_crypto__sha1__init1 = 4023233417; // precomputed2
 const u32 _const_crypto__sha1__init2 = 2562383102; // precomputed2
 const u32 _const_crypto__sha1__init4 = 3285377520; // precomputed2
 const u32 _const_crypto__sha1___k2 = 2400959708; // precomputed2
 const u32 _const_crypto__sha1___k3 = 3395469782; // precomputed2
 const u64 _const_rand__wyrand__wyp0 = 11562461410679940143U; // precomputed2
 const u64 _const_rand__wyrand__wyp1 = 16646288086500911323U; // precomputed2
 const f64 _const_rand__sqrt2 = 1.4142135623730951; // precomputed2
Array_rune _const_rand__clock_seq_hi_and_reserved_valid_values; // inited later
 rand__PRNG*  default_rng; // global4

 log__Logger*  default_logger; // global4

Array_fixed_u8_16 _const_net__addr_ip6_any = {((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0))}; // fixed array const
Array_fixed_u8_4 _const_net__addr_ip_any = {((u8)(0)), ((u8)(0)), ((u8)(0)), ((u8)(0))}; // fixed array const
u32 _const_net__aoffset; // inited later
time__Time _const_net__no_deadline; // inited later
time__Duration _const_net__no_timeout; // inited later
bool _const_net__is_windows; // inited later
 const net__WsaError _const_net__error_ewouldblock = 10035; // precomputed2
 const net__WsaError _const_net__error_einprogress = 10036; // precomputed2
int _const_net__fionbio; // inited later
Array_net__SocketOption _const_net__opts_bool; // inited later
Array_net__SocketOption _const_net__opts_int; // inited later
Array_net__SocketOption _const_net__opts_can_set; // inited later
 const u16 _const_net__socket_max_port = 65535; // precomputed2
mbedtls_ctr_drbg_context _const_net__mbedtls__ctr_drbg; // inited later
mbedtls_entropy_context _const_net__mbedtls__entropy; // inited later
 const u8 _const_net__socks__socks_version5 = 5; // precomputed2
 const u8 _const_net__socks__addr_type_ipv4 = 1; // precomputed2
 const u8 _const_net__socks__addr_type_fqdn = 3; // precomputed2
 const u8 _const_net__socks__addr_type_ipv6 = 4; // precomputed2
 const u8 _const_net__socks__no_auth = 0; // precomputed2
 const u8 _const_net__socks__auth_user_password = 2; // precomputed2
Map_string_net__http__CommonHeader _const_net__http__common_header_map; // inited later
Array_int _const_net__websocket__invalid_close_codes; // inited later
Array_u8 _const_net__websocket__empty_bytearr; // inited later
 const net__WsaError _const_net__websocket__error_ewouldblock = 10035; // precomputed2
string _const_discord__default_user_agent; // inited later
int _const_discord__all_intents; // inited later
 const u64 _const_discord__snowflake_epoch = 1420070400000U; // precomputed2
time__Duration _const_time__microsecond; // inited later
Array_fixed_int_256 _const_encoding__utf8__props = {_const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, (_const_encoding__utf8__p_z | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_c, _const_encoding__utf8__p_z, (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lo | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), 0, (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lo | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_n | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_p | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_lu | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_s | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr), (_const_encoding__utf8__p_ll | _const_encoding__utf8__p_pr)}; // fixed array const
time__Duration _const_net__infinite_timeout; // inited later
IError _const_net__err_new_socket_failed; // inited later
IError _const_net__err_option_not_settable; // inited later
IError _const_net__err_option_wrong_type; // inited later
IError _const_net__err_port_out_of_range; // inited later
IError _const_net__err_no_udp_remote; // inited later
IError _const_net__err_connect_failed; // inited later
IError _const_net__err_connect_timed_out; // inited later
IError _const_net__err_timed_out; // inited later
IError _const_net__err_connection_refused; // inited later
time__Duration _const_time__millisecond; // inited later
time__Duration _const_time__second; // inited later
time__Duration _const_time__minute; // inited later
i64 _const_net__tcp_default_read_timeout; // inited later
i64 _const_net__tcp_default_write_timeout; // inited later
i64 _const_net__connect_timeout; // inited later
i64 _const_net__udp_default_read_timeout; // inited later
i64 _const_net__udp_default_write_timeout; // inited later
time__Duration _const_time__hour; // inited later

// V interface table:
static IError I_None___to_Interface_IError(None__* x);
 const int _IError_None___index = 0;
static IError I_voidptr_to_Interface_IError(voidptr* x);
 const int _IError_voidptr_index = 1;
static IError I_Error_to_Interface_IError(Error* x);
 const int _IError_Error_index = 2;
static IError I_MessageError_to_Interface_IError(MessageError* x);
 const int _IError_MessageError_index = 3;
static IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x);
 const int _IError_time__TimeParseError_index = 4;
static IError I_io__Eof_to_Interface_IError(io__Eof* x);
 const int _IError_io__Eof_index = 5;
static IError I_io__NotExpected_to_Interface_IError(io__NotExpected* x);
 const int _IError_io__NotExpected_index = 6;
static IError I_os__Eof_to_Interface_IError(os__Eof* x);
 const int _IError_os__Eof_index = 7;
static IError I_os__NotExpected_to_Interface_IError(os__NotExpected* x);
 const int _IError_os__NotExpected_index = 8;
static IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x);
 const int _IError_os__FileNotOpenedError_index = 9;
static IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x);
 const int _IError_os__SizeOfTypeIs0Error_index = 10;
static IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x);
 const int _IError_os__ExecutableNotFoundError_index = 11;
static IError I_x__json2__DecodeError_to_Interface_IError(x__json2__DecodeError* x);
 const int _IError_x__json2__DecodeError_index = 12;
static IError I_x__json2__InvalidTokenError_to_Interface_IError(x__json2__InvalidTokenError* x);
 const int _IError_x__json2__InvalidTokenError_index = 13;
static IError I_x__json2__UnknownTokenError_to_Interface_IError(x__json2__UnknownTokenError* x);
 const int _IError_x__json2__UnknownTokenError_index = 14;
static IError I_net__http__HeaderKeyError_to_Interface_IError(net__http__HeaderKeyError* x);
 const int _IError_net__http__HeaderKeyError_index = 15;
static IError I_discord__InternalServerError_to_Interface_IError(discord__InternalServerError* x);
 const int _IError_discord__InternalServerError_index = 16;
static IError I_discord__Unauthorized_to_Interface_IError(discord__Unauthorized* x);
 const int _IError_discord__Unauthorized_index = 17;
static IError I_discord__Forbidden_to_Interface_IError(discord__Forbidden* x);
 const int _IError_discord__Forbidden_index = 18;
static IError I_discord__NotFound_to_Interface_IError(discord__NotFound* x);
 const int _IError_discord__NotFound_index = 19;
static IError I_discord__Ratelimit_to_Interface_IError(discord__Ratelimit* x);
 const int _IError_discord__Ratelimit_index = 20;
static IError I_discord__RestError_to_Interface_IError(discord__RestError* x);
 const int _IError_discord__RestError_index = 21;
// ^^^ number of types for interface IError: 22

// Methods wrapper for interface "IError"
static inline string None___msg_Interface_IError_method_wrapper(None__* err) {
	return Error_msg(err->Error);
}
static inline int None___code_Interface_IError_method_wrapper(None__* err) {
	return Error_code(err->Error);
}
static inline string Error_msg_Interface_IError_method_wrapper(Error* err) {
	return Error_msg(*err);
}
static inline int Error_code_Interface_IError_method_wrapper(Error* err) {
	return Error_code(*err);
}
static inline string MessageError_msg_Interface_IError_method_wrapper(MessageError* err) {
	return MessageError_msg(*err);
}
static inline int MessageError_code_Interface_IError_method_wrapper(MessageError* err) {
	return MessageError_code(*err);
}
static inline string time__TimeParseError_msg_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return time__TimeParseError_msg(*err);
}
static inline int time__TimeParseError_code_Interface_IError_method_wrapper(time__TimeParseError* err) {
	return Error_code(err->Error);
}
static inline string io__Eof_msg_Interface_IError_method_wrapper(io__Eof* err) {
	return Error_msg(err->Error);
}
static inline int io__Eof_code_Interface_IError_method_wrapper(io__Eof* err) {
	return Error_code(err->Error);
}
static inline string io__NotExpected_msg_Interface_IError_method_wrapper(io__NotExpected* err) {
	return io__NotExpected_msg(*err);
}
static inline int io__NotExpected_code_Interface_IError_method_wrapper(io__NotExpected* err) {
	return io__NotExpected_code(*err);
}
static inline string os__Eof_msg_Interface_IError_method_wrapper(os__Eof* err) {
	return Error_msg(err->Error);
}
static inline int os__Eof_code_Interface_IError_method_wrapper(os__Eof* err) {
	return Error_code(err->Error);
}
static inline string os__NotExpected_msg_Interface_IError_method_wrapper(os__NotExpected* err) {
	return os__NotExpected_msg(*err);
}
static inline int os__NotExpected_code_Interface_IError_method_wrapper(os__NotExpected* err) {
	return os__NotExpected_code(*err);
}
static inline string os__FileNotOpenedError_msg_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return os__FileNotOpenedError_msg(*err);
}
static inline int os__FileNotOpenedError_code_Interface_IError_method_wrapper(os__FileNotOpenedError* err) {
	return Error_code(err->Error);
}
static inline string os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return os__SizeOfTypeIs0Error_msg(*err);
}
static inline int os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper(os__SizeOfTypeIs0Error* err) {
	return Error_code(err->Error);
}
static inline string os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return os__ExecutableNotFoundError_msg(*err);
}
static inline int os__ExecutableNotFoundError_code_Interface_IError_method_wrapper(os__ExecutableNotFoundError* err) {
	return Error_code(err->Error);
}
static inline int x__json2__DecodeError_code_Interface_IError_method_wrapper(x__json2__DecodeError* err) {
	return x__json2__DecodeError_code(*err);
}
static inline string x__json2__DecodeError_msg_Interface_IError_method_wrapper(x__json2__DecodeError* err) {
	return x__json2__DecodeError_msg(*err);
}
static inline int x__json2__InvalidTokenError_code_Interface_IError_method_wrapper(x__json2__InvalidTokenError* err) {
	return x__json2__InvalidTokenError_code(*err);
}
static inline string x__json2__InvalidTokenError_msg_Interface_IError_method_wrapper(x__json2__InvalidTokenError* err) {
	return x__json2__InvalidTokenError_msg(*err);
}
static inline int x__json2__UnknownTokenError_code_Interface_IError_method_wrapper(x__json2__UnknownTokenError* err) {
	return x__json2__UnknownTokenError_code(*err);
}
static inline string x__json2__UnknownTokenError_msg_Interface_IError_method_wrapper(x__json2__UnknownTokenError* err) {
	return x__json2__UnknownTokenError_msg(*err);
}
static inline string net__http__HeaderKeyError_msg_Interface_IError_method_wrapper(net__http__HeaderKeyError* err) {
	return net__http__HeaderKeyError_msg(*err);
}
static inline int net__http__HeaderKeyError_code_Interface_IError_method_wrapper(net__http__HeaderKeyError* err) {
	return net__http__HeaderKeyError_code(*err);
}
static inline int discord__InternalServerError_code_Interface_IError_method_wrapper(discord__InternalServerError* re) {
	return discord__RestError_code(re->RestError);
}
static inline string discord__InternalServerError_msg_Interface_IError_method_wrapper(discord__InternalServerError* re) {
	return discord__RestError_msg(re->RestError);
}
static inline int discord__Unauthorized_code_Interface_IError_method_wrapper(discord__Unauthorized* re) {
	return discord__RestError_code(re->RestError);
}
static inline string discord__Unauthorized_msg_Interface_IError_method_wrapper(discord__Unauthorized* re) {
	return discord__RestError_msg(re->RestError);
}
static inline int discord__Forbidden_code_Interface_IError_method_wrapper(discord__Forbidden* re) {
	return discord__RestError_code(re->RestError);
}
static inline string discord__Forbidden_msg_Interface_IError_method_wrapper(discord__Forbidden* re) {
	return discord__RestError_msg(re->RestError);
}
static inline int discord__NotFound_code_Interface_IError_method_wrapper(discord__NotFound* re) {
	return discord__RestError_code(re->RestError);
}
static inline string discord__NotFound_msg_Interface_IError_method_wrapper(discord__NotFound* re) {
	return discord__RestError_msg(re->RestError);
}
static inline int discord__Ratelimit_code_Interface_IError_method_wrapper(discord__Ratelimit* re) {
	return discord__RestError_code(re->RestError);
}
static inline string discord__Ratelimit_msg_Interface_IError_method_wrapper(discord__Ratelimit* re) {
	return discord__RestError_msg(re->RestError);
}
static inline int discord__RestError_code_Interface_IError_method_wrapper(discord__RestError* re) {
	return discord__RestError_code(*re);
}
static inline string discord__RestError_msg_Interface_IError_method_wrapper(discord__RestError* re) {
	return discord__RestError_msg(*re);
}

struct _IError_interface_methods {
	string (*_method_msg)(void* _);
	int (*_method_code)(void* _);
};

 struct _IError_interface_methods IError_name_table[22] = {
	{
		._method_msg = (void*) None___msg_Interface_IError_method_wrapper,
		._method_code = (void*) None___code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) 0,
		._method_code = (void*) 0,
	},
	{
		._method_msg = (void*) Error_msg_Interface_IError_method_wrapper,
		._method_code = (void*) Error_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) MessageError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) MessageError_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) time__TimeParseError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) time__TimeParseError_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) io__Eof_msg_Interface_IError_method_wrapper,
		._method_code = (void*) io__Eof_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) io__NotExpected_msg_Interface_IError_method_wrapper,
		._method_code = (void*) io__NotExpected_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) os__Eof_msg_Interface_IError_method_wrapper,
		._method_code = (void*) os__Eof_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) os__NotExpected_msg_Interface_IError_method_wrapper,
		._method_code = (void*) os__NotExpected_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) os__FileNotOpenedError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) os__FileNotOpenedError_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) os__SizeOfTypeIs0Error_msg_Interface_IError_method_wrapper,
		._method_code = (void*) os__SizeOfTypeIs0Error_code_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) os__ExecutableNotFoundError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) os__ExecutableNotFoundError_code_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) x__json2__DecodeError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) x__json2__DecodeError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) x__json2__InvalidTokenError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) x__json2__InvalidTokenError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) x__json2__UnknownTokenError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) x__json2__UnknownTokenError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_msg = (void*) net__http__HeaderKeyError_msg_Interface_IError_method_wrapper,
		._method_code = (void*) net__http__HeaderKeyError_code_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) discord__InternalServerError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) discord__InternalServerError_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) discord__Unauthorized_code_Interface_IError_method_wrapper,
		._method_msg = (void*) discord__Unauthorized_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) discord__Forbidden_code_Interface_IError_method_wrapper,
		._method_msg = (void*) discord__Forbidden_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) discord__NotFound_code_Interface_IError_method_wrapper,
		._method_msg = (void*) discord__NotFound_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) discord__Ratelimit_code_Interface_IError_method_wrapper,
		._method_msg = (void*) discord__Ratelimit_msg_Interface_IError_method_wrapper,
	},
	{
		._method_code = (void*) discord__RestError_code_Interface_IError_method_wrapper,
		._method_msg = (void*) discord__RestError_msg_Interface_IError_method_wrapper,
	},
};


// Casting functions for converting "None__" to interface "IError"
static inline IError I_None___to_Interface_IError(None__* x) {
	return (IError) {
		._None__ = x,
		._typ = _IError_None___index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "voidptr" to interface "IError"
static inline IError I_voidptr_to_Interface_IError(voidptr* x) {
	return (IError) {
		._voidptr = x,
		._typ = _IError_voidptr_index,
		.msg = (string*)((char*)x/*.... ast.voidptr_type */),
		.code = (int*)((char*)x/*.... ast.voidptr_type */),
	};
}

// Casting functions for converting "Error" to interface "IError"
static inline IError I_Error_to_Interface_IError(Error* x) {
	return (IError) {
		._Error = x,
		._typ = _IError_Error_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "MessageError" to interface "IError"
static inline IError I_MessageError_to_Interface_IError(MessageError* x) {
	return (IError) {
		._MessageError = x,
		._typ = _IError_MessageError_index,
		.msg = (string*)((char*)x + __offsetof_ptr(x, MessageError, msg)),
		.code = (int*)((char*)x + __offsetof_ptr(x, MessageError, code)),
	};
}

// Casting functions for converting "time__TimeParseError" to interface "IError"
static inline IError I_time__TimeParseError_to_Interface_IError(time__TimeParseError* x) {
	return (IError) {
		._time__TimeParseError = x,
		._typ = _IError_time__TimeParseError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, time__TimeParseError, code)),
	};
}

// Casting functions for converting "io__Eof" to interface "IError"
static inline IError I_io__Eof_to_Interface_IError(io__Eof* x) {
	return (IError) {
		._io__Eof = x,
		._typ = _IError_io__Eof_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "io__NotExpected" to interface "IError"
static inline IError I_io__NotExpected_to_Interface_IError(io__NotExpected* x) {
	return (IError) {
		._io__NotExpected = x,
		._typ = _IError_io__NotExpected_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, io__NotExpected, code)),
	};
}

// Casting functions for converting "os__Eof" to interface "IError"
static inline IError I_os__Eof_to_Interface_IError(os__Eof* x) {
	return (IError) {
		._os__Eof = x,
		._typ = _IError_os__Eof_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "os__NotExpected" to interface "IError"
static inline IError I_os__NotExpected_to_Interface_IError(os__NotExpected* x) {
	return (IError) {
		._os__NotExpected = x,
		._typ = _IError_os__NotExpected_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, os__NotExpected, code)),
	};
}

// Casting functions for converting "os__FileNotOpenedError" to interface "IError"
static inline IError I_os__FileNotOpenedError_to_Interface_IError(os__FileNotOpenedError* x) {
	return (IError) {
		._os__FileNotOpenedError = x,
		._typ = _IError_os__FileNotOpenedError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "os__SizeOfTypeIs0Error" to interface "IError"
static inline IError I_os__SizeOfTypeIs0Error_to_Interface_IError(os__SizeOfTypeIs0Error* x) {
	return (IError) {
		._os__SizeOfTypeIs0Error = x,
		._typ = _IError_os__SizeOfTypeIs0Error_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "os__ExecutableNotFoundError" to interface "IError"
static inline IError I_os__ExecutableNotFoundError_to_Interface_IError(os__ExecutableNotFoundError* x) {
	return (IError) {
		._os__ExecutableNotFoundError = x,
		._typ = _IError_os__ExecutableNotFoundError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "x__json2__DecodeError" to interface "IError"
static inline IError I_x__json2__DecodeError_to_Interface_IError(x__json2__DecodeError* x) {
	return (IError) {
		._x__json2__DecodeError = x,
		._typ = _IError_x__json2__DecodeError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "x__json2__InvalidTokenError" to interface "IError"
static inline IError I_x__json2__InvalidTokenError_to_Interface_IError(x__json2__InvalidTokenError* x) {
	return (IError) {
		._x__json2__InvalidTokenError = x,
		._typ = _IError_x__json2__InvalidTokenError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "x__json2__UnknownTokenError" to interface "IError"
static inline IError I_x__json2__UnknownTokenError_to_Interface_IError(x__json2__UnknownTokenError* x) {
	return (IError) {
		._x__json2__UnknownTokenError = x,
		._typ = _IError_x__json2__UnknownTokenError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x),
	};
}

// Casting functions for converting "net__http__HeaderKeyError" to interface "IError"
static inline IError I_net__http__HeaderKeyError_to_Interface_IError(net__http__HeaderKeyError* x) {
	return (IError) {
		._net__http__HeaderKeyError = x,
		._typ = _IError_net__http__HeaderKeyError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, net__http__HeaderKeyError, code)),
	};
}

// Casting functions for converting "discord__InternalServerError" to interface "IError"
static inline IError I_discord__InternalServerError_to_Interface_IError(discord__InternalServerError* x) {
	return (IError) {
		._discord__InternalServerError = x,
		._typ = _IError_discord__InternalServerError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, discord__InternalServerError, RestError) + __offsetof_ptr(x, discord__RestError, code)),
	};
}

// Casting functions for converting "discord__Unauthorized" to interface "IError"
static inline IError I_discord__Unauthorized_to_Interface_IError(discord__Unauthorized* x) {
	return (IError) {
		._discord__Unauthorized = x,
		._typ = _IError_discord__Unauthorized_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, discord__Unauthorized, RestError) + __offsetof_ptr(x, discord__RestError, code)),
	};
}

// Casting functions for converting "discord__Forbidden" to interface "IError"
static inline IError I_discord__Forbidden_to_Interface_IError(discord__Forbidden* x) {
	return (IError) {
		._discord__Forbidden = x,
		._typ = _IError_discord__Forbidden_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, discord__Forbidden, RestError) + __offsetof_ptr(x, discord__RestError, code)),
	};
}

// Casting functions for converting "discord__NotFound" to interface "IError"
static inline IError I_discord__NotFound_to_Interface_IError(discord__NotFound* x) {
	return (IError) {
		._discord__NotFound = x,
		._typ = _IError_discord__NotFound_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, discord__NotFound, RestError) + __offsetof_ptr(x, discord__RestError, code)),
	};
}

// Casting functions for converting "discord__Ratelimit" to interface "IError"
static inline IError I_discord__Ratelimit_to_Interface_IError(discord__Ratelimit* x) {
	return (IError) {
		._discord__Ratelimit = x,
		._typ = _IError_discord__Ratelimit_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, discord__Ratelimit, RestError) + __offsetof_ptr(x, discord__RestError, code)),
	};
}

// Casting functions for converting "discord__RestError" to interface "IError"
static inline IError I_discord__RestError_to_Interface_IError(discord__RestError* x) {
	return (IError) {
		._discord__RestError = x,
		._typ = _IError_discord__RestError_index,
		.msg = (string*)((char*)x),
		.code = (int*)((char*)x + __offsetof_ptr(x, discord__RestError, code)),
	};
}

static log__Logger I_log__ThreadSafeLog_to_Interface_log__Logger(log__ThreadSafeLog* x);
 const int _log__Logger_log__ThreadSafeLog_index = 0;
static log__Logger I_voidptr_to_Interface_log__Logger(voidptr* x);
 const int _log__Logger_voidptr_index = 1;
static log__Logger I_log__Log_to_Interface_log__Logger(log__Log* x);
 const int _log__Logger_log__Log_index = 2;
// ^^^ number of types for interface log__Logger: 3

// Methods wrapper for interface "log__Logger"

struct _log__Logger_interface_methods {
	log__Level (*_method_get_level)(void* _);
	void (*_method_fatal)(void* _, string s);
	void (*_method__v_error)(void* _, string s);
	void (*_method_warn)(void* _, string s);
	void (*_method_info)(void* _, string s);
	void (*_method_debug)(void* _, string s);
	void (*_method_set_level)(void* _, log__Level level);
	void (*_method__v_free)(void* _);
};

 struct _log__Logger_interface_methods log__Logger_name_table[3] = {
	{
		._method__v_free = (void*) log__ThreadSafeLog_free,
		._method_set_level = (void*) log__ThreadSafeLog_set_level,
		._method_debug = (void*) log__ThreadSafeLog_debug,
		._method_info = (void*) log__ThreadSafeLog_info,
		._method_warn = (void*) log__ThreadSafeLog_warn,
		._method__v_error = (void*) log__ThreadSafeLog_error,
		._method_fatal = (void*) log__ThreadSafeLog_fatal,
		._method_get_level = (void*) log__Log_get_level,
	},
	{
		._method_get_level = (void*) 0,
		._method_fatal = (void*) 0,
		._method__v_error = (void*) 0,
		._method_warn = (void*) 0,
		._method_info = (void*) 0,
		._method_debug = (void*) 0,
		._method_set_level = (void*) 0,
		._method__v_free = (void*) 0,
	},
	{
		._method_get_level = (void*) log__Log_get_level,
		._method_set_level = (void*) log__Log_set_level,
		._method_fatal = (void*) log__Log_fatal,
		._method__v_error = (void*) log__Log_error,
		._method_warn = (void*) log__Log_warn,
		._method_info = (void*) log__Log_info,
		._method_debug = (void*) log__Log_debug,
		._method__v_free = (void*) log__Log_free,
	},
};


// Casting functions for converting "log__ThreadSafeLog" to interface "log__Logger"
static inline log__Logger I_log__ThreadSafeLog_to_Interface_log__Logger(log__ThreadSafeLog* x) {
	return (log__Logger) {
		._log__ThreadSafeLog = x,
		._typ = _log__Logger_log__ThreadSafeLog_index,
	};
}

// Casting functions for converting "voidptr" to interface "log__Logger"
static inline log__Logger I_voidptr_to_Interface_log__Logger(voidptr* x) {
	return (log__Logger) {
		._voidptr = x,
		._typ = _log__Logger_voidptr_index,
	};
}

// Casting functions for converting "log__Log" to interface "log__Logger"
static inline log__Logger I_log__Log_to_Interface_log__Logger(log__Log* x) {
	return (log__Logger) {
		._log__Log = x,
		._typ = _log__Logger_log__Log_index,
	};
}

static discord__Component I_discord__ActionRow_to_Interface_discord__Component(discord__ActionRow* x);
 const int _discord__Component_discord__ActionRow_index = 0;
static discord__Component I_voidptr_to_Interface_discord__Component(voidptr* x);
 const int _discord__Component_voidptr_index = 1;
static discord__Component I_discord__Button_to_Interface_discord__Component(discord__Button* x);
 const int _discord__Component_discord__Button_index = 2;
static discord__Component I_discord__StringSelect_to_Interface_discord__Component(discord__StringSelect* x);
 const int _discord__Component_discord__StringSelect_index = 3;
static discord__Component I_discord__UserSelect_to_Interface_discord__Component(discord__UserSelect* x);
 const int _discord__Component_discord__UserSelect_index = 4;
static discord__Component I_discord__RoleSelect_to_Interface_discord__Component(discord__RoleSelect* x);
 const int _discord__Component_discord__RoleSelect_index = 5;
static discord__Component I_discord__MentionableSelect_to_Interface_discord__Component(discord__MentionableSelect* x);
 const int _discord__Component_discord__MentionableSelect_index = 6;
static discord__Component I_discord__ChannelSelect_to_Interface_discord__Component(discord__ChannelSelect* x);
 const int _discord__Component_discord__ChannelSelect_index = 7;
static discord__Component I_discord__TextInput_to_Interface_discord__Component(discord__TextInput* x);
 const int _discord__Component_discord__TextInput_index = 8;
// ^^^ number of types for interface discord__Component: 9

// Methods wrapper for interface "discord__Component"
static inline void discord__ActionRow_is_component_Interface_discord__Component_method_wrapper(discord__ActionRow* _d1) {
	discord__ActionRow_is_component(*_d1);
}
static inline x__json2__Any discord__ActionRow_build_Interface_discord__Component_method_wrapper(discord__ActionRow* ar) {
	return discord__ActionRow_build(*ar);
}
static inline void discord__Button_is_component_Interface_discord__Component_method_wrapper(discord__Button* _d2) {
	discord__Button_is_component(*_d2);
}
static inline x__json2__Any discord__Button_build_Interface_discord__Component_method_wrapper(discord__Button* b) {
	return discord__Button_build(*b);
}
static inline void discord__StringSelect_is_component_Interface_discord__Component_method_wrapper(discord__StringSelect* _d3) {
	discord__StringSelect_is_component(*_d3);
}
static inline x__json2__Any discord__StringSelect_build_Interface_discord__Component_method_wrapper(discord__StringSelect* ss) {
	return discord__StringSelect_build(*ss);
}
static inline void discord__UserSelect_is_component_Interface_discord__Component_method_wrapper(discord__UserSelect* _d4) {
	discord__UserSelect_is_component(*_d4);
}
static inline x__json2__Any discord__UserSelect_build_Interface_discord__Component_method_wrapper(discord__UserSelect* us) {
	return discord__UserSelect_build(*us);
}
static inline void discord__RoleSelect_is_component_Interface_discord__Component_method_wrapper(discord__RoleSelect* _d5) {
	discord__RoleSelect_is_component(*_d5);
}
static inline x__json2__Any discord__RoleSelect_build_Interface_discord__Component_method_wrapper(discord__RoleSelect* rs) {
	return discord__RoleSelect_build(*rs);
}
static inline void discord__MentionableSelect_is_component_Interface_discord__Component_method_wrapper(discord__MentionableSelect* _d6) {
	discord__MentionableSelect_is_component(*_d6);
}
static inline x__json2__Any discord__MentionableSelect_build_Interface_discord__Component_method_wrapper(discord__MentionableSelect* ms) {
	return discord__MentionableSelect_build(*ms);
}
static inline void discord__ChannelSelect_is_component_Interface_discord__Component_method_wrapper(discord__ChannelSelect* _d7) {
	discord__ChannelSelect_is_component(*_d7);
}
static inline x__json2__Any discord__ChannelSelect_build_Interface_discord__Component_method_wrapper(discord__ChannelSelect* cs) {
	return discord__ChannelSelect_build(*cs);
}
static inline void discord__TextInput_is_component_Interface_discord__Component_method_wrapper(discord__TextInput* _d8) {
	discord__TextInput_is_component(*_d8);
}
static inline x__json2__Any discord__TextInput_build_Interface_discord__Component_method_wrapper(discord__TextInput* ti) {
	return discord__TextInput_build(*ti);
}

struct _discord__Component_interface_methods {
	void (*_method_is_component)(void* _);
	x__json2__Any (*_method_build)(void* _);
};

 struct _discord__Component_interface_methods discord__Component_name_table[9] = {
	{
		._method_is_component = (void*) discord__ActionRow_is_component_Interface_discord__Component_method_wrapper,
		._method_build = (void*) discord__ActionRow_build_Interface_discord__Component_method_wrapper,
	},
	{
		._method_is_component = (void*) 0,
		._method_build = (void*) 0,
	},
	{
		._method_is_component = (void*) discord__Button_is_component_Interface_discord__Component_method_wrapper,
		._method_build = (void*) discord__Button_build_Interface_discord__Component_method_wrapper,
	},
	{
		._method_is_component = (void*) discord__StringSelect_is_component_Interface_discord__Component_method_wrapper,
		._method_build = (void*) discord__StringSelect_build_Interface_discord__Component_method_wrapper,
	},
	{
		._method_is_component = (void*) discord__UserSelect_is_component_Interface_discord__Component_method_wrapper,
		._method_build = (void*) discord__UserSelect_build_Interface_discord__Component_method_wrapper,
	},
	{
		._method_is_component = (void*) discord__RoleSelect_is_component_Interface_discord__Component_method_wrapper,
		._method_build = (void*) discord__RoleSelect_build_Interface_discord__Component_method_wrapper,
	},
	{
		._method_is_component = (void*) discord__MentionableSelect_is_component_Interface_discord__Component_method_wrapper,
		._method_build = (void*) discord__MentionableSelect_build_Interface_discord__Component_method_wrapper,
	},
	{
		._method_is_component = (void*) discord__ChannelSelect_is_component_Interface_discord__Component_method_wrapper,
		._method_build = (void*) discord__ChannelSelect_build_Interface_discord__Component_method_wrapper,
	},
	{
		._method_is_component = (void*) discord__TextInput_is_component_Interface_discord__Component_method_wrapper,
		._method_build = (void*) discord__TextInput_build_Interface_discord__Component_method_wrapper,
	},
};


// Casting functions for converting "discord__ActionRow" to interface "discord__Component"
static inline discord__Component I_discord__ActionRow_to_Interface_discord__Component(discord__ActionRow* x) {
	return (discord__Component) {
		._discord__ActionRow = x,
		._typ = _discord__Component_discord__ActionRow_index,
	};
}

// Casting functions for converting "voidptr" to interface "discord__Component"
static inline discord__Component I_voidptr_to_Interface_discord__Component(voidptr* x) {
	return (discord__Component) {
		._voidptr = x,
		._typ = _discord__Component_voidptr_index,
	};
}

// Casting functions for converting "discord__Button" to interface "discord__Component"
static inline discord__Component I_discord__Button_to_Interface_discord__Component(discord__Button* x) {
	return (discord__Component) {
		._discord__Button = x,
		._typ = _discord__Component_discord__Button_index,
	};
}

// Casting functions for converting "discord__StringSelect" to interface "discord__Component"
static inline discord__Component I_discord__StringSelect_to_Interface_discord__Component(discord__StringSelect* x) {
	return (discord__Component) {
		._discord__StringSelect = x,
		._typ = _discord__Component_discord__StringSelect_index,
	};
}

// Casting functions for converting "discord__UserSelect" to interface "discord__Component"
static inline discord__Component I_discord__UserSelect_to_Interface_discord__Component(discord__UserSelect* x) {
	return (discord__Component) {
		._discord__UserSelect = x,
		._typ = _discord__Component_discord__UserSelect_index,
	};
}

// Casting functions for converting "discord__RoleSelect" to interface "discord__Component"
static inline discord__Component I_discord__RoleSelect_to_Interface_discord__Component(discord__RoleSelect* x) {
	return (discord__Component) {
		._discord__RoleSelect = x,
		._typ = _discord__Component_discord__RoleSelect_index,
	};
}

// Casting functions for converting "discord__MentionableSelect" to interface "discord__Component"
static inline discord__Component I_discord__MentionableSelect_to_Interface_discord__Component(discord__MentionableSelect* x) {
	return (discord__Component) {
		._discord__MentionableSelect = x,
		._typ = _discord__Component_discord__MentionableSelect_index,
	};
}

// Casting functions for converting "discord__ChannelSelect" to interface "discord__Component"
static inline discord__Component I_discord__ChannelSelect_to_Interface_discord__Component(discord__ChannelSelect* x) {
	return (discord__Component) {
		._discord__ChannelSelect = x,
		._typ = _discord__Component_discord__ChannelSelect_index,
	};
}

// Casting functions for converting "discord__TextInput" to interface "discord__Component"
static inline discord__Component I_discord__TextInput_to_Interface_discord__Component(discord__TextInput* x) {
	return (discord__Component) {
		._discord__TextInput = x,
		._typ = _discord__Component_discord__TextInput_index,
	};
}

static discord__Image I_discord__JpegImage_to_Interface_discord__Image(discord__JpegImage* x);
 const int _discord__Image_discord__JpegImage_index = 0;
static discord__Image I_voidptr_to_Interface_discord__Image(voidptr* x);
 const int _discord__Image_voidptr_index = 1;
static discord__Image I_discord__PngImage_to_Interface_discord__Image(discord__PngImage* x);
 const int _discord__Image_discord__PngImage_index = 2;
static discord__Image I_discord__GifImage_to_Interface_discord__Image(discord__GifImage* x);
 const int _discord__Image_discord__GifImage_index = 3;
// ^^^ number of types for interface discord__Image: 4

// Methods wrapper for interface "discord__Image"
static inline void discord__JpegImage_is_image_Interface_discord__Image_method_wrapper(discord__JpegImage* _d9) {
	discord__JpegImage_is_image(*_d9);
}
static inline string discord__JpegImage_build_Interface_discord__Image_method_wrapper(discord__JpegImage* ji) {
	return discord__JpegImage_build(*ji);
}
static inline void discord__PngImage_is_image_Interface_discord__Image_method_wrapper(discord__PngImage* _d10) {
	discord__PngImage_is_image(*_d10);
}
static inline string discord__PngImage_build_Interface_discord__Image_method_wrapper(discord__PngImage* pi) {
	return discord__PngImage_build(*pi);
}
static inline void discord__GifImage_is_image_Interface_discord__Image_method_wrapper(discord__GifImage* _d11) {
	discord__GifImage_is_image(*_d11);
}
static inline string discord__GifImage_build_Interface_discord__Image_method_wrapper(discord__GifImage* gi) {
	return discord__GifImage_build(*gi);
}

struct _discord__Image_interface_methods {
	void (*_method_is_image)(void* _);
	string (*_method_build)(void* _);
};

 struct _discord__Image_interface_methods discord__Image_name_table[4] = {
	{
		._method_is_image = (void*) discord__JpegImage_is_image_Interface_discord__Image_method_wrapper,
		._method_build = (void*) discord__JpegImage_build_Interface_discord__Image_method_wrapper,
	},
	{
		._method_is_image = (void*) 0,
		._method_build = (void*) 0,
	},
	{
		._method_is_image = (void*) discord__PngImage_is_image_Interface_discord__Image_method_wrapper,
		._method_build = (void*) discord__PngImage_build_Interface_discord__Image_method_wrapper,
	},
	{
		._method_is_image = (void*) discord__GifImage_is_image_Interface_discord__Image_method_wrapper,
		._method_build = (void*) discord__GifImage_build_Interface_discord__Image_method_wrapper,
	},
};


// Casting functions for converting "discord__JpegImage" to interface "discord__Image"
static inline discord__Image I_discord__JpegImage_to_Interface_discord__Image(discord__JpegImage* x) {
	return (discord__Image) {
		._discord__JpegImage = x,
		._typ = _discord__Image_discord__JpegImage_index,
		.data = (Array_u8*)((char*)x + __offsetof_ptr(x, discord__JpegImage, data)),
	};
}

// Casting functions for converting "voidptr" to interface "discord__Image"
static inline discord__Image I_voidptr_to_Interface_discord__Image(voidptr* x) {
	return (discord__Image) {
		._voidptr = x,
		._typ = _discord__Image_voidptr_index,
		.data = (Array_u8*)((char*)x/*.... ast.voidptr_type */),
	};
}

// Casting functions for converting "discord__PngImage" to interface "discord__Image"
static inline discord__Image I_discord__PngImage_to_Interface_discord__Image(discord__PngImage* x) {
	return (discord__Image) {
		._discord__PngImage = x,
		._typ = _discord__Image_discord__PngImage_index,
		.data = (Array_u8*)((char*)x + __offsetof_ptr(x, discord__PngImage, data)),
	};
}

// Casting functions for converting "discord__GifImage" to interface "discord__Image"
static inline discord__Image I_discord__GifImage_to_Interface_discord__Image(discord__GifImage* x) {
	return (discord__Image) {
		._discord__GifImage = x,
		._typ = _discord__Image_discord__GifImage_index,
		.data = (Array_u8*)((char*)x + __offsetof_ptr(x, discord__GifImage, data)),
	};
}

static io__Writer I_io__MultiWriter_to_Interface_io__Writer(io__MultiWriter* x);
 const int _io__Writer_io__MultiWriter_index = 0;
static io__Writer I_voidptr_to_Interface_io__Writer(voidptr* x);
 const int _io__Writer_voidptr_index = 1;
static io__Writer I_strings__Builder_to_Interface_io__Writer(strings__Builder* x);
 const int _io__Writer_strings__Builder_index = 2;
static io__Writer I_os__File_to_Interface_io__Writer(os__File* x);
 const int _io__Writer_os__File_index = 3;
static io__Writer I_net__TcpConn_to_Interface_io__Writer(net__TcpConn* x);
 const int _io__Writer_net__TcpConn_index = 4;
static io__Writer I_net__ssl__SSLConn_to_Interface_io__Writer(net__ssl__SSLConn* x);
 const int _io__Writer_net__ssl__SSLConn_index = 5;
static io__Writer I_io__ReaderWriterImpl_to_Interface_io__Writer(io__ReaderWriterImpl* x);
 const int _io__Writer_io__ReaderWriterImpl_index = 6;
static io__Writer I_net__UdpConn_to_Interface_io__Writer(net__UdpConn* x);
 const int _io__Writer_net__UdpConn_index = 7;
static io__Writer I_net__mbedtls__SSLConn_to_Interface_io__Writer(net__mbedtls__SSLConn* x);
 const int _io__Writer_net__mbedtls__SSLConn_index = 8;
static io__Writer I_crypto__sha1__Digest_to_Interface_io__Writer(crypto__sha1__Digest* x);
 const int _io__Writer_crypto__sha1__Digest_index = 9;
// ^^^ number of types for interface io__Writer: 10

// Methods wrapper for interface "io__Writer"

struct _io__Writer_interface_methods {
	_result_int (*_method_write)(void* _, Array_u8 buf);
};

 struct _io__Writer_interface_methods io__Writer_name_table[10] = {
	{
		._method_write = (void*) io__MultiWriter_write,
	},
	{
		._method_write = (void*) 0,
	},
	{
		._method_write = (void*) strings__Builder_write,
	},
	{
		._method_write = (void*) os__File_write,
	},
	{
		._method_write = (void*) net__TcpConn_write,
	},
	{
		._method_write = (void*) net__mbedtls__SSLConn_write,
	},
	{
		._method_write = (void*) io__ReaderWriterImpl_write,
	},
	{
		._method_write = (void*) net__UdpConn_write,
	},
	{
		._method_write = (void*) net__mbedtls__SSLConn_write,
	},
	{
		._method_write = (void*) crypto__sha1__Digest_write,
	},
};


// Casting functions for converting "io__MultiWriter" to interface "io__Writer"
static inline io__Writer I_io__MultiWriter_to_Interface_io__Writer(io__MultiWriter* x) {
	return (io__Writer) {
		._io__MultiWriter = x,
		._typ = _io__Writer_io__MultiWriter_index,
	};
}

// Casting functions for converting "voidptr" to interface "io__Writer"
static inline io__Writer I_voidptr_to_Interface_io__Writer(voidptr* x) {
	return (io__Writer) {
		._voidptr = x,
		._typ = _io__Writer_voidptr_index,
	};
}

// Casting functions for converting "strings__Builder" to interface "io__Writer"
static inline io__Writer I_strings__Builder_to_Interface_io__Writer(strings__Builder* x) {
	return (io__Writer) {
		._strings__Builder = x,
		._typ = _io__Writer_strings__Builder_index,
	};
}

// Casting functions for converting "os__File" to interface "io__Writer"
static inline io__Writer I_os__File_to_Interface_io__Writer(os__File* x) {
	return (io__Writer) {
		._os__File = x,
		._typ = _io__Writer_os__File_index,
	};
}

// Casting functions for converting "net__TcpConn" to interface "io__Writer"
static inline io__Writer I_net__TcpConn_to_Interface_io__Writer(net__TcpConn* x) {
	return (io__Writer) {
		._net__TcpConn = x,
		._typ = _io__Writer_net__TcpConn_index,
	};
}

// Casting functions for converting "net__ssl__SSLConn" to interface "io__Writer"
static inline io__Writer I_net__ssl__SSLConn_to_Interface_io__Writer(net__ssl__SSLConn* x) {
	return (io__Writer) {
		._net__ssl__SSLConn = x,
		._typ = _io__Writer_net__ssl__SSLConn_index,
	};
}

// Casting functions for converting "io__ReaderWriterImpl" to interface "io__Writer"
static inline io__Writer I_io__ReaderWriterImpl_to_Interface_io__Writer(io__ReaderWriterImpl* x) {
	return (io__Writer) {
		._io__ReaderWriterImpl = x,
		._typ = _io__Writer_io__ReaderWriterImpl_index,
	};
}

// Casting functions for converting "net__UdpConn" to interface "io__Writer"
static inline io__Writer I_net__UdpConn_to_Interface_io__Writer(net__UdpConn* x) {
	return (io__Writer) {
		._net__UdpConn = x,
		._typ = _io__Writer_net__UdpConn_index,
	};
}

// Casting functions for converting "net__mbedtls__SSLConn" to interface "io__Writer"
static inline io__Writer I_net__mbedtls__SSLConn_to_Interface_io__Writer(net__mbedtls__SSLConn* x) {
	return (io__Writer) {
		._net__mbedtls__SSLConn = x,
		._typ = _io__Writer_net__mbedtls__SSLConn_index,
	};
}

// Casting functions for converting "crypto__sha1__Digest" to interface "io__Writer"
static inline io__Writer I_crypto__sha1__Digest_to_Interface_io__Writer(crypto__sha1__Digest* x) {
	return (io__Writer) {
		._crypto__sha1__Digest = x,
		._typ = _io__Writer_crypto__sha1__Digest_index,
	};
}

static x__json2__Encodable I_x__json2__Any_to_Interface_x__json2__Encodable(x__json2__Any* x);
 const int _x__json2__Encodable_x__json2__Any_index = 0;
static x__json2__Encodable I_voidptr_to_Interface_x__json2__Encodable(voidptr* x);
 const int _x__json2__Encodable_voidptr_index = 1;
// ^^^ number of types for interface x__json2__Encodable: 2

// Methods wrapper for interface "x__json2__Encodable"
static inline string x__json2__Any_json_str_Interface_x__json2__Encodable_method_wrapper(x__json2__Any* f) {
	return x__json2__Any_json_str(*f);
}

struct _x__json2__Encodable_interface_methods {
	string (*_method_json_str)(void* _);
};

 struct _x__json2__Encodable_interface_methods x__json2__Encodable_name_table[2] = {
	{
		._method_json_str = (void*) x__json2__Any_json_str_Interface_x__json2__Encodable_method_wrapper,
	},
	{
		._method_json_str = (void*) 0,
	},
};


// Casting functions for converting "x__json2__Any" to interface "x__json2__Encodable"
static inline x__json2__Encodable I_x__json2__Any_to_Interface_x__json2__Encodable(x__json2__Any* x) {
	return (x__json2__Encodable) {
		._x__json2__Any = x,
		._typ = _x__json2__Encodable_x__json2__Any_index,
	};
}

// Casting functions for converting "voidptr" to interface "x__json2__Encodable"
static inline x__json2__Encodable I_voidptr_to_Interface_x__json2__Encodable(voidptr* x) {
	return (x__json2__Encodable) {
		._voidptr = x,
		._typ = _x__json2__Encodable_voidptr_index,
	};
}

// ^^^ number of types for interface x__json2__Decodable: 0

// Methods wrapper for interface "x__json2__Decodable"

struct _x__json2__Decodable_interface_methods {
	void (*_method_from_json)(void* _, x__json2__Any f);
};

 struct _x__json2__Decodable_interface_methods x__json2__Decodable_name_table[1];



static net__http__Handler I_net__http__DebugHandler_to_Interface_net__http__Handler(net__http__DebugHandler* x);
 const int _net__http__Handler_net__http__DebugHandler_index = 0;
static net__http__Handler I_voidptr_to_Interface_net__http__Handler(voidptr* x);
 const int _net__http__Handler_voidptr_index = 1;
// ^^^ number of types for interface net__http__Handler: 2

// Methods wrapper for interface "net__http__Handler"
static inline net__http__Response net__http__DebugHandler_handle_Interface_net__http__Handler_method_wrapper(net__http__DebugHandler* d, net__http__Request req) {
	return net__http__DebugHandler_handle(*d, req);
}

struct _net__http__Handler_interface_methods {
	net__http__Response (*_method_handle)(void* _, net__http__Request );
};

 struct _net__http__Handler_interface_methods net__http__Handler_name_table[2] = {
	{
		._method_handle = (void*) net__http__DebugHandler_handle_Interface_net__http__Handler_method_wrapper,
	},
	{
		._method_handle = (void*) 0,
	},
};


// Casting functions for converting "net__http__DebugHandler" to interface "net__http__Handler"
static inline net__http__Handler I_net__http__DebugHandler_to_Interface_net__http__Handler(net__http__DebugHandler* x) {
	return (net__http__Handler) {
		._net__http__DebugHandler = x,
		._typ = _net__http__Handler_net__http__DebugHandler_index,
	};
}

// Casting functions for converting "voidptr" to interface "net__http__Handler"
static inline net__http__Handler I_voidptr_to_Interface_net__http__Handler(voidptr* x) {
	return (net__http__Handler) {
		._voidptr = x,
		._typ = _net__http__Handler_voidptr_index,
	};
}

static io__Reader I_net__TcpConn_to_Interface_io__Reader(net__TcpConn* x);
 const int _io__Reader_net__TcpConn_index = 0;
static io__Reader I_voidptr_to_Interface_io__Reader(voidptr* x);
 const int _io__Reader_voidptr_index = 1;
static io__Reader I_os__File_to_Interface_io__Reader(os__File* x);
 const int _io__Reader_os__File_index = 2;
static io__Reader I_net__ssl__SSLConn_to_Interface_io__Reader(net__ssl__SSLConn* x);
 const int _io__Reader_net__ssl__SSLConn_index = 3;
static io__Reader I_io__BufferedReader_to_Interface_io__Reader(io__BufferedReader* x);
 const int _io__Reader_io__BufferedReader_index = 4;
static io__Reader I_io__ReaderWriterImpl_to_Interface_io__Reader(io__ReaderWriterImpl* x);
 const int _io__Reader_io__ReaderWriterImpl_index = 5;
static io__Reader I_net__mbedtls__SSLConn_to_Interface_io__Reader(net__mbedtls__SSLConn* x);
 const int _io__Reader_net__mbedtls__SSLConn_index = 6;
// ^^^ number of types for interface io__Reader: 7

// Methods wrapper for interface "io__Reader"
static inline _result_int net__TcpConn_read_Interface_io__Reader_method_wrapper(net__TcpConn* c, Array_u8* buf) {
	return net__TcpConn_read(*c, buf);
}

struct _io__Reader_interface_methods {
	_result_int (*_method_read)(void* _, Array_u8* buf);
};

 struct _io__Reader_interface_methods io__Reader_name_table[7] = {
	{
		._method_read = (void*) net__TcpConn_read_Interface_io__Reader_method_wrapper,
	},
	{
		._method_read = (void*) 0,
	},
	{
		._method_read = (void*) os__File_read,
	},
	{
		._method_read = (void*) net__mbedtls__SSLConn_read,
	},
	{
		._method_read = (void*) io__BufferedReader_read,
	},
	{
		._method_read = (void*) io__ReaderWriterImpl_read,
	},
	{
		._method_read = (void*) net__mbedtls__SSLConn_read,
	},
};


// Casting functions for converting "net__TcpConn" to interface "io__Reader"
static inline io__Reader I_net__TcpConn_to_Interface_io__Reader(net__TcpConn* x) {
	return (io__Reader) {
		._net__TcpConn = x,
		._typ = _io__Reader_net__TcpConn_index,
	};
}

// Casting functions for converting "voidptr" to interface "io__Reader"
static inline io__Reader I_voidptr_to_Interface_io__Reader(voidptr* x) {
	return (io__Reader) {
		._voidptr = x,
		._typ = _io__Reader_voidptr_index,
	};
}

// Casting functions for converting "os__File" to interface "io__Reader"
static inline io__Reader I_os__File_to_Interface_io__Reader(os__File* x) {
	return (io__Reader) {
		._os__File = x,
		._typ = _io__Reader_os__File_index,
	};
}

// Casting functions for converting "net__ssl__SSLConn" to interface "io__Reader"
static inline io__Reader I_net__ssl__SSLConn_to_Interface_io__Reader(net__ssl__SSLConn* x) {
	return (io__Reader) {
		._net__ssl__SSLConn = x,
		._typ = _io__Reader_net__ssl__SSLConn_index,
	};
}

// Casting functions for converting "io__BufferedReader" to interface "io__Reader"
static inline io__Reader I_io__BufferedReader_to_Interface_io__Reader(io__BufferedReader* x) {
	return (io__Reader) {
		._io__BufferedReader = x,
		._typ = _io__Reader_io__BufferedReader_index,
	};
}

// Casting functions for converting "io__ReaderWriterImpl" to interface "io__Reader"
static inline io__Reader I_io__ReaderWriterImpl_to_Interface_io__Reader(io__ReaderWriterImpl* x) {
	return (io__Reader) {
		._io__ReaderWriterImpl = x,
		._typ = _io__Reader_io__ReaderWriterImpl_index,
	};
}

// Casting functions for converting "net__mbedtls__SSLConn" to interface "io__Reader"
static inline io__Reader I_net__mbedtls__SSLConn_to_Interface_io__Reader(net__mbedtls__SSLConn* x) {
	return (io__Reader) {
		._net__mbedtls__SSLConn = x,
		._typ = _io__Reader_net__mbedtls__SSLConn_index,
	};
}

static io__RandomReader I_os__File_to_Interface_io__RandomReader(os__File* x);
 const int _io__RandomReader_os__File_index = 0;
static io__RandomReader I_voidptr_to_Interface_io__RandomReader(voidptr* x);
 const int _io__RandomReader_voidptr_index = 1;
// ^^^ number of types for interface io__RandomReader: 2

// Methods wrapper for interface "io__RandomReader"

struct _io__RandomReader_interface_methods {
	_result_int (*_method_read_from)(void* _, u64 pos, Array_u8* buf);
};

 struct _io__RandomReader_interface_methods io__RandomReader_name_table[2] = {
	{
		._method_read_from = (void*) os__File_read_from,
	},
	{
		._method_read_from = (void*) 0,
	},
};


// Casting functions for converting "os__File" to interface "io__RandomReader"
static inline io__RandomReader I_os__File_to_Interface_io__RandomReader(os__File* x) {
	return (io__RandomReader) {
		._os__File = x,
		._typ = _io__RandomReader_os__File_index,
	};
}

// Casting functions for converting "voidptr" to interface "io__RandomReader"
static inline io__RandomReader I_voidptr_to_Interface_io__RandomReader(voidptr* x) {
	return (io__RandomReader) {
		._voidptr = x,
		._typ = _io__RandomReader_voidptr_index,
	};
}

static io__ReaderWriter I_io__ReaderWriterImpl_to_Interface_io__ReaderWriter(io__ReaderWriterImpl* x);
 const int _io__ReaderWriter_io__ReaderWriterImpl_index = 0;
static io__ReaderWriter I_voidptr_to_Interface_io__ReaderWriter(voidptr* x);
 const int _io__ReaderWriter_voidptr_index = 1;
// ^^^ number of types for interface io__ReaderWriter: 2

// Methods wrapper for interface "io__ReaderWriter"

struct _io__ReaderWriter_interface_methods {
	_result_int (*_method_read)(void* _, Array_u8* buf);
	_result_int (*_method_write)(void* _, Array_u8 buf);
};

 struct _io__ReaderWriter_interface_methods io__ReaderWriter_name_table[2] = {
	{
		._method_read = (void*) io__ReaderWriterImpl_read,
		._method_write = (void*) io__ReaderWriterImpl_write,
	},
	{
		._method_read = (void*) 0,
		._method_write = (void*) 0,
	},
};


// Casting functions for converting "io__ReaderWriterImpl" to interface "io__ReaderWriter"
static inline io__ReaderWriter I_io__ReaderWriterImpl_to_Interface_io__ReaderWriter(io__ReaderWriterImpl* x) {
	return (io__ReaderWriter) {
		._io__ReaderWriterImpl = x,
		._typ = _io__ReaderWriter_io__ReaderWriterImpl_index,
	};
}

// Casting functions for converting "voidptr" to interface "io__ReaderWriter"
static inline io__ReaderWriter I_voidptr_to_Interface_io__ReaderWriter(voidptr* x) {
	return (io__ReaderWriter) {
		._voidptr = x,
		._typ = _io__ReaderWriter_voidptr_index,
	};
}

// ^^^ number of types for interface io__RandomWriter: 0

// Methods wrapper for interface "io__RandomWriter"

struct _io__RandomWriter_interface_methods {
	_result_int (*_method_write_to)(void* _, u64 pos, Array_u8 buf);
};

 struct _io__RandomWriter_interface_methods io__RandomWriter_name_table[1];



static rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x);
 const int _rand__PRNG_rand__wyrand__WyRandRNG_index = 0;
static rand__PRNG I_voidptr_to_Interface_rand__PRNG(voidptr* x);
 const int _rand__PRNG_voidptr_index = 1;
// ^^^ number of types for interface rand__PRNG: 2

// Methods wrapper for interface "rand__PRNG"

struct _rand__PRNG_interface_methods {
	void (*_method_seed)(void* _, Array_u32 seed_data);
	u8 (*_method_u8)(void* _);
	u16 (*_method_u16)(void* _);
	u32 (*_method_u32)(void* _);
	u64 (*_method_u64)(void* _);
	int (*_method_block_size)(void* _);
	void (*_method__v_free)(void* _);
};

 struct _rand__PRNG_interface_methods rand__PRNG_name_table[2] = {
	{
		._method_seed = (void*) rand__wyrand__WyRandRNG_seed,
		._method_u8 = (void*) rand__wyrand__WyRandRNG_u8,
		._method_u16 = (void*) rand__wyrand__WyRandRNG_u16,
		._method_u32 = (void*) rand__wyrand__WyRandRNG_u32,
		._method_u64 = (void*) rand__wyrand__WyRandRNG_u64,
		._method_block_size = (void*) rand__wyrand__WyRandRNG_block_size,
		._method__v_free = (void*) rand__wyrand__WyRandRNG_free,
	},
	{
		._method_seed = (void*) 0,
		._method_u8 = (void*) 0,
		._method_u16 = (void*) 0,
		._method_u32 = (void*) 0,
		._method_u64 = (void*) 0,
		._method_block_size = (void*) 0,
		._method__v_free = (void*) 0,
	},
};


// Casting functions for converting "rand__wyrand__WyRandRNG" to interface "rand__PRNG"
static inline rand__PRNG I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rand__wyrand__WyRandRNG* x) {
	return (rand__PRNG) {
		._rand__wyrand__WyRandRNG = x,
		._typ = _rand__PRNG_rand__wyrand__WyRandRNG_index,
	};
}

// Casting functions for converting "voidptr" to interface "rand__PRNG"
static inline rand__PRNG I_voidptr_to_Interface_rand__PRNG(voidptr* x) {
	return (rand__PRNG) {
		._voidptr = x,
		._typ = _rand__PRNG_voidptr_index,
	};
}

static hash__Hasher I_crypto__sha1__Digest_to_Interface_hash__Hasher(crypto__sha1__Digest* x);
 const int _hash__Hasher_crypto__sha1__Digest_index = 0;
static hash__Hasher I_voidptr_to_Interface_hash__Hasher(voidptr* x);
 const int _hash__Hasher_voidptr_index = 1;
// ^^^ number of types for interface hash__Hasher: 2

// Methods wrapper for interface "hash__Hasher"

struct _hash__Hasher_interface_methods {
	Array_u8 (*_method_sum)(void* _, Array_u8 b);
	int (*_method_size)(void* _);
	int (*_method_block_size)(void* _);
};

 struct _hash__Hasher_interface_methods hash__Hasher_name_table[2] = {
	{
		._method_sum = (void*) crypto__sha1__Digest_sum,
		._method_size = (void*) crypto__sha1__Digest_size,
		._method_block_size = (void*) crypto__sha1__Digest_block_size,
	},
	{
		._method_sum = (void*) 0,
		._method_size = (void*) 0,
		._method_block_size = (void*) 0,
	},
};


// Casting functions for converting "crypto__sha1__Digest" to interface "hash__Hasher"
static inline hash__Hasher I_crypto__sha1__Digest_to_Interface_hash__Hasher(crypto__sha1__Digest* x) {
	return (hash__Hasher) {
		._crypto__sha1__Digest = x,
		._typ = _hash__Hasher_crypto__sha1__Digest_index,
	};
}

// Casting functions for converting "voidptr" to interface "hash__Hasher"
static inline hash__Hasher I_voidptr_to_Interface_hash__Hasher(voidptr* x) {
	return (hash__Hasher) {
		._voidptr = x,
		._typ = _hash__Hasher_voidptr_index,
	};
}

// ^^^ number of types for interface hash__Hash32er: 0

// Methods wrapper for interface "hash__Hash32er"

struct _hash__Hash32er_interface_methods {
	u32 (*_method_sum32)(void* _);
};

 struct _hash__Hash32er_interface_methods hash__Hash32er_name_table[1];



// ^^^ number of types for interface hash__Hash64er: 0

// Methods wrapper for interface "hash__Hash64er"

struct _hash__Hash64er_interface_methods {
	u64 (*_method_sum64)(void* _);
};

 struct _hash__Hash64er_interface_methods hash__Hash64er_name_table[1];





// V gowrappers:

void __v_thread_wait(__v_thread thread) {
	u32 stat = WaitForSingleObject(thread, INFINITE);
	if (stat != 0) { _v_panic(_SLIT("unable to join thread")); }
	CloseHandle(thread);
}
u32 net__http__HandlerWorker_process_requests_thread_wrapper(thread_arg_net__http__HandlerWorker_process_requests *arg) {
	arg->fn(arg->arg0);
	_v_free(arg);
	return 0;
}
u32 net__websocket__Server_handle_ping_thread_wrapper(thread_arg_net__websocket__Server_handle_ping *arg) {
	arg->fn(arg->arg0);
	_v_free(arg);
	return 0;
}
u32 net__websocket__Server_serve_client_thread_wrapper(thread_arg_net__websocket__Server_serve_client *arg) {
	*((_result_void*)(arg->ret_ptr)) = arg->fn(arg->arg0, arg->arg1);
	_v_free(arg);
	return 0;
}
u32 _thread_wrapper(thread_arg_ *arg) {
	arg->fn(arg->arg1, arg->arg2, arg->arg3);
	_v_free(arg);
	return 0;
}

void Array___v_thread_wait(Array___v_thread a) {
	for (int i = 0; i < a.len; ++i) {
		__v_thread t = ((__v_thread*)a.data)[i];
		if (t == 0) continue;
		__v_thread_wait(t);
	}
}
u32 anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255_thread_wrapper(thread_arg_anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255 *arg) {
	*((_result_int*)(arg->ret_ptr)) = arg->fn(arg->arg1, arg->arg2);
	_v_free(arg);
	return 0;
}

// V shared type functions:
static inline voidptr __dup__shared__net__websocket__ServerState(voidptr src, int sz) {
	__shared__net__websocket__ServerState* dest = memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
static inline voidptr __dup__shared__net__websocket__ClientState(voidptr src, int sz) {
	__shared__net__websocket__ClientState* dest = memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}

typedef struct __shared_map __shared_map;
struct __shared_map {
	sync__RwMutex mtx;
	map val;
};
static inline voidptr __dup_shared_map(voidptr src, int sz) {
	__shared_map* dest = memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
typedef struct __shared_array __shared_array;
struct __shared_array {
	sync__RwMutex mtx;
	array val;
};
static inline voidptr __dup_shared_array(voidptr src, int sz) {
	__shared_array* dest = memdup(src, sz);
	sync__RwMutex_init(&dest->mtx);
	return dest;
}
static inline void __sort_ptr(uintptr_t a[], bool b[], int l) {
	for (int i=1; i<l; i++) {
		uintptr_t ins = a[i];
		bool insb = b[i];
		int j = i;
		while(j>0 && a[j-1] > ins) {
			a[j] = a[j-1];
			b[j] = b[j-1];
			j--;
		}
		a[j] = ins;
		b[j] = insb;
	}
}

// V channel code:

static inline net__TcpConn* __chan_net__TcpConn_ptr_popval(chan_net__TcpConn_ptr ch) {
	net__TcpConn* val;
	sync__Channel_try_pop_priv(ch, &val, false);
	return val;
}

static inline void __chan_net__TcpConn_ptr_pushval(chan_net__TcpConn_ptr ch, net__TcpConn* val) {
	sync__Channel_try_push_priv(ch, &val, false);
}

static inline discord__DispatchEvent_T_discord__GatewayClient __chan_discord__DispatchEvent_T_discord__GatewayClient_popval(chan_discord__DispatchEvent_T_discord__GatewayClient ch) {
	discord__DispatchEvent_T_discord__GatewayClient val;
	sync__Channel_try_pop_priv(ch, &val, false);
	return val;
}

static inline void __chan_discord__DispatchEvent_T_discord__GatewayClient_pushval(chan_discord__DispatchEvent_T_discord__GatewayClient ch, discord__DispatchEvent_T_discord__GatewayClient val) {
	sync__Channel_try_push_priv(ch, &val, false);
}

static inline _option_net__TcpConn_ptr __Option_chan_net__TcpConn_ptr_popval(chan_net__TcpConn_ptr ch) {
	_option_net__TcpConn_ptr _tmp = {0};
	if (sync__Channel_try_pop_priv(ch, _tmp.data, false)) {
		return (_option_net__TcpConn_ptr){ .state = 2, .err = _v_error(_SLIT("channel closed")), .data = {EMPTY_STRUCT_INITIALIZATION} };
	}
	return _tmp;
}

// V auto str functions:
static string time__FormatTime_str(time__FormatTime it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatTime__hhmm12: return _SLIT("hhmm12");
		case time__FormatTime__hhmm24: return _SLIT("hhmm24");
		case time__FormatTime__hhmmss12: return _SLIT("hhmmss12");
		case time__FormatTime__hhmmss24: return _SLIT("hhmmss24");
		case time__FormatTime__hhmmss24_milli: return _SLIT("hhmmss24_milli");
		case time__FormatTime__hhmmss24_micro: return _SLIT("hhmmss24_micro");
		case time__FormatTime__hhmmss24_nano: return _SLIT("hhmmss24_nano");
		case time__FormatTime__no_time: return _SLIT("no_time");
		default: return _SLIT("unknown enum value");
	}
}
static string time__FormatDate_str(time__FormatDate it) { /* gen_str_for_enum */
	switch(it) {
		case time__FormatDate__ddmmyy: return _SLIT("ddmmyy");
		case time__FormatDate__ddmmyyyy: return _SLIT("ddmmyyyy");
		case time__FormatDate__mmddyy: return _SLIT("mmddyy");
		case time__FormatDate__mmddyyyy: return _SLIT("mmddyyyy");
		case time__FormatDate__mmmd: return _SLIT("mmmd");
		case time__FormatDate__mmmdd: return _SLIT("mmmdd");
		case time__FormatDate__mmmddyy: return _SLIT("mmmddyy");
		case time__FormatDate__mmmddyyyy: return _SLIT("mmmddyyyy");
		case time__FormatDate__no_date: return _SLIT("no_date");
		case time__FormatDate__yyyymmdd: return _SLIT("yyyymmdd");
		case time__FormatDate__yymmdd: return _SLIT("yymmdd");
		default: return _SLIT("unknown enum value");
	}
}
static string x__json2__TokenKind_str(x__json2__TokenKind it) { /* gen_str_for_enum */
	switch(it) {
		case x__json2__TokenKind__none_: return _SLIT("none_");
		case x__json2__TokenKind__error: return _SLIT("error");
		case x__json2__TokenKind__str_: return _SLIT("str_");
		case x__json2__TokenKind__float: return _SLIT("float");
		case x__json2__TokenKind__int_: return _SLIT("int_");
		case x__json2__TokenKind__null: return _SLIT("null");
		case x__json2__TokenKind__bool_: return _SLIT("bool_");
		case x__json2__TokenKind__eof: return _SLIT("eof");
		case x__json2__TokenKind__comma: return _SLIT("comma");
		case x__json2__TokenKind__colon: return _SLIT("colon");
		case x__json2__TokenKind__lsbr: return _SLIT("lsbr");
		case x__json2__TokenKind__rsbr: return _SLIT("rsbr");
		case x__json2__TokenKind__lcbr: return _SLIT("lcbr");
		case x__json2__TokenKind__rcbr: return _SLIT("rcbr");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_u8_str(Array_u8 a) { return indent_Array_u8_str(a, 0);}
static string indent_Array_u8_str(Array_u8 a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		u8 it = *(u8*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = u8_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string net__WsaError_str(net__WsaError it) { /* gen_str_for_enum */
	switch(it) {
		case net__WsaError__wsaeintr: return _SLIT("wsaeintr");
		case net__WsaError__wsaebadf: return _SLIT("wsaebadf");
		case net__WsaError__wsaeacces: return _SLIT("wsaeacces");
		case net__WsaError__wsaefault: return _SLIT("wsaefault");
		case net__WsaError__wsaeinval: return _SLIT("wsaeinval");
		case net__WsaError__wsaemfile: return _SLIT("wsaemfile");
		case net__WsaError__wsaewouldblock: return _SLIT("wsaewouldblock");
		case net__WsaError__wsaeinprogress: return _SLIT("wsaeinprogress");
		case net__WsaError__wsaealready: return _SLIT("wsaealready");
		case net__WsaError__wsaenotsock: return _SLIT("wsaenotsock");
		case net__WsaError__wsaedestaddrreq: return _SLIT("wsaedestaddrreq");
		case net__WsaError__wsaemsgsize: return _SLIT("wsaemsgsize");
		case net__WsaError__wsaeprototype: return _SLIT("wsaeprototype");
		case net__WsaError__wsaenoprotoopt: return _SLIT("wsaenoprotoopt");
		case net__WsaError__wsaeprotonosupport: return _SLIT("wsaeprotonosupport");
		case net__WsaError__wsaesocktnosupport: return _SLIT("wsaesocktnosupport");
		case net__WsaError__wsaeopnotsupp: return _SLIT("wsaeopnotsupp");
		case net__WsaError__wsaepfnosupport: return _SLIT("wsaepfnosupport");
		case net__WsaError__wsaeafnosupport: return _SLIT("wsaeafnosupport");
		case net__WsaError__wsaeaddrinuse: return _SLIT("wsaeaddrinuse");
		case net__WsaError__wsaeaddrnotavail: return _SLIT("wsaeaddrnotavail");
		case net__WsaError__wsaenetdown: return _SLIT("wsaenetdown");
		case net__WsaError__wsaenetunreach: return _SLIT("wsaenetunreach");
		case net__WsaError__wsaenetreset: return _SLIT("wsaenetreset");
		case net__WsaError__wsaeconnaborted: return _SLIT("wsaeconnaborted");
		case net__WsaError__wsaeconnreset: return _SLIT("wsaeconnreset");
		case net__WsaError__wsaenobufs: return _SLIT("wsaenobufs");
		case net__WsaError__wsaeisconn: return _SLIT("wsaeisconn");
		case net__WsaError__wsaenotconn: return _SLIT("wsaenotconn");
		case net__WsaError__wsaeshutdown: return _SLIT("wsaeshutdown");
		case net__WsaError__wsaetoomanyrefs: return _SLIT("wsaetoomanyrefs");
		case net__WsaError__wsaetimedout: return _SLIT("wsaetimedout");
		case net__WsaError__wsaeconnrefused: return _SLIT("wsaeconnrefused");
		case net__WsaError__wsaeloop: return _SLIT("wsaeloop");
		case net__WsaError__wsaenametoolong: return _SLIT("wsaenametoolong");
		case net__WsaError__wsaehostdown: return _SLIT("wsaehostdown");
		case net__WsaError__wsaehostunreach: return _SLIT("wsaehostunreach");
		case net__WsaError__wsaenotempty: return _SLIT("wsaenotempty");
		case net__WsaError__wsaeproclim: return _SLIT("wsaeproclim");
		case net__WsaError__wsaeusers: return _SLIT("wsaeusers");
		case net__WsaError__wsaedquot: return _SLIT("wsaedquot");
		case net__WsaError__wsaestale: return _SLIT("wsaestale");
		case net__WsaError__wsaeremote: return _SLIT("wsaeremote");
		case net__WsaError__wsasysnotready: return _SLIT("wsasysnotready");
		case net__WsaError__wsavernotsupported: return _SLIT("wsavernotsupported");
		case net__WsaError__wsanotinitialised: return _SLIT("wsanotinitialised");
		case net__WsaError__wsaediscon: return _SLIT("wsaediscon");
		case net__WsaError__wsaenomore: return _SLIT("wsaenomore");
		case net__WsaError__wsaecancelled: return _SLIT("wsaecancelled");
		case net__WsaError__wsaeinvalidproctable: return _SLIT("wsaeinvalidproctable");
		case net__WsaError__wsaeinvalidprovider: return _SLIT("wsaeinvalidprovider");
		case net__WsaError__wsaeproviderfailedinit: return _SLIT("wsaeproviderfailedinit");
		case net__WsaError__wsasyscallfailure: return _SLIT("wsasyscallfailure");
		case net__WsaError__wsaservice_not_found: return _SLIT("wsaservice_not_found");
		case net__WsaError__wsatype_not_found: return _SLIT("wsatype_not_found");
		case net__WsaError__wsa_e_no_more: return _SLIT("wsa_e_no_more");
		case net__WsaError__wsa_e_cancelled: return _SLIT("wsa_e_cancelled");
		case net__WsaError__wsaerefused: return _SLIT("wsaerefused");
		case net__WsaError__wsahost_not_found: return _SLIT("wsahost_not_found");
		case net__WsaError__wsatry_again: return _SLIT("wsatry_again");
		case net__WsaError__wsano_recovery: return _SLIT("wsano_recovery");
		case net__WsaError__wsano_data: return _SLIT("wsano_data");
		case net__WsaError__wsa_qos_receivers: return _SLIT("wsa_qos_receivers");
		case net__WsaError__wsa_qos_senders: return _SLIT("wsa_qos_senders");
		case net__WsaError__wsa_qos_no_senders: return _SLIT("wsa_qos_no_senders");
		case net__WsaError__wsa_qos_no_receivers: return _SLIT("wsa_qos_no_receivers");
		case net__WsaError__wsa_qos_request_confirmed: return _SLIT("wsa_qos_request_confirmed");
		case net__WsaError__wsa_qos_admission_failure: return _SLIT("wsa_qos_admission_failure");
		case net__WsaError__wsa_qos_policy_failure: return _SLIT("wsa_qos_policy_failure");
		case net__WsaError__wsa_qos_bad_style: return _SLIT("wsa_qos_bad_style");
		case net__WsaError__wsa_qos_bad_object: return _SLIT("wsa_qos_bad_object");
		case net__WsaError__wsa_qos_traffic_ctrl_error: return _SLIT("wsa_qos_traffic_ctrl_error");
		case net__WsaError__wsa_qos_generic_error: return _SLIT("wsa_qos_generic_error");
		case net__WsaError__wsa_qos_eservicetype: return _SLIT("wsa_qos_eservicetype");
		case net__WsaError__wsa_qos_eflowspec: return _SLIT("wsa_qos_eflowspec");
		case net__WsaError__wsa_qos_eprovspecbuf: return _SLIT("wsa_qos_eprovspecbuf");
		case net__WsaError__wsa_qos_efilterstyle: return _SLIT("wsa_qos_efilterstyle");
		case net__WsaError__wsa_qos_efiltertype: return _SLIT("wsa_qos_efiltertype");
		case net__WsaError__wsa_qos_efiltercount: return _SLIT("wsa_qos_efiltercount");
		case net__WsaError__wsa_qos_eobjlength: return _SLIT("wsa_qos_eobjlength");
		case net__WsaError__wsa_qos_eflowcount: return _SLIT("wsa_qos_eflowcount");
		case net__WsaError__wsa_qos_eunkownpsobj: return _SLIT("wsa_qos_eunkownpsobj");
		case net__WsaError__wsa_qos_epolicyobj: return _SLIT("wsa_qos_epolicyobj");
		case net__WsaError__wsa_qos_eflowdesc: return _SLIT("wsa_qos_eflowdesc");
		case net__WsaError__wsa_qos_epsflowspec: return _SLIT("wsa_qos_epsflowspec");
		case net__WsaError__wsa_qos_epsfilterspec: return _SLIT("wsa_qos_epsfilterspec");
		case net__WsaError__wsa_qos_esdmodeobj: return _SLIT("wsa_qos_esdmodeobj");
		case net__WsaError__wsa_qos_eshaperateobj: return _SLIT("wsa_qos_eshaperateobj");
		case net__WsaError__wsa_qos_reserved_petype: return _SLIT("wsa_qos_reserved_petype");
		case net__WsaError__wsa_secure_host_not_found: return _SLIT("wsa_secure_host_not_found");
		case net__WsaError__wsa_ipsec_name_policy_error: return _SLIT("wsa_ipsec_name_policy_error");
		default: return _SLIT("unknown enum value");
	}
}
static string net__TcpSocket_str(net__TcpSocket it) { return indent_net__TcpSocket_str(it, 0);}
static string net__websocket__Frame_str(net__websocket__Frame it) { return indent_net__websocket__Frame_str(it, 0);}
static string net__websocket__OPCode_str(net__websocket__OPCode it) { /* gen_str_for_enum */
	switch(it) {
		case net__websocket__OPCode__continuation: return _SLIT("continuation");
		case net__websocket__OPCode__text_frame: return _SLIT("text_frame");
		case net__websocket__OPCode__binary_frame: return _SLIT("binary_frame");
		case net__websocket__OPCode__close: return _SLIT("close");
		case net__websocket__OPCode__ping: return _SLIT("ping");
		case net__websocket__OPCode__pong: return _SLIT("pong");
		default: return _SLIT("unknown enum value");
	}
}
static string net__websocket__State_str(net__websocket__State it) { /* gen_str_for_enum */
	switch(it) {
		case net__websocket__State__connecting: return _SLIT("connecting");
		case net__websocket__State__open: return _SLIT("open");
		case net__websocket__State__closing: return _SLIT("closing");
		case net__websocket__State__closed: return _SLIT("closed");
		default: return _SLIT("unknown enum value");
	}
}
static string discord__WSMessage_str(discord__WSMessage it) { return indent_discord__WSMessage_str(it, 0);}
static string discord__Guild_str(discord__Guild it) { return indent_discord__Guild_str(it, 0);}
static string net__Socket_str(net__Socket it) { return indent_net__Socket_str(it, 0);}
static string Array_fixed_u8_4_str(Array_fixed_u8_4 a) { return indent_Array_fixed_u8_4_str(a, 0);}
static string indent_Array_fixed_u8_4_str(Array_fixed_u8_4 a, int indent_count) {
	strings__Builder sb = strings__new_builder(4 * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < 4; ++i) {
		strings__Builder_write_string(&sb, u8_str(a[i]));
		if (i < 3) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
string _option_int_str(_option_int it) { return indent__option_int_str(it, 0); }
string indent__option_int_str(_option_int it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = int_str(*(int*)it.data);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
static string discord__Snowflake_str(discord__Snowflake it) { return indent_discord__Snowflake_str(it, 0); }
static string indent_discord__Snowflake_str(discord__Snowflake it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string tmp_ds = u64_str(it);
	string res = str_intp(3, _MOV((StrIntpData[]){
		{_SLIT0, 0xfe10, {.d_s = indents }},
		{_SLIT("discord.Snowflake("), 0xfe10, {.d_s = tmp_ds }},
		{_SLIT(")"), 0, {.d_c = 0 }}
	}));
	string_free(&indents);
	string_free(&tmp_ds);
	return res;
}
string _option_string_str(_option_string it) { return indent__option_string_str(it, 0); }
string indent__option_string_str(_option_string it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = string_str(*(string*)it.data)}},{_SLIT("'"), 0, {.d_c = 0 }}}));
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
string _option_discord__Snowflake_str(_option_discord__Snowflake it) { return indent__option_discord__Snowflake_str(it, 0); }
string indent__option_discord__Snowflake_str(_option_discord__Snowflake it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = indent_discord__Snowflake_str(*(discord__Snowflake*)it.data, indent_count);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
string _option_bool_str(_option_bool it) { return indent__option_bool_str(it, 0); }
string indent__option_bool_str(_option_bool it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = bool_str(*(bool*)it.data);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
static string discord__VerificationLevel_str(discord__VerificationLevel it) { /* gen_str_for_enum */
	switch(it) {
		case discord__VerificationLevel__none_: return _SLIT("none_");
		case discord__VerificationLevel__low: return _SLIT("low");
		case discord__VerificationLevel__medium: return _SLIT("medium");
		case discord__VerificationLevel__high: return _SLIT("high");
		case discord__VerificationLevel__very_high: return _SLIT("very_high");
		default: return _SLIT("unknown enum value");
	}
}
static string discord__MessageNotificationsLevel_str(discord__MessageNotificationsLevel it) { /* gen_str_for_enum */
	switch(it) {
		case discord__MessageNotificationsLevel__all_messages: return _SLIT("all_messages");
		case discord__MessageNotificationsLevel__only_mentions: return _SLIT("only_mentions");
		default: return _SLIT("unknown enum value");
	}
}
static string discord__ExplicitContentFilterLevel_str(discord__ExplicitContentFilterLevel it) { /* gen_str_for_enum */
	switch(it) {
		case discord__ExplicitContentFilterLevel__disabled: return _SLIT("disabled");
		case discord__ExplicitContentFilterLevel__members_without_roles: return _SLIT("members_without_roles");
		case discord__ExplicitContentFilterLevel__all_members: return _SLIT("all_members");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_discord__Role_str(Array_discord__Role a) { return indent_Array_discord__Role_str(a, 0);}
static string indent_Array_discord__Role_str(Array_discord__Role a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		discord__Role it = *(discord__Role*)array_get(a, i);
		string x = indent_discord__Role_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_discord__Emoji_str(Array_discord__Emoji a) { return indent_Array_discord__Emoji_str(a, 0);}
static string indent_Array_discord__Emoji_str(Array_discord__Emoji a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		discord__Emoji it = *(discord__Emoji*)array_get(a, i);
		string x = indent_discord__Emoji_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string Array_discord__GuildFeature_str(Array_discord__GuildFeature a) { return indent_Array_discord__GuildFeature_str(a, 0);}
static string indent_Array_discord__GuildFeature_str(Array_discord__GuildFeature a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		string it = *(string*)array_get(a, i);
		string x = str_intp(2, _MOV((StrIntpData[]){{_SLIT("'"), 0xfe10, {.d_s = it }}, {_SLIT("'"), 0, {.d_c = 0 }}}));

		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string discord__MFALevel_str(discord__MFALevel it) { /* gen_str_for_enum */
	switch(it) {
		case discord__MFALevel__none_: return _SLIT("none_");
		case discord__MFALevel__elevated: return _SLIT("elevated");
		default: return _SLIT("unknown enum value");
	}
}
static string discord__SystemChannelFlags_str(discord__SystemChannelFlags it) { /* gen_str_for_enum */
	string ret = _SLIT("discord.SystemChannelFlags{");
	int first = 1;
	u64 zit = (u64)it;
	if (zit & 0x0000000000000001U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".suppress_join_notifications")); first = 0;}
	if (zit & 0x0000000000000002U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".suppress_premium_subscriptions")); first = 0;}
	if (zit & 0x0000000000000004U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".suppress_guild_reminder_notifications")); first = 0;}
	if (zit & 0x0000000000000008U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".suppress_join_notification_replies")); first = 0;}
	if (zit & 0x0000000000000010U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".suppress_role_subscription_purchase_notifications")); first = 0;}
	if (zit & 0x0000000000000020U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".suppress_role_subscription_purchase_notifications_replies")); first = 0;}
	ret = string__plus(ret, _SLIT("}"));
	return ret;
}
static string discord__PremiumTier_str(discord__PremiumTier it) { /* gen_str_for_enum */
	switch(it) {
		case discord__PremiumTier__none_: return _SLIT("none_");
		case discord__PremiumTier__tier_1: return _SLIT("tier_1");
		case discord__PremiumTier__tier_2: return _SLIT("tier_2");
		case discord__PremiumTier__tier_3: return _SLIT("tier_3");
		default: return _SLIT("unknown enum value");
	}
}
string _option_discord__WelcomeScreen_str(_option_discord__WelcomeScreen it) { return indent__option_discord__WelcomeScreen_str(it, 0); }
string indent__option_discord__WelcomeScreen_str(_option_discord__WelcomeScreen it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = indent_discord__WelcomeScreen_str(*(discord__WelcomeScreen*)it.data, indent_count);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
static string discord__NSFWLevel_str(discord__NSFWLevel it) { /* gen_str_for_enum */
	switch(it) {
		case discord__NSFWLevel__default: return _SLIT("default");
		case discord__NSFWLevel__explicit: return _SLIT("explicit");
		case discord__NSFWLevel__safe: return _SLIT("safe");
		case discord__NSFWLevel__age_restricted: return _SLIT("age_restricted");
		default: return _SLIT("unknown enum value");
	}
}
static string Array_discord__Sticker_str(Array_discord__Sticker a) { return indent_Array_discord__Sticker_str(a, 0);}
static string indent_Array_discord__Sticker_str(Array_discord__Sticker a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		discord__Sticker it = *(discord__Sticker*)array_get(a, i);
		string x = indent_discord__Sticker_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string discord__Role_str(discord__Role it) { return indent_discord__Role_str(it, 0);}
static string discord__Emoji_str(discord__Emoji it) { return indent_discord__Emoji_str(it, 0);}
static string discord__WelcomeScreen_str(discord__WelcomeScreen it) { return indent_discord__WelcomeScreen_str(it, 0);}
static string discord__Sticker_str(discord__Sticker it) { return indent_discord__Sticker_str(it, 0);}
static string discord__Permissions_str(discord__Permissions it) { /* gen_str_for_enum */
	string ret = _SLIT("discord.Permissions{");
	int first = 1;
	u64 zit = (u64)it;
	if (zit & 0x0000000000000001U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".create_instant_invite")); first = 0;}
	if (zit & 0x0000000000000002U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".kick_members")); first = 0;}
	if (zit & 0x0000000000000004U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".ban_members")); first = 0;}
	if (zit & 0x0000000000000008U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".administrator")); first = 0;}
	if (zit & 0x0000000000000010U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_channels")); first = 0;}
	if (zit & 0x0000000000000020U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_guild")); first = 0;}
	if (zit & 0x0000000000000040U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".add_reactions")); first = 0;}
	if (zit & 0x0000000000000080U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".view_audit_log")); first = 0;}
	if (zit & 0x0000000000000100U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".priority_speaker")); first = 0;}
	if (zit & 0x0000000000000200U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".stream")); first = 0;}
	if (zit & 0x0000000000000400U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".view_channel")); first = 0;}
	if (zit & 0x0000000000000800U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".send_messages")); first = 0;}
	if (zit & 0x0000000000001000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".send_tts_messages")); first = 0;}
	if (zit & 0x0000000000002000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_messages")); first = 0;}
	if (zit & 0x0000000000004000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".embed_links")); first = 0;}
	if (zit & 0x0000000000008000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".attach_files")); first = 0;}
	if (zit & 0x0000000000010000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".read_message_history")); first = 0;}
	if (zit & 0x0000000000020000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".mention_everyone")); first = 0;}
	if (zit & 0x0000000000040000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".use_external_emojis")); first = 0;}
	if (zit & 0x0000000000080000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".view_guild_insights")); first = 0;}
	if (zit & 0x0000000000100000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".connect")); first = 0;}
	if (zit & 0x0000000000200000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".speak")); first = 0;}
	if (zit & 0x0000000000400000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".mute_members")); first = 0;}
	if (zit & 0x0000000000800000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".deafen_members")); first = 0;}
	if (zit & 0x0000000001000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".move_members")); first = 0;}
	if (zit & 0x0000000002000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".use_vad")); first = 0;}
	if (zit & 0x0000000004000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".change_nickname")); first = 0;}
	if (zit & 0x0000000008000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_nicknames")); first = 0;}
	if (zit & 0x0000000010000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_roles")); first = 0;}
	if (zit & 0x0000000020000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_webhooks")); first = 0;}
	if (zit & 0x0000000040000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_guild_expressions")); first = 0;}
	if (zit & 0x0000000080000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".use_application_commands")); first = 0;}
	if (zit & 0x0000000100000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".request_to_speak")); first = 0;}
	if (zit & 0x0000000200000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_events")); first = 0;}
	if (zit & 0x0000000400000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".manage_threads")); first = 0;}
	if (zit & 0x0000000800000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".create_public_threads")); first = 0;}
	if (zit & 0x0000001000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".create_private_threads")); first = 0;}
	if (zit & 0x0000002000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".use_external_stickers")); first = 0;}
	if (zit & 0x0000004000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".send_messages_in_threads")); first = 0;}
	if (zit & 0x0000008000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".use_embedded_activities")); first = 0;}
	if (zit & 0x0000010000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".moderate_members")); first = 0;}
	if (zit & 0x0000020000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".view_creator_monetization_analytics")); first = 0;}
	if (zit & 0x0000040000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".use_soundboard")); first = 0;}
	if (zit & 0x0000080000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".create_guild_expressions")); first = 0;}
	if (zit & 0x0000100000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".create_events")); first = 0;}
	if (zit & 0x0000200000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".use_external_sounds")); first = 0;}
	if (zit & 0x0000400000000000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".send_voice_messages")); first = 0;}
	ret = string__plus(ret, _SLIT("}"));
	return ret;
}
string _option_discord__RoleTags_str(_option_discord__RoleTags it) { return indent__option_discord__RoleTags_str(it, 0); }
string indent__option_discord__RoleTags_str(_option_discord__RoleTags it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = indent_discord__RoleTags_str(*(discord__RoleTags*)it.data, indent_count);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
static string discord__RoleFlags_str(discord__RoleFlags it) { /* gen_str_for_enum */
	string ret = _SLIT("discord.RoleFlags{");
	int first = 1;
	u64 zit = (u64)it;
	if (zit & 0x0000000000000001U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".in_prompt")); first = 0;}
	ret = string__plus(ret, _SLIT("}"));
	return ret;
}
string _option_Array_discord__Snowflake_str(_option_Array_discord__Snowflake it) { return indent__option_Array_discord__Snowflake_str(it, 0); }
string indent__option_Array_discord__Snowflake_str(_option_Array_discord__Snowflake it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = indent_Array_discord__Snowflake_str(*(Array_discord__Snowflake*)it.data, indent_count);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
string _option_discord__User_str(_option_discord__User it) { return indent__option_discord__User_str(it, 0); }
string indent__option_discord__User_str(_option_discord__User it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = indent_discord__User_str(*(discord__User*)it.data, indent_count);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
static string Array_discord__WelcomeChannel_str(Array_discord__WelcomeChannel a) { return indent_Array_discord__WelcomeChannel_str(a, 0);}
static string indent_Array_discord__WelcomeChannel_str(Array_discord__WelcomeChannel a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		discord__WelcomeChannel it = *(discord__WelcomeChannel*)array_get(a, i);
		string x = indent_discord__WelcomeChannel_str(it, indent_count);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string discord__StickerType_str(discord__StickerType it) { /* gen_str_for_enum */
	switch(it) {
		case discord__StickerType__standard: return _SLIT("standard");
		case discord__StickerType__guild: return _SLIT("guild");
		default: return _SLIT("unknown enum value");
	}
}
static string discord__StickerFormatType_str(discord__StickerFormatType it) { /* gen_str_for_enum */
	switch(it) {
		case discord__StickerFormatType__png: return _SLIT("png");
		case discord__StickerFormatType__apng: return _SLIT("apng");
		case discord__StickerFormatType__lottie: return _SLIT("lottie");
		case discord__StickerFormatType__gif: return _SLIT("gif");
		default: return _SLIT("unknown enum value");
	}
}
static string discord__RoleTags_str(discord__RoleTags it) { return indent_discord__RoleTags_str(it, 0);}
static string Array_discord__Snowflake_str(Array_discord__Snowflake a) { return indent_Array_discord__Snowflake_str(a, 0);}
static string indent_Array_discord__Snowflake_str(Array_discord__Snowflake a, int indent_count) {
	strings__Builder sb = strings__new_builder(a.len * 10);
	strings__Builder_write_string(&sb, _SLIT("["));
	for (int i = 0; i < a.len; ++i) {
		u64 it = *(u64*)array_get(a, i);
		strings__Builder_write_string(&sb, _SLIT(""));
		string x = u64_str(it);
		strings__Builder_write_string(&sb, x);
		if (i < a.len-1) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_string(&sb, _SLIT("]"));
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}
static string discord__User_str(discord__User it) { return indent_discord__User_str(it, 0);}
static string discord__WelcomeChannel_str(discord__WelcomeChannel it) { return indent_discord__WelcomeChannel_str(it, 0);}
string _option_discord__UserFlags_str(_option_discord__UserFlags it) { return indent__option_discord__UserFlags_str(it, 0); }
string indent__option_discord__UserFlags_str(_option_discord__UserFlags it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = discord__UserFlags_str(*(discord__UserFlags*)it.data);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
string _option_discord__PremiumType_str(_option_discord__PremiumType it) { return indent__option_discord__PremiumType_str(it, 0); }
string indent__option_discord__PremiumType_str(_option_discord__PremiumType it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = discord__PremiumType_str(*(discord__PremiumType*)it.data);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
string _option_discord__AvatarDecorationData_str(_option_discord__AvatarDecorationData it) { return indent__option_discord__AvatarDecorationData_str(it, 0); }
string indent__option_discord__AvatarDecorationData_str(_option_discord__AvatarDecorationData it, int indent_count) {
	string res;
	if (it.state == 0) {
		res = indent_discord__AvatarDecorationData_str(*(discord__AvatarDecorationData*)it.data, indent_count);
		return str_intp(2, _MOV((StrIntpData[]){{_SLIT("Option("), 0xfe10, {.d_s = res }},{_SLIT(")"), 0, {.d_c = 0}}}));
	}
	return _SLIT("Option(none)");
}
static string discord__UserFlags_str(discord__UserFlags it) { /* gen_str_for_enum */
	string ret = _SLIT("discord.UserFlags{");
	int first = 1;
	u64 zit = (u64)it;
	if (zit & 0x0000000000000001U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".staff")); first = 0;}
	if (zit & 0x0000000000000002U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".partner")); first = 0;}
	if (zit & 0x0000000000000004U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".hypesquad")); first = 0;}
	if (zit & 0x0000000000000008U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".bug_hunter_level_1")); first = 0;}
	if (zit & 0x0000000000000010U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".reserved_4")); first = 0;}
	if (zit & 0x0000000000000020U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".reserved_5")); first = 0;}
	if (zit & 0x0000000000000040U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".hypesquad_online_house_1")); first = 0;}
	if (zit & 0x0000000000000080U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".hypesquad_online_house_2")); first = 0;}
	if (zit & 0x0000000000000100U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".hypesquad_online_house_3")); first = 0;}
	if (zit & 0x0000000000000200U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".premium_early_supporter")); first = 0;}
	if (zit & 0x0000000000000400U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".team_pseudo_user")); first = 0;}
	if (zit & 0x0000000000000800U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".reserved_11")); first = 0;}
	if (zit & 0x0000000000001000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".reserved_12")); first = 0;}
	if (zit & 0x0000000000002000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".reserved_13")); first = 0;}
	if (zit & 0x0000000000004000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".bug_hunter_level_2")); first = 0;}
	if (zit & 0x0000000000008000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".reserved_15")); first = 0;}
	if (zit & 0x0000000000010000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".verified_bot")); first = 0;}
	if (zit & 0x0000000000020000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".verified_developer")); first = 0;}
	if (zit & 0x0000000000040000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".certified_moderator")); first = 0;}
	if (zit & 0x0000000000080000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".bot_http_interactions")); first = 0;}
	if (zit & 0x0000000000100000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".reserved_20")); first = 0;}
	if (zit & 0x0000000000200000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".reserved_21")); first = 0;}
	if (zit & 0x0000000000400000U) {if (!first) {ret = string__plus(ret, _SLIT(" | "));} ret = string__plus(ret, _SLIT(".active_developer")); first = 0;}
	ret = string__plus(ret, _SLIT("}"));
	return ret;
}
static string discord__PremiumType_str(discord__PremiumType it) { /* gen_str_for_enum */
	switch(it) {
		case discord__PremiumType__none_: return _SLIT("none_");
		case discord__PremiumType__nitro_classic: return _SLIT("nitro_classic");
		case discord__PremiumType__nitro: return _SLIT("nitro");
		case discord__PremiumType__nitro_basic: return _SLIT("nitro_basic");
		default: return _SLIT("unknown enum value");
	}
}
static string discord__AvatarDecorationData_str(discord__AvatarDecorationData it) { return indent_discord__AvatarDecorationData_str(it, 0);}

// V dump functions:
x__json2__Any _v_dump_expr_x__json2__Any(string fpath, int line, string sexpr, x__json2__Any dump_arg) {
	string sline = int_str(line);
	string value = x__json2__Any_str(dump_arg);

	strings__Builder sb = strings__new_builder(256);

	strings__Builder_write_rune(&sb, '[');
	strings__Builder_write_string(&sb, fpath);
	strings__Builder_write_rune(&sb, ':');
	strings__Builder_write_string(&sb, sline);
	strings__Builder_write_rune(&sb, ']');
	strings__Builder_write_rune(&sb, ' ');
	strings__Builder_write_string(&sb, sexpr);
	strings__Builder_write_rune(&sb, ':');
	strings__Builder_write_rune(&sb, ' ');
	strings__Builder_write_string(&sb, value);
	strings__Builder_write_rune(&sb, '\n');

	string res;
	res = strings__Builder_str(&sb);
	eprint(res);
	string_free(&res);
	strings__Builder_free(&sb);

	string_free(&value);
	string_free(&sline);
	return dump_arg;
}
discord__Guild _v_dump_expr_discord__Guild(string fpath, int line, string sexpr, discord__Guild dump_arg) {
	string sline = int_str(line);
	string value = discord__Guild_str(dump_arg);

	strings__Builder sb = strings__new_builder(256);

	strings__Builder_write_rune(&sb, '[');
	strings__Builder_write_string(&sb, fpath);
	strings__Builder_write_rune(&sb, ':');
	strings__Builder_write_string(&sb, sline);
	strings__Builder_write_rune(&sb, ']');
	strings__Builder_write_rune(&sb, ' ');
	strings__Builder_write_string(&sb, sexpr);
	strings__Builder_write_rune(&sb, ':');
	strings__Builder_write_rune(&sb, ' ');
	strings__Builder_write_string(&sb, value);
	strings__Builder_write_rune(&sb, '\n');

	string res;
	res = strings__Builder_str(&sb);
	eprint(res);
	string_free(&res);
	strings__Builder_free(&sb);

	string_free(&value);
	string_free(&sline);
	return dump_arg;
}
bool _v_dump_expr_bool(string fpath, int line, string sexpr, bool dump_arg) {
	string sline = int_str(line);
	string value = bool_str(dump_arg);

	strings__Builder sb = strings__new_builder(256);

	strings__Builder_write_rune(&sb, '[');
	strings__Builder_write_string(&sb, fpath);
	strings__Builder_write_rune(&sb, ':');
	strings__Builder_write_string(&sb, sline);
	strings__Builder_write_rune(&sb, ']');
	strings__Builder_write_rune(&sb, ' ');
	strings__Builder_write_string(&sb, sexpr);
	strings__Builder_write_rune(&sb, ':');
	strings__Builder_write_rune(&sb, ' ');
	strings__Builder_write_string(&sb, value);
	strings__Builder_write_rune(&sb, '\n');

	string res;
	res = strings__Builder_str(&sb);
	eprint(res);
	string_free(&res);
	strings__Builder_free(&sb);

	string_free(&value);
	string_free(&sline);
	return dump_arg;
}


// V auto functions:
static string indent_net__TcpSocket_str(net__TcpSocket it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t1 = indent_net__Socket_str(it.Socket, indent_count + 1);
	string res = str_intp( 7, _MOV((StrIntpData[]){
		{_SLIT("net.TcpSocket{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    Socket: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t1}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t1);
	string_free(&indents);
	return res;
}

static string indent_net__websocket__Frame_str(net__websocket__Frame it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t2 = net__websocket__OPCode_str((it.opcode));
	string _t3 = indent_Array_fixed_u8_4_str(it.masking_key, indent_count + 1);
	string res = str_intp( 43, _MOV((StrIntpData[]){
		{_SLIT("websocket.Frame{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    header_len: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.header_len}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    frame_size: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.frame_size}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    fin: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.fin ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    rsv1: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.rsv1 ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    rsv2: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.rsv2 ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    rsv3: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.rsv3 ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    opcode: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t2}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    has_mask: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.has_mask ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    payload_len: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.payload_len}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    masking_key: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t3}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t3);
	string_free(&_t2);
	string_free(&indents);
	return res;
}

static string indent_discord__WSMessage_str(discord__WSMessage it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t4 = x__json2__Any_str(it.data);
	string _t5 = _option_int_str(it.seq);
	string res = str_intp( 19, _MOV((StrIntpData[]){
		{_SLIT("discord.WSMessage{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    opcode: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.opcode}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    data: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t4}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    seq: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t5}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    event: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.event}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t5);
	string_free(&_t4);
	string_free(&indents);
	return res;
}

static string indent_discord__Guild_str(discord__Guild it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t6 = indent_discord__Snowflake_str(it.id, indent_count + 1);
	string _t7 = _option_string_str(it.icon);
	string _t8 = _option_string_str(it.icon_hash);
	string _t9 = _option_string_str(it.splash);
	string _t10 = _option_string_str(it.discovery_splash);
	string _t11 = indent_discord__Snowflake_str(it.owner_id, indent_count + 1);
	string _t12 = indent__option_discord__Snowflake_str(it.afk_channel_id, indent_count + 1);
	string _t13 = time__Duration_str(it.afk_timeout);
	string _t14 = _option_bool_str(it.widget_enabled);
	string _t15 = indent__option_discord__Snowflake_str(it.widget_channel_id, indent_count + 1);
	string _t16 = discord__VerificationLevel_str((it.verification_level));
	string _t17 = discord__MessageNotificationsLevel_str((it.default_message_notifications));
	string _t18 = discord__ExplicitContentFilterLevel_str((it.explicit_content_filter));
	string _t19 = indent_Array_discord__Role_str(it.roles, indent_count + 1);
	string _t20 = indent_Array_discord__Emoji_str(it.emojis, indent_count + 1);
	string _t21 = indent_Array_discord__GuildFeature_str(it.features, indent_count + 1);
	string _t22 = discord__MFALevel_str((it.mfa_level));
	string _t23 = indent__option_discord__Snowflake_str(it.application_id, indent_count + 1);
	string _t24 = indent__option_discord__Snowflake_str(it.system_channel_id, indent_count + 1);
	string _t25 = discord__SystemChannelFlags_str((it.system_channel_flags));
	string _t26 = indent__option_discord__Snowflake_str(it.rules_channel_id, indent_count + 1);
	string _t27 = _option_int_str(it.max_presences);
	string _t28 = _option_int_str(it.max_members);
	string _t29 = _option_string_str(it.vanity_url_code);
	string _t30 = _option_string_str(it.description);
	string _t31 = _option_string_str(it.banner);
	string _t32 = discord__PremiumTier_str((it.premium_tier));
	string _t33 = _option_int_str(it.premium_subscription_count);
	string _t34 = indent__option_discord__Snowflake_str(it.public_updates_channel_id, indent_count + 1);
	string _t35 = _option_int_str(it.max_video_channel_users);
	string _t36 = _option_int_str(it.max_stage_video_channel_users);
	string _t37 = _option_int_str(it.approximate_member_count);
	string _t38 = _option_int_str(it.approximate_presence_count);
	string _t39 = indent__option_discord__WelcomeScreen_str(it.welcome_screen, indent_count + 1);
	string _t40 = discord__NSFWLevel_str((it.nsfw_level));
	string _t41 = indent_Array_discord__Sticker_str(it.stickers, indent_count + 1);
	string _t42 = indent__option_discord__Snowflake_str(it.safety_alerts_channel_id, indent_count + 1);
	string res = str_intp( 163, _MOV((StrIntpData[]){
		{_SLIT("discord.Guild{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    id: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t6}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.name}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    icon: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t7}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    icon_hash: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t8}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    splash: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t9}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    discovery_splash: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t10}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    owner_id: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t11}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    afk_channel_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t12}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    afk_timeout: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t13}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    widget_enabled: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t14}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    widget_channel_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t15}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    verification_level: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t16}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    default_message_notifications: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t17}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    explicit_content_filter: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t18}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    roles: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t19}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    emojis: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t20}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    features: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t21}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    mfa_level: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t22}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    application_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t23}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    system_channel_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t24}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    system_channel_flags: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t25}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    rules_channel_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t26}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    max_presences: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t27}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    max_members: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t28}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    vanity_url_code: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t29}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    description: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t30}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    banner: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t31}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    premium_tier: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t32}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    premium_subscription_count: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t33}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    preferred_locale: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.preferred_locale}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    public_updates_channel_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t34}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    max_video_channel_users: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t35}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    max_stage_video_channel_users: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t36}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    approximate_member_count: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t37}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    approximate_presence_count: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t38}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    welcome_screen: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t39}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    nsfw_level: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t40}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    stickers: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t41}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    premium_progress_bar_enabled: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.premium_progress_bar_enabled ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    safety_alerts_channel_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t42}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t42);
	string_free(&_t41);
	string_free(&_t40);
	string_free(&_t39);
	string_free(&_t38);
	string_free(&_t37);
	string_free(&_t36);
	string_free(&_t35);
	string_free(&_t34);
	string_free(&_t33);
	string_free(&_t32);
	string_free(&_t31);
	string_free(&_t30);
	string_free(&_t29);
	string_free(&_t28);
	string_free(&_t27);
	string_free(&_t26);
	string_free(&_t25);
	string_free(&_t24);
	string_free(&_t23);
	string_free(&_t22);
	string_free(&_t21);
	string_free(&_t20);
	string_free(&_t19);
	string_free(&_t18);
	string_free(&_t17);
	string_free(&_t16);
	string_free(&_t15);
	string_free(&_t14);
	string_free(&_t13);
	string_free(&_t12);
	string_free(&_t11);
	string_free(&_t10);
	string_free(&_t9);
	string_free(&_t8);
	string_free(&_t7);
	string_free(&_t6);
	string_free(&indents);
	return res;
}

static string indent_net__Socket_str(net__Socket it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string res = str_intp( 7, _MOV((StrIntpData[]){
		{_SLIT("net.Socket{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    handle: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.handle}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&indents);
	return res;
}

static string indent_discord__Role_str(discord__Role it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t43 = indent_discord__Snowflake_str(it.id, indent_count + 1);
	string _t44 = _option_string_str(it.icon);
	string _t45 = _option_string_str(it.unicode_emoji);
	string _t46 = discord__Permissions_str((it.permissions));
	string _t47 = indent__option_discord__RoleTags_str(it.tags, indent_count + 1);
	string _t48 = discord__RoleFlags_str((it.flags));
	string res = str_intp( 51, _MOV((StrIntpData[]){
		{_SLIT("discord.Role{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    id: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t43}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.name}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    color: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.color}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    hoist: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.hoist ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    icon: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t44}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    unicode_emoji: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t45}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    position: "), 0, {.d_c=0}}, {_SLIT(""), 7, {.d_i32=it.position}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    permissions: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t46}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    managed: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.managed ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    mentionable: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.mentionable ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    tags: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t47}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    flags: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t48}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t48);
	string_free(&_t47);
	string_free(&_t46);
	string_free(&_t45);
	string_free(&_t44);
	string_free(&_t43);
	string_free(&indents);
	return res;
}

static string indent_discord__Emoji_str(discord__Emoji it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t49 = indent__option_discord__Snowflake_str(it.id, indent_count + 1);
	string _t50 = _option_string_str(it.name);
	string _t51 = indent__option_Array_discord__Snowflake_str(it.roles, indent_count + 1);
	string _t52 = indent__option_discord__User_str(it.user, indent_count + 1);
	string _t53 = _option_bool_str(it.require_colons);
	string _t54 = _option_bool_str(it.managed);
	string _t55 = _option_bool_str(it.animated);
	string _t56 = _option_bool_str(it.available);
	string res = str_intp( 35, _MOV((StrIntpData[]){
		{_SLIT("discord.Emoji{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t49}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t50}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    roles: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t51}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    user: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t52}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    require_colons: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t53}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    managed: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t54}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    animated: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t55}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    available: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t56}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t56);
	string_free(&_t55);
	string_free(&_t54);
	string_free(&_t53);
	string_free(&_t52);
	string_free(&_t51);
	string_free(&_t50);
	string_free(&_t49);
	string_free(&indents);
	return res;
}

static string indent_discord__WelcomeScreen_str(discord__WelcomeScreen it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t57 = _option_string_str(it.description);
	string _t58 = indent_Array_discord__WelcomeChannel_str(it.welcome_channels, indent_count + 1);
	string res = str_intp( 11, _MOV((StrIntpData[]){
		{_SLIT("discord.WelcomeScreen{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    description: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t57}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    welcome_channels: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t58}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t58);
	string_free(&_t57);
	string_free(&indents);
	return res;
}

static string indent_discord__Sticker_str(discord__Sticker it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t59 = indent_discord__Snowflake_str(it.id, indent_count + 1);
	string _t60 = indent__option_discord__Snowflake_str(it.pack_id, indent_count + 1);
	string _t61 = _option_string_str(it.description);
	string _t62 = _option_string_str(it.tags);
	string _t63 = discord__StickerType_str((it.typ));
	string _t64 = discord__StickerFormatType_str((it.format_type));
	string _t65 = _option_bool_str(it.available);
	string _t66 = indent__option_discord__Snowflake_str(it.guild_id, indent_count + 1);
	string _t67 = indent__option_discord__User_str(it.user, indent_count + 1);
	string _t68 = _option_int_str(it.sort_value);
	string res = str_intp( 47, _MOV((StrIntpData[]){
		{_SLIT("discord.Sticker{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    id: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t59}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    pack_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t60}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    name: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.name}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    description: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t61}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    tags: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t62}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    typ: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t63}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    format_type: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t64}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    available: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t65}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    guild_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t66}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    user: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t67}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    sort_value: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t68}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t68);
	string_free(&_t67);
	string_free(&_t66);
	string_free(&_t65);
	string_free(&_t64);
	string_free(&_t63);
	string_free(&_t62);
	string_free(&_t61);
	string_free(&_t60);
	string_free(&_t59);
	string_free(&indents);
	return res;
}

static string indent_discord__RoleTags_str(discord__RoleTags it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t69 = indent__option_discord__Snowflake_str(it.bot_id, indent_count + 1);
	string _t70 = indent__option_discord__Snowflake_str(it.integration_id, indent_count + 1);
	string _t71 = indent__option_discord__Snowflake_str(it.subscription_listing_id, indent_count + 1);
	string res = str_intp( 27, _MOV((StrIntpData[]){
		{_SLIT("discord.RoleTags{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    bot_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t69}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    integration_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t70}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    premium_subscriber: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.premium_subscriber ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    subscription_listing_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t71}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    available_for_purchase: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.available_for_purchase ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    guild_connections: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=it.guild_connections ? _SLIT("true") : _SLIT("false")}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t71);
	string_free(&_t70);
	string_free(&_t69);
	string_free(&indents);
	return res;
}

static string indent_discord__User_str(discord__User it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t72 = indent_discord__Snowflake_str(it.id, indent_count + 1);
	string _t73 = _option_string_str(it.global_name);
	string _t74 = _option_string_str(it.avatar);
	string _t75 = _option_bool_str(it.bot);
	string _t76 = _option_bool_str(it.system);
	string _t77 = _option_bool_str(it.mfa_enabled);
	string _t78 = _option_string_str(it.banner);
	string _t79 = _option_int_str(it.accent_color);
	string _t80 = _option_string_str(it.locale);
	string _t81 = _option_bool_str(it.verified);
	string _t82 = _option_string_str(it.email);
	string _t83 = _option_discord__UserFlags_str((it.flags));
	string _t84 = _option_discord__PremiumType_str((it.premium_type));
	string _t85 = _option_discord__UserFlags_str((it.public_flags));
	string _t86 = indent__option_discord__AvatarDecorationData_str(it.avatar_decoration, indent_count + 1);
	string res = str_intp( 71, _MOV((StrIntpData[]){
		{_SLIT("discord.User{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    id: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t72}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    username: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.username}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    discriminator: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.discriminator}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    global_name: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t73}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    avatar: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t74}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    bot: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t75}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    system: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t76}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    mfa_enabled: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t77}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    banner: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t78}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    accent_color: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t79}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    locale: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t80}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    verified: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t81}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    email: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t82}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    flags: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t83}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    premium_type: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t84}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    public_flags: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t85}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    avatar_decoration: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t86}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t86);
	string_free(&_t85);
	string_free(&_t84);
	string_free(&_t83);
	string_free(&_t82);
	string_free(&_t81);
	string_free(&_t80);
	string_free(&_t79);
	string_free(&_t78);
	string_free(&_t77);
	string_free(&_t76);
	string_free(&_t75);
	string_free(&_t74);
	string_free(&_t73);
	string_free(&_t72);
	string_free(&indents);
	return res;
}

static string indent_discord__WelcomeChannel_str(discord__WelcomeChannel it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t87 = indent__option_discord__Snowflake_str(it.channel_id, indent_count + 1);
	string _t88 = indent__option_discord__Snowflake_str(it.emoji_id, indent_count + 1);
	string _t89 = _option_string_str(it.emoji_name);
	string res = str_intp( 19, _MOV((StrIntpData[]){
		{_SLIT("discord.WelcomeChannel{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    channel_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t87}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    description: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.description}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    emoji_id: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t88}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    emoji_name: "), 0, {.d_c=0}}, {_SLIT(""), 0xfe10, {.d_s=_t89}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t89);
	string_free(&_t88);
	string_free(&_t87);
	string_free(&indents);
	return res;
}

static string indent_discord__AvatarDecorationData_str(discord__AvatarDecorationData it, int indent_count) {
	string indents = string_repeat(_SLIT("    "), indent_count);
	string _t90 = indent_discord__Snowflake_str(it.sku_id, indent_count + 1);
	string res = str_intp( 11, _MOV((StrIntpData[]){
		{_SLIT("discord.AvatarDecorationData{\n"), 0, {.d_c=0}},
		{_SLIT0, 0xfe10, {.d_s=indents}}, {_SLIT("    asset: "), 0, {.d_c=0}}, {_SLIT("'"), 16, {.d_s=it.asset}}, {_SLIT("'"), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("    sku_id: "), 0, {.d_c=0}}, {_SLIT(""), 16, {.d_s=_t90}}, {_SLIT(""), 0, {.d_c=0}},
		{_SLIT("\n"), 0xfe10, {.d_s=indents}}, {_SLIT("}"), 0, {.d_c=0}},
	}));
	string_free(&_t90);
	string_free(&indents);
	return res;
}

static inline x__json2__Any f64_to_sumtype_x__json2__Any/*KEK*/(f64* x) {
	f64* ptr = memdup(x, sizeof(f64));
	return (x__json2__Any){ ._f64 = ptr, ._typ = 17};
}

static inline x__json2__Any i64_to_sumtype_x__json2__Any/*KEK*/(i64* x) {
	i64* ptr = memdup(x, sizeof(i64));
	return (x__json2__Any){ ._i64 = ptr, ._typ = 9};
}

static inline x__json2__Any string_to_sumtype_x__json2__Any/*KEK*/(string* x) {
	string* ptr = memdup(x, sizeof(string));
	return (x__json2__Any){ ._string = ptr, ._typ = 21};
}

static inline x__json2__Any bool_to_sumtype_x__json2__Any/*KEK*/(bool* x) {
	bool* ptr = memdup(x, sizeof(bool));
	return (x__json2__Any){ ._bool = ptr, ._typ = 19};
}

static inline x__json2__Any x__json2__Null_to_sumtype_x__json2__Any/*KEK*/(x__json2__Null* x) {
	x__json2__Null* ptr = memdup(x, sizeof(x__json2__Null));
	return (x__json2__Any){ ._x__json2__Null = ptr, ._typ = 170};
}

static inline x__json2__Any Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(Array_x__json2__Any* x) {
	Array_x__json2__Any* ptr = memdup(x, sizeof(Array_x__json2__Any));
	return (x__json2__Any){ ._Array_x__json2__Any = ptr, ._typ = 174};
}

static inline x__json2__Any Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(Map_string_x__json2__Any* x) {
	Map_string_x__json2__Any* ptr = memdup(x, sizeof(Map_string_x__json2__Any));
	return (x__json2__Any){ ._Map_string_x__json2__Any = ptr, ._typ = 173};
}

static inline x__json2__Any int_to_sumtype_x__json2__Any/*KEK*/(int* x) {
	int* ptr = memdup(x, sizeof(int));
	return (x__json2__Any){ ._int = ptr, ._typ = 8};
}

static inline x__json2__Any discord__Snowflake_to_sumtype_x__json2__Any/*KEK*/(u64* x) {
	u64* ptr = memdup(x, sizeof(u64));
	return (x__json2__Any){ ._u64 = ptr, ._typ = 14};
}

static bool Array_u8_contains(Array_u8 a, u8 v) {
	for (int i = 0; i < a.len; ++i) {
		if (((u8*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_string_contains(Array_string a, string v) {
	for (int i = 0; i < a.len; ++i) {
		if (fast_string_eq(((string*)a.data)[i], v)) {
			return true;
		}
	}
	return false;
}

static bool Array_rune_contains(Array_rune a, rune v) {
	for (int i = 0; i < a.len; ++i) {
		if (((rune*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static bool Array_int_contains(Array_int a, int v) {
	for (int i = 0; i < a.len; ++i) {
		if (((int*)a.data)[i] == v) {
			return true;
		}
	}
	return false;
}

static int Array_string_index(Array_string a, string v) {
	string* pelem = a.data;
	for (int i = 0; i < a.len; ++i, ++pelem) {
		if (fast_string_eq(*pelem, v)) {
			return i;
		}
	}
	return -1;
}

static bool Array_rune_arr_eq(Array_rune a, Array_rune b) {
	if (a.len != b.len) {
		return false;
	}
	for (int i = 0; i < a.len; ++i) {
		if (*((rune*)((byte*)a.data+(i*a.element_size))) != *((rune*)((byte*)b.data+(i*b.element_size)))) {
			return false;
		}
	}
	return true;
}

static bool time__Duration_alias_eq(time__Duration a, time__Duration b) {
	return a == b;
}


// V closure helpers

#ifdef _MSC_VER
	#define __RETURN_ADDRESS() ((char*)_ReturnAddress())
#elif defined(__TINYC__) && defined(_WIN32)
	#define __RETURN_ADDRESS() ((char*)__builtin_return_address(0))
#else
	#define __RETURN_ADDRESS() ((char*)__builtin_extract_return_addr(__builtin_return_address(0)))
#endif

static int _V_page_size = 0x4000; // 16K
#define ASSUMED_PAGE_SIZE 0x4000
#define _CLOSURE_SIZE (((2*sizeof(void*) > sizeof(__closure_thunk) ? 2*sizeof(void*) : sizeof(__closure_thunk)) + sizeof(void*) - 1) & ~(sizeof(void*) - 1))
// equal to `max(2*sizeof(void*), sizeof(__closure_thunk))`, rounded up to the next multiple of `sizeof(void*)`

// refer to https://godbolt.org/z/r7P3EYv6c for a complete assembly
#ifdef __V_amd64
static const char __closure_thunk[] = {
	0xF3, 0x44, 0x0F, 0x7E, 0x3D, 0xF7, 0xBF, 0xFF, 0xFF,  // movq  xmm15, QWORD PTR [rip - userdata]
	0xFF, 0x25, 0xF9, 0xBF, 0xFF, 0xFF                     // jmp  QWORD PTR [rip - fn]
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0x66, 0x4C, 0x0F, 0x7E, 0xF8,  // movq rax, xmm15
	0xC3                           // ret
};
#elif defined(__V_x86)
static char __closure_thunk[] = {
	0xe8, 0x00, 0x00, 0x00, 0x00,        // call here
	                                     // here:
	0x59,                                // pop  ecx
	0x66, 0x0F, 0x6E, 0xF9,              // movd xmm7, ecx
	0xff, 0xA1, 0xff, 0xbf, 0xff, 0xff,  // jmp  DWORD PTR [ecx - 0x4001] # <fn>
};

static char __CLOSURE_GET_DATA_BYTES[] = {
	0x66, 0x0F, 0x7E, 0xF8,              // movd eax, xmm7
	0x8B, 0x80, 0xFB, 0xBF, 0xFF, 0xFF,  // mov eax, DWORD PTR [eax - 0x4005]
	0xc3                                 // ret
};

#elif defined(__V_arm64)
static char __closure_thunk[] = {
	0x11, 0x00, 0xFE, 0x58,  // ldr x17, userdata
	0x30, 0x00, 0xFE, 0x58,  // ldr x16, fn
	0x00, 0x02, 0x1F, 0xD6   // br  x16
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0xE0, 0x03, 0x11, 0xAA,  // mov x0, x17
	0xC0, 0x03, 0x5F, 0xD6   // ret
};
#elif defined(__V_arm32)
static char __closure_thunk[] = {
	0x04, 0xC0, 0x4F, 0xE2,  // adr ip, here
                             // here:
	0x01, 0xC9, 0x4C, 0xE2,  // sub  ip, ip, #4000
	0x90, 0xCA, 0x07, 0xEE,  // vmov s15, ip
	0x00, 0xC0, 0x9C, 0xE5,  // ldr  ip, [ip, 0]
	0x1C, 0xFF, 0x2F, 0xE1   // bx   ip
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0x90, 0x0A, 0x17, 0xEE,
	0x04, 0x00, 0x10, 0xE5,
	0x1E, 0xFF, 0x2F, 0xE1
};
#elif defined (__V_rv64)
static char __closure_thunk[] = {
	0x97, 0xCF, 0xFF, 0xFF,  // auipc t6, 0xffffc
	0x03, 0xBF, 0x8F, 0x00,  // ld    t5, 8(t6)
	0x67, 0x00, 0x0F, 0x00   // jr    t5
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0x03, 0xb5, 0x0f, 0x00,  // ld    a0, 0(t6)
	0x67, 0x80, 0x00, 0x00   // ret
};
#elif defined (__V_rv32)
static char __closure_thunk[] = {
	0x97, 0xCF, 0xFF, 0xFF,  // auipc t6, 0xffffc
	0x03, 0xAF, 0x4F, 0x00,  // lw    t5, 4(t6)
	0x67, 0x00, 0x0F, 0x00   // jr    t5
};
static char __CLOSURE_GET_DATA_BYTES[] = {
	0x03, 0xA5, 0x0F, 0x00,  // lw    a0, 0(t6)
	0x67, 0x80, 0x00, 0x00   // ret
};
#endif

static void*(*__CLOSURE_GET_DATA)(void) = 0;

static inline void __closure_set_data(char* closure, void* data) {
	void** p = (void**)(closure - ASSUMED_PAGE_SIZE);
	p[0] = data;
}

static inline void __closure_set_function(char* closure, void* f) {
	void** p = (void**)(closure - ASSUMED_PAGE_SIZE);
	p[1] = f;
}

#ifdef _WIN32
#include <synchapi.h>
static SRWLOCK _closure_mtx;
#define _closure_mtx_init() InitializeSRWLock(&_closure_mtx)
#define _closure_mtx_lock() AcquireSRWLockExclusive(&_closure_mtx)
#define _closure_mtx_unlock() ReleaseSRWLockExclusive(&_closure_mtx)
#else
static pthread_mutex_t _closure_mtx;
#define _closure_mtx_init() pthread_mutex_init(&_closure_mtx, 0)
#define _closure_mtx_lock() pthread_mutex_lock(&_closure_mtx)
#define _closure_mtx_unlock() pthread_mutex_unlock(&_closure_mtx)
#endif
static char* _closure_ptr = 0;
static int _closure_cap = 0;

static void __closure_alloc(void) {
#ifdef _WIN32
	char* p = VirtualAlloc(NULL, _V_page_size * 2, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (p == NULL) return;
#else
	char* p = mmap(0, _V_page_size * 2, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	if (p == MAP_FAILED) return;
#endif
	char* x = p + _V_page_size;
	int remaining = _V_page_size / _CLOSURE_SIZE;
	_closure_ptr = x;
	_closure_cap = remaining;
	while (remaining > 0) {
		memcpy(x, __closure_thunk, sizeof(__closure_thunk));
		remaining--;
		x += _CLOSURE_SIZE;
	}
#ifdef _WIN32
	DWORD _tmp;
	VirtualProtect(_closure_ptr, _V_page_size, PAGE_EXECUTE_READ, &_tmp);
#else
	mprotect(_closure_ptr, _V_page_size, PROT_READ | PROT_EXEC);
#endif
}

#ifdef _WIN32
void __closure_init() {
	SYSTEM_INFO si;
	GetNativeSystemInfo(&si);
	uint32_t page_size = si.dwPageSize * (((ASSUMED_PAGE_SIZE - 1) / si.dwPageSize) + 1);
	_V_page_size = page_size;
	__closure_alloc();
	DWORD _tmp;
	VirtualProtect(_closure_ptr, page_size, PAGE_READWRITE, &_tmp);
	memcpy(_closure_ptr, __CLOSURE_GET_DATA_BYTES, sizeof(__CLOSURE_GET_DATA_BYTES));
	VirtualProtect(_closure_ptr, page_size, PAGE_EXECUTE_READ, &_tmp);
	__CLOSURE_GET_DATA = (void*)_closure_ptr;
	_closure_ptr += _CLOSURE_SIZE;
	_closure_cap--;
}
#else
void __closure_init() {
	uint32_t page_size = sysconf(_SC_PAGESIZE);
	page_size = page_size * (((ASSUMED_PAGE_SIZE - 1) / page_size) + 1);
	_V_page_size = page_size;
	__closure_alloc();
	mprotect(_closure_ptr, page_size, PROT_READ | PROT_WRITE);
	memcpy(_closure_ptr, __CLOSURE_GET_DATA_BYTES, sizeof(__CLOSURE_GET_DATA_BYTES));
	mprotect(_closure_ptr, page_size, PROT_READ | PROT_EXEC);
	__CLOSURE_GET_DATA = (void*)_closure_ptr;
	_closure_ptr += _CLOSURE_SIZE;
	_closure_cap--;
}
#endif

static void* __closure_create(void* fn, void* data) {
	_closure_mtx_lock();
	if (_closure_cap == 0) {
		__closure_alloc();
	}
	_closure_cap--;
	void* closure = _closure_ptr;
	_closure_ptr += _CLOSURE_SIZE;
	__closure_set_data(closure, data);
	__closure_set_function(closure, fn);
	_closure_mtx_unlock();
	return closure;
}


// V anon functions:
/*F*/
VV_LOCAL_SYMBOL _result_void anon_fn_f5aad9dbbbe573d0_mut_net__websocket__client_int_string_mut_net__websocket__serverclient__result_void_5147(net__websocket__Client* c, int code, string reason, net__websocket__ServerClient* sc) {
	log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object, _SLIT("server-> Delete client"));
	sync__RwMutex_lock(&sc->server->server_state->mtx);
	/*lock*/ {
		map_delete(&sc->server->server_state->val.clients, &(string[]){sc->client->id});
	}
	sync__RwMutex_unlock(&sc->server->server_state->mtx);;
	return (_result_void){0};
}
	

/*F*/
VV_LOCAL_SYMBOL multi_return_string_x__json2__Any anon_fn_741189b08a0d001a_discord__snowflake_string__multi_return_string_x__json2__Any_630(discord__Snowflake k, string v) {
	return (multi_return_string_x__json2__Any){.arg0=discord__Snowflake_build(k), .arg1=string_to_sumtype_x__json2__Any/*KEK*/(&v)};
}
	

/*F*/
VV_LOCAL_SYMBOL string anon_fn_d9dbe34f3e4698d6_int_x__json2__any__string_753(int _d1, x__json2__Any er) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	if (er._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t4 = (x__json2__Any*)(map_get_check(ADDR(map, (*er._Map_string_x__json2__Any)), &(string[]){_SLIT("message")}));
		_option_x__json2__Any _t3 = {0};
		if (_t4) {
			*((x__json2__Any*)&_t3.data) = *((x__json2__Any*)_t4);
		} else {
			_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t3.state != 0) {
			IError err = _t3.err;
			*(x__json2__Any*) _t3.data = string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT(""))));
		}
		x__json2__Any* _t6 = (x__json2__Any*)(map_get_check(ADDR(map, (*er._Map_string_x__json2__Any)), &(string[]){_SLIT("message")}));
		_option_x__json2__Any _t5 = {0};
		if (_t6) {
			*((x__json2__Any*)&_t5.data) = *((x__json2__Any*)_t6);
		} else {
			_t5.state = 2; _t5.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t5.state != 0) {
			IError err = _t5.err;
			*(x__json2__Any*) _t5.data = string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT(""))));
		}
		
		
		_t2 = /* as */ *(string*)__as_cast((((*(x__json2__Any*)_t3.data)))._string,(((*(x__json2__Any*)_t5.data)))._typ, 21) /*expected idx: 21, name: string */ ;
	}
	
	else {
		_v_panic(_SLIT("error was not dict"));
		VUNREACHABLE();
	}
	string _t1 = _t2;
	return _t1;
}
				

/*F*/
VV_LOCAL_SYMBOL string anon_fn_d9dbe34f3e4698d6_string_string__string_1411(string k, string m) {
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("In "), /*115 &string*/0xfe10, {.d_s = k}}, {_SLIT(": "), /*115 &string*/0xfe10, {.d_s = m}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}
		

/*F*/
struct _V_anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient_Ctx {
	discord__EmitOptions options;
};

VV_LOCAL_SYMBOL void anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient(_result_void (*f)(discord__DispatchEvent_T_discord__GatewayClient ), int j, discord__DispatchEvent_T_discord__GatewayClient e) {
		struct _V_anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient_Ctx* _V_closure_ctx = __CLOSURE_GET_DATA();
	_result_void _t1 = f(e);
	if (_t1.is_error) {
		IError err = _t1.err;
		_option_anon_fn_int_ierror _t2;
		if (_t2 = _V_closure_ctx->options.error_handler, _t2.state == 0) {
			anon_fn_int_ierror g = *(anon_fn_int_ierror*)_t2.data;
			g(j, err);
		}
	;
	}
	
 ;
}
		

/*F*/
struct _V_anon_fn_263669e3d870cc7d_int_ierror_862_Ctx {
	discord__GatewayClient cr;
};

VV_LOCAL_SYMBOL void anon_fn_263669e3d870cc7d_int_ierror_862(int i, IError e) {
	struct _V_anon_fn_263669e3d870cc7d_int_ierror_862_Ctx* _V_closure_ctx = __CLOSURE_GET_DATA();
	log__Logger_name_table[_V_closure_ctx->cr.Client.logger._typ]._method__v_error(_V_closure_ctx->cr.Client.logger._object,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Error on listener "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT(": "), /*115 &IError*/0xfe10, {.d_s = IError_str(e)}}, {_SLIT0, 0, { .d_c = 0 }}})));
}
	

/*F*/
	VV_LOCAL_SYMBOL _result_int anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255(discord__GatewayClient* client, time__Duration heartbeat_interval) {
	log__Logger_name_table[client->Client.logger._typ]._method_debug(client->Client.logger._object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Heart spawned with interval: "), /*115 &time.Duration*/0xfe10, {.d_s = time__Duration_str(heartbeat_interval)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	for (;;) {
		if (!(client->ready)) break;
		log__Logger_name_table[client->Client.logger._typ]._method_debug(client->Client.logger._object, _SLIT("Sleeping"));
		time__sleep(heartbeat_interval);
		log__Logger_name_table[client->Client.logger._typ]._method_debug(client->Client.logger._object, _SLIT("Sending HEARTBEAT"));
		_result_void _t1 = discord__GatewayClient_heartbeat(client);
		if (_t1.is_error) {
			_result_int _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
		log__Logger_name_table[client->Client.logger._typ]._method_debug(client->Client.logger._object, _SLIT("Sent HEARTBEAT"));
	}
	_result_int _t3;
	_result_ok(&(int[]) { 0 }, (_result*)(&_t3), sizeof(int));
	return _t3;
}
	

/*F*/
VV_LOCAL_SYMBOL _result_void anon_fn_263669e3d870cc7d_mut_net__websocket__client_int_string_voidptr__result_void_1828(net__websocket__Client* _d1, int code, string reason, voidptr r) {
	discord__GatewayClient* client = ((discord__GatewayClient*)(r));
	log__Logger_name_table[client->Client.logger._typ]._method__v_error(client->Client.logger._object,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Websocket closed with "), /*100 &int*/0xfe07, {.d_i32 = code}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = reason}}, {_SLIT0, 0, { .d_c = 0 }}})));
	return (_result_void){0};
}
	

/*F*/
VV_LOCAL_SYMBOL _result_void anon_fn_263669e3d870cc7d_mut_net__websocket__client_net__websocket__message_voidptr__result_void_2034(net__websocket__Client* _d2, net__websocket__Message* m, voidptr r) {
	discord__GatewayClient* client = ((discord__GatewayClient*)(r));
	_result_discord__WSMessage _t1 = discord__decode_websocket_message(*m);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	discord__WSMessage message =  (*(discord__WSMessage*)_t1.data);
	log__Logger_name_table[client->Client.logger._typ]._method_debug(client->Client.logger._object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("M "), /*115 &discord.WSMessage*/0xfe10, {.d_s = discord__WSMessage_str(message)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (!client->ready) {
		if (message.opcode != 10) {
			return (_result_void){ .is_error=true, .err=_v_error(_SLIT("First message wasnt HELLO")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		client->ready = true;
		discord__Properties _t4; /* if prepend */
		_option_discord__Properties _t5;
		if (_t5 = client->properties, _t5.state == 0) {
			discord__Properties o = *(discord__Properties*)_t5.data;
			_t4 = o;
		} else {
			IError err = _t5.err;
			_t4 = ((discord__Properties){.os = os__user_os(),.browser = _SLIT("discord.v"),.device = _SLIT("discord.v"),});
		}
		discord__Properties props =  _t4;
		log__Logger_name_table[client->Client.logger._typ]._method_debug(client->Client.logger._object, _SLIT("Sending IDENTIFY"));
		_result_void _t6 = discord__GatewayClient_send(client, ((discord__WSMessage){.opcode = 2,.data = Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 3, sizeof(string), sizeof(x__json2__Any),
				_MOV((string[3]){
					_SLIT("token"), 
					_SLIT("intents"), 
					_SLIT("properties"), 
				}),
				_MOV((x__json2__Any[3]){
					string_to_sumtype_x__json2__Any/*KEK*/(&client->Client.token), 
					int_to_sumtype_x__json2__Any/*KEK*/(&client->intents), 
					Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 3, sizeof(string), sizeof(x__json2__Any),
				_MOV((string[3]){
					_SLIT("os"), 
					_SLIT("browser"), 
					_SLIT("device"), 
				}),
				_MOV((x__json2__Any[3]){
					string_to_sumtype_x__json2__Any/*KEK*/(&props.os), 
					string_to_sumtype_x__json2__Any/*KEK*/(&props.browser), 
					string_to_sumtype_x__json2__Any/*KEK*/(&props.device), 
				})
			)
		
		))), 
				})
			)
		
		))),.seq = (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.event = (string){.str=(byteptr)"", .is_lit=1},}));
		if (_t6.is_error) {
			_result_void _t7;
			memcpy(&_t7, &_t6, sizeof(_result));
			return _t7;
		}
		
 ;
		log__Logger_name_table[client->Client.logger._typ]._method_debug(client->Client.logger._object, _SLIT("Spawning heart"));
		x__json2__Any* _t9 = (x__json2__Any*)(map_get_check(ADDR(map, x__json2__Any_as_map(message.data)), &(string[]){_SLIT("heartbeat_interval")}));
		_option_x__json2__Any _t8 = {0};
		if (_t9) {
			*((x__json2__Any*)&_t8.data) = *((x__json2__Any*)_t9);
		} else {
			_t8.state = 2; _t8.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t8.state != 0) {
			_result_void _t10;
			memcpy(&_t10, &_t8, sizeof(_result));
			return _t10;
		}
		x__json2__Any* _t12 = (x__json2__Any*)(map_get_check(ADDR(map, x__json2__Any_as_map(message.data)), &(string[]){_SLIT("heartbeat_interval")}));
		_option_x__json2__Any _t11 = {0};
		if (_t12) {
			*((x__json2__Any*)&_t11.data) = *((x__json2__Any*)_t12);
		} else {
			_t11.state = 2; _t11.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t11.state != 0) {
			_result_void _t13;
			memcpy(&_t13, &_t11, sizeof(_result));
			return _t13;
		}
		
		
		discord__GatewayClient_spawn_heart(client, /* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t8.data))._i64,((*(x__json2__Any*)_t11.data))._typ, 9) /*expected idx: 9, name: i64 */ );
		return (_result_void){0};
	}
	if (message.opcode == 0) {
		log__Logger_name_table[client->Client.logger._typ]._method_debug(client->Client.logger._object,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Dispatch "), /*115 &string*/0xfe10, {.d_s = message.event}}, {_SLIT(": "), /*115 &x.json2.Any*/0xfe10, {.d_s = x__json2__Any_str(message.data)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		_result_void _t14 = discord__GatewayClient_raw_dispatch(client, message.event, message.data);
		if (_t14.is_error) {
			_result_void _t15;
			memcpy(&_t15, &_t14, sizeof(_result));
			return _t15;
		}
		
 ;
	}
	return (_result_void){0};
}
	

/*F*/
VV_LOCAL_SYMBOL int anon_fn_8ca92943f0af0818_int_discord__intents__int_585(int x, discord__Intents y) {
	int _t1 = (x | ((int)(y)));
	return _t1;
}
	

/*F*/
VV_LOCAL_SYMBOL _result_void anon_fn_f860512d614a01ac_discord__dispatchevent_t_discord__gatewayclient__result_void_345(discord__DispatchEvent_T_discord__GatewayClient event) {
	if (string__eq(event.name, _SLIT("MESSAGE_CREATE"))) {
		Map_string_x__json2__Any d = x__json2__Any_as_map(event.data);
		x__json2__Any* _t2 = (x__json2__Any*)(map_get_check(ADDR(map, d), &(string[]){_SLIT("channel_id")}));
		_option_x__json2__Any _t1 = {0};
		if (_t2) {
			*((x__json2__Any*)&_t1.data) = *((x__json2__Any*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t1.state != 0) {
			_result_void _t3;
			memcpy(&_t3, &_t1, sizeof(_result));
			return _t3;
		}
		x__json2__Any* _t5 = (x__json2__Any*)(map_get_check(ADDR(map, d), &(string[]){_SLIT("channel_id")}));
		_option_x__json2__Any _t4 = {0};
		if (_t5) {
			*((x__json2__Any*)&_t4.data) = *((x__json2__Any*)_t5);
		} else {
			_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t4.state != 0) {
			_result_void _t6;
			memcpy(&_t6, &_t4, sizeof(_result));
			return _t6;
		}
		
		
		string channel_id = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t1.data))._string,((*(x__json2__Any*)_t4.data))._typ, 21) /*expected idx: 21, name: string */ ;
		x__json2__Any* _t8 = (x__json2__Any*)(map_get_check(ADDR(map, d), &(string[]){_SLIT("id")}));
		_option_x__json2__Any _t7 = {0};
		if (_t8) {
			*((x__json2__Any*)&_t7.data) = *((x__json2__Any*)_t8);
		} else {
			_t7.state = 2; _t7.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t7.state != 0) {
			_result_void _t9;
			memcpy(&_t9, &_t7, sizeof(_result));
			return _t9;
		}
		x__json2__Any* _t11 = (x__json2__Any*)(map_get_check(ADDR(map, d), &(string[]){_SLIT("id")}));
		_option_x__json2__Any _t10 = {0};
		if (_t11) {
			*((x__json2__Any*)&_t10.data) = *((x__json2__Any*)_t11);
		} else {
			_t10.state = 2; _t10.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t10.state != 0) {
			_result_void _t12;
			memcpy(&_t12, &_t10, sizeof(_result));
			return _t12;
		}
		
		
		string message_id = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t7.data))._string,((*(x__json2__Any*)_t10.data))._typ, 21) /*expected idx: 21, name: string */ ;
		x__json2__Any* _t14 = (x__json2__Any*)(map_get_check(ADDR(map, d), &(string[]){_SLIT("content")}));
		_option_x__json2__Any _t13 = {0};
		if (_t14) {
			*((x__json2__Any*)&_t13.data) = *((x__json2__Any*)_t14);
		} else {
			_t13.state = 2; _t13.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t13.state != 0) {
			_result_void _t15;
			memcpy(&_t15, &_t13, sizeof(_result));
			return _t15;
		}
		x__json2__Any* _t17 = (x__json2__Any*)(map_get_check(ADDR(map, d), &(string[]){_SLIT("content")}));
		_option_x__json2__Any _t16 = {0};
		if (_t17) {
			*((x__json2__Any*)&_t16.data) = *((x__json2__Any*)_t17);
		} else {
			_t16.state = 2; _t16.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t16.state != 0) {
			_result_void _t18;
			memcpy(&_t18, &_t16, sizeof(_result));
			return _t18;
		}
		
		
		string content = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t13.data))._string,((*(x__json2__Any*)_t16.data))._typ, 21) /*expected idx: 21, name: string */ ;
		if (!string_starts_with(content, _SLIT("!"))) {
			return (_result_void){0};
		}
		Array_string args = string_split(string_substr(content, 1, 2147483647), _SLIT(" "));
		string* _t21 = (string*)(array_get_with_check(args, 0));
		_option_string _t20 = {0};
		if (_t21) {
			*((string*)&_t20.data) = *((string*)_t21);
		} else {
			_t20.state = 2; _t20.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t20.state != 0) {
			IError err = _t20.err;
			*(string*) _t20.data = _SLIT("");
		}
		
		string /*A*/ _t19 = *(string*)_t20.data;
		
		if (string__eq(_t19, _SLIT("square"))) {
			if (args.len != 2) {
				_option_x__json2__Any _t23;
				_option_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(x__json2__Any),
						_MOV((string[1]){
							_SLIT("content"), 
						}),
						_MOV((x__json2__Any[1]){
							string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("Specify argument, e.g. !square 7")))), 
						})
					)
				
				))) }, (_option*)(&_t23), sizeof(x__json2__Any));
				_result_net__http__Response _t22 = discord__Client_request(event.creator->Client, net__http__Method__post,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/channels/"), /*115 &string*/0xfe10, {.d_s = channel_id}}, {_SLIT("/messages"), 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t23,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
				if (_t22.is_error) {
					_result_void _t24;
					memcpy(&_t24, &_t22, sizeof(_result));
					return _t24;
				}
				
  (*(net__http__Response*)_t22.data);
				return (_result_void){0};
			}
			_result_int _t25 = strconv__atoi((*(string*)array_get(args, 1)));
			if (_t25.is_error) {
				IError err = _t25.err;
				_option_x__json2__Any _t27;
				_option_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(x__json2__Any),
						_MOV((string[1]){
							_SLIT("content"), 
						}),
						_MOV((x__json2__Any[1]){
							string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("Invalid integer")))), 
						})
					)
				
				))) }, (_option*)(&_t27), sizeof(x__json2__Any));
				_result_net__http__Response _t26 = discord__Client_request(event.creator->Client, net__http__Method__post,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/channels/"), /*115 &string*/0xfe10, {.d_s = channel_id}}, {_SLIT("/messages"), 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t27,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
				if (_t26.is_error) {
					_result_void _t28;
					memcpy(&_t28, &_t26, sizeof(_result));
					return _t28;
				}
				
  (*(net__http__Response*)_t26.data);
				return (_result_void){0};
			}
			
 			int i =  (*(int*)_t25.data);
			_option_x__json2__Any _t30;
			_option_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[2]){
						_SLIT("content"), 
						_SLIT("message_reference"), 
					}),
					_MOV((x__json2__Any[2]){
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (int_str(((int)(i * i)))))), 
						Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[1]){
						_SLIT("message_id"), 
					}),
					_MOV((x__json2__Any[1]){
						string_to_sumtype_x__json2__Any/*KEK*/(&message_id), 
					})
				)
			
			))), 
					})
				)
			
			))) }, (_option*)(&_t30), sizeof(x__json2__Any));
			_result_net__http__Response _t29 = discord__Client_request(event.creator->Client, net__http__Method__post,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/channels/"), /*115 &string*/0xfe10, {.d_s = channel_id}}, {_SLIT("/messages"), 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t30,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
			if (_t29.is_error) {
				_result_void _t31;
				memcpy(&_t31, &_t29, sizeof(_result));
				return _t31;
			}
			
  (*(net__http__Response*)_t29.data);
		}
		else if (string__eq(_t19, _SLIT("ping"))) {
			_option_x__json2__Any _t33;
			_option_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[2]){
						_SLIT("content"), 
						_SLIT("message_reference"), 
					}),
					_MOV((x__json2__Any[2]){
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("Pong!")))), 
						Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[1]){
						_SLIT("message_id"), 
					}),
					_MOV((x__json2__Any[1]){
						string_to_sumtype_x__json2__Any/*KEK*/(&message_id), 
					})
				)
			
			))), 
					})
				)
			
			))) }, (_option*)(&_t33), sizeof(x__json2__Any));
			_result_net__http__Response _t32 = discord__Client_request(event.creator->Client, net__http__Method__post,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/channels/"), /*115 &string*/0xfe10, {.d_s = channel_id}}, {_SLIT("/messages"), 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t33,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
			if (_t32.is_error) {
				_result_void _t34;
				memcpy(&_t34, &_t32, sizeof(_result));
				return _t34;
			}
			
  (*(net__http__Response*)_t32.data);
		}
		else if (string__eq(_t19, _SLIT("guild"))) {
			x__json2__Any* _t37 = (x__json2__Any*)(map_get_check(ADDR(map, d), &(string[]){_SLIT("guild_id")}));
			_option_x__json2__Any _t36 = {0};
			if (_t37) {
				*((x__json2__Any*)&_t36.data) = *((x__json2__Any*)_t37);
			} else {
				_t36.state = 2; _t36.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t36.state != 0) {
				_result_void _t38;
				memcpy(&_t38, &_t36, sizeof(_result));
				return _t38;
			}
			
			_result_discord__Snowflake _t35 = discord__Snowflake__static__parse((*(x__json2__Any*)_t36.data));
			if (_t35.is_error) {
				_result_void _t39;
				memcpy(&_t39, &_t35, sizeof(_result));
				return _t39;
			}
			
 			discord__Snowflake guild_id =  (*(discord__Snowflake*)_t35.data);
			_result_discord__Guild _t40 = discord__Client_fetch_guild(event.creator->Client, guild_id);
			if (_t40.is_error) {
				_result_void _t41;
				memcpy(&_t41, &_t40, sizeof(_result));
				return _t41;
			}
			
 			 _v_dump_expr_discord__Guild(_SLIT(".\\\\src\\\\main.v"), 65, _SLIT("event.creator.fetch_guild(guild_id)!"),  (*(discord__Guild*)_t40.data));
			_option_x__json2__Any _t43;
			_option_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[2]){
						_SLIT("content"), 
						_SLIT("message_reference"), 
					}),
					_MOV((x__json2__Any[2]){
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("Dumped!")))), 
						Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[1]){
						_SLIT("message_id"), 
					}),
					_MOV((x__json2__Any[1]){
						string_to_sumtype_x__json2__Any/*KEK*/(&message_id), 
					})
				)
			
			))), 
					})
				)
			
			))) }, (_option*)(&_t43), sizeof(x__json2__Any));
			_result_net__http__Response _t42 = discord__Client_request(event.creator->Client, net__http__Method__post,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/channels/"), /*115 &string*/0xfe10, {.d_s = channel_id}}, {_SLIT("/messages"), 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t43,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
			if (_t42.is_error) {
				_result_void _t44;
				memcpy(&_t44, &_t42, sizeof(_result));
				return _t44;
			}
			
  (*(net__http__Response*)_t42.data);
		}
		else {
		}
	}
	return (_result_void){0};
}
	


// end of V out

// >> typeof() support for sum types / interfaces
static char * v_typeof_interface_IError(int sidx) { /* IError */ 
	if (sidx == _IError_None___index) return "None__";
	if (sidx == _IError_voidptr_index) return "voidptr";
	if (sidx == _IError_Error_index) return "Error";
	if (sidx == _IError_MessageError_index) return "MessageError";
	if (sidx == _IError_time__TimeParseError_index) return "time.TimeParseError";
	if (sidx == _IError_io__Eof_index) return "io.Eof";
	if (sidx == _IError_io__NotExpected_index) return "io.NotExpected";
	if (sidx == _IError_os__Eof_index) return "os.Eof";
	if (sidx == _IError_os__NotExpected_index) return "os.NotExpected";
	if (sidx == _IError_os__FileNotOpenedError_index) return "os.FileNotOpenedError";
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return "os.SizeOfTypeIs0Error";
	if (sidx == _IError_os__ExecutableNotFoundError_index) return "os.ExecutableNotFoundError";
	if (sidx == _IError_x__json2__DecodeError_index) return "x.json2.DecodeError";
	if (sidx == _IError_x__json2__InvalidTokenError_index) return "x.json2.InvalidTokenError";
	if (sidx == _IError_x__json2__UnknownTokenError_index) return "x.json2.UnknownTokenError";
	if (sidx == _IError_net__http__HeaderKeyError_index) return "net.http.HeaderKeyError";
	if (sidx == _IError_discord__InternalServerError_index) return "discord.InternalServerError";
	if (sidx == _IError_discord__Unauthorized_index) return "discord.Unauthorized";
	if (sidx == _IError_discord__Forbidden_index) return "discord.Forbidden";
	if (sidx == _IError_discord__NotFound_index) return "discord.NotFound";
	if (sidx == _IError_discord__Ratelimit_index) return "discord.Ratelimit";
	if (sidx == _IError_discord__RestError_index) return "discord.RestError";
	return "unknown IError";
}

static int v_typeof_interface_idx_IError(int sidx) { /* IError */ 
	if (sidx == _IError_None___index) return 65629;
	if (sidx == _IError_voidptr_index) return 2;
	if (sidx == _IError_Error_index) return 94;
	if (sidx == _IError_MessageError_index) return 96;
	if (sidx == _IError_time__TimeParseError_index) return 377;
	if (sidx == _IError_io__Eof_index) return 515;
	if (sidx == _IError_io__NotExpected_index) return 516;
	if (sidx == _IError_os__Eof_index) return 269;
	if (sidx == _IError_os__NotExpected_index) return 270;
	if (sidx == _IError_os__FileNotOpenedError_index) return 65809;
	if (sidx == _IError_os__SizeOfTypeIs0Error_index) return 65810;
	if (sidx == _IError_os__ExecutableNotFoundError_index) return 65824;
	if (sidx == _IError_x__json2__DecodeError_index) return 326;
	if (sidx == _IError_x__json2__InvalidTokenError_index) return 329;
	if (sidx == _IError_x__json2__UnknownTokenError_index) return 331;
	if (sidx == _IError_net__http__HeaderKeyError_index) return 422;
	if (sidx == _IError_discord__InternalServerError_index) return 190;
	if (sidx == _IError_discord__Unauthorized_index) return 187;
	if (sidx == _IError_discord__Forbidden_index) return 188;
	if (sidx == _IError_discord__NotFound_index) return 189;
	if (sidx == _IError_discord__Ratelimit_index) return 191;
	if (sidx == _IError_discord__RestError_index) return 183;
	return 30;
}
char * v_typeof_sumtype_x__json2__Any(int sidx) { /* x.json2.Any */ 
	switch(sidx) {
		case 117: return "x.json2.Any";
		case 170: return "x.json2.Null";
		case 174: return "[]x.json2.Any";
		case 19: return "bool";
		case 16: return "f32";
		case 17: return "f64";
		case 6: return "i16";
		case 9: return "i64";
		case 5: return "i8";
		case 8: return "int";
		case 173: return "map[string]x.json2.Any";
		case 21: return "string";
		case 176: return "time.Time";
		case 12: return "u16";
		case 13: return "u32";
		case 14: return "u64";
		case 11: return "u8";
		default: return "unknown x.json2.Any";
	}
}

int v_typeof_sumtype_idx_x__json2__Any(int sidx) { /* x.json2.Any */ 
	switch(sidx) {
		case 117: return 117;
		case 170: return 170;
		case 174: return 174;
		case 19: return 19;
		case 16: return 16;
		case 17: return 17;
		case 6: return 6;
		case 9: return 9;
		case 5: return 5;
		case 8: return 8;
		case 173: return 173;
		case 21: return 21;
		case 176: return 176;
		case 12: return 12;
		case 13: return 13;
		case 14: return 14;
		case 11: return 11;
		default: return 117;
	}
}
static char * v_typeof_interface_log__Logger(int sidx) { /* log.Logger */ 
	if (sidx == _log__Logger_log__ThreadSafeLog_index) return "log.ThreadSafeLog";
	if (sidx == _log__Logger_voidptr_index) return "voidptr";
	if (sidx == _log__Logger_log__Log_index) return "log.Log";
	return "unknown log.Logger";
}

static int v_typeof_interface_idx_log__Logger(int sidx) { /* log.Logger */ 
	if (sidx == _log__Logger_log__ThreadSafeLog_index) return 65889;
	if (sidx == _log__Logger_voidptr_index) return 2;
	if (sidx == _log__Logger_log__Log_index) return 65680;
	return 139;
}
static char * v_typeof_interface_discord__Component(int sidx) { /* discord.Component */ 
	if (sidx == _discord__Component_discord__ActionRow_index) return "discord.ActionRow";
	if (sidx == _discord__Component_voidptr_index) return "voidptr";
	if (sidx == _discord__Component_discord__Button_index) return "discord.Button";
	if (sidx == _discord__Component_discord__StringSelect_index) return "discord.StringSelect";
	if (sidx == _discord__Component_discord__UserSelect_index) return "discord.UserSelect";
	if (sidx == _discord__Component_discord__RoleSelect_index) return "discord.RoleSelect";
	if (sidx == _discord__Component_discord__MentionableSelect_index) return "discord.MentionableSelect";
	if (sidx == _discord__Component_discord__ChannelSelect_index) return "discord.ChannelSelect";
	if (sidx == _discord__Component_discord__TextInput_index) return "discord.TextInput";
	return "unknown discord.Component";
}

static int v_typeof_interface_idx_discord__Component(int sidx) { /* discord.Component */ 
	if (sidx == _discord__Component_discord__ActionRow_index) return 148;
	if (sidx == _discord__Component_voidptr_index) return 2;
	if (sidx == _discord__Component_discord__Button_index) return 151;
	if (sidx == _discord__Component_discord__StringSelect_index) return 154;
	if (sidx == _discord__Component_discord__UserSelect_index) return 156;
	if (sidx == _discord__Component_discord__RoleSelect_index) return 157;
	if (sidx == _discord__Component_discord__MentionableSelect_index) return 161;
	if (sidx == _discord__Component_discord__ChannelSelect_index) return 163;
	if (sidx == _discord__Component_discord__TextInput_index) return 165;
	return 146;
}
static char * v_typeof_interface_discord__Image(int sidx) { /* discord.Image */ 
	if (sidx == _discord__Image_discord__JpegImage_index) return "discord.JpegImage";
	if (sidx == _discord__Image_voidptr_index) return "voidptr";
	if (sidx == _discord__Image_discord__PngImage_index) return "discord.PngImage";
	if (sidx == _discord__Image_discord__GifImage_index) return "discord.GifImage";
	return "unknown discord.Image";
}

static int v_typeof_interface_idx_discord__Image(int sidx) { /* discord.Image */ 
	if (sidx == _discord__Image_discord__JpegImage_index) return 249;
	if (sidx == _discord__Image_voidptr_index) return 2;
	if (sidx == _discord__Image_discord__PngImage_index) return 250;
	if (sidx == _discord__Image_discord__GifImage_index) return 251;
	return 248;
}
static char * v_typeof_interface_io__Writer(int sidx) { /* io.Writer */ 
	if (sidx == _io__Writer_io__MultiWriter_index) return "io.MultiWriter";
	if (sidx == _io__Writer_voidptr_index) return "voidptr";
	if (sidx == _io__Writer_strings__Builder_index) return "strings.Builder";
	if (sidx == _io__Writer_os__File_index) return "os.File";
	if (sidx == _io__Writer_net__TcpConn_index) return "net.TcpConn";
	if (sidx == _io__Writer_net__ssl__SSLConn_index) return "net.ssl.SSLConn";
	if (sidx == _io__Writer_io__ReaderWriterImpl_index) return "io.ReaderWriterImpl";
	if (sidx == _io__Writer_net__UdpConn_index) return "net.UdpConn";
	if (sidx == _io__Writer_net__mbedtls__SSLConn_index) return "net.mbedtls.SSLConn";
	if (sidx == _io__Writer_crypto__sha1__Digest_index) return "crypto.sha1.Digest";
	return "unknown io.Writer";
}

static int v_typeof_interface_idx_io__Writer(int sidx) { /* io.Writer */ 
	if (sidx == _io__Writer_io__MultiWriter_index) return 66054;
	if (sidx == _io__Writer_voidptr_index) return 2;
	if (sidx == _io__Writer_strings__Builder_index) return 110;
	if (sidx == _io__Writer_os__File_index) return 271;
	if (sidx == _io__Writer_net__TcpConn_index) return 432;
	if (sidx == _io__Writer_net__ssl__SSLConn_index) return 433;
	if (sidx == _io__Writer_io__ReaderWriterImpl_index) return 522;
	if (sidx == _io__Writer_net__UdpConn_index) return 562;
	if (sidx == _io__Writer_net__mbedtls__SSLConn_index) return 565;
	if (sidx == _io__Writer_crypto__sha1__Digest_index) return 583;
	return 335;
}
static char * v_typeof_interface_x__json2__Encodable(int sidx) { /* x.json2.Encodable */ 
	if (sidx == _x__json2__Encodable_x__json2__Any_index) return "x.json2.Any";
	if (sidx == _x__json2__Encodable_voidptr_index) return "voidptr";
	return "unknown x.json2.Encodable";
}

static int v_typeof_interface_idx_x__json2__Encodable(int sidx) { /* x.json2.Encodable */ 
	if (sidx == _x__json2__Encodable_x__json2__Any_index) return 117;
	if (sidx == _x__json2__Encodable_voidptr_index) return 2;
	return 336;
}
static char * v_typeof_interface_x__json2__Decodable(int sidx) { /* x.json2.Decodable */ 
	return "unknown x.json2.Decodable";
}

static int v_typeof_interface_idx_x__json2__Decodable(int sidx) { /* x.json2.Decodable */ 
	return 340;
}
static char * v_typeof_interface_net__http__Handler(int sidx) { /* net.http.Handler */ 
	if (sidx == _net__http__Handler_net__http__DebugHandler_index) return "net.http.DebugHandler";
	if (sidx == _net__http__Handler_voidptr_index) return "voidptr";
	return "unknown net.http.Handler";
}

static int v_typeof_interface_idx_net__http__Handler(int sidx) { /* net.http.Handler */ 
	if (sidx == _net__http__Handler_net__http__DebugHandler_index) return 446;
	if (sidx == _net__http__Handler_voidptr_index) return 2;
	return 445;
}
static char * v_typeof_interface_io__Reader(int sidx) { /* io.Reader */ 
	if (sidx == _io__Reader_net__TcpConn_index) return "net.TcpConn";
	if (sidx == _io__Reader_voidptr_index) return "voidptr";
	if (sidx == _io__Reader_os__File_index) return "os.File";
	if (sidx == _io__Reader_net__ssl__SSLConn_index) return "net.ssl.SSLConn";
	if (sidx == _io__Reader_io__BufferedReader_index) return "io.BufferedReader";
	if (sidx == _io__Reader_io__ReaderWriterImpl_index) return "io.ReaderWriterImpl";
	if (sidx == _io__Reader_net__mbedtls__SSLConn_index) return "net.mbedtls.SSLConn";
	return "unknown io.Reader";
}

static int v_typeof_interface_idx_io__Reader(int sidx) { /* io.Reader */ 
	if (sidx == _io__Reader_net__TcpConn_index) return 65968;
	if (sidx == _io__Reader_voidptr_index) return 2;
	if (sidx == _io__Reader_os__File_index) return 271;
	if (sidx == _io__Reader_net__ssl__SSLConn_index) return 433;
	if (sidx == _io__Reader_io__BufferedReader_index) return 434;
	if (sidx == _io__Reader_io__ReaderWriterImpl_index) return 522;
	if (sidx == _io__Reader_net__mbedtls__SSLConn_index) return 565;
	return 513;
}
static char * v_typeof_interface_io__RandomReader(int sidx) { /* io.RandomReader */ 
	if (sidx == _io__RandomReader_os__File_index) return "os.File";
	if (sidx == _io__RandomReader_voidptr_index) return "voidptr";
	return "unknown io.RandomReader";
}

static int v_typeof_interface_idx_io__RandomReader(int sidx) { /* io.RandomReader */ 
	if (sidx == _io__RandomReader_os__File_index) return 271;
	if (sidx == _io__RandomReader_voidptr_index) return 2;
	return 520;
}
static char * v_typeof_interface_io__ReaderWriter(int sidx) { /* io.ReaderWriter */ 
	if (sidx == _io__ReaderWriter_io__ReaderWriterImpl_index) return "io.ReaderWriterImpl";
	if (sidx == _io__ReaderWriter_voidptr_index) return "voidptr";
	return "unknown io.ReaderWriter";
}

static int v_typeof_interface_idx_io__ReaderWriter(int sidx) { /* io.ReaderWriter */ 
	if (sidx == _io__ReaderWriter_io__ReaderWriterImpl_index) return 522;
	if (sidx == _io__ReaderWriter_voidptr_index) return 2;
	return 521;
}
static char * v_typeof_interface_io__RandomWriter(int sidx) { /* io.RandomWriter */ 
	return "unknown io.RandomWriter";
}

static int v_typeof_interface_idx_io__RandomWriter(int sidx) { /* io.RandomWriter */ 
	return 523;
}
static char * v_typeof_interface_rand__PRNG(int sidx) { /* rand.PRNG */ 
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return "rand.wyrand.WyRandRNG";
	if (sidx == _rand__PRNG_voidptr_index) return "voidptr";
	return "unknown rand.PRNG";
}

static int v_typeof_interface_idx_rand__PRNG(int sidx) { /* rand.PRNG */ 
	if (sidx == _rand__PRNG_rand__wyrand__WyRandRNG_index) return 66110;
	if (sidx == _rand__PRNG_voidptr_index) return 2;
	return 568;
}
static char * v_typeof_interface_hash__Hasher(int sidx) { /* hash.Hasher */ 
	if (sidx == _hash__Hasher_crypto__sha1__Digest_index) return "crypto.sha1.Digest";
	if (sidx == _hash__Hasher_voidptr_index) return "voidptr";
	return "unknown hash.Hasher";
}

static int v_typeof_interface_idx_hash__Hasher(int sidx) { /* hash.Hasher */ 
	if (sidx == _hash__Hasher_crypto__sha1__Digest_index) return 583;
	if (sidx == _hash__Hasher_voidptr_index) return 2;
	return 605;
}
static char * v_typeof_interface_hash__Hash32er(int sidx) { /* hash.Hash32er */ 
	return "unknown hash.Hash32er";
}

static int v_typeof_interface_idx_hash__Hash32er(int sidx) { /* hash.Hash32er */ 
	return 606;
}
static char * v_typeof_interface_hash__Hash64er(int sidx) { /* hash.Hash64er */ 
	return "unknown hash.Hash64er";
}

static int v_typeof_interface_idx_hash__Hash64er(int sidx) { /* hash.Hash64er */ 
	return 607;
}
// << typeof() support for sum types

// TypeDecl
strings__Builder strings__new_builder(int initial_size) {
	strings__Builder res = ((__new_array_with_default_noscan(0, initial_size, sizeof(u8), 0)));
	ArrayFlags_set(&res.flags, ArrayFlags__noslices);
	return res;
}

// Attr: [unsafe]
Array_u8 strings__Builder_reuse_as_plain_u8_array(strings__Builder* b) {
	ArrayFlags_clear(&b->flags, ArrayFlags__noslices);
	return *b;
}

// Attr: [unsafe]
void strings__Builder_write_ptr(strings__Builder* b, u8* ptr, int len) {
	if (len == 0) {
		return;
	}
	array_push_many(b, ptr, len);
}

// Attr: [manualfree]
void strings__Builder_write_rune(strings__Builder* b, rune r) {
	Array_fixed_u8_5 buffer = {0, 0, 0, 0, 0};
	string res = utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
	if (res.len == 0) {
		return;
	}
	array_push_many(b, res.str, res.len);
}

void strings__Builder_write_runes(strings__Builder* b, Array_rune runes) {
	Array_fixed_u8_5 buffer = {0, 0, 0, 0, 0};
	for (int _t1 = 0; _t1 < runes.len; ++_t1) {
		rune r = ((rune*)runes.data)[_t1];
		string res = utf32_to_str_no_malloc(((u32)(r)), &buffer[0]);
		if (res.len == 0) {
			continue;
		}
		array_push_many(b, res.str, res.len);
	}
}

void strings__Builder_clear(strings__Builder* b) {
	*b = __new_array_with_default_noscan(0, b->cap, sizeof(u8), 0);
}

void strings__Builder_write_u8(strings__Builder* b, u8 data) {
	array_push_noscan((array*)b, _MOV((u8[]){ data }));
}

void strings__Builder_write_byte(strings__Builder* b, u8 data) {
	array_push_noscan((array*)b, _MOV((u8[]){ data }));
}

// Attr: [direct_array_access]
void strings__Builder_write_decimal(strings__Builder* b, i64 n) {
	if (n == 0) {
		strings__Builder_write_u8(b, 0x30);
		return;
	}
	Array_fixed_u8_25 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	i64 x = (n < 0 ? (-n) : (n));
	int i = 24;
	for (;;) {
		if (!(x != 0)) break;
		i64 nextx = (i64)(x / 10);
		i64 r = (i64)(x % 10);
		buf[i] = (u8)(((u8)(r)) + 0x30);
		x = nextx;
		i--;
	}
	if (n < 0) {
		buf[i] = '-';
		i--;
	}
	strings__Builder_write_ptr(b, &buf[(int)(i + 1)], (int)(24 - i));
}

_result_int strings__Builder_write(strings__Builder* b, Array_u8 data) {
	if (data.len == 0) {
		_result_int _t1;
		_result_ok(&(int[]) { 0 }, (_result*)(&_t1), sizeof(int));
		return _t1;
	}
	_PUSH_MANY_noscan(b, (data), _t2, strings__Builder);
	_result_int _t3;
	_result_ok(&(int[]) { data.len }, (_result*)(&_t3), sizeof(int));
	return _t3;
}

// Attr: [manualfree]
void strings__Builder_drain_builder(strings__Builder* b, strings__Builder* other, int other_new_cap) {
	if (other->len > 0) {
		_PUSH_MANY_noscan(b, (*other), _t1, strings__Builder);
	}
	strings__Builder_free(other);
	*other = strings__new_builder(other_new_cap);
}

// Attr: [inline]
inline u8 strings__Builder_byte_at(strings__Builder* b, int n) {
	return (*(u8*)array_get(*(((Array_u8*)(b))), n));
}

// Attr: [inline]
inline void strings__Builder_write_string(strings__Builder* b, string s) {
	if (s.len == 0) {
		return;
	}
	array_push_many(b, s.str, s.len);
}

// Attr: [inline]
inline void strings__Builder_writeln_string(strings__Builder* b, string s) {
	strings__Builder_write_string(b, s);
	strings__Builder_write_string(b, _SLIT("\n"));
}

void strings__Builder_go_back(strings__Builder* b, int n) {
	array_trim(b, (int)(b->len - n));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string strings__Builder_spart(strings__Builder* b, int start_pos, int n) {
	{ // Unsafe block
		u8* x = malloc_noscan((int)(n + 1));
		vmemcpy(x, ((u8*)(b->data)) + start_pos, n);
		x[n] = 0;
		return tos(x, n);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string strings__Builder_cut_last(strings__Builder* b, int n) {
	int cut_pos = (int)(b->len - n);
	string res = strings__Builder_spart(b, cut_pos, n);
	array_trim(b, cut_pos);
	return res;
}

string strings__Builder_cut_to(strings__Builder* b, int pos) {
	if (pos > b->len) {
		return _SLIT("");
	}
	return strings__Builder_cut_last(b, (int)(b->len - pos));
}

void strings__Builder_go_back_to(strings__Builder* b, int pos) {
	array_trim(b, pos);
}

// Attr: [inline]
inline void strings__Builder_writeln(strings__Builder* b, string s) {
	if (s.len > 0) {
		array_push_many(b, s.str, s.len);
	}
	array_push_noscan((array*)b, _MOV((u8[]){ ((u8)('\n')) }));
}

string strings__Builder_last_n(strings__Builder* b, int n) {
	if (n > b->len) {
		return _SLIT("");
	}
	return strings__Builder_spart(b, (int)(b->len - n), n);
}

string strings__Builder_after(strings__Builder* b, int n) {
	if (n >= b->len) {
		return _SLIT("");
	}
	return strings__Builder_spart(b, n, (int)(b->len - n));
}

string strings__Builder_str(strings__Builder* b) {
	array_push_noscan((array*)b, _MOV((u8[]){ ((u8)(0)) }));
	u8* bcopy = ((u8*)(memdup_noscan(b->data, b->len)));
	string s = u8_vstring_with_len(bcopy, (int)(b->len - 1));
	array_trim(b, 0);
	return s;
}

void strings__Builder_ensure_cap(strings__Builder* b, int n) {
	if (n <= b->cap) {
		return;
	}
	u8* new_data = vcalloc((int)(n * b->element_size));
	if (b->data != ((void*)0)) {
		vmemcpy(new_data, b->data, (int)(b->len * b->element_size));
		if (ArrayFlags_has(&b->flags, ArrayFlags__noslices)) {
			_v_free(b->data);
		}
	}
	{ // Unsafe block
		b->data = new_data;
		b->offset = 0;
		b->cap = n;
	}
}

// Attr: [unsafe]
void strings__Builder_free(strings__Builder* b) {
	if (b->data != 0) {
		_v_free(b->data);
		{ // Unsafe block
			b->data = ((void*)0);
		}
	}
}

int strings__levenshtein_distance(string a, string b) {
	Array_int f = array_repeat_to_depth_noscan(new_array_from_c_array_noscan(1, 1, sizeof(int), _MOV((int[1]){0})), (int)(b.len + 1), 0);
	for (int j = 0; j < f.len; ++j) {
		array_set(&f, j, &(int[]) { j });
	}
	for (int _t1 = 0; _t1 < a.len; ++_t1) {
		u8 ca = a.str[_t1];
		int j = 1;
		int fj1 = (*(int*)array_get(f, 0));
		(*(int*)array_get(f, 0))++;
		for (int _t2 = 0; _t2 < b.len; ++_t2) {
			u8 cb = b.str[_t2];
			int mn = ((int)((*(int*)array_get(f, j)) + 1) <= (int)((*(int*)array_get(f, (int)(j - 1))) + 1) ? ((int)((*(int*)array_get(f, j)) + 1)) : ((int)((*(int*)array_get(f, (int)(j - 1))) + 1)));
			if (cb != ca) {
				mn = (mn <= (int)(fj1 + 1) ? (mn) : ((int)(fj1 + 1)));
			} else {
				mn = (mn <= fj1 ? (mn) : (fj1));
			}
			fj1 = (*(int*)array_get(f, j));
			array_set(&f, j, &(int[]) { mn });
			j++;
		}
	}
	return (*(int*)array_get(f, (int)(f.len - 1)));
}

f32 strings__levenshtein_distance_percentage(string a, string b) {
	int d = strings__levenshtein_distance(a, b);
	int l = (a.len >= b.len ? (a.len) : (b.len));
	return (f32)(((f32)(((f32)(1.00)) - (f32)(((f32)(d)) / ((f32)(l))))) * ((f32)(100.00)));
}

f32 strings__dice_coefficient(string s1, string s2) {
	if (s1.len == 0 || s2.len == 0) {
		return 0.0;
	}
	if (string__eq(s1, s2)) {
		return 1.0;
	}
	if (s1.len < 2 || s2.len < 2) {
		return 0.0;
	}
	string a = (s1.len > s2.len ? (s1) : (s2));
	string b = (string__eq(a, s1) ? (s2) : (s1));
	Map_string_int first_bigrams = new_map_noscan_value(sizeof(string), sizeof(int), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	for (int i = 0; i < (int)(a.len - 1); ++i) {
		string bigram = string_substr(a, i, (int_literal)(i + 2));
		int q = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((int)((*(int*)map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 })) + 1)) : (1));
		map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { q });
	}
	int intersection_size = 0;
	for (int i = 0; i < (int)(b.len - 1); ++i) {
		string bigram = string_substr(b, i, (int_literal)(i + 2));
		int count = (_IN_MAP(ADDR(string, bigram), ADDR(map, first_bigrams)) ? ((*(int*)map_get(ADDR(map, first_bigrams), &(string[]){bigram}, &(int[]){ 0 }))) : (0));
		if (count > 0) {
			map_set(&first_bigrams, &(string[]){bigram}, &(int[]) { (int)(count - 1) });
			intersection_size++;
		}
	}
	return (f32)(((f32)(((f32)(2.0)) * ((f32)(intersection_size)))) / ((f32)((f32)(((f32)(a.len)) + ((f32)(b.len))) - 2)));
}

// Attr: [direct_array_access]
string strings__repeat(u8 c, int n) {
	if (n <= 0) {
		return _SLIT("");
	}
	u8* bytes = malloc_noscan((int)(n + 1));
	{ // Unsafe block
		memset(bytes, c, n);
		bytes[n] = '0';
	}
	return u8_vstring_with_len(bytes, n);
}

// Attr: [direct_array_access]
string strings__repeat_string(string s, int n) {
	if (n <= 0 || s.len == 0) {
		return _SLIT("");
	}
	int slen = s.len;
	int blen = (int)(slen * n);
	u8* bytes = malloc_noscan((int)(blen + 1));
	for (int bi = 0; bi < n; ++bi) {
		int bislen = (int)(bi * slen);
		for (int si = 0; si < slen; ++si) {
			{ // Unsafe block
				bytes[(int)(bislen + si)] = s.str[ si];
			}
		}
	}
	{ // Unsafe block
		bytes[blen] = '0';
	}
	return u8_vstring_with_len(bytes, blen);
}

string strings__find_between_pair_u8(string input, u8 start, u8 end) {
	int marks = 0;
	int start_index = -1;
	for (int i = 0; i < input.len; ++i) {
		u8 b = input.str[i];
		if (b == start) {
			if (start_index == -1) {
				start_index = (int)(i + 1);
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			if (b == end) {
				marks--;
				if (marks == 0) {
					return string_substr(input, start_index, i);
				}
			}
		}
	}
	return _SLIT("");
}

string strings__find_between_pair_rune(string input, rune start, rune end) {
	int marks = 0;
	int start_index = -1;
	Array_rune runes = string_runes(input);
	for (int i = 0; i < runes.len; ++i) {
		rune r = ((rune*)runes.data)[i];
		if (r == start) {
			if (start_index == -1) {
				start_index = (int)(i + 1);
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			if (r == end) {
				marks--;
				if (marks == 0) {
					return Array_rune_string(array_slice(runes, start_index, i));
				}
			}
		}
	}
	return _SLIT("");
}

string strings__find_between_pair_string(string input, string start, string end) {
	int start_index = -1;
	int marks = 0;
	Array_rune start_runes = string_runes(start);
	Array_rune end_runes = string_runes(end);
	Array_rune runes = string_runes(input);
	int i = 0;
	for (; i < runes.len; i++) {
		Array_rune start_slice = array_slice_ni(runes, i, (int)(i + start_runes.len));
		if (Array_rune_arr_eq(start_slice, start_runes)) {
			i = (int)((int)(i + start_runes.len) - 1);
			if (start_index < 0) {
				start_index = (int)(i + 1);
			}
			marks++;
			continue;
		}
		if (start_index > 0) {
			Array_rune end_slice = array_slice_ni(runes, i, (int)(i + end_runes.len));
			if (Array_rune_arr_eq(end_slice, end_runes)) {
				marks--;
				if (marks == 0) {
					return Array_rune_string(array_slice(runes, start_index, i));
				}
				i = (int)((int)(i + end_runes.len) - 1);
				continue;
			}
		}
	}
	return _SLIT("");
}

Array_string strings__split_capital(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int word_start = 0;
	for (int idx = 0; idx < s.len; ++idx) {
		u8 c = s.str[idx];
		if (c >= 'A' && c <= 'Z') {
			if (word_start != idx) {
				array_push((array*)&res, _MOV((string[]){ string_substr_ni(s, word_start, idx) }));
			}
			word_start = idx;
			continue;
		}
	}
	if (word_start != s.len) {
		array_push((array*)&res, _MOV((string[]){ string_substr_ni(s, word_start, 2147483647) }));
	}
	return res;
}

int math__bits__leading_zeros_8(u8 x) {
	return (int)(8 - math__bits__len_8(x));
}

int math__bits__leading_zeros_16(u16 x) {
	return (int)(16 - math__bits__len_16(x));
}

int math__bits__leading_zeros_32(u32 x) {
	return (int)(32 - math__bits__len_32(x));
}

int math__bits__leading_zeros_64(u64 x) {
	return (int)(64 - math__bits__len_64(x));
}

int math__bits__trailing_zeros_8(u8 x) {
	return ((int)(_const_math__bits__ntz_8_tab[v_fixed_index(x, 256)]));
}

int math__bits__trailing_zeros_16(u16 x) {
	if (x == 0U) {
		return 16;
	}
	return ((int)(_const_math__bits__de_bruijn32tab[v_fixed_index(((u32)(((u32)((x & -x))) * _const_math__bits__de_bruijn32) >> (27)), 32)]));
}

int math__bits__trailing_zeros_32(u32 x) {
	if (x == 0U) {
		return 32;
	}
	return ((int)(_const_math__bits__de_bruijn32tab[v_fixed_index(((u32)(((x & -x)) * _const_math__bits__de_bruijn32) >> (27)), 32)]));
}

int math__bits__trailing_zeros_64(u64 x) {
	if (x == 0U) {
		return 64;
	}
	return ((int)(_const_math__bits__de_bruijn64tab[v_fixed_index(((u64)(((x & -x)) * _const_math__bits__de_bruijn64) >> (58)), 64)]));
}

int math__bits__ones_count_8(u8 x) {
	return ((int)(_const_math__bits__pop_8_tab[v_fixed_index(x, 256)]));
}

int math__bits__ones_count_16(u16 x) {
	return ((int)((u8)(_const_math__bits__pop_8_tab[v_fixed_index((x >> 8U), 256)] + _const_math__bits__pop_8_tab[v_fixed_index((x & ((u16)(0xffU))), 256)])));
}

int math__bits__ones_count_32(u32 x) {
	return ((int)((u8)((u8)((u8)(_const_math__bits__pop_8_tab[v_fixed_index((x >> 24U), 256)] + _const_math__bits__pop_8_tab[v_fixed_index(((x >> 16U) & 0xffU), 256)]) + _const_math__bits__pop_8_tab[v_fixed_index(((x >> 8U) & 0xffU), 256)]) + _const_math__bits__pop_8_tab[v_fixed_index((x & ((u32)(0xffU))), 256)])));
}

int math__bits__ones_count_64(u64 x) {
	u64 y = (u64)((((x >> ((u64)(1U))) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) + ((x & ((_const_math__bits__m0 & _const_math__bits__max_u64)))));
	y = (u64)((((y >> ((u64)(2U))) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) + ((y & ((_const_math__bits__m1 & _const_math__bits__max_u64)))));
	y = (((u64)(((y >> 4U)) + y)) & ((_const_math__bits__m2 & _const_math__bits__max_u64)));
	y += (y >> 8U);
	y += (y >> 16U);
	y += (y >> 32U);
	return (((int)(y)) & ((int_literal)((128) - 1)));
}

// Attr: [inline]
inline u8 math__bits__rotate_left_8(u8 x, int k) {
	u8 s = (((u8)(k)) & ((u8)(_const_math__bits__n8 - ((u8)(1)))));
	return (((x << s)) | ((x >> ((u8)(_const_math__bits__n8 - s)))));
}

// Attr: [inline]
inline u16 math__bits__rotate_left_16(u16 x, int k) {
	u16 s = (((u16)(k)) & ((u16)(_const_math__bits__n16 - ((u16)(1U)))));
	return (((x << s)) | ((x >> ((u16)(_const_math__bits__n16 - s)))));
}

// Attr: [inline]
inline u32 math__bits__rotate_left_32(u32 x, int k) {
	u32 s = (((u32)(k)) & ((u32)(_const_math__bits__n32 - ((u32)(1U)))));
	return (((x << s)) | ((x >> ((u32)(_const_math__bits__n32 - s)))));
}

// Attr: [inline]
inline u64 math__bits__rotate_left_64(u64 x, int k) {
	u64 s = (((u64)(k)) & ((u64)(_const_math__bits__n64 - ((u64)(1U)))));
	return (((x << s)) | ((x >> ((u64)(_const_math__bits__n64 - s)))));
}

// Attr: [inline]
inline u8 math__bits__reverse_8(u8 x) {
	return _const_math__bits__rev_8_tab[v_fixed_index(x, 256)];
}

// Attr: [inline]
inline u16 math__bits__reverse_16(u16 x) {
	return (((u16)(_const_math__bits__rev_8_tab[v_fixed_index((x >> 8U), 256)])) | ((((u16)(_const_math__bits__rev_8_tab[v_fixed_index((x & ((u16)(0xffU))), 256)])) << 8U)));
}

// Attr: [inline]
inline u32 math__bits__reverse_32(u32 x) {
	u64 y = (((((x >> ((u32)(1U))) & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) | ((((x & ((_const_math__bits__m0 & _const_math__bits__max_u32)))) << 1U))));
	y = (((((y >> ((u32)(2U))) & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) | ((((y & ((_const_math__bits__m1 & _const_math__bits__max_u32)))) << ((u32)(2U))))));
	y = (((((y >> ((u32)(4U))) & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) | ((((y & ((_const_math__bits__m2 & _const_math__bits__max_u32)))) << ((u32)(4U))))));
	return math__bits__reverse_bytes_32(((u32)(y)));
}

// Attr: [inline]
inline u64 math__bits__reverse_64(u64 x) {
	u64 y = (((((x >> ((u64)(1U))) & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) | ((((x & ((_const_math__bits__m0 & _const_math__bits__max_u64)))) << 1U))));
	y = (((((y >> ((u64)(2U))) & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) | ((((y & ((_const_math__bits__m1 & _const_math__bits__max_u64)))) << 2U))));
	y = (((((y >> ((u64)(4U))) & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) | ((((y & ((_const_math__bits__m2 & _const_math__bits__max_u64)))) << 4U))));
	return math__bits__reverse_bytes_64(y);
}

// Attr: [inline]
inline u16 math__bits__reverse_bytes_16(u16 x) {
	return (((x >> 8U)) | ((x << 8U)));
}

// Attr: [inline]
inline u32 math__bits__reverse_bytes_32(u32 x) {
	u64 y = (((((x >> ((u32)(8U))) & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) | ((((x & ((_const_math__bits__m3 & _const_math__bits__max_u32)))) << ((u32)(8U))))));
	return ((u32)((((y >> 16U)) | ((y << 16U)))));
}

// Attr: [inline]
inline u64 math__bits__reverse_bytes_64(u64 x) {
	u64 y = (((((x >> ((u64)(8U))) & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) | ((((x & ((_const_math__bits__m3 & _const_math__bits__max_u64)))) << ((u64)(8U))))));
	y = (((((y >> ((u64)(16U))) & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) | ((((y & ((_const_math__bits__m4 & _const_math__bits__max_u64)))) << ((u64)(16U))))));
	return (((y >> 32U)) | ((y << 32U)));
}

int math__bits__len_8(u8 x) {
	return ((int)(_const_math__bits__len_8_tab[v_fixed_index(x, 256)]));
}

int math__bits__len_16(u16 x) {
	u16 y = x;
	int n = 0;
	if (y >= 256U) {
		y >>= 8U;
		n = 8;
	}
	return (int)(n + ((int)(_const_math__bits__len_8_tab[v_fixed_index(y, 256)])));
}

int math__bits__len_32(u32 x) {
	u32 y = x;
	int n = 0;
	if (y >= (65536)) {
		y >>= 16U;
		n = 16;
	}
	if (y >= (256)) {
		y >>= 8U;
		n += 8;
	}
	return (int)(n + ((int)(_const_math__bits__len_8_tab[v_fixed_index(y, 256)])));
}

int math__bits__len_64(u64 x) {
	u64 y = x;
	int n = 0;
	if (y >= (((u64)(1U)) << ((u64)(32U)))) {
		y >>= 32U;
		n = 32;
	}
	if (y >= (((u64)(1U)) << ((u64)(16U)))) {
		y >>= 16U;
		n += 16;
	}
	if (y >= (((u64)(1U)) << ((u64)(8U)))) {
		y >>= 8U;
		n += 8;
	}
	return (int)(n + ((int)(_const_math__bits__len_8_tab[v_fixed_index(y, 256)])));
}

multi_return_u32_u32 math__bits__add_32(u32 x, u32 y, u32 carry) {
	u64 sum64 = (u64)((u64)(((u64)(x)) + ((u64)(y))) + ((u64)(carry)));
	u32 sum = ((u32)(sum64));
	u32 carry_out = ((u32)((sum64 >> 32U)));
	return (multi_return_u32_u32){.arg0=sum, .arg1=carry_out};
}

multi_return_u64_u64 math__bits__add_64(u64 x, u64 y, u64 carry) {
	u64 sum = (u64)((u64)(x + y) + carry);
	u64 carry_out = (((((x & y)) | ((((x | y)) & ~sum)))) >> 63U);
	return (multi_return_u64_u64){.arg0=sum, .arg1=carry_out};
}

multi_return_u32_u32 math__bits__sub_32(u32 x, u32 y, u32 borrow) {
	u32 diff = (u32)((u32)(x - y) - borrow);
	u32 borrow_out = (((((~x & y)) | ((~((x ^ y)) & diff)))) >> 31U);
	return (multi_return_u32_u32){.arg0=diff, .arg1=borrow_out};
}

multi_return_u64_u64 math__bits__sub_64(u64 x, u64 y, u64 borrow) {
	u64 diff = (u64)((u64)(x - y) - borrow);
	u64 borrow_out = (((((~x & y)) | ((~((x ^ y)) & diff)))) >> 63U);
	return (multi_return_u64_u64){.arg0=diff, .arg1=borrow_out};
}

multi_return_u32_u32 math__bits__mul_32(u32 x, u32 y) {
	u64 tmp = (u64)(((u64)(x)) * ((u64)(y)));
	u32 hi = ((u32)((tmp >> 32U)));
	u32 lo = ((u32)(tmp));
	return (multi_return_u32_u32){.arg0=hi, .arg1=lo};
}

multi_return_u64_u64 math__bits__mul_64(u64 x, u64 y) {
	u64 x0 = (x & _const_math__bits__mask32);
	u64 x1 = (x >> 32U);
	u64 y0 = (y & _const_math__bits__mask32);
	u64 y1 = (y >> 32U);
	u64 w0 = (u64)(x0 * y0);
	u64 t = (u64)((u64)(x1 * y0) + ((w0 >> 32U)));
	u64 w1 = (t & _const_math__bits__mask32);
	u64 w2 = (t >> 32U);
	w1 += (u64)(x0 * y1);
	u64 hi = (u64)((u64)((u64)(x1 * y1) + w2) + ((w1 >> 32U)));
	u64 lo = (u64)(x * y);
	return (multi_return_u64_u64){.arg0=hi, .arg1=lo};
}

multi_return_u32_u32 math__bits__div_32(u32 hi, u32 lo, u32 y) {
	if (y != 0U && y <= hi) {
		_v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	u64 z = (((((u64)(hi)) << 32U)) | ((u64)(lo)));
	u32 quo = ((u32)((u64)(z / ((u64)(y)))));
	u32 rem = ((u32)((u64)(z % ((u64)(y)))));
	return (multi_return_u32_u32){.arg0=quo, .arg1=rem};
}

multi_return_u64_u64 math__bits__div_64(u64 hi, u64 lo, u64 y1) {
	u64 y = y1;
	if (y == 0U) {
		_v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	if (y <= hi) {
		_v_panic(_const_math__bits__overflow_error);
		VUNREACHABLE();
	}
	u32 s = ((u32)(math__bits__leading_zeros_64(y)));
	y <<= s;
	u64 yn1 = (y >> 32U);
	u64 yn0 = (y & _const_math__bits__mask32);
	u64 ss1 = ((hi << s));
	u32 xxx = (u32)(64 - s);
	u64 ss2 = (lo >> xxx);
	if (xxx == 64U) {
		ss2 = 0U;
	}
	u64 un32 = (ss1 | ss2);
	u64 un10 = (lo << s);
	u64 un1 = (un10 >> 32U);
	u64 un0 = (un10 & _const_math__bits__mask32);
	u64 q1 = (u64)(un32 / yn1);
	u64 rhat = (u64)(un32 - ((u64)(q1 * yn1)));
	for (;;) {
		if (!(q1 >= _const_math__bits__two32 || ((u64)(q1 * yn0)) > ((u64)(((u64)(_const_math__bits__two32 * rhat)) + un1)))) break;
		q1--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 un21 = (u64)(((u64)(un32 * _const_math__bits__two32)) + ((u64)(un1 - ((u64)(q1 * y)))));
	u64 q0 = (u64)(un21 / yn1);
	rhat = (u64)(un21 - (u64)(q0 * yn1));
	for (;;) {
		if (!(q0 >= _const_math__bits__two32 || ((u64)(q0 * yn0)) > ((u64)(((u64)(_const_math__bits__two32 * rhat)) + un0)))) break;
		q0--;
		rhat += yn1;
		if (rhat >= _const_math__bits__two32) {
			break;
		}
	}
	u64 qq = ((u64)(((u64)(q1 * _const_math__bits__two32)) + q0));
	u64 rr = (((u64)((u64)(((u64)(un21 * _const_math__bits__two32)) + un0) - ((u64)(q0 * y)))) >> s);
	return (multi_return_u64_u64){.arg0=qq, .arg1=rr};
}

u32 math__bits__rem_32(u32 hi, u32 lo, u32 y) {
	return ((u32)((u64)(((((((u64)(hi)) << 32U)) | ((u64)(lo)))) % ((u64)(y)))));
}

u64 math__bits__rem_64(u64 hi, u64 lo, u64 y) {
	multi_return_u64_u64 mr_16733 = math__bits__div_64((u64)(hi % y), lo, y);
	u64 rem = mr_16733.arg1;
	return rem;
}

multi_return_f64_int math__bits__normalize(f64 x) {
	f64 smallest_normal = 2.2250738585072014e-308;
	if (((x > ((f64)(0.0)) ? (x) : (-x))) < smallest_normal) {
		return (multi_return_f64_int){.arg0=(f64)(x * ((((u64)(1U)) << ((u64)(52U))))), .arg1=-52};
	}
	return (multi_return_f64_int){.arg0=x, .arg1=0};
}

// Attr: [inline]
inline u32 math__bits__f32_bits(f32 f) {
	u32 p = *((u32*)(&f));
	return p;
}

// Attr: [inline]
inline f32 math__bits__f32_from_bits(u32 b) {
	f32 p = *((f32*)(&b));
	return p;
}

// Attr: [inline]
inline u64 math__bits__f64_bits(f64 f) {
	u64 p = *((u64*)(&f));
	return p;
}

// Attr: [inline]
inline f64 math__bits__f64_from_bits(u64 b) {
	f64 p = *((f64*)(&b));
	return p;
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsr96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r0 = (((s0 >> 1U)) | ((((s1 & ((u32)(1U)))) << 31U)));
	r1 = (((s1 >> 1U)) | ((((s2 & ((u32)(1U)))) << 31U)));
	r2 = (s2 >> 1U);
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__lsl96(u32 s2, u32 s1, u32 s0) {
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	r2 = (((s2 << 1U)) | ((((s1 & ((((u32)(1U)) << 31U)))) >> 31U)));
	r1 = (((s1 << 1U)) | ((((s0 & ((((u32)(1U)) << 31U)))) >> 31U)));
	r0 = (s0 << 1U);
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__add96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = (u64)(((u64)(s0)) + ((u64)(d0)));
	r0 = ((u32)(w));
	w >>= 32U;
	w += (u64)(((u64)(s1)) + ((u64)(d1)));
	r1 = ((u32)(w));
	w >>= 32U;
	w += (u64)(((u64)(s2)) + ((u64)(d2)));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL multi_return_u32_u32_u32 strconv__sub96(u32 s2, u32 s1, u32 s0, u32 d2, u32 d1, u32 d0) {
	u64 w = ((u64)(0U));
	u32 r0 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	w = (u64)(((u64)(s0)) - ((u64)(d0)));
	r0 = ((u32)(w));
	w >>= 32U;
	w += (u64)(((u64)(s1)) - ((u64)(d1)));
	r1 = ((u32)(w));
	w >>= 32U;
	w += (u64)(((u64)(s2)) - ((u64)(d2)));
	r2 = ((u32)(w));
	return (multi_return_u32_u32_u32){.arg0=r2, .arg1=r1, .arg2=r0};
}

VV_LOCAL_SYMBOL bool strconv__is_digit(u8 x) {
	return x >= _const_strconv__c_zero && x <= _const_strconv__c_nine;
}

VV_LOCAL_SYMBOL bool strconv__is_space(u8 x) {
	return x == '\t' || x == '\n' || x == '\v' || x == '\f' || x == '\r' || x == ' ';
}

VV_LOCAL_SYMBOL bool strconv__is_exp(u8 x) {
	return x == 'E' || x == 'e';
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL multi_return_strconv__ParserState_strconv__PrepNumber strconv__parser(string s) {
	int digx = 0;
	strconv__ParserState result = strconv__ParserState__ok;
	bool expneg = false;
	int expexp = 0;
	int i = 0;
	strconv__PrepNumber pn = ((strconv__PrepNumber){.negative = 0,.exponent = 0,.mantissa = 0,});
	for (;;) {
		if (!(i < s.len && u8_is_space(s.str[ i]))) break;
		i++;
	}
	if (s.str[ i] == '-') {
		pn.negative = true;
		i++;
	}
	if (s.str[ i] == '+') {
		i++;
	}
	for (;;) {
		if (!(i < s.len && u8_is_digit(s.str[ i]))) break;
		if (digx < _const_strconv__digits) {
			pn.mantissa *= 10U;
			pn.mantissa += ((u64)((rune)(s.str[ i] - _const_strconv__c_zero)));
			digx++;
		} else if (pn.exponent < 2147483647) {
			pn.exponent++;
		}
		i++;
	}
	if (i < s.len && s.str[ i] == '.') {
		i++;
		for (;;) {
			if (!(i < s.len && u8_is_digit(s.str[ i]))) break;
			if (digx < _const_strconv__digits) {
				pn.mantissa *= 10U;
				pn.mantissa += ((u64)((rune)(s.str[ i] - _const_strconv__c_zero)));
				pn.exponent--;
				digx++;
			}
			i++;
		}
	}
	if (i < s.len && (s.str[ i] == 'e' || s.str[ i] == 'E')) {
		i++;
		if (i < s.len) {
			if (s.str[ i] == _const_strconv__c_plus) {
				i++;
			} else if (s.str[ i] == _const_strconv__c_minus) {
				expneg = true;
				i++;
			}
			for (;;) {
				if (!(i < s.len && u8_is_digit(s.str[ i]))) break;
				if (expexp < 214748364) {
					expexp *= 10;
					expexp += ((int)((rune)(s.str[ i] - _const_strconv__c_zero)));
				}
				i++;
			}
		}
	}
	if (expneg) {
		expexp = -expexp;
	}
	pn.exponent += expexp;
	if (pn.mantissa == 0U) {
		if (pn.negative) {
			result = strconv__ParserState__mzero;
		} else {
			result = strconv__ParserState__pzero;
		}
	} else if (pn.exponent > 309) {
		if (pn.negative) {
			result = strconv__ParserState__minf;
		} else {
			result = strconv__ParserState__pinf;
		}
	} else if (pn.exponent < -328) {
		if (pn.negative) {
			result = strconv__ParserState__mzero;
		} else {
			result = strconv__ParserState__pzero;
		}
	}
	if (i == 0 && s.len > 0) {
		return (multi_return_strconv__ParserState_strconv__PrepNumber){.arg0=strconv__ParserState__invalid_number, .arg1=pn};
	}
	return (multi_return_strconv__ParserState_strconv__PrepNumber){.arg0=result, .arg1=pn};
}

VV_LOCAL_SYMBOL u64 strconv__converter(strconv__PrepNumber* pn) {
	int binexp = 92;
	u32 s2 = ((u32)(0U));
	u32 s1 = ((u32)(0U));
	u32 s0 = ((u32)(0U));
	u32 q2 = ((u32)(0U));
	u32 q1 = ((u32)(0U));
	u32 q0 = ((u32)(0U));
	u32 r2 = ((u32)(0U));
	u32 r1 = ((u32)(0U));
	u32 r0 = ((u32)(0U));
	u32 mask28 = ((u32)((((u64)(0xFU)) << 28U)));
	u64 result = ((u64)(0U));
	s0 = ((u32)((pn->mantissa & ((u64)(0x00000000FFFFFFFFU)))));
	s1 = ((u32)((pn->mantissa >> 32U)));
	s2 = ((u32)(0U));
	for (;;) {
		if (!(pn->exponent > 0)) break;
		multi_return_u32_u32_u32 mr_5541 = strconv__lsl96(s2, s1, s0);
		q2 = mr_5541.arg0;
		q1 = mr_5541.arg1;
		q0 = mr_5541.arg2;
		multi_return_u32_u32_u32 mr_5587 = strconv__lsl96(q2, q1, q0);
		r2 = mr_5587.arg0;
		r1 = mr_5587.arg1;
		r0 = mr_5587.arg2;
		multi_return_u32_u32_u32 mr_5643 = strconv__lsl96(r2, r1, r0);
		s2 = mr_5643.arg0;
		s1 = mr_5643.arg1;
		s0 = mr_5643.arg2;
		multi_return_u32_u32_u32 mr_5699 = strconv__add96(s2, s1, s0, q2, q1, q0);
		s2 = mr_5699.arg0;
		s1 = mr_5699.arg1;
		s0 = mr_5699.arg2;
		pn->exponent--;
		for (;;) {
			if (!(((s2 & mask28)) != 0U)) break;
			multi_return_u32_u32_u32 mr_5822 = strconv__lsr96(s2, s1, s0);
			q2 = mr_5822.arg0;
			q1 = mr_5822.arg1;
			q0 = mr_5822.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	for (;;) {
		if (!(pn->exponent < 0)) break;
		for (;;) {
			if (!(!(((s2 & ((((u32)(1U)) << 31U)))) != 0U))) break;
			multi_return_u32_u32_u32 mr_5969 = strconv__lsl96(s2, s1, s0);
			q2 = mr_5969.arg0;
			q1 = mr_5969.arg1;
			q0 = mr_5969.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
		q2 = (u32)(s2 / _const_strconv__c_ten);
		r1 = (u32)(s2 % _const_strconv__c_ten);
		r2 = (((s1 >> 8U)) | ((r1 << 24U)));
		q1 = (u32)(r2 / _const_strconv__c_ten);
		r1 = (u32)(r2 % _const_strconv__c_ten);
		r2 = ((((((s1 & ((u32)(0xFFU)))) << 16U)) | ((s0 >> 16U))) | ((r1 << 24U)));
		r0 = (u32)(r2 / _const_strconv__c_ten);
		r1 = (u32)(r2 % _const_strconv__c_ten);
		q1 = (((q1 << 8U)) | ((((r0 & ((u32)(0x00FF0000U)))) >> 16U)));
		q0 = (r0 << 16U);
		r2 = (((s0 & ((u32)(0xFFFFU)))) | ((r1 << 16U)));
		q0 |= (u32)(r2 / _const_strconv__c_ten);
		s2 = q2;
		s1 = q1;
		s0 = q0;
		pn->exponent++;
	}
	if (s2 != 0U || s1 != 0U || s0 != 0U) {
		for (;;) {
			if (!(((s2 & mask28)) == 0U)) break;
			multi_return_u32_u32_u32 mr_6705 = strconv__lsl96(s2, s1, s0);
			q2 = mr_6705.arg0;
			q1 = mr_6705.arg1;
			q0 = mr_6705.arg2;
			binexp--;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	int nbit = 7;
	u32 check_round_bit = (((u32)(1U)) << ((u32)(nbit)));
	u32 check_round_mask = (((u32)(0xFFFFFFFFU)) << ((u32)(nbit)));
	if (((s1 & check_round_bit)) != 0U) {
		if (((s1 & ~check_round_mask)) != 0U) {
			multi_return_u32_u32_u32 mr_7790 = strconv__add96(s2, s1, s0, 0U, check_round_bit, 0U);
			s2 = mr_7790.arg0;
			s1 = mr_7790.arg1;
			s0 = mr_7790.arg2;
		} else {
			if (((s1 & ((check_round_bit << ((u32)(1U)))))) != 0U) {
				multi_return_u32_u32_u32 mr_7984 = strconv__add96(s2, s1, s0, 0U, check_round_bit, 0U);
				s2 = mr_7984.arg0;
				s1 = mr_7984.arg1;
				s0 = mr_7984.arg2;
			}
		}
		s1 = (s1 & check_round_mask);
		s0 = ((u32)(0U));
		if ((s2 & ((mask28 << ((u32)(1U))))) != 0U) {
			multi_return_u32_u32_u32 mr_8191 = strconv__lsr96(s2, s1, s0);
			q2 = mr_8191.arg0;
			q1 = mr_8191.arg1;
			q0 = mr_8191.arg2;
			binexp++;
			s2 = q2;
			s1 = q1;
			s0 = q0;
		}
	}
	binexp += 1023;
	if (binexp > 2046) {
		if (pn->negative) {
			result = _const_strconv__double_minus_infinity;
		} else {
			result = _const_strconv__double_plus_infinity;
		}
	} else if (binexp < 1) {
		if (pn->negative) {
			result = _const_strconv__double_minus_zero;
		} else {
			result = _const_strconv__double_plus_zero;
		}
	} else if (s2 != 0U) {
		u64 q = ((u64)(0U));
		u64 binexs2 = (((u64)(binexp)) << 52U);
		q = ((((((u64)((s2 & ~mask28))) << 24U)) | ((((u64)(((u64)(s1)) + ((u64)(128U)))) >> 8U))) | binexs2);
		if (pn->negative) {
			q |= ((((u64)(1U)) << 63U));
		}
		result = q;
	}
	return result;
}

_result_f64 strconv__atof64(string s) {
	if (s.len == 0) {
		return (_result_f64){ .is_error=true, .err=_v_error(_SLIT("expected a number found an empty string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	strconv__Float64u res = ((strconv__Float64u){0});
	multi_return_strconv__ParserState_strconv__PrepNumber mr_9282 = strconv__parser(s);
	strconv__ParserState res_parsing = mr_9282.arg0;
	strconv__PrepNumber pn = mr_9282.arg1;
	switch (res_parsing) {
		case strconv__ParserState__ok: {
				res.u = strconv__converter((voidptr)&/*qq*/pn);
				break;
		}
		case strconv__ParserState__pzero: {
				res.u = _const_strconv__double_plus_zero;
				break;
		}
		case strconv__ParserState__mzero: {
				res.u = _const_strconv__double_minus_zero;
				break;
		}
		case strconv__ParserState__pinf: {
				res.u = _const_strconv__double_plus_infinity;
				break;
		}
		case strconv__ParserState__minf: {
				res.u = _const_strconv__double_minus_infinity;
				break;
		}
		case strconv__ParserState__invalid_number: {
				return (_result_f64){ .is_error=true, .err=_v_error(_SLIT("not a number")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	
	_result_f64 _t3;
	_result_ok(&(f64[]) { res.f }, (_result*)(&_t3), sizeof(f64));
	return _t3;
}

// Attr: [direct_array_access]
f64 strconv__atof_quick(string s) {
	strconv__Float64u f = ((strconv__Float64u){0});
	f64 sign = ((f64)(1.0));
	int i = 0;
	for (;;) {
		if (!(i < s.len && s.str[ i] == ' ')) break;
		i++;
	}
	if (i < s.len) {
		if (s.str[ i] == '-') {
			sign = -1.0;
			i++;
		} else if (s.str[ i] == '+') {
			i++;
		}
	}
	if (s.str[ i] == 'i' && (int)(i + 2) < s.len && s.str[ (int)(i + 1)] == 'n' && s.str[ (int)(i + 2)] == 'f') {
		if (sign > ((f64)(0.0))) {
			f.u = _const_strconv__double_plus_infinity;
		} else {
			f.u = _const_strconv__double_minus_infinity;
		}
		return f.f;
	}
	for (;;) {
		if (!(i < s.len && s.str[ i] == '0')) break;
		i++;
		if (i >= s.len) {
			if (sign > ((f64)(0.0))) {
				f.u = _const_strconv__double_plus_zero;
			} else {
				f.u = _const_strconv__double_minus_zero;
			}
			return f.f;
		}
	}
	for (;;) {
		if (!(i < s.len && (s.str[ i] >= '0' && s.str[ i] <= '9'))) break;
		f.f *= ((f64)(10.0));
		f.f += ((f64)((rune)(s.str[ i] - '0')));
		i++;
	}
	if (i < s.len && s.str[ i] == '.') {
		i++;
		f64 frac_mul = ((f64)(0.1));
		for (;;) {
			if (!(i < s.len && (s.str[ i] >= '0' && s.str[ i] <= '9'))) break;
			f.f += (f64)(((f64)((rune)(s.str[ i] - '0'))) * frac_mul);
			frac_mul *= ((f64)(0.1));
			i++;
		}
	}
	if (i < s.len && (s.str[ i] == 'e' || s.str[ i] == 'E')) {
		i++;
		int exp = 0;
		int exp_sign = 1;
		if (i < s.len) {
			if (s.str[ i] == '-') {
				exp_sign = -1;
				i++;
			} else if (s.str[ i] == '+') {
				i++;
			}
		}
		for (;;) {
			if (!(i < s.len && s.str[ i] == '0')) break;
			i++;
		}
		for (;;) {
			if (!(i < s.len && (s.str[ i] >= '0' && s.str[ i] <= '9'))) break;
			exp *= 10;
			exp += ((int)((rune)(s.str[ i] - '0')));
			i++;
		}
		if (exp_sign == 1) {
			if (exp > 309) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_infinity;
				} else {
					f.u = _const_strconv__double_minus_infinity;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = ((strconv__Float64u){.u = _const_strconv__pos_exp[exp],});
			f.f = (f64)(f.f * tmp_mul.f);
		} else {
			if (exp > 324) {
				if (sign > 0) {
					f.u = _const_strconv__double_plus_zero;
				} else {
					f.u = _const_strconv__double_minus_zero;
				}
				return f.f;
			}
			strconv__Float64u tmp_mul = ((strconv__Float64u){.u = _const_strconv__neg_exp[exp],});
			f.f = (f64)(f.f * tmp_mul.f);
		}
	}
	{ // Unsafe block
		f.f = (f64)(f.f * sign);
		return f.f;
	}
	return 0;
}

// Attr: [inline]
inline u8 strconv__byte_to_lower(u8 c) {
	return (c | 32);
}

_result_u64 strconv__common_parse_uint(string s, int _base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	multi_return_u64_int mr_772 = strconv__common_parse_uint2(s, _base, _bit_size);
	u64 result = mr_772.arg0;
	int err = mr_772.arg1;
	if (err != 0 && (error_on_non_digit || error_on_high_digit)) {
		switch (err) {
			case -1: {
					return (_result_u64){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: wrong base "), /*100 &int*/0xfe07, {.d_i32 = _base}}, {_SLIT(" for "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			case -2: {
					return (_result_u64){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: wrong bit size "), /*100 &int*/0xfe07, {.d_i32 = _bit_size}}, {_SLIT(" for "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			case -3: {
					return (_result_u64){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: integer overflow "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			default: {
					return (_result_u64){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("common_parse_uint: syntax error "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		
	}
	_result_u64 _t5;
	_result_ok(&(u64[]) { result }, (_result*)(&_t5), sizeof(u64));
	return _t5;
}

// Attr: [direct_array_access]
multi_return_u64_int strconv__common_parse_uint2(string s, int _base, int _bit_size) {
	if (s.len < 1) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
	}
	int bit_size = _bit_size;
	int base = _base;
	int start_index = 0;
	if (base == 0) {
		base = 10;
		if (s.str[ 0] == '0') {
			u8 ch = (s.str[ 1] | 32);
			if (s.len >= 3) {
				if (ch == 'b') {
					base = 2;
					start_index += 2;
				} else if (ch == 'o') {
					base = 8;
					start_index += 2;
				} else if (ch == 'x') {
					base = 16;
					start_index += 2;
				}
				if (s.str[ start_index] == '_') {
					start_index++;
				}
			} else if (s.len >= 2 && (s.str[ 1] >= '0' && s.str[ 1] <= '9')) {
				base = 10;
				start_index++;
			} else {
				base = 8;
				start_index++;
			}
		}
	}
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	} else if (bit_size < 0 || bit_size > 64) {
		return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=-2};
	}
	u64 cutoff = (u64)((u64)(_const_strconv__max_u64 / ((u64)(base))) + ((u64)(1U)));
	u64 max_val = (bit_size == 64 ? (_const_strconv__max_u64) : ((u64)(((((u64)(1U)) << ((u64)(bit_size)))) - ((u64)(1U)))));
	int basem1 = (int)(base - 1);
	u64 n = ((u64)(0U));
	for (int i = start_index; i < s.len; ++i) {
		u8 c = s.str[ i];
		if (c == '_') {
			if (i == start_index || i >= ((int)(s.len - 1))) {
				return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
			}
			if (s.str[ (int)(i - 1)] == '_' || s.str[ (int)(i + 1)] == '_') {
				return (multi_return_u64_int){.arg0=((u64)(0U)), .arg1=1};
			}
			continue;
		}
		int sub_count = 0;
		c -= 48;
		if (c >= 17) {
			sub_count++;
			c -= 7;
			if (c >= 42) {
				sub_count++;
				c -= 32;
			}
		}
		if (c > basem1 || (sub_count == 0 && c > 9)) {
			return (multi_return_u64_int){.arg0=n, .arg1=(int)(i + 1)};
		}
		if (n >= cutoff) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n *= ((u64)(base));
		u64 n1 = (u64)(n + ((u64)(c)));
		if (n1 < n || n1 > max_val) {
			return (multi_return_u64_int){.arg0=max_val, .arg1=-3};
		}
		n = n1;
	}
	return (multi_return_u64_int){.arg0=n, .arg1=0};
}

_result_u64 strconv__parse_uint(string s, int _base, int _bit_size) {
	_result_u64 _t1 = strconv__common_parse_uint(s, _base, _bit_size, true, true);
	return _t1;
}

// Attr: [direct_array_access]
_result_i64 strconv__common_parse_int(string _s, int base, int _bit_size, bool error_on_non_digit, bool error_on_high_digit) {
	if (_s.len < 1) {
		_result_i64 _t1;
		_result_ok(&(i64[]) { ((i64)(0)) }, (_result*)(&_t1), sizeof(i64));
		return _t1;
	}
	int bit_size = _bit_size;
	if (bit_size == 0) {
		bit_size = _const_strconv__int_size;
	}
	string s = _s;
	bool neg = false;
	if (s.str[ 0] == '+') {
		{ // Unsafe block
			s = tos(s.str + 1, (int)(s.len - 1));
		}
	} else if (s.str[ 0] == '-') {
		neg = true;
		{ // Unsafe block
			s = tos(s.str + 1, (int)(s.len - 1));
		}
	}
	_result_u64 _t2 = strconv__common_parse_uint(s, base, bit_size, error_on_non_digit, error_on_high_digit);
	if (_t2.is_error) {
		_result_i64 _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	u64 un =  (*(u64*)_t2.data);
	if (un == 0U) {
		_result_i64 _t4;
		_result_ok(&(i64[]) { ((i64)(0)) }, (_result*)(&_t4), sizeof(i64));
		return _t4;
	}
	u64 cutoff = (((u64)(1U)) << ((u64)((int)(bit_size - 1))));
	if (!neg && un >= cutoff) {
		_result_i64 _t5;
		_result_ok(&(i64[]) { ((i64)((u64)(cutoff - ((u64)(1U))))) }, (_result*)(&_t5), sizeof(i64));
		return _t5;
	}
	if (neg && un > cutoff) {
		_result_i64 _t6;
		_result_ok(&(i64[]) { -((i64)(cutoff)) }, (_result*)(&_t6), sizeof(i64));
		return _t6;
	}
	_result_i64 _t8; /* if prepend */
	if (neg) {
		_result_ok(&(i64[]) { -((i64)(un)) }, (_result*)(&_t8), sizeof(i64));
	} else {
		_result_ok(&(i64[]) { ((i64)(un)) }, (_result*)(&_t8), sizeof(i64));
	}
	return  _t8;
}

_result_i64 strconv__parse_int(string _s, int base, int _bit_size) {
	_result_i64 _t1 = strconv__common_parse_int(_s, base, _bit_size, true, true);
	return _t1;
}

// Attr: [direct_array_access]
_result_int strconv__atoi(string s) {
	if ((s).len == 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("strconv.atoi: parsing \"\": invalid syntax")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if ((_const_strconv__int_size == 32 && (0 < s.len && s.len < 10)) || (_const_strconv__int_size == 64 && (0 < s.len && s.len < 19))) {
		int start_idx = 0;
		if (s.str[ 0] == '-' || s.str[ 0] == '+') {
			start_idx++;
			if ((int)(s.len - start_idx) < 1) {
				return (_result_int){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strconv.atoi: parsing \""), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT("\": invalid syntax"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		int n = 0;
		for (int i = start_idx; i < s.len; ++i) {
			rune ch = (rune)(s.str[ i] - '0');
			if (ch > 9) {
				return (_result_int){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("strconv.atoi: parsing \""), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT("\": invalid syntax"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			n = (int)((int)(n * 10) + ((int)(ch)));
		}
		_result_int _t5; /* if prepend */
		if (s.str[ 0] == '-') {
			_result_ok(&(int[]) { -n }, (_result*)(&_t5), sizeof(int));
		} else {
			_result_ok(&(int[]) { n }, (_result*)(&_t5), sizeof(int));
		}
		return  _t5;
	}
	_result_i64 _t6 = strconv__parse_int(s, 10, 0);
	if (_t6.is_error) {
		_result_int _t7;
		memcpy(&_t7, &_t6, sizeof(_result));
		return _t7;
	}
	
 	i64 int64 =  (*(i64*)_t6.data);
	_result_int _t8;
	_result_ok(&(int[]) { ((int)(int64)) }, (_result*)(&_t8), sizeof(int));
	return _t8;
}

// Attr: [direct_array_access]
string strconv__Dec32_get_string_32(strconv__Dec32 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = (int)(i_n_digit + 1);
	int pad_digit = (int)(i_pad_digit + 1);
	u32 out = d.m;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = (int)(pad_digit - out_len);
	}
	Array_u8 buf = __new_array_with_default_noscan(((int)((int)((int)((int)(out_len + 5) + 1) + 1))), 0, sizeof(u8), 0);
	int i = 0;
	if (neg) {
		if (buf.data != 0) {
			((u8*)buf.data)[i] = '-';
		}
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (u32)(_const_strconv__ten_pow_table_32[(int)((int)(out_len - n_digit) - 1)] * 5U);
		out /= _const_strconv__ten_pow_table_32[(int)(out_len - n_digit)];
		out_len = n_digit;
	}
	int y = (int)(i + out_len);
	int x = 0;
	for (;;) {
		if (!(x < ((int)((int)(out_len - disp) - 1)))) break;
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u32)(out % 10U))));
		out /= 10U;
		i++;
		x++;
	}
	if (i_n_digit == 0) {
		{ // Unsafe block
			((u8*)buf.data)[i] = 0;
			return tos(((u8*)(&((u8*)buf.data)[0])), i);
		}
	}
	if (out_len >= 1) {
		((u8*)buf.data)[(int)(y - x)] = '.';
		x++;
		i++;
	}
	if ((int)(y - x) >= 0) {
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u32)(out % 10U))));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((u8*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((u8*)buf.data)[i] = 'e';
	i++;
	int exp = (int)((int)(d.e + out_len_original) - 1);
	if (exp < 0) {
		((u8*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((u8*)buf.data)[i] = '+';
		i++;
	}
	int d1 = (int)(exp % 10);
	int d0 = (int)(exp / 10);
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d0)));
	i++;
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d1)));
	i++;
	((u8*)buf.data)[i] = 0;
	return tos(((u8*)(&((u8*)buf.data)[0])), i);
}

VV_LOCAL_SYMBOL multi_return_strconv__Dec32_bool strconv__f32_to_decimal_exact_int(u32 i_mant, u32 exp) {
	strconv__Dec32 d = ((strconv__Dec32){.m = 0,.e = 0,});
	u32 e = (u32)(exp - _const_strconv__bias32);
	if (e > _const_strconv__mantbits32) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	u32 shift = (u32)(_const_strconv__mantbits32 - e);
	u32 mant = (i_mant | 0x00800000U);
	d.m = (mant >> shift);
	if (((d.m << shift)) != mant) {
		return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!(((u32)(d.m % 10U)) == 0U)) break;
		d.m /= 10U;
		d.e++;
	}
	return (multi_return_strconv__Dec32_bool){.arg0=d, .arg1=true};
}

VV_LOCAL_SYMBOL strconv__Dec32 strconv__f32_to_decimal(u32 mant, u32 exp) {
	int e2 = 0;
	u32 m2 = ((u32)(0U));
	if (exp == 0U) {
		e2 = (int)((int)((int_literal)(1 - _const_strconv__bias32) - ((int)(_const_strconv__mantbits32))) - 2);
		m2 = mant;
	} else {
		e2 = (int)((int)((int)(((int)(exp)) - _const_strconv__bias32) - ((int)(_const_strconv__mantbits32))) - 2);
		m2 = (((((u32)(1U)) << _const_strconv__mantbits32)) | mant);
	}
	bool even = ((m2 & 1U)) == 0U;
	bool accept_bounds = even;
	u32 mv = ((u32)((u32)(4 * m2)));
	u32 mp = ((u32)((u32)((u32)(4 * m2) + 2U)));
	u32 mm_shift = strconv__bool_to_u32(mant != 0U || exp <= 1U);
	u32 mm = ((u32)((u32)((u32)((u32)(4 * m2) - 1U) - mm_shift)));
	u32 vr = ((u32)(0U));
	u32 vp = ((u32)(0U));
	u32 vm = ((u32)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	u8 last_removed_digit = ((u8)(0));
	if (e2 >= 0) {
		u32 q = strconv__log10_pow2(e2);
		e10 = ((int)(q));
		int k = (int)((int)(_const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)(q)))) - 1);
		int i = (int)((int)(-e2 + ((int)(q))) + k);
		vr = strconv__mul_pow5_invdiv_pow2(mv, q, i);
		vp = strconv__mul_pow5_invdiv_pow2(mp, q, i);
		vm = strconv__mul_pow5_invdiv_pow2(mm, q, i);
		if (q != 0U && (u32)(((u32)(vp - 1U)) / 10U) <= (u32)(vm / 10U)) {
			int l = (int)((int)(_const_strconv__pow5_inv_num_bits_32 + strconv__pow5_bits(((int)((u32)(q - 1U))))) - 1);
			last_removed_digit = ((u8)((u32)(strconv__mul_pow5_invdiv_pow2(mv, (u32)(q - 1U), (int)((int)(-e2 + ((int)((u32)(q - 1U)))) + l)) % 10U)));
		}
		if (q <= 9U) {
			if ((u32)(mv % 5U) == 0U) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_32(mm, q);
			} else if (strconv__multiple_of_power_of_five_32(mp, q)) {
				vp--;
			}
		}
	} else {
		u32 q = strconv__log10_pow5(-e2);
		e10 = (int)(((int)(q)) + e2);
		int i = (int)(-e2 - ((int)(q)));
		int k = (int)(strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_32);
		int j = (int)(((int)(q)) - k);
		vr = strconv__mul_pow5_div_pow2(mv, ((u32)(i)), j);
		vp = strconv__mul_pow5_div_pow2(mp, ((u32)(i)), j);
		vm = strconv__mul_pow5_div_pow2(mm, ((u32)(i)), j);
		if (q != 0U && ((u32)(((u32)(vp - 1U)) / 10U)) <= (u32)(vm / 10U)) {
			j = (int)((int)(((int)(q)) - 1) - ((int)(strconv__pow5_bits((int)(i + 1)) - _const_strconv__pow5_num_bits_32)));
			last_removed_digit = ((u8)((u32)(strconv__mul_pow5_div_pow2(mv, ((u32)((int)(i + 1))), j) % 10U)));
		}
		if (q <= 1U) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = mm_shift == 1U;
			} else {
				vp--;
			}
		} else if (q < 31U) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_32(mv, (u32)(q - 1U));
		}
	}
	int removed = 0;
	u32 out = ((u32)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			if (!((u32)(vp / 10U) > (u32)(vm / 10U))) break;
			vm_is_trailing_zeros = vm_is_trailing_zeros && ((u32)(vm % 10U)) == 0U;
			vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
			last_removed_digit = ((u8)((u32)(vr % 10U)));
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				if (!((u32)(vm % 10U) == 0U)) break;
				vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
				last_removed_digit = ((u8)((u32)(vr % 10U)));
				vr /= 10U;
				vp /= 10U;
				vm /= 10U;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && last_removed_digit == 5 && ((u32)(vr % 2U)) == 0U) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		for (;;) {
			if (!((u32)(vp / 10U) > (u32)(vm / 10U))) break;
			last_removed_digit = ((u8)((u32)(vr % 10U)));
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		out = (u32)(vr + strconv__bool_to_u32(vr == vm || last_removed_digit >= 5));
	}
	return ((strconv__Dec32){.m = out,.e = (int)(e10 + removed),});
}

string strconv__f32_to_str(f32 f, int n_digit) {
	strconv__Uf32 u1 = ((strconv__Uf32){0});
	u1.f = f;
	u32 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits32 + _const_strconv__expbits32)))) != 0U;
	u32 mant = (u & ((u32)(((((u32)(1U)) << _const_strconv__mantbits32)) - ((u32)(1U)))));
	u32 exp = (((u >> _const_strconv__mantbits32)) & ((u32)(((((u32)(1U)) << _const_strconv__expbits32)) - ((u32)(1U)))));
	if (exp == _const_strconv__maxexp32 || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec32_bool mr_8733 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_8733.arg0;
	bool ok = mr_8733.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, 0);
}

string strconv__f32_to_str_pad(f32 f, int n_digit) {
	strconv__Uf32 u1 = ((strconv__Uf32){0});
	u1.f = f;
	u32 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits32 + _const_strconv__expbits32)))) != 0U;
	u32 mant = (u & ((u32)(((((u32)(1U)) << _const_strconv__mantbits32)) - ((u32)(1U)))));
	u32 exp = (((u >> _const_strconv__mantbits32)) & ((u32)(((((u32)(1U)) << _const_strconv__expbits32)) - ((u32)(1U)))));
	if (exp == _const_strconv__maxexp32 || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec32_bool mr_9515 = strconv__f32_to_decimal_exact_int(mant, exp);
	strconv__Dec32 d = mr_9515.arg0;
	bool ok = mr_9515.arg1;
	if (!ok) {
		d = strconv__f32_to_decimal(mant, exp);
	}
	return strconv__Dec32_get_string_32(d, neg, n_digit, n_digit);
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL string strconv__Dec64_get_string_64(strconv__Dec64 d, bool neg, int i_n_digit, int i_pad_digit) {
	int n_digit = (int)(i_n_digit + 1);
	int pad_digit = (int)(i_pad_digit + 1);
	u64 out = d.m;
	int d_exp = d.e;
	int out_len = strconv__dec_digits(out);
	int out_len_original = out_len;
	int fw_zeros = 0;
	if (pad_digit > out_len) {
		fw_zeros = (int)(pad_digit - out_len);
	}
	Array_u8 buf = __new_array_with_default_noscan(((int)((int)((int)((int)(out_len + 6) + 1) + 1) + fw_zeros)), 0, sizeof(u8), 0);
	int i = 0;
	if (neg) {
		((u8*)buf.data)[i] = '-';
		i++;
	}
	int disp = 0;
	if (out_len <= 1) {
		disp = 1;
	}
	if (n_digit < out_len) {
		out += (u64)(_const_strconv__ten_pow_table_64[(int)((int)(out_len - n_digit) - 1)] * 5U);
		out /= _const_strconv__ten_pow_table_64[(int)(out_len - n_digit)];
		if ((u64)(d.m / _const_strconv__ten_pow_table_64[(int)(out_len - n_digit)]) < out) {
			d_exp++;
			n_digit++;
		}
		out_len = n_digit;
	}
	int y = (int)(i + out_len);
	int x = 0;
	for (;;) {
		if (!(x < ((int)((int)(out_len - disp) - 1)))) break;
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u64)(out % 10U))));
		out /= 10U;
		i++;
		x++;
	}
	if (i_n_digit == 0) {
		{ // Unsafe block
			((u8*)buf.data)[i] = 0;
			return tos(((u8*)(&((u8*)buf.data)[0])), i);
		}
	}
	if (out_len >= 1) {
		((u8*)buf.data)[(int)(y - x)] = '.';
		x++;
		i++;
	}
	if ((int)(y - x) >= 0) {
		((u8*)buf.data)[(int)(y - x)] = (rune)('0' + ((u8)((u64)(out % 10U))));
		i++;
	}
	for (;;) {
		if (!(fw_zeros > 0)) break;
		((u8*)buf.data)[i] = '0';
		i++;
		fw_zeros--;
	}
	((u8*)buf.data)[i] = 'e';
	i++;
	int exp = (int)((int)(d_exp + out_len_original) - 1);
	if (exp < 0) {
		((u8*)buf.data)[i] = '-';
		i++;
		exp = -exp;
	} else {
		((u8*)buf.data)[i] = '+';
		i++;
	}
	int d2 = (int)(exp % 10);
	exp /= 10;
	int d1 = (int)(exp % 10);
	int d0 = (int)(exp / 10);
	if (d0 > 0) {
		((u8*)buf.data)[i] = (rune)('0' + ((u8)(d0)));
		i++;
	}
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d1)));
	i++;
	((u8*)buf.data)[i] = (rune)('0' + ((u8)(d2)));
	i++;
	((u8*)buf.data)[i] = 0;
	return tos(((u8*)(&((u8*)buf.data)[0])), i);
}

VV_LOCAL_SYMBOL multi_return_strconv__Dec64_bool strconv__f64_to_decimal_exact_int(u64 i_mant, u64 exp) {
	strconv__Dec64 d = ((strconv__Dec64){.m = 0,.e = 0,});
	u64 e = (u64)(exp - _const_strconv__bias64);
	if (e > _const_strconv__mantbits64) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	u64 shift = (u64)(_const_strconv__mantbits64 - e);
	u64 mant = (i_mant | ((u64)(0x0010000000000000U)));
	d.m = (mant >> shift);
	if (((d.m << shift)) != mant) {
		return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=false};
	}
	for (;;) {
		if (!(((u64)(d.m % 10U)) == 0U)) break;
		d.m /= 10U;
		d.e++;
	}
	return (multi_return_strconv__Dec64_bool){.arg0=d, .arg1=true};
}

VV_LOCAL_SYMBOL strconv__Dec64 strconv__f64_to_decimal(u64 mant, u64 exp) {
	int e2 = 0;
	u64 m2 = ((u64)(0U));
	if (exp == 0U) {
		e2 = (int)((int)((int_literal)(1 - _const_strconv__bias64) - ((int)(_const_strconv__mantbits64))) - 2);
		m2 = mant;
	} else {
		e2 = (int)((int)((int)(((int)(exp)) - _const_strconv__bias64) - ((int)(_const_strconv__mantbits64))) - 2);
		m2 = (((((u64)(1U)) << _const_strconv__mantbits64)) | mant);
	}
	bool even = ((m2 & 1U)) == 0U;
	bool accept_bounds = even;
	u64 mv = ((u64)((u64)(4 * m2)));
	u64 mm_shift = strconv__bool_to_u64(mant != 0U || exp <= 1U);
	u64 vr = ((u64)(0U));
	u64 vp = ((u64)(0U));
	u64 vm = ((u64)(0U));
	int e10 = 0;
	bool vm_is_trailing_zeros = false;
	bool vr_is_trailing_zeros = false;
	if (e2 >= 0) {
		u32 q = (u32)(strconv__log10_pow2(e2) - strconv__bool_to_u32(e2 > 3));
		e10 = ((int)(q));
		int k = (int)((int)(_const_strconv__pow5_inv_num_bits_64 + strconv__pow5_bits(((int)(q)))) - 1);
		int i = (int)((int)(-e2 + ((int)(q))) + k);
		strconv__Uint128 mul = *(((strconv__Uint128*)(&_const_strconv__pow5_inv_split_64_x[v_fixed_index((u32)(q * 2U), 584)])));
		vr = strconv__mul_shift_64((u64)(((u64)(4U)) * m2), mul, i);
		vp = strconv__mul_shift_64((u64)((u64)(((u64)(4U)) * m2) + ((u64)(2U))), mul, i);
		vm = strconv__mul_shift_64((u64)((u64)((u64)(((u64)(4U)) * m2) - ((u64)(1U))) - mm_shift), mul, i);
		if (q <= 21U) {
			if ((u64)(mv % 5U) == 0U) {
				vr_is_trailing_zeros = strconv__multiple_of_power_of_five_64(mv, q);
			} else if (accept_bounds) {
				vm_is_trailing_zeros = strconv__multiple_of_power_of_five_64((u64)((u64)(mv - 1U) - mm_shift), q);
			} else if (strconv__multiple_of_power_of_five_64((u64)(mv + 2U), q)) {
				vp--;
			}
		}
	} else {
		u32 q = (u32)(strconv__log10_pow5(-e2) - strconv__bool_to_u32(-e2 > 1));
		e10 = (int)(((int)(q)) + e2);
		int i = (int)(-e2 - ((int)(q)));
		int k = (int)(strconv__pow5_bits(i) - _const_strconv__pow5_num_bits_64);
		int j = (int)(((int)(q)) - k);
		strconv__Uint128 mul = *(((strconv__Uint128*)(&_const_strconv__pow5_split_64_x[v_fixed_index((int)(i * 2), 652)])));
		vr = strconv__mul_shift_64((u64)(((u64)(4U)) * m2), mul, j);
		vp = strconv__mul_shift_64((u64)((u64)(((u64)(4U)) * m2) + ((u64)(2U))), mul, j);
		vm = strconv__mul_shift_64((u64)((u64)((u64)(((u64)(4U)) * m2) - ((u64)(1U))) - mm_shift), mul, j);
		if (q <= 1U) {
			vr_is_trailing_zeros = true;
			if (accept_bounds) {
				vm_is_trailing_zeros = (mm_shift == 1U);
			} else {
				vp--;
			}
		} else if (q < 63U) {
			vr_is_trailing_zeros = strconv__multiple_of_power_of_two_64(mv, (u32)(q - 1U));
		}
	}
	int removed = 0;
	u8 last_removed_digit = ((u8)(0));
	u64 out = ((u64)(0U));
	if (vm_is_trailing_zeros || vr_is_trailing_zeros) {
		for (;;) {
			u64 vp_div_10 = (u64)(vp / 10U);
			u64 vm_div_10 = (u64)(vm / 10U);
			if (vp_div_10 <= vm_div_10) {
				break;
			}
			u64 vm_mod_10 = (u64)(vm % 10U);
			u64 vr_div_10 = (u64)(vr / 10U);
			u64 vr_mod_10 = (u64)(vr % 10U);
			vm_is_trailing_zeros = vm_is_trailing_zeros && vm_mod_10 == 0U;
			vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
			last_removed_digit = ((u8)(vr_mod_10));
			vr = vr_div_10;
			vp = vp_div_10;
			vm = vm_div_10;
			removed++;
		}
		if (vm_is_trailing_zeros) {
			for (;;) {
				u64 vm_div_10 = (u64)(vm / 10U);
				u64 vm_mod_10 = (u64)(vm % 10U);
				if (vm_mod_10 != 0U) {
					break;
				}
				u64 vp_div_10 = (u64)(vp / 10U);
				u64 vr_div_10 = (u64)(vr / 10U);
				u64 vr_mod_10 = (u64)(vr % 10U);
				vr_is_trailing_zeros = vr_is_trailing_zeros && last_removed_digit == 0;
				last_removed_digit = ((u8)(vr_mod_10));
				vr = vr_div_10;
				vp = vp_div_10;
				vm = vm_div_10;
				removed++;
			}
		}
		if (vr_is_trailing_zeros && last_removed_digit == 5 && ((u64)(vr % 2U)) == 0U) {
			last_removed_digit = 4;
		}
		out = vr;
		if ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5) {
			out++;
		}
	} else {
		bool round_up = false;
		for (;;) {
			if (!((u64)(vp / 100U) > (u64)(vm / 100U))) break;
			round_up = ((u64)(vr % 100U)) >= 50U;
			vr /= 100U;
			vp /= 100U;
			vm /= 100U;
			removed += 2;
		}
		for (;;) {
			if (!((u64)(vp / 10U) > (u64)(vm / 10U))) break;
			round_up = ((u64)(vr % 10U)) >= 5U;
			vr /= 10U;
			vp /= 10U;
			vm /= 10U;
			removed++;
		}
		out = (u64)(vr + strconv__bool_to_u64(vr == vm || round_up));
	}
	return ((strconv__Dec64){.m = out,.e = (int)(e10 + removed),});
}

string strconv__f64_to_str(f64 f, int n_digit) {
	strconv__Uf64 u1 = ((strconv__Uf64){0});
	u1.f = f;
	u64 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits64 + _const_strconv__expbits64)))) != 0U;
	u64 mant = (u & ((u64)(((((u64)(1U)) << _const_strconv__mantbits64)) - ((u64)(1U)))));
	u64 exp = (((u >> _const_strconv__mantbits64)) & ((u64)(((((u64)(1U)) << _const_strconv__expbits64)) - ((u64)(1U)))));
	if (exp == _const_strconv__maxexp64 || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec64_bool mr_9357 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_9357.arg0;
	bool ok = mr_9357.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, 0);
}

string strconv__f64_to_str_pad(f64 f, int n_digit) {
	strconv__Uf64 u1 = ((strconv__Uf64){0});
	u1.f = f;
	u64 u = u1.u;
	bool neg = ((u >> ((u32)(_const_strconv__mantbits64 + _const_strconv__expbits64)))) != 0U;
	u64 mant = (u & ((u64)(((((u64)(1U)) << _const_strconv__mantbits64)) - ((u64)(1U)))));
	u64 exp = (((u >> _const_strconv__mantbits64)) & ((u64)(((((u64)(1U)) << _const_strconv__expbits64)) - ((u64)(1U)))));
	if (exp == _const_strconv__maxexp64 || (exp == 0U && mant == 0U)) {
		return strconv__get_string_special(neg, exp == 0U, mant == 0U);
	}
	multi_return_strconv__Dec64_bool mr_10128 = strconv__f64_to_decimal_exact_int(mant, exp);
	strconv__Dec64 d = mr_10128.arg0;
	bool ok = mr_10128.arg1;
	if (!ok) {
		d = strconv__f64_to_decimal(mant, exp);
	}
	return strconv__Dec64_get_string_64(d, neg, n_digit, n_digit);
}

// Attr: [manualfree]
string strconv__format_str(string s, strconv__BF_param p) {
	bool strconv__format_str_defer_0 = false;
	strings__Builder res;
	if (p.len0 <= 0) {
		return string_clone(s);
	}
	int dif = (int)(p.len0 - utf8_str_visible_length(s));
	if (dif <= 0) {
		return string_clone(s);
	}
	res = strings__new_builder((int)(s.len + dif));
	strconv__format_str_defer_0 = true;
	if (p.align == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	string _t3 = strings__Builder_str(&res);
		// Defer begin
		if (strconv__format_str_defer_0) {
			strings__Builder_free(&res);
		}
		// Defer end
	return _t3;
}

void strconv__format_str_sb(string s, strconv__BF_param p, strings__Builder* sb) {
	if (p.len0 <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	int dif = (int)(p.len0 - utf8_str_visible_length(s));
	if (dif <= 0) {
		strings__Builder_write_string(sb, s);
		return;
	}
	if (p.align == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(sb, p.pad_ch);
		}
	}
	strings__Builder_write_string(sb, s);
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(sb, p.pad_ch);
		}
	}
}

// Attr: [direct_array_access]
void strconv__format_dec_sb(u64 d, strconv__BF_param p, strings__Builder* res) {
	int n_char = strconv__dec_digits(d);
	int sign_len = (!p.positive || p.sign_flag ? (1) : (0));
	int number_len = (int)(sign_len + n_char);
	int dif = (int)(p.len0 - number_len);
	bool sign_written = false;
	if (p.align == strconv__Align_text__right) {
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(res, '+');
					sign_written = true;
				}
			} else {
				strings__Builder_write_u8(res, '-');
				sign_written = true;
			}
		}
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(res, p.pad_ch);
		}
	}
	if (!sign_written) {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_u8(res, '+');
			}
		} else {
			strings__Builder_write_u8(res, '-');
		}
	}
	Array_fixed_u8_32 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int i = 20;
	u64 n = d;
	u64 d_i = ((u64)(0U));
	if (n > 0U) {
		for (;;) {
			if (!(n > 0U)) break;
			u64 n1 = (u64)(n / 100U);
			d_i = (((u64)(n - ((u64)(n1 * 100U)))) << 1U);
			n = n1;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
			d_i++;
			{ // Unsafe block
				buf[i] = _const_strconv__digit_pairs.str[d_i];
			}
			i--;
		}
		i++;
		if (d_i < 20U) {
			i++;
		}
		strings__Builder_write_ptr(res, &buf[i], n_char);
	} else {
		strings__Builder_write_u8(res, '0');
	}
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(res, p.pad_ch);
		}
	}
	return;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__f64_to_str_lnd1(f64 f, int dec_digit) {
	{ // Unsafe block
		string s = strconv__f64_to_str((f64)(f + _const_strconv__dec_round[dec_digit]), 18);
		if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
			return s;
		}
		bool m_sgn_flag = false;
		int sgn = 1;
		Array_fixed_u8_26 b = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
		int d_pos = 1;
		int i = 0;
		int i1 = 0;
		int exp = 0;
		int exp_sgn = 1;
		int dot_res_sp = -1;
		for (int _t2 = 0; _t2 < s.len; ++_t2) {
			u8 c = s.str[_t2];

			if (c == ('-')) {
				sgn = -1;
				i++;
			}
			else if (c == ('+')) {
				sgn = 1;
				i++;
			}
			else if ((c >= '0' && c <= '9')) {
				b[i1] = c;
				i1++;
				i++;
			}
			else if (c == ('.')) {
				if (sgn > 0) {
					d_pos = i;
				} else {
					d_pos = (int)(i - 1);
				}
				i++;
			}
			else if (c == ('e')) {
				i++;
				break;
			}
			else {
				string_free(&s);
				return _SLIT("[Float conversion error!!]");
			}
		}
		b[i1] = 0;
		if (s.str[ i] == '-') {
			exp_sgn = -1;
			i++;
		} else if (s.str[ i] == '+') {
			exp_sgn = 1;
			i++;
		}
		int c = i;
		for (;;) {
			if (!(c < s.len)) break;
			exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
			c++;
		}
		Array_u8 res = __new_array_with_default_noscan((int)(exp + 32), 0, sizeof(u8), &(u8[]){0});
		int r_i = 0;
		string_free(&s);
		if (sgn == 1) {
			if (m_sgn_flag) {
				((u8*)res.data)[r_i] = '+';
				r_i++;
			}
		} else {
			((u8*)res.data)[r_i] = '-';
			r_i++;
		}
		i = 0;
		if (exp_sgn >= 0) {
			for (;;) {
				if (!(b[i] != 0)) break;
				((u8*)res.data)[r_i] = b[i];
				r_i++;
				i++;
				if (i >= d_pos && exp >= 0) {
					if (exp == 0) {
						dot_res_sp = r_i;
						((u8*)res.data)[r_i] = '.';
						r_i++;
					}
					exp--;
				}
			}
			for (;;) {
				if (!(exp >= 0)) break;
				((u8*)res.data)[r_i] = '0';
				r_i++;
				exp--;
			}
		} else {
			bool dot_p = true;
			for (;;) {
				if (!(exp > 0)) break;
				((u8*)res.data)[r_i] = '0';
				r_i++;
				exp--;
				if (dot_p) {
					dot_res_sp = r_i;
					((u8*)res.data)[r_i] = '.';
					r_i++;
					dot_p = false;
				}
			}
			for (;;) {
				if (!(b[i] != 0)) break;
				((u8*)res.data)[r_i] = b[i];
				r_i++;
				i++;
			}
		}
		if (dec_digit <= 0) {
			if (dot_res_sp < 0) {
				dot_res_sp = (int)(i + 1);
			}
			string tmp_res = string_clone(tos(res.data, dot_res_sp));
			array_free(&res);
			return tmp_res;
		}
		if (dot_res_sp >= 0) {
			r_i = (int)((int)(dot_res_sp + dec_digit) + 1);
			((u8*)res.data)[r_i] = 0;
			for (int c1 = 1; c1 < (int)(dec_digit + 1); ++c1) {
				if (((u8*)res.data)[(int)(r_i - c1)] == 0) {
					((u8*)res.data)[(int)(r_i - c1)] = '0';
				}
			}
			string tmp_res = string_clone(tos(res.data, r_i));
			array_free(&res);
			return tmp_res;
		} else {
			if (dec_digit > 0) {
				int c1 = 0;
				((u8*)res.data)[r_i] = '.';
				r_i++;
				for (;;) {
					if (!(c1 < dec_digit)) break;
					((u8*)res.data)[r_i] = '0';
					r_i++;
					c1++;
				}
				((u8*)res.data)[r_i] = 0;
			}
			string tmp_res = string_clone(tos(res.data, r_i));
			array_free(&res);
			return tmp_res;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_fl(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_lnd1((f >= ((f64)(0.0)) ? (f) : (-f)), p.len1);
		if (fs.str[ 0] == '[') {
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			string_free(&tmp);
		}
		Array_fixed_u8_32 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
		Array_fixed_u8_32 out = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = (int)((int)(p.len0 - buf_i) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = tos_clone(&out[0]);
		string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_es(f64 f, strconv__BF_param p) {
	{ // Unsafe block
		string fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros(fs);
			string_free(&tmp);
		}
		Array_fixed_u8_32 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
		Array_fixed_u8_32 out = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
		int buf_i = 0;
		int out_i = 0;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					out[out_i] = '+';
					out_i++;
					sign_len_diff = -1;
				}
			} else {
				out[out_i] = '-';
				out_i++;
				sign_len_diff = -1;
			}
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					buf[buf_i] = '+';
					buf_i++;
				}
			} else {
				buf[buf_i] = '-';
				buf_i++;
			}
		}
		vmemcpy(&buf[buf_i], fs.str, fs.len);
		buf_i += fs.len;
		int dif = (int)((int)(p.len0 - buf_i) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		vmemcpy(&out[out_i], &buf[0], buf_i);
		out_i += buf_i;
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				out[out_i] = p.pad_ch;
				out_i++;
			}
		}
		out[out_i] = 0;
		string tmp = fs;
		fs = tos_clone(&out[0]);
		string_free(&tmp);
		return fs;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
string strconv__remove_tail_zeros(string s) {
	{ // Unsafe block
		u8* buf = malloc_noscan((int)(s.len + 1));
		int i_d = 0;
		int i_s = 0;
		for (;;) {
			if (!(i_s < s.len && !(s.str[ i_s] == '-' || s.str[ i_s] == '+') && (s.str[ i_s] > '9' || s.str[ i_s] < '0'))) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && (s.str[ i_s] == '-' || s.str[ i_s] == '+')) {
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		for (;;) {
			if (!(i_s < s.len && s.str[ i_s] >= '0' && s.str[ i_s] <= '9')) break;
			buf[i_d] = s.str[ i_s];
			i_s++;
			i_d++;
		}
		if (i_s < s.len && s.str[ i_s] == '.') {
			int i_s1 = (int)(i_s + 1);
			int sum = 0;
			for (;;) {
				if (!(i_s1 < s.len && s.str[ i_s1] >= '0' && s.str[ i_s1] <= '9')) break;
				sum += (u8)(s.str[ i_s1] - ((u8)('0')));
				i_s1++;
			}
			if (sum > 0) {
				for (int c_i = i_s; c_i < i_s1; ++c_i) {
					buf[i_d] = s.str[ c_i];
					i_d++;
				}
			}
			i_s = i_s1;
		}
		if (i_s < s.len && s.str[ i_s] != '.') {
			for (;;) {
				buf[i_d] = s.str[ i_s];
				i_s++;
				i_d++;
				if (i_s >= s.len) {
					break;
				}
			}
		}
		buf[i_d] = 0;
		return tos(buf, i_d);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string strconv__ftoa_64(f64 f) {
	return strconv__f64_to_str(f, 17);
}

// Attr: [inline]
inline string strconv__ftoa_long_64(f64 f) {
	return strconv__f64_to_str_l(f);
}

// Attr: [inline]
inline string strconv__ftoa_32(f32 f) {
	return strconv__f32_to_str(f, 8);
}

// Attr: [inline]
inline string strconv__ftoa_long_32(f32 f) {
	return strconv__f32_to_str_l(f);
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_int(i64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid radix: "), /*100 &int*/0xfe07, {.d_i32 = radix}}, {_SLIT(" . It should be => 2 and <= 36"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (n == 0) {
			return _SLIT("0");
		}
		i64 n_copy = n;
		bool have_minus = false;
		if (n < 0) {
			have_minus = true;
			n_copy = -n_copy;
		}
		string res = _SLIT("");
		for (;;) {
			if (!(n_copy != 0)) break;
			string tmp_0 = res;
			int bdx = ((int)((i64)(n_copy % radix)));
			string tmp_1 = u8_ascii_str(_const_strconv__base_digits.str[ bdx]);
			res = string__plus(tmp_1, res);
			string_free(&tmp_0);
			string_free(&tmp_1);
			n_copy /= radix;
		}
		if (have_minus) {
			string final_res = string__plus(_SLIT("-"), res);
			string_free(&res);
			return final_res;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_uint(u64 n, int radix) {
	{ // Unsafe block
		if (radix < 2 || radix > 36) {
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid radix: "), /*100 &int*/0xfe07, {.d_i32 = radix}}, {_SLIT(" . It should be => 2 and <= 36"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (n == 0U) {
			return _SLIT("0");
		}
		u64 n_copy = n;
		string res = _SLIT("");
		u64 uradix = ((u64)(radix));
		for (;;) {
			if (!(n_copy != 0U)) break;
			string tmp_0 = res;
			string tmp_1 = u8_ascii_str(_const_strconv__base_digits.str[ (u64)(n_copy % uradix)]);
			res = string__plus(tmp_1, res);
			string_free(&tmp_0);
			string_free(&tmp_1);
			n_copy /= uradix;
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string strconv__f32_to_str_l(f32 f) {
	string s = strconv__f32_to_str(f, 6);
	string res = strconv__fxx_to_str_l_parse(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f32_to_str_l_with_dot(f32 f) {
	string s = strconv__f32_to_str(f, 6);
	string res = strconv__fxx_to_str_l_parse_with_dot(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f64_to_str_l(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse(s);
	string_free(&s);
	return res;
}

// Attr: [manualfree]
string strconv__f64_to_str_l_with_dot(f64 f) {
	string s = strconv__f64_to_str(f, 18);
	string res = strconv__fxx_to_str_l_parse_with_dot(s);
	string_free(&s);
	return res;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__fxx_to_str_l_parse(string s) {
	if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
		return string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_u8_26 b = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = (int)(i - 1);
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (s.str[ i] == '-') {
		exp_sgn = -1;
		i++;
	} else if (s.str[ i] == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
		c++;
	}
	Array_u8 res = __new_array_with_default_noscan((int)(exp + 32), 0, sizeof(u8), &(u8[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			((u8*)res.data)[r_i] = '+';
			r_i++;
		}
	} else {
		((u8*)res.data)[r_i] = '-';
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					((u8*)res.data)[r_i] = '.';
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
			if (dot_p) {
				((u8*)res.data)[r_i] = '.';
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
		}
	}
	if (r_i > 1 && ((u8*)res.data)[(int)(r_i - 1)] == '.') {
		((u8*)res.data)[r_i] = '0';
		r_i++;
	} else if (!Array_u8_contains(res, '.')) {
		((u8*)res.data)[r_i] = '.';
		r_i++;
		((u8*)res.data)[r_i] = '0';
		r_i++;
	}
	((u8*)res.data)[r_i] = 0;
	return tos(res.data, r_i);
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__fxx_to_str_l_parse_with_dot(string s) {
	if (s.len > 2 && (s.str[ 0] == 'n' || s.str[ 1] == 'i')) {
		return string_clone(s);
	}
	bool m_sgn_flag = false;
	int sgn = 1;
	Array_fixed_u8_26 b = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int d_pos = 1;
	int i = 0;
	int i1 = 0;
	int exp = 0;
	int exp_sgn = 1;
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 c = s.str[_t2];
		if (c == '-') {
			sgn = -1;
			i++;
		} else if (c == '+') {
			sgn = 1;
			i++;
		} else if (c >= '0' && c <= '9') {
			b[i1] = c;
			i1++;
			i++;
		} else if (c == '.') {
			if (sgn > 0) {
				d_pos = i;
			} else {
				d_pos = (int)(i - 1);
			}
			i++;
		} else if (c == 'e') {
			i++;
			break;
		} else {
			return _SLIT("Float conversion error!!");
		}
	}
	b[i1] = 0;
	if (s.str[ i] == '-') {
		exp_sgn = -1;
		i++;
	} else if (s.str[ i] == '+') {
		exp_sgn = 1;
		i++;
	}
	int c = i;
	for (;;) {
		if (!(c < s.len)) break;
		exp = (int)((int)(exp * 10) + ((int)((rune)(s.str[ c] - '0'))));
		c++;
	}
	Array_u8 res = __new_array_with_default_noscan((int)(exp + 32), 0, sizeof(u8), &(u8[]){0});
	int r_i = 0;
	if (sgn == 1) {
		if (m_sgn_flag) {
			((u8*)res.data)[r_i] = '+';
			r_i++;
		}
	} else {
		((u8*)res.data)[r_i] = '-';
		r_i++;
	}
	i = 0;
	if (exp_sgn >= 0) {
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
			if (i >= d_pos && exp >= 0) {
				if (exp == 0) {
					((u8*)res.data)[r_i] = '.';
					r_i++;
				}
				exp--;
			}
		}
		for (;;) {
			if (!(exp >= 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
		}
	} else {
		bool dot_p = true;
		for (;;) {
			if (!(exp > 0)) break;
			((u8*)res.data)[r_i] = '0';
			r_i++;
			exp--;
			if (dot_p) {
				((u8*)res.data)[r_i] = '.';
				r_i++;
				dot_p = false;
			}
		}
		for (;;) {
			if (!(b[i] != 0)) break;
			((u8*)res.data)[r_i] = b[i];
			r_i++;
			i++;
		}
	}
	if (r_i > 1 && ((u8*)res.data)[(int)(r_i - 1)] == '.') {
		((u8*)res.data)[r_i] = '0';
		r_i++;
	} else if (!Array_u8_contains(res, '.')) {
		((u8*)res.data)[r_i] = '.';
		r_i++;
		((u8*)res.data)[r_i] = '0';
		r_i++;
	}
	((u8*)res.data)[r_i] = 0;
	return tos(res.data, r_i);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int strconv__bool_to_int(bool b) {
	if (b) {
		return 1;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 strconv__bool_to_u32(bool b) {
	if (b) {
		return ((u32)(1U));
	}
	return ((u32)(0U));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 strconv__bool_to_u64(bool b) {
	if (b) {
		return ((u64)(1U));
	}
	return ((u64)(0U));
}

VV_LOCAL_SYMBOL string strconv__get_string_special(bool neg, bool expZero, bool mantZero) {
	if (!mantZero) {
		return _SLIT("nan");
	}
	if (!expZero) {
		if (neg) {
			return _SLIT("-inf");
		} else {
			return _SLIT("+inf");
		}
	}
	if (neg) {
		return _SLIT("-0e+00");
	}
	return _SLIT("0e+00");
}

VV_LOCAL_SYMBOL u32 strconv__mul_shift_32(u32 m, u64 mul, int ishift) {
	multi_return_u64_u64 mr_750 = math__bits__mul_64(((u64)(m)), mul);
	u64 hi = mr_750.arg0;
	u64 lo = mr_750.arg1;
	u64 shifted_sum = (u64)(((lo >> ((u64)(ishift)))) + ((hi << ((u64)((int)(64 - ishift))))));
	;
	return ((u32)(shifted_sum));
}

VV_LOCAL_SYMBOL u32 strconv__mul_pow5_invdiv_pow2(u32 m, u32 q, int j) {
	return strconv__mul_shift_32(m, _const_strconv__pow5_inv_split_32[v_fixed_index(q, 31)], j);
}

VV_LOCAL_SYMBOL u32 strconv__mul_pow5_div_pow2(u32 m, u32 i, int j) {
	return strconv__mul_shift_32(m, _const_strconv__pow5_split_32[v_fixed_index(i, 47)], j);
}

VV_LOCAL_SYMBOL u32 strconv__pow5_factor_32(u32 i_v) {
	u32 v = i_v;
	for (u32 n = ((u32)(0U)); true; n++) {
		u32 q = (u32)(v / 5U);
		u32 r = (u32)(v % 5U);
		if (r != 0U) {
			return n;
		}
		v = q;
	}
	return v;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_32(u32 v, u32 p) {
	return strconv__pow5_factor_32(v) >= p;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_32(u32 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_32(v))) >= p;
}

VV_LOCAL_SYMBOL u32 strconv__log10_pow2(int e) {
	;
	;
	return (((u32)(((u32)(e)) * 78913U)) >> 18U);
}

VV_LOCAL_SYMBOL u32 strconv__log10_pow5(int e) {
	;
	;
	return (((u32)(((u32)(e)) * 732923U)) >> 20U);
}

VV_LOCAL_SYMBOL int strconv__pow5_bits(int e) {
	;
	;
	return ((int)((u32)(((((u32)(((u32)(e)) * 1217359U)) >> 19U)) + 1U)));
}

VV_LOCAL_SYMBOL u64 strconv__shift_right_128(strconv__Uint128 v, int shift) {
	;
	return (((v.hi << ((u64)((int)(64 - shift))))) | ((v.lo >> ((u32)(shift)))));
}

VV_LOCAL_SYMBOL u64 strconv__mul_shift_64(u64 m, strconv__Uint128 mul, int shift) {
	multi_return_u64_u64 mr_3069 = math__bits__mul_64(m, mul.hi);
	u64 hihi = mr_3069.arg0;
	u64 hilo = mr_3069.arg1;
	multi_return_u64_u64 mr_3104 = math__bits__mul_64(m, mul.lo);
	u64 lohi = mr_3104.arg0;
	strconv__Uint128 sum = ((strconv__Uint128){.lo = (u64)(lohi + hilo),.hi = hihi,});
	if (sum.lo < lohi) {
		sum.hi++;
	}
	return strconv__shift_right_128(sum, (int)(shift - 64));
}

VV_LOCAL_SYMBOL u32 strconv__pow5_factor_64(u64 v_i) {
	u64 v = v_i;
	for (u32 n = ((u32)(0U)); true; n++) {
		u64 q = (u64)(v / 5U);
		u64 r = (u64)(v % 5U);
		if (r != 0U) {
			return n;
		}
		v = q;
	}
	return ((u32)(0U));
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_five_64(u64 v, u32 p) {
	return strconv__pow5_factor_64(v) >= p;
}

VV_LOCAL_SYMBOL bool strconv__multiple_of_power_of_two_64(u64 v, u32 p) {
	return ((u32)(math__bits__trailing_zeros_64(v))) >= p;
}

int strconv__dec_digits(u64 n) {
	if (n <= 9999999999U) {
		if (n <= 99999U) {
			if (n <= 99U) {
				if (n <= 9U) {
					return 1;
				} else {
					return 2;
				}
			} else {
				if (n <= 999U) {
					return 3;
				} else {
					if (n <= 9999U) {
						return 4;
					} else {
						return 5;
					}
				}
			}
		} else {
			if (n <= 9999999U) {
				if (n <= 999999U) {
					return 6;
				} else {
					return 7;
				}
			} else {
				if (n <= 99999999U) {
					return 8;
				} else {
					if (n <= 999999999U) {
						return 9;
					}
					return 10;
				}
			}
		}
	} else {
		if (n <= 999999999999999U) {
			if (n <= 999999999999U) {
				if (n <= 99999999999U) {
					return 11;
				} else {
					return 12;
				}
			} else {
				if (n <= 9999999999999U) {
					return 13;
				} else {
					if (n <= 99999999999999U) {
						return 14;
					} else {
						return 15;
					}
				}
			}
		} else {
			if (n <= 99999999999999999U) {
				if (n <= 9999999999999999U) {
					return 16;
				} else {
					return 17;
				}
			} else {
				if (n <= 999999999999999999U) {
					return 18;
				} else {
					if (n <= 9999999999999999999U) {
						return 19;
					}
					return 20;
				}
			}
		}
	}
	return 0;
}

// Attr: [unsafe]
void strconv__v_printf(string str, Array_voidptr pt) {
	print(strconv__v_sprintf(str, pt));
}

// Attr: [direct_array_access]
// Attr: [manualfree]
// Attr: [unsafe]
string strconv__v_sprintf(string str, Array_voidptr pt) {
	bool strconv__v_sprintf_defer_0 = false;
	strings__Builder res;
	res = strings__new_builder((int)(pt.len * 16));
	strconv__v_sprintf_defer_0 = true;
	int i = 0;
	int p_index = 0;
	bool sign = false;
	strconv__Align_text align = strconv__Align_text__right;
	int len0 = -1;
	int len1 = -1;
	int def_len1 = 6;
	u8 pad_ch = ((u8)(' '));
	rune ch1 = '0';
	rune ch2 = '0';
	strconv__Char_parse_state status = strconv__Char_parse_state__norm_char;
	for (;;) {
		if (!(i < str.len)) break;
		if (status == strconv__Char_parse_state__reset_params) {
			sign = false;
			align = strconv__Align_text__right;
			len0 = -1;
			len1 = -1;
			pad_ch = ' ';
			status = strconv__Char_parse_state__norm_char;
			ch1 = '0';
			ch2 = '0';
			continue;
		}
		u8 ch = str.str[ i];
		if (ch != '%' && status == strconv__Char_parse_state__norm_char) {
			strings__Builder_write_u8(&res, ch);
			i++;
			continue;
		}
		if (ch == '%' && status == strconv__Char_parse_state__field_char) {
			status = strconv__Char_parse_state__norm_char;
			strings__Builder_write_u8(&res, ch);
			i++;
			continue;
		}
		if (ch == '%' && status == strconv__Char_parse_state__norm_char) {
			status = strconv__Char_parse_state__field_char;
			i++;
			continue;
		}
		if (ch == 'c' && status == strconv__Char_parse_state__field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			u8 d1 = *(((u8*)(((voidptr*)pt.data)[p_index])));
			strings__Builder_write_u8(&res, d1);
			status = strconv__Char_parse_state__reset_params;
			p_index++;
			i++;
			continue;
		}
		if (ch == 'p' && status == strconv__Char_parse_state__field_char) {
			strconv__v_sprintf_panic(p_index, pt.len);
			strings__Builder_write_string(&res, _SLIT("0x"));
			strings__Builder_write_string(&res, ptr_str(((voidptr*)pt.data)[p_index]));
			status = strconv__Char_parse_state__reset_params;
			p_index++;
			i++;
			continue;
		}
		if (status == strconv__Char_parse_state__field_char) {
			rune fc_ch1 = '0';
			rune fc_ch2 = '0';
			if (((int)(i + 1)) < str.len) {
				fc_ch1 = str.str[ (int)(i + 1)];
				if (((int)(i + 2)) < str.len) {
					fc_ch2 = str.str[ (int)(i + 2)];
				}
			}
			if (ch == '+') {
				sign = true;
				i++;
				continue;
			} else if (ch == '-') {
				align = strconv__Align_text__left;
				i++;
				continue;
			} else if (ch == '0' || ch == ' ') {
				if (align == strconv__Align_text__right) {
					pad_ch = ch;
				}
				i++;
				continue;
			} else if (ch == '\'') {
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 >= '1' && fc_ch1 <= '9') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			} else if (ch == '.' && fc_ch1 == '*' && fc_ch2 == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				int len = *(((int*)(((voidptr*)pt.data)[p_index])));
				p_index++;
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = *(((string*)(((voidptr*)pt.data)[p_index])));
				s = string_substr(s, 0, len);
				p_index++;
				strings__Builder_write_string(&res, s);
				status = strconv__Char_parse_state__reset_params;
				i += 3;
				continue;
			}
			status = strconv__Char_parse_state__len_set_start;
			continue;
		}
		if (status == strconv__Char_parse_state__len_set_start) {
			if (ch >= '1' && ch <= '9') {
				len0 = ((int)((rune)(ch - '0')));
				status = strconv__Char_parse_state__len_set_in;
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__len_set_in) {
			if (ch >= '0' && ch <= '9') {
				len0 *= 10;
				len0 += ((int)((rune)(ch - '0')));
				i++;
				continue;
			}
			if (ch == '.') {
				status = strconv__Char_parse_state__check_float;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_float) {
			if (ch >= '0' && ch <= '9') {
				len1 = ((int)((rune)(ch - '0')));
				status = strconv__Char_parse_state__check_float_in;
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_float_in) {
			if (ch >= '0' && ch <= '9') {
				len1 *= 10;
				len1 += ((int)((rune)(ch - '0')));
				i++;
				continue;
			}
			status = strconv__Char_parse_state__check_type;
			continue;
		}
		if (status == strconv__Char_parse_state__check_type) {
			if (ch == 'l') {
				if (ch1 == '0') {
					ch1 = 'l';
					i++;
					continue;
				} else {
					ch2 = 'l';
					i++;
					continue;
				}
			} else if (ch == 'h') {
				if (ch1 == '0') {
					ch1 = 'h';
					i++;
					continue;
				} else {
					ch2 = 'h';
					i++;
					continue;
				}
			} else if (ch == 'd' || ch == 'i') {
				u64 d1 = ((u64)(0U));
				bool positive = true;

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						strconv__v_sprintf_panic(p_index, pt.len);
						i8 x = *(((i8*)(((voidptr*)pt.data)[p_index])));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					} else {
						i16 x = *(((i16*)(((voidptr*)pt.data)[p_index])));
						positive = (x >= 0 ? (true) : (false));
						d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
					}
				}
				else if (ch1 == ('l')) {
					strconv__v_sprintf_panic(p_index, pt.len);
					i64 x = *(((i64*)(((voidptr*)pt.data)[p_index])));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				}
				else {
					strconv__v_sprintf_panic(p_index, pt.len);
					int x = *(((int*)(((voidptr*)pt.data)[p_index])));
					positive = (x >= 0 ? (true) : (false));
					d1 = (positive ? (((u64)(x))) : (((u64)(-x))));
				}
				string tmp = strconv__format_dec_old(d1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.align = align,
					.allign = strconv__Align_text__right,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				ch1 = '0';
				ch2 = '0';
				continue;
			} else if (ch == 'u') {
				u64 d1 = ((u64)(0U));
				bool positive = true;
				strconv__v_sprintf_panic(p_index, pt.len);

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						d1 = ((u64)(*(((u8*)(((voidptr*)pt.data)[p_index])))));
					} else {
						d1 = ((u64)(*(((u16*)(((voidptr*)pt.data)[p_index])))));
					}
				}
				else if (ch1 == ('l')) {
					d1 = ((u64)(*(((u64*)(((voidptr*)pt.data)[p_index])))));
				}
				else {
					d1 = ((u64)(*(((u32*)(((voidptr*)pt.data)[p_index])))));
				}
				string tmp = strconv__format_dec_old(d1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = positive,
					.sign_flag = sign,
					.align = align,
					.allign = strconv__Align_text__right,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'x' || ch == 'X') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s = _SLIT("");

				if (ch1 == ('h')) {
					if (ch2 == 'h') {
						i8 x = *(((i8*)(((voidptr*)pt.data)[p_index])));
						s = i8_hex(x);
					} else {
						i16 x = *(((i16*)(((voidptr*)pt.data)[p_index])));
						s = i16_hex(x);
					}
				}
				else if (ch1 == ('l')) {
					i64 x = *(((i64*)(((voidptr*)pt.data)[p_index])));
					s = i64_hex(x);
				}
				else {
					int x = *(((int*)(((voidptr*)pt.data)[p_index])));
					s = int_hex(x);
				}
				if (ch == 'X') {
					string tmp = s;
					s = string_to_upper(s);
					string_free(&tmp);
				}
				string tmp = strconv__format_str(s, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.align = align,
					.allign = strconv__Align_text__right,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				string_free(&tmp);
				string_free(&s);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			}
			if (ch == 'f' || ch == 'F') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)(((voidptr*)pt.data)[p_index])));
					bool positive = x >= ((f64)(0.0));
					len1 = (len1 >= 0 ? (len1) : (def_len1));
					string s = strconv__format_fl_old(((f64)(x)), ((strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.align = align,
						.allign = strconv__Align_text__right,
						.rm_tail_zero = 0,
					}));
					if (ch == 'F') {
						string tmp = string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'e' || ch == 'E') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)(((voidptr*)pt.data)[p_index])));
					bool positive = x >= ((f64)(0.0));
					len1 = (len1 >= 0 ? (len1) : (def_len1));
					string s = strconv__format_es_old(((f64)(x)), ((strconv__BF_param){
						.pad_ch = pad_ch,
						.len0 = len0,
						.len1 = len1,
						.positive = positive,
						.sign_flag = sign,
						.align = align,
						.allign = strconv__Align_text__right,
						.rm_tail_zero = 0,
					}));
					if (ch == 'E') {
						string tmp = string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 'g' || ch == 'G') {
				#if !defined(CUSTOM_DEFINE_nofloat)
				{
					strconv__v_sprintf_panic(p_index, pt.len);
					f64 x = *(((f64*)(((voidptr*)pt.data)[p_index])));
					bool positive = x >= ((f64)(0.0));
					string s = _SLIT("");
					f64 tx = strconv__fabs(x);
					if (tx < ((f64)(999999.0)) && tx >= ((f64)(0.00001))) {
						len1 = (len1 >= 0 ? ((int)(len1 + 1)) : (def_len1));
						string tmp = s;
						s = strconv__format_fl_old(x, ((strconv__BF_param){
							.pad_ch = pad_ch,
							.len0 = len0,
							.len1 = len1,
							.positive = positive,
							.sign_flag = sign,
							.align = align,
							.allign = strconv__Align_text__right,
							.rm_tail_zero = true,
						}));
						string_free(&tmp);
					} else {
						len1 = (len1 >= 0 ? ((int)(len1 + 1)) : (def_len1));
						string tmp = s;
						s = strconv__format_es_old(x, ((strconv__BF_param){
							.pad_ch = pad_ch,
							.len0 = len0,
							.len1 = len1,
							.positive = positive,
							.sign_flag = sign,
							.align = align,
							.allign = strconv__Align_text__right,
							.rm_tail_zero = true,
						}));
						string_free(&tmp);
					}
					if (ch == 'G') {
						string tmp = string_to_upper(s);
						strings__Builder_write_string(&res, tmp);
						string_free(&tmp);
					} else {
						strings__Builder_write_string(&res, s);
					}
					string_free(&s);
				}
				#endif
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			} else if (ch == 's') {
				strconv__v_sprintf_panic(p_index, pt.len);
				string s1 = *(((string*)(((voidptr*)pt.data)[p_index])));
				pad_ch = ' ';
				string tmp = strconv__format_str(s1, ((strconv__BF_param){
					.pad_ch = pad_ch,
					.len0 = len0,
					.len1 = 0,
					.positive = true,
					.sign_flag = false,
					.align = align,
					.allign = strconv__Align_text__right,
					.rm_tail_zero = 0,
				}));
				strings__Builder_write_string(&res, tmp);
				string_free(&tmp);
				status = strconv__Char_parse_state__reset_params;
				p_index++;
				i++;
				continue;
			}
		}
		status = strconv__Char_parse_state__reset_params;
		p_index++;
		i++;
	}
	if (p_index != pt.len) {
		_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = p_index}}, {_SLIT(" % conversion specifiers, but given "), /*100 &int*/0xfe07, {.d_i32 = pt.len}}, {_SLIT(" args"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	string _t4 = strings__Builder_str(&res);
		// Defer begin
		if (strconv__v_sprintf_defer_0) {
			strings__Builder_free(&res);
		}
		// Defer end
	return _t4;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void strconv__v_sprintf_panic(int idx, int len) {
	if (idx >= len) {
		_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = (int)(idx + 1)}}, {_SLIT(" % conversion specifiers, but given only "), /*100 &int*/0xfe07, {.d_i32 = len}}, {_SLIT(" args"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
}

VV_LOCAL_SYMBOL f64 strconv__fabs(f64 x) {
	if (x < ((f64)(0.0))) {
		return -x;
	}
	return x;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string strconv__format_fl_old(f64 f, strconv__BF_param p) {
	bool strconv__format_fl_old_defer_0 = false;
	strings__Builder res;
	{ // Unsafe block
		string s = _SLIT("");
		string fs = strconv__f64_to_str_lnd1((f >= ((f64)(0.0)) ? (f) : (-f)), p.len1);
		if (fs.str[ 0] == '[') {
			string_free(&s);
			return fs;
		}
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros_old(fs);
			string_free(&tmp);
		}
		res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
		strconv__format_fl_old_defer_0 = true;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(&res, '+');
					sign_len_diff = -1;
				}
			} else {
				strings__Builder_write_u8(&res, '-');
				sign_len_diff = -1;
			}
			string tmp = s;
			s = string_clone(fs);
			string_free(&tmp);
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					string tmp = s;
					s = string__plus(_SLIT("+"), fs);
					string_free(&tmp);
				} else {
					string tmp = s;
					s = string_clone(fs);
					string_free(&tmp);
				}
			} else {
				string tmp = s;
				s = string__plus(_SLIT("-"), fs);
				string_free(&tmp);
			}
		}
		int dif = (int)((int)(p.len0 - s.len) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		strings__Builder_write_string(&res, s);
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		string_free(&s);
		string_free(&fs);
		string _t2 = strings__Builder_str(&res);
			// Defer begin
			if (strconv__format_fl_old_defer_0) {
				strings__Builder_free(&res);
			}
			// Defer end
		return _t2;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL string strconv__format_es_old(f64 f, strconv__BF_param p) {
	bool strconv__format_es_old_defer_0 = false;
	strings__Builder res;
	string fs;
	string s;
	{ // Unsafe block
		s = _SLIT("");
		fs = strconv__f64_to_str_pad((f > 0 ? (f) : (-f)), p.len1);
		if (p.rm_tail_zero) {
			string tmp = fs;
			fs = strconv__remove_tail_zeros_old(fs);
			string_free(&tmp);
		}
		res = strings__new_builder((p.len0 > fs.len ? (p.len0) : (fs.len)));
		strconv__format_es_old_defer_0 = true;
		int sign_len_diff = 0;
		if (p.pad_ch == '0') {
			if (p.positive) {
				if (p.sign_flag) {
					strings__Builder_write_u8(&res, '+');
					sign_len_diff = -1;
				}
			} else {
				strings__Builder_write_u8(&res, '-');
				sign_len_diff = -1;
			}
			string tmp = s;
			s = string_clone(fs);
			string_free(&tmp);
		} else {
			if (p.positive) {
				if (p.sign_flag) {
					string tmp = s;
					s = string__plus(_SLIT("+"), fs);
					string_free(&tmp);
				} else {
					string tmp = s;
					s = string_clone(fs);
					string_free(&tmp);
				}
			} else {
				string tmp = s;
				s = string__plus(_SLIT("-"), fs);
				string_free(&tmp);
			}
		}
		int dif = (int)((int)(p.len0 - s.len) + sign_len_diff);
		if (p.align == strconv__Align_text__right) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		strings__Builder_write_string(&res, s);
		if (p.align == strconv__Align_text__left) {
			for (int i1 = 0; i1 < dif; i1++) {
				strings__Builder_write_u8(&res, p.pad_ch);
			}
		}
		string _t1 = strings__Builder_str(&res);
			// Defer begin
			if (strconv__format_es_old_defer_0) {
				strings__Builder_free(&res);
				string_free(&fs);
				string_free(&s);
			}
			// Defer end
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string strconv__remove_tail_zeros_old(string s) {
	int i = 0;
	int last_zero_start = -1;
	int dot_pos = -1;
	bool in_decimal = false;
	u8 prev_ch = ((u8)(0));
	for (;;) {
		if (!(i < s.len)) break;
		u8 ch = s.str[i];
		if (ch == '.') {
			in_decimal = true;
			dot_pos = i;
		} else if (in_decimal) {
			if (ch == '0' && prev_ch != '0') {
				last_zero_start = i;
			} else if (ch >= '1' && ch <= '9') {
				last_zero_start = -1;
			} else if (ch == 'e') {
				break;
			}
		}
		prev_ch = ch;
		i++;
	}
	string tmp = _SLIT("");
	if (last_zero_start > 0) {
		if (last_zero_start == (int)(dot_pos + 1)) {
			tmp = string__plus(string_substr(s, 0, dot_pos), string_substr(s, i, 2147483647));
		} else {
			tmp = string__plus(string_substr(s, 0, last_zero_start), string_substr(s, i, 2147483647));
		}
	} else {
		tmp = string_clone(s);
	}
	if (tmp.str[(int)(tmp.len - 1)] == '.') {
		return string_substr(tmp, 0, (int)(tmp.len - 1));
	}
	return tmp;
}

// Attr: [manualfree]
string strconv__format_dec_old(u64 d, strconv__BF_param p) {
	bool strconv__format_dec_old_defer_0 = false;
	strings__Builder res;
	string s;
	s = _SLIT("");
	res = strings__new_builder(20);
	strconv__format_dec_old_defer_0 = true;
	int sign_len_diff = 0;
	if (p.pad_ch == '0') {
		if (p.positive) {
			if (p.sign_flag) {
				strings__Builder_write_u8(&res, '+');
				sign_len_diff = -1;
			}
		} else {
			strings__Builder_write_u8(&res, '-');
			sign_len_diff = -1;
		}
		string tmp = s;
		s = u64_str(d);
		string_free(&tmp);
	} else {
		if (p.positive) {
			if (p.sign_flag) {
				string tmp = s;
				s = string__plus(_SLIT("+"), u64_str(d));
				string_free(&tmp);
			} else {
				string tmp = s;
				s = u64_str(d);
				string_free(&tmp);
			}
		} else {
			string tmp = s;
			s = string__plus(_SLIT("-"), u64_str(d));
			string_free(&tmp);
		}
	}
	int dif = (int)((int)(p.len0 - s.len) + sign_len_diff);
	if (p.align == strconv__Align_text__right) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	strings__Builder_write_string(&res, s);
	if (p.align == strconv__Align_text__left) {
		for (int i1 = 0; i1 < dif; i1++) {
			strings__Builder_write_u8(&res, p.pad_ch);
		}
	}
	string _t1 = strings__Builder_str(&res);
		// Defer begin
		if (strconv__format_dec_old_defer_0) {
			strings__Builder_free(&res);
			string_free(&s);
		}
		// Defer end
	return _t1;
}

VV_LOCAL_SYMBOL array __new_array(int mylen, int cap, int elm_size) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_default(int mylen, int cap, int elm_size, voidptr val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u64 total_size = (u64)(((u64)(cap_)) * ((u64)(elm_size)));
	if (cap_ > 0 && mylen == 0) {
		arr.data = _v_malloc(__at_least_one(total_size));
	} else {
		arr.data = vcalloc(total_size);
	}
	if (val != 0) {
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				if (arr.element_size == 1) {
					u8 byte_value = *(((u8*)(val)));
					for (int i = 0; i < arr.len; ++i) {
						eptr[i] = byte_value;
					}
				} else {
					for (int _t1 = 0; _t1 < arr.len; ++_t1) {
						vmemcpy(eptr, val, arr.element_size);
						eptr += arr.element_size;
					}
				}
			}
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_multi_default(int mylen, int cap, int elm_size, voidptr val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = 0,.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u64 total_size = (u64)(((u64)(cap_)) * ((u64)(elm_size)));
	arr.data = vcalloc(__at_least_one(total_size));
	if (val != 0) {
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				for (int i = 0; i < arr.len; ++i) {
					vmemcpy(eptr, ((charptr)(val)) + (int)(i * arr.element_size), arr.element_size);
					eptr += arr.element_size;
				}
			}
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_array_default(int mylen, int cap, int elm_size, array val, int depth) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = _v_malloc(__at_least_one((u64)(((u64)(cap_)) * ((u64)(elm_size))))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u8* eptr = ((u8*)(arr.data));
	{ // Unsafe block
		if (eptr != ((void*)0)) {
			for (int _t1 = 0; _t1 < arr.len; ++_t1) {
				array val_clone = array_clone_to_depth(&val, depth);
				vmemcpy(eptr, &val_clone, arr.element_size);
				eptr += arr.element_size;
			}
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_map_default(int mylen, int cap, int elm_size, map val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = _v_malloc(__at_least_one((u64)(((u64)(cap_)) * ((u64)(elm_size))))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	u8* eptr = ((u8*)(arr.data));
	{ // Unsafe block
		if (eptr != ((void*)0)) {
			for (int _t1 = 0; _t1 < arr.len; ++_t1) {
				map val_clone = map_clone(&val);
				vmemcpy(eptr, &val_clone, arr.element_size);
				eptr += arr.element_size;
			}
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array(int len, int cap, int elm_size, voidptr c_array) {
	int cap_ = (cap < len ? (len) : (cap));
	array arr = ((array){.data = vcalloc((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = len,.cap = cap_,.flags = 0,.element_size = elm_size,});
	vmemcpy(arr.data, c_array, (u64)(((u64)(len)) * ((u64)(elm_size))));
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array_no_alloc(int len, int cap, int elm_size, voidptr c_array) {
	array arr = ((array){.data = c_array,.offset = 0,.len = len,.cap = cap,.flags = 0,.element_size = elm_size,});
	return arr;
}

VV_LOCAL_SYMBOL void array_ensure_cap(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	if (ArrayFlags_has(&a->flags, ArrayFlags__nogrow)) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.ensure_cap: array with the flag `.nogrow` cannot grow in size, array required new size: "), /*100 &int*/0xfe07, {.d_i32 = required}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	int cap = (a->cap > 0 ? (a->cap) : (2));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	u64 new_size = (u64)(((u64)(cap)) * ((u64)(a->element_size)));
	u8* new_data = _v_malloc(__at_least_one(new_size));
	if (a->data != ((void*)0)) {
		vmemcpy(new_data, a->data, (u64)(((u64)(a->len)) * ((u64)(a->element_size))));
		if (ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
			_v_free(a->data);
		}
	}
	a->data = new_data;
	a->offset = 0;
	a->cap = cap;
}

array array_repeat(array a, int count) {
	return array_repeat_to_depth(a, count, 0);
}

// Attr: [direct_array_access]
// Attr: [unsafe]
array array_repeat_to_depth(array a, int count, int depth) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.repeat: count is negative: "), /*100 &int*/0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	u64 size = (u64)((u64)(((u64)(count)) * ((u64)(a.len))) * ((u64)(a.element_size)));
	if (size == 0U) {
		size = ((u64)(a.element_size));
	}
	array arr = ((array){.data = vcalloc(size),.offset = 0,.len = (int)(count * a.len),.cap = (int)(count * a.len),.flags = 0,.element_size = a.element_size,});
	if (a.len > 0) {
		u64 a_total_size = (u64)(((u64)(a.len)) * ((u64)(a.element_size)));
		u64 arr_step_size = (u64)(((u64)(a.len)) * ((u64)(arr.element_size)));
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			if (eptr != ((void*)0)) {
				for (int _t1 = 0; _t1 < count; ++_t1) {
					if (depth > 0) {
						array ary_clone = array_clone_to_depth(&a, depth);
						vmemcpy(eptr, ((u8*)(ary_clone.data)), a_total_size);
					} else {
						vmemcpy(eptr, ((u8*)(a.data)), a_total_size);
					}
					eptr += arr_step_size;
				}
			}
		}
	}
	return arr;
}

void array_insert(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.insert: index out of range (i == "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), /*100 &int*/0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	if (a->len >= a->cap) {
		array_ensure_cap(a, (int)(a->len + 1));
	}
	{ // Unsafe block
		vmemmove(array_get_unsafe(/*rec*/*a, (int)(i + 1)), array_get_unsafe(/*rec*/*a, i), (u64)(((u64)(((int)(a->len - i)))) * ((u64)(a->element_size))));
		array_set_unsafe(a, i, val);
	}
	a->len++;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void array_insert_many(array* a, int i, voidptr val, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.insert_many: index out of range (i == "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), /*100 &int*/0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	array_ensure_cap(a, (int)(a->len + size));
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = array_get_unsafe(/*rec*/*a, i);
		vmemmove(array_get_unsafe(/*rec*/*a, (int)(i + size)), iptr, (u64)(((u64)((int)(a->len - i))) * ((u64)(elem_size))));
		vmemcpy(iptr, val, (u64)(((u64)(size)) * ((u64)(elem_size))));
	}
	a->len += size;
}

void array_prepend(array* a, voidptr val) {
	array_insert(a, 0, val);
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void array_prepend_many(array* a, voidptr val, int size) {
	array_insert_many(a, 0, val, size);
}

void array_delete(array* a, int i) {
	array_delete_many(a, i, 1);
}

void array_delete_many(array* a, int i, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || (int)(i + size) > a->len) {
			string endidx = (size > 1 ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT(".."), /*100 &int*/0xfe07, {.d_i32 = (int)(i + size)}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (_SLIT("")));
			_v_panic( str_intp(4, _MOV((StrIntpData[]){{_SLIT("array.delete: index out of range (i == "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT0, /*115 &string*/0xfe10, {.d_s = endidx}}, {_SLIT(", a.len == "), /*100 &int*/0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	if (ArrayFlags_all(&a->flags, (ArrayFlags__noshrink | ArrayFlags__noslices))) {
		vmemmove(((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), ((u8*)(a->data)) + (u64)(((u64)((int)(i + size))) * ((u64)(a->element_size))), (u64)(((u64)((int)((int)(a->len - i) - size))) * ((u64)(a->element_size))));
		a->len -= size;
		return;
	}
	voidptr old_data = a->data;
	int new_size = (int)(a->len - size);
	int new_cap = (new_size == 0 ? (1) : (new_size));
	a->data = vcalloc((u64)(((u64)(new_cap)) * ((u64)(a->element_size))));
	vmemcpy(a->data, old_data, (u64)(((u64)(i)) * ((u64)(a->element_size))));
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), ((u8*)(old_data)) + (u64)(((u64)((int)(i + size))) * ((u64)(a->element_size))), (u64)(((u64)((int)((int)(a->len - i) - size))) * ((u64)(a->element_size))));
	if (ArrayFlags_has(&a->flags, ArrayFlags__noslices)) {
		_v_free(old_data);
	}
	a->len = new_size;
	a->cap = new_cap;
}

void array_clear(array* a) {
	a->len = 0;
}

// Attr: [unsafe]
void array_reset(array* a) {
	vmemset(a->data, 0, (int)(a->len * a->element_size));
}

void array_trim(array* a, int index) {
	if (index < a->len) {
		a->len = index;
	}
}

void array_drop(array* a, int num) {
	if (num <= 0) {
		return;
	}
	int n = (num <= a->len ? (num) : (a->len));
	u64 blen = (u64)(((u64)(n)) * ((u64)(a->element_size)));
	a->data = ((u8*)(a->data)) + blen;
	a->offset += ((int)(blen));
	a->len -= n;
	a->cap -= n;
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL voidptr array_get_unsafe(array a, int i) {
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}

VV_LOCAL_SYMBOL voidptr array_get(array a, int i) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a.len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.get: index out of range (i == "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), /*100 &int*/0xfe07, {.d_i32 = a.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}

VV_LOCAL_SYMBOL voidptr array_get_with_check(array a, int i) {
	if (i < 0 || i >= a.len) {
		return 0;
	}
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)(i)) * ((u64)(a.element_size)));
	}
	return 0;
}

voidptr array_first(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			_v_panic(_SLIT("array.first: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	return a.data;
}

voidptr array_last(array a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a.len == 0) {
			_v_panic(_SLIT("array.last: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	{ // Unsafe block
		return ((u8*)(a.data)) + (u64)(((u64)((int)(a.len - 1))) * ((u64)(a.element_size)));
	}
	return 0;
}

voidptr array_pop(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			_v_panic(_SLIT("array.pop: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	int new_len = (int)(a->len - 1);
	u8* last_elem = ((u8*)(a->data)) + (u64)(((u64)(new_len)) * ((u64)(a->element_size)));
	a->len = new_len;
	return last_elem;
}

void array_delete_last(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			_v_panic(_SLIT("array.pop: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	a->len--;
}

VV_LOCAL_SYMBOL array array_slice(array a, int start, int _end) {
	int end = (_end == _const_max_int ? (a.len) : (_end));
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.slice: invalid slice index ("), /*100 &int*/0xfe07, {.d_i32 = start}}, {_SLIT(" > "), /*100 &int*/0xfe07, {.d_i32 = end}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (end > a.len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.slice: slice bounds out of range ("), /*100 &int*/0xfe07, {.d_i32 = end}}, {_SLIT(" >= "), /*100 &int*/0xfe07, {.d_i32 = a.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		if (start < 0) {
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.slice: slice bounds out of range ("), /*100 &int*/0xfe07, {.d_i32 = start}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	u64 offset = (u64)(((u64)(start)) * ((u64)(a.element_size)));
	u8* data = ((u8*)(a.data)) + offset;
	int l = (int)(end - start);
	array res = ((array){.data = data,.offset = (int)(a.offset + ((int)(offset))),.len = l,.cap = l,.flags = 0,.element_size = a.element_size,});
	return res;
}

VV_LOCAL_SYMBOL array array_slice_ni(array a, int _start, int _end) {
	int end = (_end == _const_max_int ? (a.len) : (_end));
	int start = _start;
	if (start < 0) {
		start = (int)(a.len + start);
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = (int)(a.len + end);
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= a.len) {
		end = a.len;
	}
	if (start >= a.len || start > end) {
		array res = ((array){.data = a.data,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = a.element_size,});
		return res;
	}
	u64 offset = (u64)(((u64)(start)) * ((u64)(a.element_size)));
	u8* data = ((u8*)(a.data)) + offset;
	int l = (int)(end - start);
	array res = ((array){.data = data,.offset = (int)(a.offset + ((int)(offset))),.len = l,.cap = l,.flags = 0,.element_size = a.element_size,});
	return res;
}

VV_LOCAL_SYMBOL array array_clone_static_to_depth(array a, int depth) {
	return array_clone_to_depth(&a, depth);
}

array array_clone(array* a) {
	return array_clone_to_depth(a, 0);
}

// Attr: [unsafe]
array array_clone_to_depth(array* a, int depth) {
	array arr = ((array){.data = vcalloc((u64)(((u64)(a->cap)) * ((u64)(a->element_size)))),.offset = 0,.len = a->len,.cap = a->cap,.flags = 0,.element_size = a->element_size,});
	if (depth > 0 && _us32_eq(sizeof(array),a->element_size) && a->len >= 0 && a->cap >= a->len) {
		for (int i = 0; i < a->len; ++i) {
			array ar = ((array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,});
			vmemcpy(&ar, array_get_unsafe(/*rec*/*a, i), ((int)(sizeof(array))));
			array ar_clone = array_clone_to_depth(&ar, (int)(depth - 1));
			array_set_unsafe(&arr, i, &ar_clone);
		}
		return arr;
	} else {
		if (a->data != 0) {
			vmemcpy(((u8*)(arr.data)), a->data, (u64)(((u64)(a->cap)) * ((u64)(a->element_size))));
		}
		return arr;
	}
	return (array){.data = 0,.offset = 0,.len = 0,.cap = 0,.element_size = 0,};
}

// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL void array_set_unsafe(array* a, int i, voidptr val) {
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(i))), val, a->element_size);
}

VV_LOCAL_SYMBOL void array_set(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= a->len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.set: index out of range (i == "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), /*100 &int*/0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(i))), val, a->element_size);
}

VV_LOCAL_SYMBOL void array_push(array* a, voidptr val) {
	if (a->len >= a->cap) {
		array_ensure_cap(a, (int)(a->len + 1));
	}
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), val, a->element_size);
	a->len++;
}

// Attr: [unsafe]
void array_push_many(array* a3, voidptr val, int size) {
	if (size <= 0 || val == ((void*)0)) {
		return;
	}
	array_ensure_cap(a3, (int)(a3->len + size));
	if (a3->data == val && a3->data != 0) {
		array copy = array_clone(a3);
		vmemcpy(((u8*)(a3->data)) + (u64)(((u64)(a3->element_size)) * ((u64)(a3->len))), copy.data, (u64)(((u64)(a3->element_size)) * ((u64)(size))));
	} else {
		if (a3->data != 0 && val != 0) {
			vmemcpy(((u8*)(a3->data)) + (u64)(((u64)(a3->element_size)) * ((u64)(a3->len))), val, (u64)(((u64)(a3->element_size)) * ((u64)(size))));
		}
	}
	a3->len += size;
}

void array_reverse_in_place(array* a) {
	if (a->len < 2 || a->element_size == 0) {
		return;
	}
	{ // Unsafe block
		u8* tmp_value = _v_malloc(a->element_size);
		for (int i = 0; i < (int)(a->len / 2); ++i) {
			vmemcpy(tmp_value, ((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), a->element_size);
			vmemcpy(((u8*)(a->data)) + (u64)(((u64)(i)) * ((u64)(a->element_size))), ((u8*)(a->data)) + (u64)(((u64)((int)((int)(a->len - 1) - i))) * ((u64)(a->element_size))), a->element_size);
			vmemcpy(((u8*)(a->data)) + (u64)(((u64)((int)((int)(a->len - 1) - i))) * ((u64)(a->element_size))), tmp_value, a->element_size);
		}
		_v_free(tmp_value);
	}
}

array array_reverse(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = ((array){.data = vcalloc((u64)(((u64)(a.cap)) * ((u64)(a.element_size)))),.offset = 0,.len = a.len,.cap = a.cap,.flags = 0,.element_size = a.element_size,});
	for (int i = 0; i < a.len; ++i) {
		array_set_unsafe(&arr, i, array_get_unsafe(a, (int)((int)(a.len - 1) - i)));
	}
	return arr;
}

// Attr: [unsafe]
void array_free(array* a) {
	if (ArrayFlags_has(&a->flags, ArrayFlags__nofree)) {
		return;
	}
	u8* mblock_ptr = ((u8*)((u64)(((u64)(a->data)) - ((u64)(a->offset)))));
	_v_free(mblock_ptr);
	{ // Unsafe block
		a->data = ((void*)0);
	}
}

array array_filter(array a, bool (*predicate)(voidptr ));

bool array_any(array a, bool (*predicate)(voidptr ));

bool array_all(array a, bool (*predicate)(voidptr ));

array array_map(array a, voidptr (*callback)(voidptr ));

void array_sort(array* a, int (*callback)(voidptr , voidptr ));

array array_sorted(array* a, int (*callback)(voidptr , voidptr ));

void array_sort_with_compare(array* a, int (*callback)(voidptr , voidptr )) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		vqsort(a->data, ((usize)(a->len)), ((usize)(a->element_size)), (voidptr)callback);
	}
	#endif
}

array array_sorted_with_compare(array* a, int (*callback)(voidptr , voidptr )) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		array r = array_clone(a);
		vqsort(r.data, ((usize)(r.len)), ((usize)(r.element_size)), (voidptr)callback);
		return r;
	}
	#endif
	return ((array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,});
}

bool array_contains(array a, voidptr value);

int array_index(array a, voidptr value);

// Attr: [direct_array_access]
// Attr: [unsafe]
void Array_string_free(Array_string* a) {
	for (int _t1 = 0; _t1 < a->len; ++_t1) {
		string* s = ((string*)a->data) + _t1;
		string_free(s);
	}
	array_free((((array*)(a))));
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string Array_string_str(Array_string a) {
	int sb_len = 4;
	if (a.len > 0) {
		sb_len += ((string*)a.data)[0].len;
		sb_len *= a.len;
	}
	sb_len += 2;
	strings__Builder sb = strings__new_builder(sb_len);
	strings__Builder_write_u8(&sb, '[');
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		strings__Builder_write_u8(&sb, '\'');
		strings__Builder_write_string(&sb, val);
		strings__Builder_write_u8(&sb, '\'');
		if (i < (int)(a.len - 1)) {
			strings__Builder_write_string(&sb, _SLIT(", "));
		}
	}
	strings__Builder_write_u8(&sb, ']');
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

string Array_u8_hex(Array_u8 b) {
	u8* hex = malloc_noscan((u64)((u64)(((u64)(b.len)) * 2U) + 1U));
	int dst_i = 0;
	for (int _t1 = 0; _t1 < b.len; ++_t1) {
		u8 i = ((u8*)b.data)[_t1];
		u8 n0 = (i >> 4);
		{ // Unsafe block
			hex[dst_i] = (n0 < 10 ? ((rune)(n0 + '0')) : ((u8)(n0 + ((u8)(87)))));
			dst_i++;
		}
		u8 n1 = (i & 0xF);
		{ // Unsafe block
			hex[dst_i] = (n1 < 10 ? ((rune)(n1 + '0')) : ((u8)(n1 + ((u8)(87)))));
			dst_i++;
		}
	}
	{ // Unsafe block
		hex[dst_i] = 0;
		return tos(hex, dst_i);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

int copy(Array_u8* dst, Array_u8 src) {
	int min = (dst->len < src.len ? (dst->len) : (src.len));
	if (min > 0) {
		vmemmove(((u8*)(dst->data)), src.data, min);
	}
	return min;
}

void array_grow_cap(array* a, int amount) {
	array_ensure_cap(a, (int)(a->cap + amount));
}

// Attr: [unsafe]
void array_grow_len(array* a, int amount) {
	array_ensure_cap(a, (int)(a->len + amount));
	a->len += amount;
}

// Attr: [unsafe]
Array_voidptr array_pointers(array a) {
	Array_voidptr res = __new_array_with_default(0, 0, sizeof(voidptr), 0);
	for (int i = 0; i < a.len; ++i) {
		array_push((array*)&res, _MOV((voidptr[]){ array_get_unsafe(a, i) }));
	}
	return res;
}

// Attr: [unsafe]
Array_u8 voidptr_vbytes(voidptr data, int len) {
	array res = ((array){.data = data,.offset = 0,.len = len,.cap = len,.flags = 0,.element_size = 1,});
	return res;
}

// Attr: [unsafe]
Array_u8 u8_vbytes(u8* data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

VV_LOCAL_SYMBOL array __new_array_noscan(int mylen, int cap, int elm_size) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_default_noscan(int mylen, int cap, int elm_size, voidptr val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	if (val != 0 && arr.data != ((void*)0)) {
		if (elm_size == 1) {
			u8 byte_value = *(((u8*)(val)));
			u8* dptr = ((u8*)(arr.data));
			for (int i = 0; i < arr.len; ++i) {
				{ // Unsafe block
					dptr[i] = byte_value;
				}
			}
		} else {
			for (int i = 0; i < arr.len; ++i) {
				array_set_unsafe(&arr, i, val);
			}
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_multi_default_noscan(int mylen, int cap, int elm_size, voidptr val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	if (val != 0 && arr.data != ((void*)0)) {
		for (int i = 0; i < arr.len; ++i) {
			array_set_unsafe(&arr, i, ((charptr)(val)) + (int)(i * elm_size));
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL array __new_array_with_array_default_noscan(int mylen, int cap, int elm_size, array val) {
	int cap_ = (cap < mylen ? (mylen) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = mylen,.cap = cap_,.flags = 0,.element_size = elm_size,});
	for (int i = 0; i < arr.len; ++i) {
		array val_clone = array_clone(&val);
		array_set_unsafe(&arr, i, &val_clone);
	}
	return arr;
}

VV_LOCAL_SYMBOL array new_array_from_c_array_noscan(int len, int cap, int elm_size, voidptr c_array) {
	int cap_ = (cap < len ? (len) : (cap));
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(cap_)) * ((u64)(elm_size)))),.offset = 0,.len = len,.cap = cap_,.flags = 0,.element_size = elm_size,});
	vmemcpy(arr.data, c_array, (u64)(((u64)(len)) * ((u64)(elm_size))));
	return arr;
}

VV_LOCAL_SYMBOL void array_ensure_cap_noscan(array* a, int required) {
	if (required <= a->cap) {
		return;
	}
	if (ArrayFlags_has(&a->flags, ArrayFlags__nogrow)) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.ensure_cap_noscan: array with the flag `.nogrow` cannot grow in size, array required new size: "), /*100 &int*/0xfe07, {.d_i32 = required}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	int cap = (a->cap > 0 ? (a->cap) : (2));
	for (;;) {
		if (!(required > cap)) break;
		cap *= 2;
	}
	u64 new_size = (u64)(((u64)(cap)) * ((u64)(a->element_size)));
	u8* new_data = vcalloc_noscan(new_size);
	if (a->data != ((void*)0)) {
		vmemcpy(new_data, a->data, (u64)(((u64)(a->len)) * ((u64)(a->element_size))));
	}
	a->data = new_data;
	a->offset = 0;
	a->cap = cap;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL array array_repeat_to_depth_noscan(array a, int count, int depth) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("array.repeat: count is negative: "), /*100 &int*/0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	u64 size = (u64)((u64)(((u64)(count)) * ((u64)(a.len))) * ((u64)(a.element_size)));
	if (size == 0U) {
		size = ((u64)(a.element_size));
	}
	array arr = ((array){.data = (depth > 0 ? (vcalloc(size)) : (vcalloc_noscan(size))),.offset = 0,.len = (int)(count * a.len),.cap = (int)(count * a.len),.flags = 0,.element_size = a.element_size,});
	if (a.len > 0) {
		u64 a_total_size = (u64)(((u64)(a.len)) * ((u64)(a.element_size)));
		u64 arr_step_size = (u64)(((u64)(a.len)) * ((u64)(arr.element_size)));
		u8* eptr = ((u8*)(arr.data));
		{ // Unsafe block
			for (int _t1 = 0; _t1 < count; ++_t1) {
				if (depth > 0) {
					array ary_clone = array_clone_to_depth_noscan(&a, depth);
					vmemcpy(eptr, ((u8*)(ary_clone.data)), a_total_size);
				} else {
					vmemcpy(eptr, ((u8*)(a.data)), a_total_size);
				}
				eptr += arr_step_size;
			}
		}
	}
	return arr;
}

VV_LOCAL_SYMBOL void array_insert_noscan(array* a, int i, voidptr val) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.insert: index out of range (i == "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), /*100 &int*/0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	array_ensure_cap_noscan(a, (int)(a->len + 1));
	{ // Unsafe block
		vmemmove(array_get_unsafe(/*rec*/*a, (int)(i + 1)), array_get_unsafe(/*rec*/*a, i), (u64)(((u64)((int)(a->len - i))) * ((u64)(a->element_size))));
		array_set_unsafe(a, i, val);
	}
	a->len++;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void array_insert_many_noscan(array* a, int i, voidptr val, int size) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i > a->len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("array.insert_many: index out of range (i == "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT(", a.len == "), /*100 &int*/0xfe07, {.d_i32 = a->len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	array_ensure_cap_noscan(a, (int)(a->len + size));
	int elem_size = a->element_size;
	{ // Unsafe block
		voidptr iptr = array_get_unsafe(/*rec*/*a, i);
		vmemmove(array_get_unsafe(/*rec*/*a, (int)(i + size)), iptr, (u64)(((u64)((int)(a->len - i))) * ((u64)(elem_size))));
		vmemcpy(iptr, val, (u64)(((u64)(size)) * ((u64)(elem_size))));
	}
	a->len += size;
}

VV_LOCAL_SYMBOL void array_prepend_noscan(array* a, voidptr val) {
	array_insert_noscan(a, 0, val);
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void array_prepend_many_noscan(array* a, voidptr val, int size) {
	array_insert_many_noscan(a, 0, val, size);
}

VV_LOCAL_SYMBOL voidptr array_pop_noscan(array* a) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (a->len == 0) {
			_v_panic(_SLIT("array.pop: array is empty"));
			VUNREACHABLE();
		}
	}
	#endif
	int new_len = (int)(a->len - 1);
	u8* last_elem = ((u8*)(a->data)) + (u64)(((u64)(new_len)) * ((u64)(a->element_size)));
	a->len = new_len;
	return memdup_noscan(last_elem, a->element_size);
}

VV_LOCAL_SYMBOL array array_clone_static_to_depth_noscan(array a, int depth) {
	return array_clone_to_depth_noscan(&a, depth);
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL array array_clone_to_depth_noscan(array* a, int depth) {
	u64 size = (u64)(((u64)(a->cap)) * ((u64)(a->element_size)));
	if (size == 0U) {
		size++;
	}
	array arr = ((array){.data = (depth == 0 ? (vcalloc_noscan(size)) : (vcalloc(size))),.offset = 0,.len = a->len,.cap = a->cap,.flags = 0,.element_size = a->element_size,});
	if (depth > 0) {
		for (int i = 0; i < a->len; ++i) {
			array ar = ((array){.data = 0,.offset = 0,.len = 0,.cap = 0,.flags = 0,.element_size = 0,});
			vmemcpy(&ar, array_get_unsafe(/*rec*/*a, i), ((int)(sizeof(array))));
			array ar_clone = array_clone_to_depth_noscan(&ar, (int)(depth - 1));
			array_set_unsafe(&arr, i, &ar_clone);
		}
		return arr;
	} else {
		if (a->data != 0) {
			vmemcpy(((u8*)(arr.data)), a->data, (u64)(((u64)(a->cap)) * ((u64)(a->element_size))));
		}
		return arr;
	}
	return (array){.data = 0,.offset = 0,.len = 0,.cap = 0,.element_size = 0,};
}

VV_LOCAL_SYMBOL void array_push_noscan(array* a, voidptr val) {
	array_ensure_cap_noscan(a, (int)(a->len + 1));
	vmemcpy(((u8*)(a->data)) + (u64)(((u64)(a->element_size)) * ((u64)(a->len))), val, a->element_size);
	a->len++;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void array_push_many_noscan(array* a3, voidptr val, int size) {
	if (size <= 0 || val == ((void*)0)) {
		return;
	}
	if (a3->data == val && a3->data != 0) {
		array copy = array_clone(a3);
		array_ensure_cap_noscan(a3, (int)(a3->len + size));
		vmemcpy(array_get_unsafe(/*rec*/*a3, a3->len), copy.data, (u64)(((u64)(a3->element_size)) * ((u64)(size))));
	} else {
		array_ensure_cap_noscan(a3, (int)(a3->len + size));
		if (a3->data != 0 && val != 0) {
			vmemcpy(array_get_unsafe(/*rec*/*a3, a3->len), val, (u64)(((u64)(a3->element_size)) * ((u64)(size))));
		}
	}
	a3->len += size;
}

VV_LOCAL_SYMBOL array array_reverse_noscan(array a) {
	if (a.len < 2) {
		return a;
	}
	array arr = ((array){.data = vcalloc_noscan((u64)(((u64)(a.cap)) * ((u64)(a.element_size)))),.offset = 0,.len = a.len,.cap = a.cap,.flags = 0,.element_size = a.element_size,});
	for (int i = 0; i < a.len; ++i) {
		array_set_unsafe(&arr, i, array_get_unsafe(a, (int)((int)(a.len - 1) - i)));
	}
	return arr;
}

VV_LOCAL_SYMBOL void array_grow_cap_noscan(array* a, int amount) {
	array_ensure_cap_noscan(a, (int)(a->cap + amount));
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void array_grow_len_noscan(array* a, int amount) {
	array_ensure_cap_noscan(a, (int)(a->len + amount));
	a->len += amount;
}

void print_backtrace(void) {
	#if !defined(CUSTOM_DEFINE_no_backtrace)
	{
		#if defined(_VFREESTANDING)
		{
		}
		#else
		{
			#if defined(_VNATIVE)
			{
			}
			#elif defined(__TINYC__)
			{
				tcc_backtrace("Backtrace");
			}
			#else
			{
			}
			#endif
		}
		#endif
	}
	#endif
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames(int skipframes) {
	#if defined(__TINYC__)
	{
		return print_backtrace_skipping_top_frames_tcc(skipframes);
	}
	#endif
	eprintln(_SLIT("print_backtrace_skipping_top_frames is not implemented"));
	return false;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_msvc(int skipframes) {
	#if defined(_MSC_VER)
	{
	}
	#else
	{
		eprintln(_SLIT("print_backtrace_skipping_top_frames_msvc must be called only when the compiler is msvc"));
		return false;
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_mingw(int skipframes) {
	eprintln(_SLIT("print_backtrace_skipping_top_frames_mingw is not implemented"));
	return false;
}

VV_LOCAL_SYMBOL bool print_backtrace_skipping_top_frames_tcc(int skipframes) {
	#if defined(__TINYC__) && !defined(_VNATIVE)
	{
		#if defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			tcc_backtrace("Backtrace");
			return true;
		}
		#endif
	}
	#else
	{
		eprintln(_SLIT("print_backtrace_skipping_top_frames_tcc must be called only when the compiler is tcc"));
		return false;
	}
	#endif
	return false;
}

// TypeDecl
// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void vhalt(void) {
	for (;;) {
	}
	while(1);
}

// Attr: [markused]
VV_LOCAL_SYMBOL void v_segmentation_fault_handler(int signal_number) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fprintf(stderr, "signal %d: segmentation fault\n", signal_number);
	}
	#endif
	#if defined(CUSTOM_DEFINE_use_libbacktrace)
	{
	}
	#else
	{
		print_backtrace();
	}
	#endif
	_v_exit((int)(128 + signal_number));
	VUNREACHABLE();
}

// Attr: [noreturn]
VNORETURN void _v_exit(int code) {
	exit(code);
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void panic_debug(int line_no, string file, string mod, string fn_name, string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		eprintln(_SLIT("================ V panic ================"));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("   module: "), /*115 &string*/0xfe10, {.d_s = mod}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" function: "), /*115 &string*/0xfe10, {.d_s = fn_name}}, {_SLIT("()"), 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("  message: "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("     file: "), /*115 &string*/0xfe10, {.d_s = file}}, {_SLIT(":"), /*100 &int*/0xfe07, {.d_i32 = line_no}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("   v hash: "), /*115 &string*/0xfe10, {.d_s = _SLIT("99d9473")}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln(_SLIT("========================================="));
		#if defined(_VNATIVE)
		{
			exit(1);
			VUNREACHABLE();
		}
		#elif defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			#if defined(__TINYC__)
			{
				#if defined(CUSTOM_DEFINE_panics_break_into_debugger)
				{
				}
				#else
				{
					tcc_backtrace("Backtrace");
				}
				#endif
				exit(1);
				VUNREACHABLE();
			}
			#endif
			#if defined(CUSTOM_DEFINE_use_libbacktrace)
			{
			}
			#else
			{
				print_backtrace_skipping_top_frames(1);
			}
			#endif
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	vhalt();
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN void panic_option_not_set(string s) {
	_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("option not set ("), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN void panic_result_not_set(string s) {
	_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("result not set ("), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN void _v_panic(string s) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		eprint(_SLIT("V panic: "));
		eprintln(s);
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("v hash: "), /*115 &string*/0xfe10, {.d_s = _SLIT("99d9473")}}, {_SLIT0, 0, { .d_c = 0 }}})));
		#if defined(_VNATIVE)
		{
			exit(1);
			VUNREACHABLE();
		}
		#elif defined(CUSTOM_DEFINE_exit_after_panic_message)
		{
		}
		#elif defined(CUSTOM_DEFINE_no_backtrace)
		{
		}
		#else
		{
			#if defined(__TINYC__)
			{
				#if defined(CUSTOM_DEFINE_panics_break_into_debugger)
				{
				}
				#else
				{
					tcc_backtrace("Backtrace");
				}
				#endif
				exit(1);
				VUNREACHABLE();
			}
			#endif
			#if defined(CUSTOM_DEFINE_use_libbacktrace)
			{
			}
			#else
			{
				print_backtrace_skipping_top_frames(1);
			}
			#endif
			exit(1);
			VUNREACHABLE();
		}
		#endif
	}
	#endif
	vhalt();
	VUNREACHABLE();
	while(1);
}

string c_error_number_str(int errnum) {
	string err_msg = _SLIT("");
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		#if !defined(__vinix__)
		{
			char* c_msg = strerror(errnum);
			err_msg = ((string){.str = ((u8*)(c_msg)), .len = strlen(c_msg), .is_lit = 1});
		}
		#endif
	}
	#endif
	return err_msg;
}

// Attr: [noreturn]
VNORETURN void panic_error_number(string basestr, int errnum) {
	_v_panic(string__plus(basestr, c_error_number_str(errnum)));
	VUNREACHABLE();
	while(1);
}

void eprintln(string s) {
	if (s.str == 0) {
		eprintln(_SLIT("eprintln(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		flush_stdout();
		flush_stderr();
		_writeln_to_fd(2, s);
		flush_stderr();
	}
	#endif
}

void eprint(string s) {
	if (s.str == 0) {
		eprint(_SLIT("eprint(NIL)"));
		return;
	}
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#else
	{
		flush_stdout();
		flush_stderr();
		_write_buf_to_fd(2, s.str, s.len);
		flush_stderr();
	}
	#endif
}

void flush_stdout(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stdout);
	}
	#endif
}

void flush_stderr(void) {
	#if defined(_VFREESTANDING)
	{
	}
	#else
	{
		fflush(stderr);
	}
	#endif
}

// Attr: [manualfree]
void print(string s) {
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		_write_buf_to_fd(1, s.str, s.len);
	}
	#endif
}

// Attr: [manualfree]
void println(string s) {
	if (s.str == 0) {
		println(_SLIT("println(NIL)"));
		return;
	}
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(__TARGET_IOS__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
		_writeln_to_fd(1, s);
	}
	#endif
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL void _writeln_to_fd(int fd, string s) {
	bool _writeln_to_fd_defer_0 = false;
	u8* buf;
	#if !defined(CUSTOM_DEFINE_builtin_writeln_should_write_at_once)
	{
		u8 lf = ((u8)('\n'));
		_write_buf_to_fd(fd, s.str, s.len);
		_write_buf_to_fd(fd, &lf, 1);
		return;
	}
	#endif
	{ // Unsafe block
		int buf_len = (int)(s.len + 1);
		buf = _v_malloc(buf_len);
		_writeln_to_fd_defer_0 = true;
		memcpy(buf, s.str, s.len);
		buf[s.len] = '\n';
		_write_buf_to_fd(fd, buf, buf_len);
	}
	// Defer begin
	if (_writeln_to_fd_defer_0) {
		_v_free(buf);
	}
	// Defer end
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL void _write_buf_to_fd(int fd, u8* buf, int buf_len) {
	if (buf_len <= 0) {
		return;
	}
	u8* ptr = buf;
	isize remaining_bytes = ((isize)(buf_len));
	isize x = ((isize)(0));
	#if defined(_VFREESTANDING) || defined(__vinix__) || defined(CUSTOM_DEFINE_builtin_write_buf_to_fd_should_use_c_write)
	{
	}
	#else
	{
		voidptr stream = ((voidptr)(stdout));
		if (fd == 2) {
			stream = ((voidptr)(stderr));
		}
		{ // Unsafe block
			for (;;) {
				if (!(remaining_bytes > 0)) break;
				x = ((isize)(fwrite(ptr, 1, remaining_bytes, stream)));
				ptr += x;
				remaining_bytes -= x;
			}
		}
	}
	#endif
}

// Attr: [unsafe]
u8* _v_malloc(isize n) {
	if (n < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	u8* res = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		{ // Unsafe block
			res = GC_MALLOC(n);
		}
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
	}
	#endif
	if (res == 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return res;
}

// Attr: [unsafe]
u8* malloc_noscan(isize n) {
	if (n < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc_noscan("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	u8* res = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		#if defined(CUSTOM_DEFINE_gcboehm_opt)
		{
			{ // Unsafe block
				res = GC_MALLOC_ATOMIC(n);
			}
		}
		#else
		{
		}
		#endif
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
	}
	#endif
	if (res == 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc_noscan("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return res;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 __at_least_one(u64 how_many) {
	if (how_many == 0U) {
		return 1U;
	}
	return how_many;
}

// Attr: [unsafe]
u8* malloc_uncollectable(isize n) {
	if (n < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc_uncollectable("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	u8* res = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		{ // Unsafe block
			res = GC_MALLOC_UNCOLLECTABLE(n);
		}
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#else
	{
	}
	#endif
	if (res == 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("malloc_uncollectable("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return res;
}

// Attr: [unsafe]
u8* v_realloc(u8* b, isize n) {
	u8* new_ptr = ((u8*)(0));
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		new_ptr = GC_REALLOC(b, n);
	}
	#else
	{
	}
	#endif
	if (new_ptr == 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("realloc("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return new_ptr;
}

// Attr: [unsafe]
u8* realloc_data(u8* old_data, int old_size, int new_size) {
	u8* nptr = ((u8*)(0));
	#if defined(_VGCBOEHM)
	{
		nptr = GC_REALLOC(old_data, new_size);
	}
	#else
	{
	}
	#endif
	if (nptr == 0) {
		_v_panic( str_intp(4, _MOV((StrIntpData[]){{_SLIT("realloc_data("), /*117 &u8*/0xfe11, {.d_p = (void*)(old_data)}}, {_SLIT(", "), /*100 &int*/0xfe07, {.d_i32 = old_size}}, {_SLIT(", "), /*100 &int*/0xfe07, {.d_i32 = new_size}}, {_SLIT(") failed"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return nptr;
}

u8* vcalloc(isize n) {
	if (n < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("calloc("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (n == 0) {
		return ((u8*)(0));
	}
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		return ((u8*)(GC_MALLOC(n)));
	}
	#else
	{
	}
	#endif
	return 0;
}

u8* vcalloc_noscan(isize n) {
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
		if (n < 0) {
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("calloc_noscan("), /*100 &isize*/0xfe09, {.d_i64 = n}}, {_SLIT(" < 0)"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
		u8* _t3;
		#if defined(CUSTOM_DEFINE_gcboehm_opt)
			_t3 = ((u8*)(memset(GC_MALLOC_ATOMIC(n), 0, n)));
			;
		#else
		#endif
		return _t3;
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [unsafe]
void _v_free(voidptr ptr) {
	#if defined(_VPREALLOC)
	{
	}
	#elif defined(_VGCBOEHM)
	{
	}
	#else
	{
	}
	#endif
}

// Attr: [unsafe]
voidptr memdup(voidptr src, isize sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = _v_malloc(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

// Attr: [unsafe]
voidptr memdup_noscan(voidptr src, isize sz) {
	if (sz == 0) {
		return vcalloc_noscan(1);
	}
	{ // Unsafe block
		u8* mem = malloc_noscan(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

// Attr: [unsafe]
voidptr memdup_uncollectable(voidptr src, isize sz) {
	if (sz == 0) {
		return vcalloc(1);
	}
	{ // Unsafe block
		u8* mem = malloc_uncollectable(sz);
		return memcpy(mem, src, sz);
	}
	return 0;
}

GCHeapUsage gc_heap_usage(void) {
	#if defined(_VGCBOEHM)
	{
		GCHeapUsage res = ((GCHeapUsage){.heap_size = 0,.free_bytes = 0,.total_bytes = 0,.unmapped_bytes = 0,.bytes_since_gc = 0,});
		GC_get_heap_usage_safe(&res.heap_size, &res.free_bytes, &res.unmapped_bytes, &res.bytes_since_gc, &res.total_bytes);
		return res;
	}
	#else
	{
	}
	#endif
	return (GCHeapUsage){0};
}

usize gc_memory_use(void) {
	#if defined(_VGCBOEHM)
	{
		return GC_get_memory_use();
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int v_fixed_index(int i, int len) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (i < 0 || i >= len) {
			string s =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("fixed array index out of range (index: "), /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT(", len: "), /*100 &int*/0xfe07, {.d_i32 = len}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
			_v_panic(s);
			VUNREACHABLE();
		}
	}
	#endif
	return i;
}

// Attr: [inline]
inline bool isnil(voidptr v) {
	return v == 0;
}

VV_LOCAL_SYMBOL voidptr __as_cast(voidptr obj, int obj_type, int expected_type) {
	if (obj_type != expected_type) {
		string obj_name = string_clone((*(VCastTypeIndexName*)array_get(as_cast_type_indexes, 0)).tname);
		string expected_name = string_clone((*(VCastTypeIndexName*)array_get(as_cast_type_indexes, 0)).tname);
		for (int _t1 = 0; _t1 < as_cast_type_indexes.len; ++_t1) {
			VCastTypeIndexName x = ((VCastTypeIndexName*)as_cast_type_indexes.data)[_t1];
			if (x.tindex == obj_type) {
				obj_name = string_clone(x.tname);
			}
			if (x.tindex == expected_type) {
				expected_name = string_clone(x.tname);
			}
		}
		_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("as cast: cannot cast `"), /*115 &string*/0xfe10, {.d_s = obj_name}}, {_SLIT("` to `"), /*115 &string*/0xfe10, {.d_s = expected_name}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	return obj;
}

// Attr: [manualfree]
// Attr: [unsafe]
void VAssertMetaInfo_free(VAssertMetaInfo* ami) {
	{ // Unsafe block
		string_free(&ami->fpath);
		string_free(&ami->fn_name);
		string_free(&ami->src);
		string_free(&ami->op);
		string_free(&ami->llabel);
		string_free(&ami->rlabel);
		string_free(&ami->lvalue);
		string_free(&ami->rvalue);
		string_free(&ami->message);
	}
}

VV_LOCAL_SYMBOL void __print_assert_failure(VAssertMetaInfo* i) {
	eprintln( str_intp(5, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = i->fpath}}, {_SLIT(":"), /*100 &int*/0xfe07, {.d_i32 = (int)(i->line_nr + 1)}}, {_SLIT(": FAIL: fn "), /*115 &string*/0xfe10, {.d_s = i->fn_name}}, {_SLIT(": assert "), /*115 &string*/0xfe10, {.d_s = i->src}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (i->op.len > 0 && !string__eq(i->op, _SLIT("call"))) {
		eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("   left value: "), /*115 &string*/0xfe10, {.d_s = i->llabel}}, {_SLIT(" = "), /*115 &string*/0xfe10, {.d_s = i->lvalue}}, {_SLIT0, 0, { .d_c = 0 }}})));
		if (string__eq(i->rlabel, i->rvalue)) {
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("  right value: "), /*115 &string*/0xfe10, {.d_s = i->rlabel}}, {_SLIT0, 0, { .d_c = 0 }}})));
		} else {
			eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("  right value: "), /*115 &string*/0xfe10, {.d_s = i->rlabel}}, {_SLIT(" = "), /*115 &string*/0xfe10, {.d_s = i->rvalue}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
	}
	if (i->has_msg) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("      message: "), /*115 &string*/0xfe10, {.d_s = i->message}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

#if defined(CUSTOM_DEFINE_dynamic_boehm)
#else
	#if defined(__APPLE__) || defined(__linux__)
	#elif defined(__FreeBSD__)
	#elif defined(__OpenBSD__)
	#elif defined(_WIN32)
		#if defined(__TINYC__)
		#elif defined(_MSC_VER)
		#else
		#endif
	#elif false
	#else
	#endif
#endif
void gc_check_leaks(void) {
}

VV_LOCAL_SYMBOL void print_libbacktrace(int frames_to_skip) {
}

// Attr: [noinline]
__NOINLINE VV_LOCAL_SYMBOL void eprint_libbacktrace(int frames_to_skip) {
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL void restore_codepage(void) {
	SetConsoleOutputCP(g_original_codepage);
}

VV_LOCAL_SYMBOL int is_terminal(int fd) {
	u32 mode = ((u32)(0U));
	voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
	GetConsoleMode(osfh, ((voidptr)(&mode)));
	return ((int)(mode));
}

VV_LOCAL_SYMBOL void builtin_init(void) {
	g_original_codepage = GetConsoleOutputCP();
	SetConsoleOutputCP(_const_cp_utf8);
	atexit((voidptr)restore_codepage);
	if (is_terminal(1) > 0) {
		SetConsoleMode(GetStdHandle(_const_std_output_handle), ((_const_enable_processed_output | _const_enable_wrap_at_eol_output) | _const_evable_virtual_terminal_processing));
		SetConsoleMode(GetStdHandle(_const_std_error_handle), ((_const_enable_processed_output | _const_enable_wrap_at_eol_output) | _const_evable_virtual_terminal_processing));
		{ // Unsafe block
			setbuf(stdout, 0);
			setbuf(stderr, 0);
		}
	}
	#if !defined(CUSTOM_DEFINE_no_backtrace)
	{
		add_unhandled_exception_handler();
	}
	#endif
}

// TypeDecl
VV_LOCAL_SYMBOL void add_vectored_exception_handler(int (*handler)(ExceptionPointers* )) {
	AddVectoredExceptionHandler(1, ((voidptr)(handler)));
}

// Attr: [callconv]
VV_LOCAL_SYMBOL int __attribute__((stdcall)) unhandled_exception_handler(ExceptionPointers* e) {
	switch (e->exception_record->code) {
		case 0x4001000A: case 0x40010006: case 0xE06D7363: {
				return 0;
		}
		default: {
				println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unhandled Exception 0x"), /*88 &u32*/0x7000fe86, {.d_u32 = e->exception_record->code}}, {_SLIT0, 0, { .d_c = 0 }}})));
				print_backtrace_skipping_top_frames(5);
				break;
		}
	}
	
	return 0;
}

VV_LOCAL_SYMBOL void add_unhandled_exception_handler(void) {
	add_vectored_exception_handler((voidptr)((VectoredExceptionHandler)(((voidptr)(unhandled_exception_handler)))));
}

VV_LOCAL_SYMBOL void break_if_debugger_attached(void) {
	#if defined(__TINYC__)
	{
		{ // Unsafe block
			voidptr* ptr = ((voidptr*)(0));
			*ptr = ((void*)0);
			{voidptr* _ = ptr;}
			;
		}
	}
	#else
	{
	}
	#endif
}

string winapi_lasterr_str(void) {
	u32 err_msg_id = GetLastError();
	if (err_msg_id == 8U) {
		return _SLIT("insufficient memory");
	}
	u16* msgbuf = ((u16*)(0));
	u32 res = FormatMessageW(((_const_format_message_allocate_buffer | _const_format_message_from_system) | _const_format_message_ignore_inserts), 0, err_msg_id, 0U, ((voidptr)(&msgbuf)), 0U, 0);
	string err_msg = (res == 0U ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Win-API error "), /*117 &u32*/0xfe06, {.d_u32 = err_msg_id}}, {_SLIT0, 0, { .d_c = 0 }}}))) : (string_from_wide(msgbuf)));
	return err_msg;
}

// Attr: [noreturn]
VNORETURN void panic_lasterr(string base) {
	_v_panic(string__plus(base, winapi_lasterr_str()));
	VUNREACHABLE();
	while(1);
}

// Attr: [trusted]
// Attr: [noreturn]
// Attr: [trusted]
// Attr: [trusted]
int proc_pidpath(int , voidptr , int );

// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// TypeDecl
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
// Attr: [inline]
// Attr: [unsafe]
inline int vstrlen(u8* s) {
	return strlen(((char*)(s)));
}

// Attr: [inline]
// Attr: [unsafe]
inline int vstrlen_char(char* s) {
	return strlen(s);
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemcpy(voidptr dest, const voidptr const_src, isize n) {
	{ // Unsafe block
		return memcpy(dest, const_src, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemmove(voidptr dest, const voidptr const_src, isize n) {
	{ // Unsafe block
		return memmove(dest, const_src, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline int vmemcmp(const voidptr const_s1, const voidptr const_s2, isize n) {
	{ // Unsafe block
		return memcmp(const_s1, const_s2, n);
	}
	return 0;
}

// Attr: [inline]
// Attr: [unsafe]
inline voidptr vmemset(voidptr s, int c, isize n) {
	{ // Unsafe block
		return memset(s, c, n);
	}
	return 0;
}

// TypeDecl
// Attr: [inline]
// Attr: [unsafe]
inline VV_LOCAL_SYMBOL void vqsort(voidptr base, usize nmemb, usize size, int (*sort_cb)(const voidptr const_a, const voidptr const_b)) {
	qsort(base, nmemb, size, ((voidptr)(sort_cb)));
}

void chan_close(chan ch) {
}

ChanState chan_try_pop(chan ch, voidptr obj) {
	return ChanState__success;
}

ChanState chan_try_push(chan ch, voidptr obj) {
	return ChanState__success;
}

int input_character(void) {
	int ch = 0;
	#if defined(_VFREESTANDING)
	{
	}
	#elif defined(__vinix__)
	{
	}
	#else
	{
		ch = getchar();
		if (ch == EOF) {
			return -1;
		}
	}
	#endif
	return ch;
}

int print_character(u8 ch) {
	#if defined(__ANDROID__) && !defined(__TERMUX__)
	{
	}
	#elif defined(_VFREESTANDING)
	{
	}
	#elif defined(__vinix__)
	{
	}
	#else
	{
		int x = putchar(ch);
		if (x == EOF) {
			return -1;
		}
	}
	#endif
	return ch;
}

#if !defined(_VNATIVE)
#endif
// Attr: [inline]
inline string f64_str(f64 x) {
	{ // Unsafe block
		strconv__Float64u f = ((strconv__Float64u){.f = x,});
		if (f.u == _const_strconv__double_minus_zero) {
			return _SLIT("-0.0");
		}
		if (f.u == _const_strconv__double_plus_zero) {
			return _SLIT("0.0");
		}
	}
	f64 abs_x = f64_abs(x);
	if (abs_x >= ((f64)(0.0001)) && abs_x < ((f64)(1.0e6))) {
		return strconv__f64_to_str_l(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f64_strg(f64 x) {
	if (x == 0) {
		return _SLIT("0.0");
	}
	f64 abs_x = f64_abs(x);
	if (abs_x >= ((f64)(0.0001)) && abs_x < ((f64)(1.0e6))) {
		return strconv__f64_to_str_l_with_dot(x);
	} else {
		return strconv__ftoa_64(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string float_literal_str(float_literal d) {
	return f64_str(((f64)(d)));
}

// Attr: [inline]
inline string f64_strsci(f64 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 17) {
		n_digit = 17;
	}
	return strconv__f64_to_str(x, n_digit);
}

// Attr: [inline]
inline string f64_strlong(f64 x) {
	return strconv__f64_to_str_l(x);
}

// Attr: [inline]
inline string f32_str(f32 x) {
	{ // Unsafe block
		strconv__Float32u f = ((strconv__Float32u){.f = x,});
		if (f.u == _const_strconv__single_minus_zero) {
			return _SLIT("-0.0");
		}
		if (f.u == _const_strconv__single_plus_zero) {
			return _SLIT("0.0");
		}
	}
	f32 abs_x = f32_abs(x);
	if (abs_x >= ((f32)(0.0001)) && abs_x < ((f32)(1.0e6))) {
		return strconv__f32_to_str_l(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f32_strg(f32 x) {
	if (x == 0) {
		return _SLIT("0.0");
	}
	f32 abs_x = f32_abs(x);
	if (abs_x >= ((f32)(0.0001)) && abs_x < ((f32)(1.0e6))) {
		return strconv__f32_to_str_l_with_dot(x);
	} else {
		return strconv__ftoa_32(x);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string f32_strsci(f32 x, int digit_num) {
	int n_digit = digit_num;
	if (n_digit < 1) {
		n_digit = 1;
	} else if (n_digit > 8) {
		n_digit = 8;
	}
	return strconv__f32_to_str(x, n_digit);
}

// Attr: [inline]
inline string f32_strlong(f32 x) {
	return strconv__f32_to_str_l(x);
}

// Attr: [inline]
inline f32 f32_abs(f32 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 f64_abs(f64 a) {
	return (a < 0 ? (-a) : (a));
}

// Attr: [inline]
inline f32 f32_max(f32 a, f32 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline f32 f32_min(f32 a, f32 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline f64 f64_max(f64 a, f64 b) {
	return (a > b ? (a) : (b));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 f64_min(f64 a, f64 b) {
	return (a < b ? (a) : (b));
}

// Attr: [inline]
inline bool f32_eq_epsilon(f32 a, f32 b) {
	f32 hi = f32_max(f32_abs(a), f32_abs(b));
	f32 delta = f32_abs((f32)(a - b));
	#if defined(_VNATIVE)
	{
		if (hi > ((f32)(1.0))) {
			return delta <= (f32)(hi * ((f32)(((float_literal)(4 * 1.19209290e-7)))));
		} else {
			return (f32)(((f32)(((float_literal)(1 / ((float_literal)(4 * 1.19209290e-7)))))) * delta) <= hi;
		}
	}
	#else
	{
		if (hi > ((f32)(1.0))) {
			return delta <= (f32)(hi * ((f32)(4 * ((f32)(FLT_EPSILON)))));
		} else {
			return (f32)(((f32)(1 / ((f32)(4 * ((f32)(FLT_EPSILON)))))) * delta) <= hi;
		}
	}
	#endif
	return 0;
}

// Attr: [inline]
inline bool f64_eq_epsilon(f64 a, f64 b) {
	f64 hi = f64_max(f64_abs(a), f64_abs(b));
	f64 delta = f64_abs((f64)(a - b));
	#if defined(_VNATIVE)
	{
		if (hi > ((f64)(1.0))) {
			return delta <= (f64)(hi * ((f64)(((float_literal)(4 * 2.2204460492503131e-16)))));
		} else {
			return (f64)(((f64)(((float_literal)(1 / ((float_literal)(4 * 2.2204460492503131e-16)))))) * delta) <= hi;
		}
	}
	#else
	{
		if (hi > ((f64)(1.0))) {
			return delta <= (f64)(hi * ((f64)(4 * ((f64)(DBL_EPSILON)))));
		} else {
			return (f64)(((f64)(1 / ((f64)(4 * ((f64)(DBL_EPSILON)))))) * delta) <= hi;
		}
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL void float_test(void) {
}

// TypeDecl
string ptr_str(voidptr ptr) {
	string buf1 = u64_hex(((u64)(ptr)));
	return buf1;
}

string isize_str(isize x) {
	return i64_str(((i64)(x)));
}

string usize_str(usize x) {
	return u64_str(((u64)(x)));
}

string char_str(char* cptr) {
	return u64_hex(((u64)(cptr)));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL string int_str_l(int nn, int max) {
	{ // Unsafe block
		i64 n = ((i64)(nn));
		int d = 0;
		if (n == 0) {
			return _SLIT("0");
		}
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		u8* buf = malloc_noscan((int)(max + 1));
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			int n1 = ((int)((i64)(n / 100)));
			d = ((int)((((u32)((int)(((int)(n)) - ((int)(n1 * 100))))) << 1U)));
			n = n1;
			buf[index] = _const_digit_pairs.str[d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[d];
			index--;
		}
		index++;
		if (d < 20) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = (int)(max - index);
		vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string i8_str(i8 n) {
	return int_str_l(((int)(n)), 5);
}

string i16_str(i16 n) {
	return int_str_l(((int)(n)), 7);
}

string u16_str(u16 n) {
	return int_str_l(((int)(n)), 7);
}

string i32_str(i32 n) {
	return int_str_l(((int)(n)), 12);
}

string int_hex_full(int nn) {
	return u64_to_hex(((u64)(nn)), 8);
}

string int_str(int n) {
	return int_str_l(n, 12);
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string u32_str(u32 nn) {
	{ // Unsafe block
		u32 n = nn;
		u32 d = ((u32)(0U));
		if (n == 0U) {
			return _SLIT("0");
		}
		int max = 12;
		u8* buf = malloc_noscan((int)(max + 1));
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0U)) break;
			u32 n1 = (u32)(n / ((u32)(100U)));
			d = ((((u32)(n - ((u32)(n1 * ((u32)(100U)))))) << ((u32)(1U))));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((u32)(20U))) {
			index++;
		}
		int diff = (int)(max - index);
		vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string int_literal_str(int_literal n) {
	return i64_str(((i64)(n)));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string i64_str(i64 nn) {
	{ // Unsafe block
		i64 n = nn;
		i64 d = ((i64)(0));
		if (n == 0) {
			return _SLIT("0");
		} else if (n == _const_min_i64) {
			return _SLIT("-9223372036854775808");
		}
		int max = 20;
		u8* buf = malloc_noscan((int)(max + 1));
		bool is_neg = false;
		if (n < 0) {
			n = -n;
			is_neg = true;
		}
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0)) break;
			i64 n1 = (i64)(n / ((i64)(100)));
			d = ((((u32)((i64)(n - ((i64)(n1 * ((i64)(100))))))) << ((i64)(1))));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < ((i64)(20))) {
			index++;
		}
		if (is_neg) {
			index--;
			buf[index] = '-';
		}
		int diff = (int)(max - index);
		vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
// Attr: [inline]
inline string u64_str(u64 nn) {
	{ // Unsafe block
		u64 n = nn;
		u64 d = ((u64)(0U));
		if (n == 0U) {
			return _SLIT("0");
		}
		int max = 20;
		u8* buf = malloc_noscan((int)(max + 1));
		int index = max;
		buf[index] = 0;
		index--;
		for (;;) {
			if (!(n > 0U)) break;
			u64 n1 = (u64)(n / 100U);
			d = ((((u64)(n - ((u64)(n1 * 100U)))) << 1U));
			n = n1;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
			d++;
			buf[index] = _const_digit_pairs.str[ d];
			index--;
		}
		index++;
		if (d < 20U) {
			index++;
		}
		int diff = (int)(max - index);
		vmemmove(buf, ((voidptr)(buf + index)), (int)(diff + 1));
		return tos(buf, diff);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string bool_str(bool b) {
	if (b) {
		return _SLIT("true");
	}
	return _SLIT("false");
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL string u64_to_hex(u64 nn, u8 len) {
	u64 n = nn;
	Array_fixed_u8_17 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	buf[len] = 0;
	int i = 0;
	for (i = (u8)(len - 1); i >= 0; i--) {
		u8 d = ((u8)((n & 0xFU)));
		buf[i] = (d < 10 ? ((rune)(d + '0')) : ((u8)(d + 87)));
		n = (n >> 4U);
	}
	return tos(memdup(&buf[0], (u8)(len + 1)), len);
}

// Attr: [direct_array_access]
// Attr: [inline]
inline VV_LOCAL_SYMBOL string u64_to_hex_no_leading_zeros(u64 nn, u8 len) {
	u64 n = nn;
	Array_fixed_u8_17 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	buf[len] = 0;
	int i = 0;
	for (i = (u8)(len - 1); i >= 0; i--) {
		u8 d = ((u8)((n & 0xFU)));
		buf[i] = (d < 10 ? ((rune)(d + '0')) : ((u8)(d + 87)));
		n = (n >> 4U);
		if (n == 0U) {
			break;
		}
	}
	int res_len = (int)(len - i);
	return tos(memdup(&buf[i], (int)(res_len + 1)), res_len);
}

string u8_hex(u8 nn) {
	if (nn == 0) {
		return _SLIT("00");
	}
	return u64_to_hex(nn, 2);
}

string i8_hex(i8 nn) {
	if (nn == 0) {
		return _SLIT("00");
	}
	return u64_to_hex(((u64)(nn)), 2);
}

string u16_hex(u16 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 4);
}

string i16_hex(i16 nn) {
	return u16_hex(((u16)(nn)));
}

string u32_hex(u32 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 8);
}

string int_hex(int nn) {
	return u32_hex(((u32)(nn)));
}

string int_hex2(int n) {
	return string__plus(_SLIT("0x"), int_hex(n));
}

string u64_hex(u64 nn) {
	if (nn == 0U) {
		return _SLIT("0");
	}
	return u64_to_hex_no_leading_zeros(nn, 16);
}

string i64_hex(i64 nn) {
	return u64_hex(((u64)(nn)));
}

string int_literal_hex(int_literal nn) {
	return u64_hex(((u64)(nn)));
}

string voidptr_str(voidptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string byteptr_str(byteptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string charptr_str(charptr nn) {
	return string__plus(_SLIT("0x"), u64_hex(((u64)(nn))));
}

string u8_hex_full(u8 nn) {
	return u64_to_hex(((u64)(nn)), 2);
}

string i8_hex_full(i8 nn) {
	return u64_to_hex(((u64)(nn)), 2);
}

string u16_hex_full(u16 nn) {
	return u64_to_hex(((u64)(nn)), 4);
}

string i16_hex_full(i16 nn) {
	return u64_to_hex(((u64)(nn)), 4);
}

string u32_hex_full(u32 nn) {
	return u64_to_hex(((u64)(nn)), 8);
}

string i64_hex_full(i64 nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string voidptr_hex_full(voidptr nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string int_literal_hex_full(int_literal nn) {
	return u64_to_hex(((u64)(nn)), 16);
}

string u64_hex_full(u64 nn) {
	return u64_to_hex(nn, 16);
}

string u8_str(u8 b) {
	return int_str_l(((int)(b)), 7);
}

string u8_ascii_str(u8 b) {
	string str = ((string){.str = malloc_noscan(2), .len = 1});
	{ // Unsafe block
		str.str[0] = b;
		str.str[1] = 0;
	}
	return str;
}

// Attr: [manualfree]
string u8_str_escaped(u8 b) {
	string _t1 = (string){.str=(byteptr)"", .is_lit=1};
	
	if (b == (0)) {
		_t1 = _SLIT("`\\0`");
	}
	else if (b == (7)) {
		_t1 = _SLIT("`\\a`");
	}
	else if (b == (8)) {
		_t1 = _SLIT("`\\b`");
	}
	else if (b == (9)) {
		_t1 = _SLIT("`\\t`");
	}
	else if (b == (10)) {
		_t1 = _SLIT("`\\n`");
	}
	else if (b == (11)) {
		_t1 = _SLIT("`\\v`");
	}
	else if (b == (12)) {
		_t1 = _SLIT("`\\f`");
	}
	else if (b == (13)) {
		_t1 = _SLIT("`\\r`");
	}
	else if (b == (27)) {
		_t1 = _SLIT("`\\e`");
	}
	else if ((b >= 32 && b <= 126)) {
		_t1 = u8_ascii_str(b);
	}
	else {
		string xx = u8_hex(b);
		string yy = string__plus(_SLIT("0x"), xx);
		string_free(&xx);
		_t1 = yy;
	}string str = _t1;
	return str;
}

// Attr: [inline]
inline bool u8_is_capital(u8 c) {
	return c >= 'A' && c <= 'Z';
}

Array_u8 Array_u8_clone(Array_u8 b) {
	Array_u8 res = __new_array_with_default_noscan(b.len, 0, sizeof(u8), 0);
	for (int i = 0; i < b.len; ++i) {
		array_set(&res, i, &(u8[]) { (*(u8*)array_get(b, i)) });
	}
	return res;
}

string Array_u8_bytestr(Array_u8 b) {
	{ // Unsafe block
		u8* buf = malloc_noscan((int)(b.len + 1));
		vmemcpy(buf, b.data, b.len);
		buf[b.len] = 0;
		return tos(buf, b.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

_result_rune Array_u8_byterune(Array_u8 b) {
	_result_rune _t1 = Array_u8_utf8_to_utf32(b);
	if (_t1.is_error) {
		_result_rune _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	rune r =  (*(rune*)_t1.data);
	_result_rune _t3;
	_result_ok(&(rune[]) { ((rune)(r)) }, (_result*)(&_t3), sizeof(rune));
	return _t3;
}

string u8_repeat(u8 b, int count) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("byte.repeat: count is negative: "), /*100 &int*/0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return u8_ascii_str(b);
	}
	u8* ret = malloc_noscan((int)(count + 1));
	for (int i = 0; i < count; ++i) {
		{ // Unsafe block
			ret[i] = b;
		}
	}
	int new_len = count;
	{ // Unsafe block
		ret[new_len] = 0;
	}
	return u8_vstring_with_len(ret, new_len);
}

VV_LOCAL_SYMBOL string _Atomic__int_str(int x) {
	return int_str(x);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool fast_string_eq(string a, string b) {
	if (a.len != b.len) {
		return false;
	}
	{ // Unsafe block
		return memcmp(a.str, b.str, b.len) == 0;
	}
	return 0;
}

VV_LOCAL_SYMBOL u64 map_hash_string(voidptr pkey) {
	string key = *((string*)(pkey));
	return wyhash(key.str, ((u64)(key.len)), 0U, ((u64*)(_wyp)));
}

VV_LOCAL_SYMBOL u64 map_hash_int_1(voidptr pkey) {
	return wyhash64(*((u8*)(pkey)), 0U);
}

VV_LOCAL_SYMBOL u64 map_hash_int_2(voidptr pkey) {
	return wyhash64(*((u16*)(pkey)), 0U);
}

VV_LOCAL_SYMBOL u64 map_hash_int_4(voidptr pkey) {
	return wyhash64(*((u32*)(pkey)), 0U);
}

VV_LOCAL_SYMBOL u64 map_hash_int_8(voidptr pkey) {
	return wyhash64(*((u64*)(pkey)), 0U);
}

VV_LOCAL_SYMBOL void DenseArray_zeros_to_end(DenseArray* d) {
	u8* tmp_value = _v_malloc(d->value_bytes);
	u8* tmp_key = _v_malloc(d->key_bytes);
	int count = 0;
	for (int i = 0; i < d->len; ++i) {
		if (DenseArray_has_index(d, i)) {
			{ // Unsafe block
				if (count != i) {
					memcpy(tmp_key, DenseArray_key(d, count), d->key_bytes);
					memcpy(DenseArray_key(d, count), DenseArray_key(d, i), d->key_bytes);
					memcpy(DenseArray_key(d, i), tmp_key, d->key_bytes);
					memcpy(tmp_value, DenseArray_value(d, count), d->value_bytes);
					memcpy(DenseArray_value(d, count), DenseArray_value(d, i), d->value_bytes);
					memcpy(DenseArray_value(d, i), tmp_value, d->value_bytes);
				}
			}
			count++;
		}
	}
	{ // Unsafe block
		_v_free(tmp_value);
		_v_free(tmp_key);
		d->deletes = 0U;
		_v_free(d->all_deleted);
	}
	d->len = count;
	int old_cap = d->cap;
	d->cap = (count < 8 ? (8) : (count));
	{ // Unsafe block
		d->values = realloc_data(d->values, (int)(d->value_bytes * old_cap), (int)(d->value_bytes * d->cap));
		d->keys = realloc_data(d->keys, (int)(d->key_bytes * old_cap), (int)(d->key_bytes * d->cap));
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL DenseArray new_dense_array(int key_bytes, int value_bytes) {
	int cap = 8;
	return ((DenseArray){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.cap = cap,
		.len = 0,
		.deletes = 0U,
		.all_deleted = ((void*)0),
		.keys = _v_malloc(__at_least_one((u64)(((u64)(cap)) * ((u64)(key_bytes))))),
		.values = _v_malloc(__at_least_one((u64)(((u64)(cap)) * ((u64)(value_bytes))))),
	});
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL voidptr DenseArray_key(DenseArray* d, int i) {
	return ((voidptr)(d->keys + (int)(i * d->key_bytes)));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL voidptr DenseArray_value(DenseArray* d, int i) {
	return ((voidptr)(d->values + (int)(i * d->value_bytes)));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL bool DenseArray_has_index(DenseArray* d, int i) {
	return d->deletes == 0U || d->all_deleted[i] == 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL int DenseArray_expand(DenseArray* d) {
	int old_cap = d->cap;
	int old_key_size = (int)(d->key_bytes * old_cap);
	int old_value_size = (int)(d->value_bytes * old_cap);
	if (d->cap == d->len) {
		d->cap += (d->cap >> 3);
		{ // Unsafe block
			d->keys = realloc_data(d->keys, old_key_size, (int)(d->key_bytes * d->cap));
			d->values = realloc_data(d->values, old_value_size, (int)(d->value_bytes * d->cap));
			if (d->deletes != 0U) {
				d->all_deleted = realloc_data(d->all_deleted, old_cap, d->cap);
				vmemset(((voidptr)(d->all_deleted + d->len)), 0, (int)(d->cap - d->len));
			}
		}
	}
	int push_index = d->len;
	{ // Unsafe block
		if (d->deletes != 0U) {
			d->all_deleted[push_index] = 0;
		}
	}
	d->len++;
	return push_index;
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL bool map_eq_string(voidptr a, voidptr b) {
	return fast_string_eq(*((string*)(a)), *((string*)(b)));
}

VV_LOCAL_SYMBOL bool map_eq_int_1(voidptr a, voidptr b) {
	return *((u8*)(a)) == *((u8*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_2(voidptr a, voidptr b) {
	return *((u16*)(a)) == *((u16*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_4(voidptr a, voidptr b) {
	return *((u32*)(a)) == *((u32*)(b));
}

VV_LOCAL_SYMBOL bool map_eq_int_8(voidptr a, voidptr b) {
	return *((u64*)(a)) == *((u64*)(b));
}

VV_LOCAL_SYMBOL void map_clone_string(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		string s = *((string*)(pkey));
		*((string*)(dest)) = string_clone(s);
	}
}

VV_LOCAL_SYMBOL void map_clone_int_1(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u8*)(dest)) = *((u8*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_2(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u16*)(dest)) = *((u16*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_4(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u32*)(dest)) = *((u32*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_clone_int_8(voidptr dest, voidptr pkey) {
	{ // Unsafe block
		*((u64*)(dest)) = *((u64*)(pkey));
	}
}

VV_LOCAL_SYMBOL void map_free_string(voidptr pkey) {
	string_free(ADDR(string, (*((string*)(pkey)))));
}

VV_LOCAL_SYMBOL void map_free_nop(voidptr _d1) {
}

VV_LOCAL_SYMBOL map new_map(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array(key_bytes, value_bytes),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}

VV_LOCAL_SYMBOL map new_map_init(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}

map map_move(map* m) {
	map r = *m;
	vmemset(m, 0, ((int)(sizeof(map))));
	return r;
}

void map_clear(map* m) {
	m->len = 0;
	m->even_index = 0U;
	m->key_values.len = 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_key_to_index(map* m, voidptr pkey) {
	u64 hash = m->hash_fn(pkey);
	u64 index = (hash & m->even_index);
	u64 meta = (((((hash >> m->shift)) & _const_hash_mask)) | _const_probe_inc);
	return (multi_return_u32_u32){.arg0=((u32)(index)), .arg1=((u32)(meta))};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL multi_return_u32_u32 map_meta_less(map* m, u32 _index, u32 _metas) {
	u32 index = _index;
	u32 meta = _metas;
	for (;;) {
		if (!(meta < m->metas[index])) break;
		index += 2U;
		meta += _const_probe_inc;
	}
	return (multi_return_u32_u32){.arg0=index, .arg1=meta};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void map_meta_greater(map* m, u32 _index, u32 _metas, u32 kvi) {
	u32 meta = _metas;
	u32 index = _index;
	u32 kv_index = kvi;
	for (;;) {
		if (!(m->metas[index] != 0U)) break;
		if (meta > m->metas[index]) {
			{ // Unsafe block
				u32 tmp_meta = m->metas[index];
				m->metas[index] = meta;
				meta = tmp_meta;
				u32 tmp_index = m->metas[(u32)(index + 1U)];
				m->metas[(u32)(index + 1U)] = kv_index;
				kv_index = tmp_index;
			}
		}
		index += 2U;
		meta += _const_probe_inc;
	}
	{ // Unsafe block
		m->metas[index] = meta;
		m->metas[(u32)(index + 1U)] = kv_index;
	}
	u32 probe_count = (u32)(((meta >> _const_hashbits)) - 1U);
	map_ensure_extra_metas(m, probe_count);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void map_ensure_extra_metas(map* m, u32 probe_count) {
	if (((probe_count << 1U)) == m->extra_metas) {
		u32 size_of_u32 = sizeof(u32);
		u32 old_mem_size = ((u32)((u32)(m->even_index + 2U) + m->extra_metas));
		m->extra_metas += _const_extra_metas_inc;
		u32 mem_size = ((u32)((u32)(m->even_index + 2U) + m->extra_metas));
		{ // Unsafe block
			u8* x = realloc_data(((u8*)(m->metas)), ((int)((u32)(size_of_u32 * old_mem_size))), ((int)((u32)(size_of_u32 * mem_size))));
			m->metas = ((u32*)(x));
			vmemset(m->metas + mem_size - _const_extra_metas_inc, 0, ((int)((u32)(sizeof(u32) * _const_extra_metas_inc))));
		}
		if (probe_count == 252U) {
			_v_panic(_SLIT("Probe overflow"));
			VUNREACHABLE();
		}
	}
}

VV_LOCAL_SYMBOL void map_set(map* m, voidptr key, voidptr value) {
	f32 load_factor = (f32)(((f32)((((u32)(m->len)) << 1U))) / ((f32)(m->even_index)));
	if (load_factor > ((f32)(_const_max_load_factor))) {
		map_expand(m);
	}
	multi_return_u32_u32 mr_11360 = map_key_to_index(m, key);
	u32 index = mr_11360.arg0;
	u32 meta = mr_11360.arg1;
	multi_return_u32_u32 mr_11396 = map_meta_less(m, index, meta);
	index = mr_11396.arg0;
	meta = mr_11396.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			{ // Unsafe block
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				vmemcpy(pval, value, m->value_bytes);
			}
			return;
		}
		index += 2U;
		meta += _const_probe_inc;
	}
	int kv_index = DenseArray_expand(&m->key_values);
	{ // Unsafe block
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		voidptr pvalue = DenseArray_value(&m->key_values, kv_index);
		m->clone_fn(pkey, key);
		vmemcpy(((u8*)(pvalue)), value, m->value_bytes);
	}
	map_meta_greater(m, index, meta, ((u32)(kv_index)));
	m->len++;
}

VV_LOCAL_SYMBOL void map_expand(map* m) {
	u32 old_cap = m->even_index;
	m->even_index = (u32)(((((u32)(m->even_index + 2U)) << 1U)) - 2U);
	if (m->cached_hashbits == 0) {
		m->shift += _const_max_cached_hashbits;
		m->cached_hashbits = _const_max_cached_hashbits;
		map_rehash(m);
	} else {
		map_cached_rehash(m, old_cap);
		m->cached_hashbits--;
	}
}

VV_LOCAL_SYMBOL void map_rehash(map* m) {
	u32 meta_bytes = (u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2U) + m->extra_metas)));
	map_reserve(m, meta_bytes);
}

void map_reserve(map* m, u32 meta_bytes) {
	{ // Unsafe block
		u8* x = v_realloc(((u8*)(m->metas)), ((int)(meta_bytes)));
		m->metas = ((u32*)(x));
		vmemset(m->metas, 0, ((int)(meta_bytes)));
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		voidptr pkey = DenseArray_key(&m->key_values, i);
		multi_return_u32_u32 mr_13170 = map_key_to_index(m, pkey);
		u32 index = mr_13170.arg0;
		u32 meta = mr_13170.arg1;
		multi_return_u32_u32 mr_13208 = map_meta_less(m, index, meta);
		index = mr_13208.arg0;
		meta = mr_13208.arg1;
		map_meta_greater(m, index, meta, ((u32)(i)));
	}
}

VV_LOCAL_SYMBOL void map_cached_rehash(map* m, u32 old_cap) {
	u32* old_metas = m->metas;
	int metasize = ((int)((u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2U) + m->extra_metas)))));
	m->metas = ((u32*)(vcalloc(metasize)));
	u32 old_extra_metas = m->extra_metas;
	for (u32 i = ((u32)(0U)); i <= (u32)(old_cap + old_extra_metas); i += 2U) {
		if (old_metas[i] == 0U) {
			continue;
		}
		u32 old_meta = old_metas[i];
		u32 old_probe_count = (((u32)(((old_meta >> _const_hashbits)) - 1U)) << 1U);
		u32 old_index = (((u32)(i - old_probe_count)) & ((m->even_index >> 1U)));
		u32 index = (((old_index | ((old_meta << m->shift)))) & m->even_index);
		u32 meta = (((old_meta & _const_hash_mask)) | _const_probe_inc);
		multi_return_u32_u32 mr_14007 = map_meta_less(m, index, meta);
		index = mr_14007.arg0;
		meta = mr_14007.arg1;
		u32 kv_index = old_metas[(u32)(i + 1U)];
		map_meta_greater(m, index, meta, kv_index);
	}
	_v_free(old_metas);
}

VV_LOCAL_SYMBOL voidptr map_get_and_set(map* m, voidptr key, voidptr zero) {
	for (;;) {
		multi_return_u32_u32 mr_14455 = map_key_to_index(m, key);
		u32 index = mr_14455.arg0;
		u32 meta = mr_14455.arg1;
		for (;;) {
			if (meta == m->metas[index]) {
				int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
				voidptr pkey = DenseArray_key(&m->key_values, kv_index);
				if (m->key_eq_fn(key, pkey)) {
					voidptr pval = DenseArray_value(&m->key_values, kv_index);
					return ((u8*)(pval));
				}
			}
			index += 2U;
			meta += _const_probe_inc;
			if (meta > m->metas[index]) {
				break;
			}
		}
		map_set(m, key, zero);
	}
	return ((void*)0);
}

VV_LOCAL_SYMBOL voidptr map_get(map* m, voidptr key, voidptr zero) {
	multi_return_u32_u32 mr_15182 = map_key_to_index(m, key);
	u32 index = mr_15182.arg0;
	u32 meta = mr_15182.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((u8*)(pval));
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return zero;
}

VV_LOCAL_SYMBOL voidptr map_get_check(map* m, voidptr key) {
	multi_return_u32_u32 mr_15847 = map_key_to_index(m, key);
	u32 index = mr_15847.arg0;
	u32 meta = mr_15847.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				voidptr pval = DenseArray_value(&m->key_values, kv_index);
				return ((u8*)(pval));
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return 0;
}

VV_LOCAL_SYMBOL bool map_exists(map* m, voidptr key) {
	multi_return_u32_u32 mr_16357 = map_key_to_index(m, key);
	u32 index = mr_16357.arg0;
	u32 meta = mr_16357.arg1;
	for (;;) {
		if (meta == m->metas[index]) {
			int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
			voidptr pkey = DenseArray_key(&m->key_values, kv_index);
			if (m->key_eq_fn(key, pkey)) {
				return true;
			}
		}
		index += 2U;
		meta += _const_probe_inc;
		if (meta > m->metas[index]) {
			break;
		}
	}
	return false;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL void DenseArray_delete(DenseArray* d, int i) {
	if (d->deletes == 0U) {
		d->all_deleted = vcalloc(d->cap);
	}
	d->deletes++;
	{ // Unsafe block
		d->all_deleted[i] = 1;
	}
}

// Attr: [unsafe]
void map_delete(map* m, voidptr key) {
	multi_return_u32_u32 mr_16995 = map_key_to_index(m, key);
	u32 index = mr_16995.arg0;
	u32 meta = mr_16995.arg1;
	multi_return_u32_u32 mr_17031 = map_meta_less(m, index, meta);
	index = mr_17031.arg0;
	meta = mr_17031.arg1;
	for (;;) {
		if (!(meta == m->metas[index])) break;
		int kv_index = ((int)(m->metas[(u32)(index + 1U)]));
		voidptr pkey = DenseArray_key(&m->key_values, kv_index);
		if (m->key_eq_fn(key, pkey)) {
			for (;;) {
				if (!(((m->metas[(u32)(index + 2U)] >> _const_hashbits)) > 1U)) break;
				{ // Unsafe block
					m->metas[index] = (u32)(m->metas[(u32)(index + 2U)] - _const_probe_inc);
					m->metas[(u32)(index + 1U)] = m->metas[(u32)(index + 3U)];
				}
				index += 2U;
			}
			m->len--;
			DenseArray_delete(&m->key_values, kv_index);
			{ // Unsafe block
				m->metas[index] = 0U;
				m->free_fn(pkey);
				vmemset(pkey, 0, m->key_bytes);
			}
			if (m->key_values.len <= 32) {
				return;
			}
			if (_us32_ge(m->key_values.deletes,((m->key_values.len >> 1)))) {
				DenseArray_zeros_to_end(&m->key_values);
				map_rehash(m);
			}
			return;
		}
		index += 2U;
		meta += _const_probe_inc;
	}
}

array map_keys(map* m) {
	array keys = __new_array(m->len, 0, m->key_bytes);
	u8* item = ((u8*)(keys.data));
	if (m->key_values.deletes == 0U) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->clone_fn(item, pkey);
				item = item + m->key_bytes;
			}
		}
		return keys;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pkey = DenseArray_key(&m->key_values, i);
			m->clone_fn(item, pkey);
			item = item + m->key_bytes;
		}
	}
	return keys;
}

array map_values(map* m) {
	array values = __new_array(m->len, 0, m->value_bytes);
	u8* item = ((u8*)(values.data));
	if (m->key_values.deletes == 0U) {
		vmemcpy(item, m->key_values.values, (int)(m->value_bytes * m->key_values.len));
		return values;
	}
	for (int i = 0; i < m->key_values.len; i++) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		{ // Unsafe block
			voidptr pvalue = DenseArray_value(&m->key_values, i);
			vmemcpy(item, pvalue, m->value_bytes);
			item = item + m->value_bytes;
		}
	}
	return values;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL DenseArray DenseArray_clone(DenseArray* d) {
	DenseArray res = ((DenseArray){
		.key_bytes = d->key_bytes,
		.value_bytes = d->value_bytes,
		.cap = d->cap,
		.len = d->len,
		.deletes = d->deletes,
		.all_deleted = ((void*)0),
		.keys = ((void*)0),
		.values = ((void*)0),
	});
	{ // Unsafe block
		if (d->deletes != 0U) {
			res.all_deleted = memdup(d->all_deleted, d->cap);
		}
		res.keys = memdup(d->keys, (int)(d->cap * d->key_bytes));
		res.values = memdup(d->values, (int)(d->cap * d->value_bytes));
	}
	return res;
}

// Attr: [unsafe]
map map_clone(map* m) {
	int metasize = ((int)((u32)(sizeof(u32) * ((u32)((u32)(m->even_index + 2U) + m->extra_metas)))));
	map res = ((map){
		.key_bytes = m->key_bytes,
		.value_bytes = m->value_bytes,
		.even_index = m->even_index,
		.cached_hashbits = m->cached_hashbits,
		.shift = m->shift,
		.key_values = DenseArray_clone(&m->key_values),
		.metas = ((u32*)(malloc_noscan(metasize))),
		.extra_metas = m->extra_metas,
		.has_string_keys = m->has_string_keys,
		.hash_fn = (voidptr)m->hash_fn,
		.key_eq_fn = (voidptr)m->key_eq_fn,
		.clone_fn = (voidptr)m->clone_fn,
		.free_fn = (voidptr)m->free_fn,
		.len = m->len,
	});
	vmemcpy(res.metas, m->metas, metasize);
	if (!m->has_string_keys) {
		return res;
	}
	for (int i = 0; i < m->key_values.len; ++i) {
		if (!DenseArray_has_index(&m->key_values, i)) {
			continue;
		}
		m->clone_fn(DenseArray_key(&res.key_values, i), DenseArray_key(&m->key_values, i));
	}
	return res;
}

// Attr: [unsafe]
void map_free(map* m) {
	_v_free(m->metas);
	{ // Unsafe block
		m->metas = ((void*)0);
	}
	if (m->key_values.deletes == 0U) {
		for (int i = 0; i < m->key_values.len; i++) {
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
				vmemset(pkey, 0, m->key_bytes);
			}
		}
	} else {
		for (int i = 0; i < m->key_values.len; i++) {
			if (!DenseArray_has_index(&m->key_values, i)) {
				continue;
			}
			{ // Unsafe block
				voidptr pkey = DenseArray_key(&m->key_values, i);
				m->free_fn(pkey);
				vmemset(pkey, 0, m->key_bytes);
			}
		}
	}
	{ // Unsafe block
		if (m->key_values.all_deleted != ((void*)0)) {
			_v_free(m->key_values.all_deleted);
			m->key_values.all_deleted = ((void*)0);
		}
		if (m->key_values.keys != ((void*)0)) {
			_v_free(m->key_values.keys);
			m->key_values.keys = ((void*)0);
		}
		if (m->key_values.values != ((void*)0)) {
			_v_free(m->key_values.values);
			m->key_values.values = ((void*)0);
		}
		m->hash_fn = (voidptr)((void*)0);
		m->key_eq_fn = (voidptr)((void*)0);
		m->clone_fn = (voidptr)((void*)0);
		m->free_fn = (voidptr)((void*)0);
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u8* __malloc_at_least_one(u64 how_many_bytes, bool noscan) {
	if (noscan) {
		return malloc_noscan(__at_least_one(how_many_bytes));
	}
	return _v_malloc(__at_least_one(how_many_bytes));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL DenseArray new_dense_array_noscan(int key_bytes, bool key_noscan, int value_bytes, bool value_noscan) {
	int cap = 8;
	return ((DenseArray){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.cap = cap,
		.len = 0,
		.deletes = 0U,
		.all_deleted = ((void*)0),
		.keys = __malloc_at_least_one((u64)(((u64)(cap)) * ((u64)(key_bytes))), key_noscan),
		.values = __malloc_at_least_one((u64)(((u64)(cap)) * ((u64)(value_bytes))), value_noscan),
	});
}

VV_LOCAL_SYMBOL map new_map_noscan_key(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array_noscan(key_bytes, true, value_bytes, false),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}

VV_LOCAL_SYMBOL map new_map_noscan_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array_noscan(key_bytes, false, value_bytes, true),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}

VV_LOCAL_SYMBOL map new_map_noscan_key_value(int key_bytes, int value_bytes, u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr )) {
	int metasize = ((int)((u32)(sizeof(u32) * ((int_literal)(_const_init_capicity + _const_extra_metas_inc)))));
	bool has_string_keys = _us32_lt(sizeof(voidptr),key_bytes);
	return ((map){
		.key_bytes = key_bytes,
		.value_bytes = value_bytes,
		.even_index = _const_init_even_index,
		.cached_hashbits = _const_max_cached_hashbits,
		.shift = _const_init_log_capicity,
		.key_values = new_dense_array_noscan(key_bytes, true, value_bytes, true),
		.metas = ((u32*)(vcalloc_noscan(metasize))),
		.extra_metas = _const_extra_metas_inc,
		.has_string_keys = has_string_keys,
		.hash_fn = (voidptr)hash_fn,
		.key_eq_fn = (voidptr)key_eq_fn,
		.clone_fn = (voidptr)clone_fn,
		.free_fn = (voidptr)free_fn,
		.len = 0,
	});
}

VV_LOCAL_SYMBOL map new_map_init_noscan_key(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map_noscan_key(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}

VV_LOCAL_SYMBOL map new_map_init_noscan_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map_noscan_value(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}

VV_LOCAL_SYMBOL map new_map_init_noscan_key_value(u64 (*hash_fn)(voidptr ), bool (*key_eq_fn)(voidptr , voidptr ), void (*clone_fn)(voidptr , voidptr ), void (*free_fn)(voidptr ), int n, int key_bytes, int value_bytes, voidptr keys, voidptr values) {
	map out = new_map_noscan_key_value(key_bytes, value_bytes, (voidptr)hash_fn, (voidptr)key_eq_fn, (voidptr)clone_fn, (voidptr)free_fn);
	u8* pkey = ((u8*)(keys));
	u8* pval = ((u8*)(values));
	for (int _t1 = 0; _t1 < n; ++_t1) {
		{ // Unsafe block
			map_set(&out, pkey, pval);
			pkey = pkey + key_bytes;
			pval = pval + value_bytes;
		}
	}
	return out;
}

// Attr: [unsafe]
void IError_free(IError* ie) {
	{ // Unsafe block
		IError* cie = ((IError*)(ie));
		_v_free(cie->_object);
	}
}

// Attr: [markused]
VV_LOCAL_SYMBOL void _option_none(voidptr data, _option* option, int size) {
	{ // Unsafe block
		*option = ((_option){.state = 2,.err = _const_none__,});
		vmemcpy(((u8*)(&option->err)) + sizeof(IError), data, size);
	}
}

// Attr: [markused]
VV_LOCAL_SYMBOL void _option_ok(voidptr data, _option* option, int size) {
	{ // Unsafe block
		*option = ((_option){.state = 0,.err = _const_none__,});
		vmemcpy(((u8*)(&option->err)) + sizeof(IError), data, size);
	}
}

VV_LOCAL_SYMBOL string None___str(None__ _d1) {
	return _SLIT("none");
}

string none_str(none _d2) {
	return _SLIT("none");
}

// Attr: [markused]
VV_LOCAL_SYMBOL void _result_ok(voidptr data, _result* res, int size) {
	{ // Unsafe block
		*res = ((_result){.is_error = 0,.err = _const_none__,});
		vmemcpy(((u8*)(&res->err)) + sizeof(IError), data, size);
	}
}

string IError_str(IError err) {
	return ((err._typ == _IError_None___index)? (_SLIT("none")) : (err._typ == _IError_Error_index)? (Error_msg(/*rec*/*(err._Error))) : (err._typ == _IError_MessageError_index)? (MessageError_msg(/*rec*/*(err._MessageError))) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* IError */ v_typeof_interface_IError( (err)._typ ))}}, {_SLIT(": "), /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}}))));
}

string Error_msg(Error err) {
	return _SLIT("");
}

int Error_code(Error err) {
	return 0;
}

string MessageError_msg(MessageError err) {
	if (err.code > 0) {
		return  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = err.msg}}, {_SLIT("; code: "), /*100 &int*/0xfe07, {.d_i32 = err.code}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	return err.msg;
}

int MessageError_code(MessageError err) {
	return err.code;
}

// Attr: [unsafe]
void MessageError_free(MessageError* err) {
	string_free(&err->msg);
}

// Attr: [inline]
inline IError _v_error(string message) {
	;
	return /*&IError*/I_MessageError_to_Interface_IError(((MessageError*)memdup(&(MessageError){.msg = message,.code = 0,}, sizeof(MessageError))));
}

// Attr: [inline]
inline IError error_with_code(string message, int code) {
	;
	return /*&IError*/I_MessageError_to_Interface_IError(((MessageError*)memdup(&(MessageError){.msg = message,.code = code,}, sizeof(MessageError))));
}

string rune_str(rune c) {
	return utf32_to_str(((u32)(c)));
}

// Attr: [manualfree]
string Array_rune_string(Array_rune ra) {
	strings__Builder sb = strings__new_builder(ra.len);
	strings__Builder_write_runes(&sb, ra);
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

string rune_repeat(rune c, int count) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("rune.repeat: count is negative: "), /*100 &int*/0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return rune_str(c);
	}
	Array_fixed_u8_5 buffer = {0, 0, 0, 0, 0};
	string res = utf32_to_str_no_malloc(((u32)(c)), &buffer[0]);
	return string_repeat(res, count);
}

// Attr: [manualfree]
Array_u8 rune_bytes(rune c) {
	Array_u8 res = __new_array_with_default_noscan(0, 5, sizeof(u8), 0);
	res.len = utf32_decode_to_buffer(((u32)(c)), ((u8*)(res.data)));
	return res;
}

int rune_length_in_bytes(rune c) {
	u32 code = ((u32)(c));
	if (code <= 0x7FU) {
		return 1;
	} else if (code <= 0x7FFU) {
		return 2;
	} else if (0xD800 <= code && code <= 0xDFFFU) {
		return -1;
	} else if (code <= 0xFFFFU) {
		return 3;
	} else if (code <= 0x10FFFFU) {
		return 4;
	}
	return -1;
}

VV_LOCAL_SYMBOL SortedMap new_sorted_map(int n, int value_bytes) {
	return ((SortedMap){.value_bytes = value_bytes,.root = new_node(),.len = 0,});
}

VV_LOCAL_SYMBOL SortedMap new_sorted_map_init(int n, int value_bytes, string* keys, voidptr values) {
	SortedMap out = new_sorted_map(n, value_bytes);
	for (int i = 0; i < n; ++i) {
		SortedMap_set(&out, keys[i], ((u8*)(values)) + (int)(i * value_bytes));
	}
	return out;
}

VV_LOCAL_SYMBOL mapnode* new_node(void) {
	return ((mapnode*)memdup(&(mapnode){.children = ((void*)0),.len = 0,.keys = {(string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}, (string){.str=(byteptr)"", .is_lit=1}},.values = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},}, sizeof(mapnode)));
}

VV_LOCAL_SYMBOL void SortedMap_set(SortedMap* m, string key, voidptr value) {
	mapnode* node = m->root;
	int child_index = 0;
	mapnode* parent = ((mapnode*)(((void*)0)));
	for (;;) {
		if (node->len == _const_max_len) {
			if (parent == ((void*)0)) {
				parent = new_node();
				m->root = parent;
			}
			mapnode_split_child(parent, child_index, node);
			if (string__eq(key, parent->keys[v_fixed_index(child_index, 11)])) {
				vmemcpy(parent->values[v_fixed_index(child_index, 11)], value, m->value_bytes);
				return;
			}
			if (string__lt(key, parent->keys[v_fixed_index(child_index, 11)])) {
				node = ((mapnode*)(parent->children[child_index]));
			} else {
				node = ((mapnode*)(parent->children[(int)(child_index + 1)]));
			}
		}
		int i = 0;
		for (;;) {
			if (!(i < node->len && string__lt(node->keys[v_fixed_index(i, 11)], key))) break;
			i++;
		}
		if (i != node->len && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			vmemcpy(node->values[v_fixed_index(i, 11)], value, m->value_bytes);
			return;
		}
		if (node->children == ((void*)0)) {
			int j = (int)(node->len - 1);
			for (;;) {
				if (!(j >= 0 && string__lt(key, node->keys[v_fixed_index(j, 11)]))) break;
				node->keys[v_fixed_index((int)(j + 1), 11)] = node->keys[v_fixed_index(j, 11)];
				node->values[v_fixed_index((int)(j + 1), 11)] = node->values[v_fixed_index(j, 11)];
				j--;
			}
			node->keys[v_fixed_index((int)(j + 1), 11)] = key;
			{ // Unsafe block
				node->values[v_fixed_index((int)(j + 1), 11)] = _v_malloc(m->value_bytes);
				vmemcpy(node->values[v_fixed_index((int)(j + 1), 11)], value, m->value_bytes);
			}
			node->len++;
			m->len++;
			return;
		}
		parent = node;
		child_index = i;
		node = ((mapnode*)(node->children[child_index]));
	}
}

VV_LOCAL_SYMBOL void mapnode_split_child(mapnode* n, int child_index, mapnode* y) {
	mapnode* z = new_node();
	z->len = _const_mid_index;
	y->len = _const_mid_index;
	for (int j = (int_literal)(_const_mid_index - 1); j >= 0; j--) {
		z->keys[v_fixed_index(j, 11)] = y->keys[v_fixed_index((int)(j + _const_degree), 11)];
		z->values[v_fixed_index(j, 11)] = y->values[v_fixed_index((int)(j + _const_degree), 11)];
	}
	if (y->children != ((void*)0)) {
		z->children = ((voidptr*)(_v_malloc(((int)(_const_children_bytes)))));
		for (int jj = (int_literal)(_const_degree - 1); jj >= 0; jj--) {
			{ // Unsafe block
				z->children[jj] = y->children[(int)(jj + _const_degree)];
			}
		}
	}
	{ // Unsafe block
		if (n->children == ((void*)0)) {
			n->children = ((voidptr*)(_v_malloc(((int)(_const_children_bytes)))));
		}
		n->children[(int)(n->len + 1)] = n->children[n->len];
	}
	for (int j = n->len; j > child_index; j--) {
		n->keys[v_fixed_index(j, 11)] = n->keys[v_fixed_index((int)(j - 1), 11)];
		n->values[v_fixed_index(j, 11)] = n->values[v_fixed_index((int)(j - 1), 11)];
		{ // Unsafe block
			n->children[j] = n->children[(int)(j - 1)];
		}
	}
	n->keys[v_fixed_index(child_index, 11)] = y->keys[v_fixed_index(_const_mid_index, 11)];
	n->values[v_fixed_index(child_index, 11)] = y->values[v_fixed_index(_const_mid_index, 11)];
	{ // Unsafe block
		n->children[child_index] = ((voidptr)(y));
		n->children[(int)(child_index + 1)] = ((voidptr)(z));
	}
	n->len++;
}

VV_LOCAL_SYMBOL bool SortedMap_get(SortedMap m, string key, voidptr out) {
	mapnode* node = m.root;
	for (;;) {
		int i = (int)(node->len - 1);
		for (;;) {
			if (!(i >= 0 && string__lt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i--;
		}
		if (i != -1 && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			vmemcpy(out, node->values[v_fixed_index(i, 11)], m.value_bytes);
			return true;
		}
		if (node->children == ((void*)0)) {
			break;
		}
		node = ((mapnode*)(node->children[(int)(i + 1)]));
	}
	return false;
}

VV_LOCAL_SYMBOL bool SortedMap_exists(SortedMap m, string key) {
	if (m.root == ((void*)0)) {
		return false;
	}
	mapnode* node = m.root;
	for (;;) {
		int i = (int)(node->len - 1);
		for (;;) {
			if (!(i >= 0 && string__lt(key, node->keys[v_fixed_index(i, 11)]))) break;
			i--;
		}
		if (i != -1 && string__eq(key, node->keys[v_fixed_index(i, 11)])) {
			return true;
		}
		if (node->children == ((void*)0)) {
			break;
		}
		node = ((mapnode*)(node->children[(int)(i + 1)]));
	}
	return false;
}

VV_LOCAL_SYMBOL int mapnode_find_key(mapnode* n, string k) {
	int idx = 0;
	for (;;) {
		if (!(idx < n->len && string__lt(n->keys[v_fixed_index(idx, 11)], k))) break;
		idx++;
	}
	return idx;
}

VV_LOCAL_SYMBOL bool mapnode_remove_key(mapnode* n, string k) {
	int idx = mapnode_find_key(n, k);
	if (idx < n->len && string__eq(n->keys[v_fixed_index(idx, 11)], k)) {
		if (n->children == ((void*)0)) {
			mapnode_remove_from_leaf(n, idx);
		} else {
			mapnode_remove_from_non_leaf(n, idx);
		}
		return true;
	} else {
		if (n->children == ((void*)0)) {
			return false;
		}
		bool flag = (idx == n->len ? (true) : (false));
		if (((mapnode*)(n->children[idx]))->len < _const_degree) {
			mapnode_fill(n, idx);
		}
		mapnode* node = ((mapnode*)(((void*)0)));
		if (flag && idx > n->len) {
			node = ((mapnode*)(n->children[(int)(idx - 1)]));
		} else {
			node = ((mapnode*)(n->children[idx]));
		}
		return mapnode_remove_key(node, k);
	}
	return 0;
}

VV_LOCAL_SYMBOL void mapnode_remove_from_leaf(mapnode* n, int idx) {
	for (int i = (int)(idx + 1); i < n->len; i++) {
		n->keys[v_fixed_index((int)(i - 1), 11)] = n->keys[v_fixed_index(i, 11)];
		n->values[v_fixed_index((int)(i - 1), 11)] = n->values[v_fixed_index(i, 11)];
	}
	n->len--;
}

VV_LOCAL_SYMBOL void mapnode_remove_from_non_leaf(mapnode* n, int idx) {
	string k = n->keys[v_fixed_index(idx, 11)];
	if (((mapnode*)(n->children[idx]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[idx]));
		for (;;) {
			if (!(current->children != ((void*)0))) break;
			current = ((mapnode*)(current->children[current->len]));
		}
		string predecessor = current->keys[v_fixed_index((int)(current->len - 1), 11)];
		n->keys[v_fixed_index(idx, 11)] = predecessor;
		n->values[v_fixed_index(idx, 11)] = current->values[v_fixed_index((int)(current->len - 1), 11)];
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, predecessor);
	} else if (((mapnode*)(n->children[(int)(idx + 1)]))->len >= _const_degree) {
		mapnode* current = ((mapnode*)(n->children[(int)(idx + 1)]));
		for (;;) {
			if (!(current->children != ((void*)0))) break;
			current = ((mapnode*)(current->children[0]));
		}
		string successor = current->keys[0];
		n->keys[v_fixed_index(idx, 11)] = successor;
		n->values[v_fixed_index(idx, 11)] = current->values[0];
		mapnode* node = ((mapnode*)(n->children[(int)(idx + 1)]));
		mapnode_remove_key(node, successor);
	} else {
		mapnode_merge(n, idx);
		mapnode* node = ((mapnode*)(n->children[idx]));
		mapnode_remove_key(node, k);
	}
}

VV_LOCAL_SYMBOL void mapnode_fill(mapnode* n, int idx) {
	if (idx != 0 && ((mapnode*)(n->children[(int)(idx - 1)]))->len >= _const_degree) {
		mapnode_borrow_from_prev(n, idx);
	} else if (idx != n->len && ((mapnode*)(n->children[(int)(idx + 1)]))->len >= _const_degree) {
		mapnode_borrow_from_next(n, idx);
	} else if (idx != n->len) {
		mapnode_merge(n, idx);
	} else {
		mapnode_merge(n, (int)(idx - 1));
	}
}

VV_LOCAL_SYMBOL void mapnode_borrow_from_prev(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[(int)(idx - 1)]));
	for (int i = (int)(child->len - 1); i >= 0; i--) {
		child->keys[v_fixed_index((int)(i + 1), 11)] = child->keys[v_fixed_index(i, 11)];
		child->values[v_fixed_index((int)(i + 1), 11)] = child->values[v_fixed_index(i, 11)];
	}
	if (child->children != ((void*)0)) {
		for (int i = child->len; i >= 0; i--) {
			{ // Unsafe block
				child->children[(int)(i + 1)] = child->children[i];
			}
		}
	}
	child->keys[0] = n->keys[v_fixed_index((int)(idx - 1), 11)];
	child->values[0] = n->values[v_fixed_index((int)(idx - 1), 11)];
	if (child->children != ((void*)0)) {
		{ // Unsafe block
			child->children[0] = sibling->children[sibling->len];
		}
	}
	n->keys[v_fixed_index((int)(idx - 1), 11)] = sibling->keys[v_fixed_index((int)(sibling->len - 1), 11)];
	n->values[v_fixed_index((int)(idx - 1), 11)] = sibling->values[v_fixed_index((int)(sibling->len - 1), 11)];
	child->len++;
	sibling->len--;
}

VV_LOCAL_SYMBOL void mapnode_borrow_from_next(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[(int)(idx + 1)]));
	child->keys[v_fixed_index(child->len, 11)] = n->keys[v_fixed_index(idx, 11)];
	child->values[v_fixed_index(child->len, 11)] = n->values[v_fixed_index(idx, 11)];
	if (child->children != ((void*)0)) {
		{ // Unsafe block
			child->children[(int)(child->len + 1)] = sibling->children[0];
		}
	}
	n->keys[v_fixed_index(idx, 11)] = sibling->keys[0];
	n->values[v_fixed_index(idx, 11)] = sibling->values[0];
	for (int i = 1; i < sibling->len; i++) {
		sibling->keys[v_fixed_index((int)(i - 1), 11)] = sibling->keys[v_fixed_index(i, 11)];
		sibling->values[v_fixed_index((int)(i - 1), 11)] = sibling->values[v_fixed_index(i, 11)];
	}
	if (sibling->children != ((void*)0)) {
		for (int i = 1; i <= sibling->len; i++) {
			{ // Unsafe block
				sibling->children[(int)(i - 1)] = sibling->children[i];
			}
		}
	}
	child->len++;
	sibling->len--;
}

VV_LOCAL_SYMBOL void mapnode_merge(mapnode* n, int idx) {
	mapnode* child = ((mapnode*)(n->children[idx]));
	mapnode* sibling = ((mapnode*)(n->children[(int)(idx + 1)]));
	child->keys[v_fixed_index(_const_mid_index, 11)] = n->keys[v_fixed_index(idx, 11)];
	child->values[v_fixed_index(_const_mid_index, 11)] = n->values[v_fixed_index(idx, 11)];
	for (int i = 0; i < sibling->len; ++i) {
		child->keys[v_fixed_index((int_literal)(i + _const_degree), 11)] = sibling->keys[v_fixed_index(i, 11)];
		child->values[v_fixed_index((int_literal)(i + _const_degree), 11)] = sibling->values[v_fixed_index(i, 11)];
	}
	if (child->children != ((void*)0)) {
		for (int i = 0; i <= sibling->len; i++) {
			{ // Unsafe block
				child->children[(int)(i + _const_degree)] = sibling->children[i];
			}
		}
	}
	for (int i = (int)(idx + 1); i < n->len; i++) {
		n->keys[v_fixed_index((int)(i - 1), 11)] = n->keys[v_fixed_index(i, 11)];
		n->values[v_fixed_index((int)(i - 1), 11)] = n->values[v_fixed_index(i, 11)];
	}
	for (int i = (int)(idx + 2); i <= n->len; i++) {
		{ // Unsafe block
			n->children[(int)(i - 1)] = n->children[i];
		}
	}
	child->len += (int)(sibling->len + 1);
	n->len--;
}

void SortedMap_delete(SortedMap* m, string key) {
	if (m->root->len == 0) {
		return;
	}
	bool removed = mapnode_remove_key(m->root, key);
	if (removed) {
		m->len--;
	}
	if (m->root->len == 0) {
		if (m->root->children == ((void*)0)) {
			return;
		} else {
			m->root = ((mapnode*)(m->root->children[0]));
		}
	}
}

VV_LOCAL_SYMBOL int mapnode_subkeys(mapnode* n, Array_string* keys, int at) {
	int position = at;
	if (n->children != ((void*)0)) {
		for (int i = 0; i < n->len; ++i) {
			mapnode* child = ((mapnode*)(n->children[i]));
			position += mapnode_subkeys(child, keys, position);
			array_set(keys, position, &(string[]) { n->keys[v_fixed_index(i, 11)] });
			position++;
		}
		mapnode* child = ((mapnode*)(n->children[n->len]));
		position += mapnode_subkeys(child, keys, position);
	} else {
		for (int i = 0; i < n->len; ++i) {
			array_set(keys, (int)(position + i), &(string[]) { n->keys[v_fixed_index(i, 11)] });
		}
		position += n->len;
	}
	return (int)(position - at);
}

Array_string SortedMap_keys(SortedMap* m) {
	Array_string keys = __new_array_with_default(m->len, 0, sizeof(string), &(string[]){_SLIT("")});
	if (m->root == ((void*)0) || m->root->len == 0) {
		return keys;
	}
	mapnode_subkeys(m->root, &/*arr*/keys, 0);
	return keys;
}

VV_LOCAL_SYMBOL void mapnode_free(mapnode* n) {
	println(_SLIT("TODO"));
}

void SortedMap_free(SortedMap* m) {
	if (m->root == ((void*)0)) {
		return;
	}
	mapnode_free(m->root);
}

void SortedMap_print(SortedMap m) {
	println(_SLIT("TODO"));
}

// Attr: [direct_array_access]
Array_rune string_runes(string s) {
	Array_rune runes = __new_array_with_default_noscan(0, s.len, sizeof(rune), 0);
	for (int i = 0; i < s.len; i++) {
		int char_len = utf8_char_len(s.str[i]);
		if (char_len > 1) {
			int end = ((int)(s.len - 1) >= (int)(i + char_len) ? ((int)(i + char_len)) : (s.len));
			string r = string_substr(s, i, end);
			array_push_noscan((array*)&runes, _MOV((rune[]){ string_utf32_code(r) }));
			i += (int)(char_len - 1);
		} else {
			array_push_noscan((array*)&runes, _MOV((rune[]){ s.str[i] }));
		}
	}
	return runes;
}

// Attr: [unsafe]
string cstring_to_vstring(char* s) {
	return string_clone(tos2(((u8*)(s))));
}

// Attr: [unsafe]
string tos_clone(u8* s) {
	return string_clone(tos2(s));
}

// Attr: [unsafe]
string tos(u8* s, int len) {
	if (s == 0) {
		_v_panic(_SLIT("tos(): nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = len});
}

// Attr: [unsafe]
string tos2(u8* s) {
	if (s == 0) {
		_v_panic(_SLIT("tos2: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = s, .len = vstrlen(s)});
}

// Attr: [unsafe]
string tos3(char* s) {
	if (s == 0) {
		_v_panic(_SLIT("tos3: nil string"));
		VUNREACHABLE();
	}
	return ((string){.str = ((u8*)(s)), .len = vstrlen_char(s)});
}

// Attr: [unsafe]
string tos4(u8* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return ((string){.str = s, .len = vstrlen(s)});
}

// Attr: [unsafe]
string tos5(char* s) {
	if (s == 0) {
		return _SLIT("");
	}
	return ((string){.str = ((u8*)(s)), .len = vstrlen_char(s)});
}

// Attr: [unsafe]
string u8_vstring(u8* bp) {
	return ((string){.str = bp, .len = vstrlen(bp)});
}

// Attr: [unsafe]
string u8_vstring_with_len(u8* bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 0});
}

// Attr: [unsafe]
string char_vstring(char* cp) {
	return ((string){.str = ((u8*)(cp)), .len = vstrlen_char(cp), .is_lit = 0});
}

// Attr: [unsafe]
string char_vstring_with_len(char* cp, int len) {
	return ((string){.str = ((u8*)(cp)), .len = len, .is_lit = 0});
}

// Attr: [unsafe]
string u8_vstring_literal(u8* bp) {
	return ((string){.str = bp, .len = vstrlen(bp), .is_lit = 1});
}

// Attr: [unsafe]
string u8_vstring_literal_with_len(u8* bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 1});
}

// Attr: [unsafe]
string char_vstring_literal(char* cp) {
	return ((string){.str = ((u8*)(cp)), .len = vstrlen_char(cp), .is_lit = 1});
}

// Attr: [unsafe]
string char_vstring_literal_with_len(char* cp, int len) {
	return ((string){.str = ((u8*)(cp)), .len = len, .is_lit = 1});
}

int string_len_utf8(string s) {
	int l = 0;
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		l++;
		i += (int_literal)(((((0xe5000000 >> ((((s.str[i] >> 3)) & 0x1e)))) & 3)) + 1);
	}
	return l;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL string string_clone_static(string a) {
	return string_clone(a);
}

string string_clone(string a) {
	if (a.len == 0) {
		return _SLIT("");
	}
	string b = ((string){.str = malloc_noscan((int)(a.len + 1)), .len = a.len});
	{ // Unsafe block
		vmemcpy(b.str, a.str, a.len);
		b.str[a.len] = 0;
	}
	return b;
}

string string_replace_once(string s, string rep, string with) {
	int idx = string_index_(s, rep);
	if (idx == -1) {
		return string_clone(s);
	}
	return string__plus(string__plus(string_substr(s, 0, idx), with), string_substr(s, (int)(idx + rep.len), s.len));
}

// Attr: [direct_array_access]
string string_replace(string s, string rep, string with) {
	bool string_replace_defer_0 = false;
	Array_int idxs;
	if (s.len == 0 || rep.len == 0 || rep.len > s.len) {
		return string_clone(s);
	}
	if (!string_contains(s, rep)) {
		return string_clone(s);
	}
	idxs = __new_array_with_default_noscan(0, (int)(s.len / rep.len), sizeof(int), 0);
	string_replace_defer_0 = true;
	int idx = 0;
	for (;;) {
		idx = string_index_after(s, rep, idx);
		if (idx == -1) {
			break;
		}
		array_push_noscan((array*)&idxs, _MOV((int[]){ idx }));
		idx += rep.len;
	}
	if (idxs.len == 0) {
		string _t4 = string_clone(s);
			// Defer begin
			if (string_replace_defer_0) {
				array_free(&idxs);
			}
			// Defer end
		return _t4;
	}
	int new_len = (int)(s.len + (int)(idxs.len * ((int)(with.len - rep.len))));
	u8* b = malloc_noscan((int)(new_len + 1));
	int b_i = 0;
	int s_idx = 0;
	for (int _t5 = 0; _t5 < idxs.len; ++_t5) {
		int rep_pos = ((int*)idxs.data)[_t5];
		for (int i = s_idx; i < rep_pos; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
		s_idx = (int)(rep_pos + rep.len);
		for (int i = 0; i < with.len; ++i) {
			{ // Unsafe block
				b[b_i] = with.str[ i];
			}
			b_i++;
		}
	}
	if (s_idx < s.len) {
		for (int i = s_idx; i < s.len; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		string _t6 = tos(b, new_len);
			// Defer begin
			if (string_replace_defer_0) {
				array_free(&idxs);
			}
			// Defer end
		return _t6;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
string string_replace_each(string s, Array_string vals) {
	if (s.len == 0 || vals.len == 0) {
		return string_clone(s);
	}
	if ((int)(vals.len % 2) != 0) {
		eprintln(_SLIT("string.replace_each(): odd number of strings"));
		return string_clone(s);
	}
	int new_len = s.len;
	Array_RepIndex idxs = __new_array_with_default_noscan(0, 6, sizeof(RepIndex), 0);
	int idx = 0;
	string s_ = string_clone(s);
	for (int rep_i = 0; rep_i < vals.len; rep_i += 2) {
		string rep = ((string*)vals.data)[rep_i];
		string with = ((string*)vals.data)[(int)(rep_i + 1)];
		for (;;) {
			idx = string_index_after(s_, rep, idx);
			if (idx == -1) {
				break;
			}
			for (int i = 0; i < rep.len; ++i) {
				{ // Unsafe block
					s_.str[(int)(idx + i)] = 127;
				}
			}
			array_push_noscan((array*)&idxs, _MOV((RepIndex[]){ ((RepIndex){.idx = idx,.val_idx = rep_i,}) }));
			idx += rep.len;
			new_len += (int)(with.len - rep.len);
		}
	}
	if (idxs.len == 0) {
		return string_clone(s);
	}
	qsort(idxs.data, idxs.len, idxs.element_size, (int (*)(const void *, const void *))&compare_15661873927483343839_RepIndex_by_idx);
	u8* b = malloc_noscan((int)(new_len + 1));
	int idx_pos = 0;
	RepIndex cur_idx = ((RepIndex*)idxs.data)[idx_pos];
	int b_i = 0;
	for (int i = 0; i < s.len; i++) {
		if (i == cur_idx.idx) {
			string rep = ((string*)vals.data)[cur_idx.val_idx];
			string with = ((string*)vals.data)[(int)(cur_idx.val_idx + 1)];
			for (int j = 0; j < with.len; ++j) {
				{ // Unsafe block
					b[b_i] = with.str[ j];
				}
				b_i++;
			}
			i += (int)(rep.len - 1);
			idx_pos++;
			if (idx_pos < idxs.len) {
				cur_idx = ((RepIndex*)idxs.data)[idx_pos];
			}
		} else {
			{ // Unsafe block
				b[b_i] = s.str[i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		return tos(b, new_len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
string string_replace_char(string s, u8 rep, u8 with, int repeat) {
	bool string_replace_char_defer_0 = false;
	Array_int idxs;
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (repeat <= 0) {
			_v_panic(_SLIT("string.replace_char(): tab length too short"));
			VUNREACHABLE();
		}
	}
	#endif
	if (s.len == 0) {
		return string_clone(s);
	}
	idxs = __new_array_with_default_noscan(0, s.len, sizeof(int), 0);
	string_replace_char_defer_0 = true;
	for (int i = 0; i < s.len; ++i) {
		u8 ch = s.str[i];
		if (ch == rep) {
			array_push_noscan((array*)&idxs, _MOV((int[]){ i }));
		}
	}
	if (idxs.len == 0) {
		string _t4 = string_clone(s);
			// Defer begin
			if (string_replace_char_defer_0) {
				array_free(&idxs);
			}
			// Defer end
		return _t4;
	}
	int new_len = (int)(s.len + (int)(idxs.len * ((int)(repeat - 1))));
	u8* b = malloc_noscan((int)(new_len + 1));
	int b_i = 0;
	int s_idx = 0;
	for (int _t5 = 0; _t5 < idxs.len; ++_t5) {
		int rep_pos = ((int*)idxs.data)[_t5];
		for (int i = s_idx; i < rep_pos; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
		s_idx = (int)(rep_pos + 1);
		for (int _t6 = 0; _t6 < repeat; ++_t6) {
			{ // Unsafe block
				b[b_i] = with;
			}
			b_i++;
		}
	}
	if (s_idx < s.len) {
		for (int i = s_idx; i < s.len; ++i) {
			{ // Unsafe block
				b[b_i] = s.str[ i];
			}
			b_i++;
		}
	}
	{ // Unsafe block
		b[new_len] = 0;
		string _t7 = tos(b, new_len);
			// Defer begin
			if (string_replace_char_defer_0) {
				array_free(&idxs);
			}
			// Defer end
		return _t7;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [inline]
inline string string_normalize_tabs(string s, int tab_len) {
	return string_replace_char(s, '\t', ' ', tab_len);
}

// Attr: [inline]
inline bool string_bool(string s) {
	return string__eq(s, _SLIT("true")) || string__eq(s, _SLIT("t"));
}

// Attr: [inline]
inline int string_int(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 32, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((int)( (*(i64*)_t2.data)));
}

// Attr: [inline]
inline i64 string_i64(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 64, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return  (*(i64*)_t2.data);
}

// Attr: [inline]
inline i8 string_i8(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 8, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((i8)( (*(i64*)_t2.data)));
}

// Attr: [inline]
inline i16 string_i16(string s) {
	_result_i64 _t2 = strconv__common_parse_int(s, 0, 16, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(i64*) _t2.data = 0;
	}
	
 	return ((i16)( (*(i64*)_t2.data)));
}

// Attr: [inline]
inline f32 string_f32(string s) {
	_result_f64 _t2 = strconv__atof64(s);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(f64*) _t2.data = 0;
	}
	
 	return ((f32)( (*(f64*)_t2.data)));
}

// Attr: [inline]
inline f64 string_f64(string s) {
	_result_f64 _t2 = strconv__atof64(s);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(f64*) _t2.data = 0;
	}
	
 	return  (*(f64*)_t2.data);
}

// Attr: [inline]
inline u8 string_u8(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 8, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u8)( (*(u64*)_t2.data)));
}

// Attr: [inline]
inline u16 string_u16(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 16, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u16)( (*(u64*)_t2.data)));
}

// Attr: [inline]
inline u32 string_u32(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 32, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return ((u32)( (*(u64*)_t2.data)));
}

// Attr: [inline]
inline u64 string_u64(string s) {
	_result_u64 _t2 = strconv__common_parse_uint(s, 0, 64, false, false);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(u64*) _t2.data = 0U;
	}
	
 	return  (*(u64*)_t2.data);
}

// Attr: [inline]
inline _result_u64 string_parse_uint(string s, int _base, int _bit_size) {
	_result_u64 _t1 = strconv__parse_uint(s, _base, _bit_size);
	return _t1;
}

// Attr: [inline]
inline _result_i64 string_parse_int(string s, int _base, int _bit_size) {
	_result_i64 _t1 = strconv__parse_int(s, _base, _bit_size);
	return _t1;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL bool string__eq(string s, string a) {
	if (s.str == 0) {
		_v_panic(_SLIT("string.eq(): nil string"));
		VUNREACHABLE();
	}
	if (s.len != a.len) {
		return false;
	}
	if (s.len > 0) {
		int last_idx = (int)(s.len - 1);
		if (s.str[ last_idx] != a.str[ last_idx]) {
			return false;
		}
	}
	{ // Unsafe block
		return vmemcmp(s.str, a.str, a.len) == 0;
	}
	return 0;
}

// Attr: [direct_array_access]
int string_compare(string s, string a) {
	int min_len = (s.len < a.len ? (s.len) : (a.len));
	for (int i = 0; i < min_len; ++i) {
		if (s.str[ i] < a.str[ i]) {
			return -1;
		}
		if (s.str[ i] > a.str[ i]) {
			return 1;
		}
	}
	if (s.len < a.len) {
		return -1;
	}
	if (s.len > a.len) {
		return 1;
	}
	return 0;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL bool string__lt(string s, string a) {
	for (int i = 0; i < s.len; ++i) {
		if (i >= a.len || s.str[ i] > a.str[ i]) {
			return false;
		} else if (s.str[ i] < a.str[ i]) {
			return true;
		}
	}
	if (s.len < a.len) {
		return true;
	}
	return false;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL string string__plus(string s, string a) {
	int new_len = (int)(a.len + s.len);
	string res = ((string){.str = malloc_noscan((int)(new_len + 1)), .len = new_len});
	{ // Unsafe block
		vmemcpy(res.str, s.str, s.len);
		vmemcpy(res.str + s.len, a.str, a.len);
	}
	{ // Unsafe block
		res.str[new_len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
Array_string string_split_any(string s, string delim) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = 0;
	if (s.len > 0) {
		if (delim.len <= 0) {
			return string_split(s, _SLIT(""));
		}
		for (int index = 0; index < s.len; ++index) {
			u8 ch = s.str[index];
			for (int _t2 = 0; _t2 < delim.len; ++_t2) {
				u8 delim_ch = delim.str[_t2];
				if (ch == delim_ch) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, i, index) }));
					i = (int)(index + 1);
					break;
				}
			}
		}
		if (i < s.len) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, i, 2147483647) }));
		}
	}
	return res;
}

// Attr: [direct_array_access]
Array_string string_rsplit_any(string s, string delim) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = (int)(s.len - 1);
	if (s.len > 0) {
		if (delim.len <= 0) {
			return string_rsplit(s, _SLIT(""));
		}
		int rbound = s.len;
		for (;;) {
			if (!(i >= 0)) break;
			for (int _t2 = 0; _t2 < delim.len; ++_t2) {
				u8 delim_ch = delim.str[_t2];
				if (s.str[ i] == delim_ch) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, (int)(i + 1), rbound) }));
					rbound = i;
					break;
				}
			}
			i--;
		}
		if (rbound > 0) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, 0, rbound) }));
		}
	}
	return res;
}

// Attr: [inline]
inline Array_string string_split(string s, string delim) {
	return string_split_nth(s, delim, 0);
}

// Attr: [inline]
inline Array_string string_rsplit(string s, string delim) {
	return string_rsplit_nth(s, delim, 0);
}

_option_multi_return_string_string string_split_once(string s, string delim) {
	Array_string result = string_split_nth(s, delim, 2);
	if (result.len != 2) {
		_option_multi_return_string_string _t1 = (_option_multi_return_string_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		return _t1;
	}
	_option_multi_return_string_string _t2;
	_option_ok(&(multi_return_string_string[]) { (multi_return_string_string){.arg0=(*(string*)array_get(result, 0)), .arg1=(*(string*)array_get(result, 1))} }, (_option*)(&_t2), sizeof(multi_return_string_string));
	return _t2;
}

_option_multi_return_string_string string_rsplit_once(string s, string delim) {
	Array_string result = string_rsplit_nth(s, delim, 2);
	if (result.len != 2) {
		_option_multi_return_string_string _t1 = (_option_multi_return_string_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		return _t1;
	}
	_option_multi_return_string_string _t2;
	_option_ok(&(multi_return_string_string[]) { (multi_return_string_string){.arg0=(*(string*)array_get(result, 1)), .arg1=(*(string*)array_get(result, 0))} }, (_option*)(&_t2), sizeof(multi_return_string_string));
	return _t2;
}

// Attr: [direct_array_access]
Array_string string_split_nth(string s, string delim, int nth) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = 0;
	switch (delim.len) {
		case 0: {
				i = 1;
				for (int _t1 = 0; _t1 < s.len; ++_t1) {
					u8 ch = s.str[_t1];
					if (nth > 0 && i >= nth) {
						array_push((array*)&res, _MOV((string[]){ string_substr(s, (int)(i - 1), 2147483647) }));
						break;
					}
					array_push((array*)&res, _MOV((string[]){ u8_ascii_str(ch) }));
					i++;
				}
				return res;
		}
		case 1: {
				int start = 0;
				u8 delim_byte = delim.str[ 0];
				for (;;) {
					if (!(i < s.len)) break;
					if (s.str[ i] == delim_byte) {
						bool was_last = nth > 0 && res.len == (int)(nth - 1);
						if (was_last) {
							break;
						}
						string val = string_substr(s, start, i);
						array_push((array*)&res, _MOV((string[]){ val }));
						start = (int)(i + delim.len);
						i = start;
					} else {
						i++;
					}
				}
				if (nth < 1 || res.len < nth) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, start, 2147483647) }));
				}
				return res;
		}
		default: {
				int start = 0;
				for (;;) {
					if (!(i <= s.len)) break;
					bool is_delim = (int)(i + delim.len) <= s.len && string__eq(string_substr(s, i, (int)(i + delim.len)), delim);
					if (is_delim) {
						bool was_last = nth > 0 && res.len == (int)(nth - 1);
						if (was_last) {
							break;
						}
						string val = string_substr(s, start, i);
						array_push((array*)&res, _MOV((string[]){ val }));
						start = (int)(i + delim.len);
						i = start;
					} else {
						i++;
					}
				}
				if (nth < 1 || res.len < nth) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, start, 2147483647) }));
				}
				return res;
		}
	}
	
	return __new_array(0, 0, sizeof(string));
}

// Attr: [direct_array_access]
Array_string string_rsplit_nth(string s, string delim, int nth) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int i = (int)(s.len - 1);
	switch (delim.len) {
		case 0: {
				for (;;) {
					if (!(i >= 0)) break;
					if (nth > 0 && res.len == (int)(nth - 1)) {
						array_push((array*)&res, _MOV((string[]){ string_substr(s, 0, (int)(i + 1)) }));
						break;
					}
					array_push((array*)&res, _MOV((string[]){ u8_ascii_str(s.str[ i]) }));
					i--;
				}
				return res;
		}
		case 1: {
				int rbound = s.len;
				u8 delim_byte = delim.str[ 0];
				for (;;) {
					if (!(i >= 0)) break;
					if (s.str[ i] == delim_byte) {
						if (nth > 0 && res.len == (int)(nth - 1)) {
							break;
						}
						array_push((array*)&res, _MOV((string[]){ string_substr(s, (int)(i + 1), rbound) }));
						rbound = i;
						i--;
					} else {
						i--;
					}
				}
				if (nth < 1 || res.len < nth) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, 0, rbound) }));
				}
				return res;
		}
		default: {
				int rbound = s.len;
				for (;;) {
					if (!(i >= 0)) break;
					bool is_delim = (int)(i - delim.len) >= 0 && string__eq(string_substr(s, (int)(i - delim.len), i), delim);
					if (is_delim) {
						if (nth > 0 && res.len == (int)(nth - 1)) {
							break;
						}
						array_push((array*)&res, _MOV((string[]){ string_substr(s, i, rbound) }));
						rbound = (int)(i - delim.len);
						i -= delim.len;
					} else {
						i--;
					}
				}
				if (nth < 1 || res.len < nth) {
					array_push((array*)&res, _MOV((string[]){ string_substr(s, 0, rbound) }));
				}
				return res;
		}
	}
	
	return __new_array(0, 0, sizeof(string));
}

// Attr: [direct_array_access]
Array_string string_split_into_lines(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (s.len == 0) {
		return res;
	}
	rune cr = '\r';
	rune lf = '\n';
	int line_start = 0;
	for (int i = 0; i < s.len; i++) {
		if (line_start <= i) {
			if (s.str[ i] == lf) {
				array_push((array*)&res, _MOV((string[]){ (line_start == i ? (_SLIT("")) : (string_substr(s, line_start, i))) }));
				line_start = (int)(i + 1);
			} else if (s.str[ i] == cr) {
				array_push((array*)&res, _MOV((string[]){ (line_start == i ? (_SLIT("")) : (string_substr(s, line_start, i))) }));
				if (((int)(i + 1)) < s.len && s.str[ (int)(i + 1)] == lf) {
					line_start = (int)(i + 2);
				} else {
					line_start = (int)(i + 1);
				}
			}
		}
	}
	if (line_start < s.len) {
		array_push((array*)&res, _MOV((string[]){ string_substr(s, line_start, 2147483647) }));
	}
	return res;
}

// Attr: [direct_array_access]
string string_substr(string s, int start, int _end) {
	int end = (_end == _const_max_int ? (s.len) : (_end));
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
			_v_panic( str_intp(4, _MOV((StrIntpData[]){{_SLIT("substr("), /*100 &int*/0xfe07, {.d_i32 = start}}, {_SLIT(", "), /*100 &int*/0xfe07, {.d_i32 = end}}, {_SLIT(") out of bounds (len="), /*100 &int*/0xfe07, {.d_i32 = s.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	int len = (int)(end - start);
	if (len == s.len) {
		return string_clone(s);
	}
	string res = ((string){.str = malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
string string_substr_unsafe(string s, int start, int _end) {
	int end = (_end == 2147483647 ? (s.len) : (_end));
	int len = (int)(end - start);
	if (len == s.len) {
		return s;
	}
	return ((string){.str = s.str + start, .len = len});
}

// Attr: [direct_array_access]
_result_string string_substr_with_check(string s, int start, int _end) {
	int end = (_end == _const_max_int ? (s.len) : (_end));
	if (start > end || start > s.len || end > s.len || start < 0 || end < 0) {
		return (_result_string){ .is_error=true, .err=_v_error( str_intp(4, _MOV((StrIntpData[]){{_SLIT("substr("), /*100 &int*/0xfe07, {.d_i32 = start}}, {_SLIT(", "), /*100 &int*/0xfe07, {.d_i32 = end}}, {_SLIT(") out of bounds (len="), /*100 &int*/0xfe07, {.d_i32 = s.len}}, {_SLIT(")"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int len = (int)(end - start);
	if (len == s.len) {
		_result_string _t2;
		_result_ok(&(string[]) { string_clone(s) }, (_result*)(&_t2), sizeof(string));
		return _t2;
	}
	string res = ((string){.str = malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	_result_string _t3;
	_result_ok(&(string[]) { res }, (_result*)(&_t3), sizeof(string));
	return _t3;
}

// Attr: [direct_array_access]
string string_substr_ni(string s, int _start, int _end) {
	int start = _start;
	int end = (_end == _const_max_int ? (s.len) : (_end));
	if (start < 0) {
		start = (int)(s.len + start);
		if (start < 0) {
			start = 0;
		}
	}
	if (end < 0) {
		end = (int)(s.len + end);
		if (end < 0) {
			end = 0;
		}
	}
	if (end >= s.len) {
		end = s.len;
	}
	if (start > s.len || end < start) {
		return _SLIT("");
	}
	int len = (int)(end - start);
	string res = ((string){.str = malloc_noscan((int)(len + 1)), .len = len});
	{ // Unsafe block
		vmemcpy(res.str, s.str + start, len);
		res.str[len] = 0;
	}
	return res;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL int string_index_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	if (p.len > 2) {
		return string_index_kmp(s, p);
	}
	int i = 0;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[(int)(i + j)] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

_option_int string_index(string s, string p) {
	int idx = string_index_(s, p);
	if (idx == -1) {
		return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_int _t2;
	_option_ok(&(int[]) { idx }, (_option*)(&_t2), sizeof(int));
	return _t2;
}

_option_int string_index_last(string s, string needle) {
	int idx = string_index_last_(s, needle);
	if (idx == -1) {
		return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_int _t2;
	_option_ok(&(int[]) { idx }, (_option*)(&_t2), sizeof(int));
	return _t2;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
// Attr: [inline]
inline _option_int string_last_index(string s, string needle) {
	_option_int _t1 = string_index_last(s, needle);
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
VV_LOCAL_SYMBOL int string_index_kmp(string s, string p) {
	bool string_index_kmp_defer_0 = false;
	Array_int prefix;
	if (p.len > s.len) {
		return -1;
	}
	prefix = __new_array_with_default_noscan(p.len, 0, sizeof(int), 0);
	string_index_kmp_defer_0 = true;
	int j = 0;
	for (int i = 1; i < p.len; i++) {
		for (;;) {
			if (!(p.str[j] != p.str[i] && j > 0)) break;
			j = ((int*)prefix.data)[(int)(j - 1)];
		}
		if (p.str[j] == p.str[i]) {
			j++;
		}
		((int*)prefix.data)[i] = j;
	}
	j = 0;
	for (int i = 0; i < s.len; ++i) {
		for (;;) {
			if (!(p.str[j] != s.str[i] && j > 0)) break;
			j = ((int*)prefix.data)[(int)(j - 1)];
		}
		if (p.str[j] == s.str[i]) {
			j++;
		}
		if (j == p.len) {
			int _t2 = (int)((int)(i - p.len) + 1);
				// Defer begin
				if (string_index_kmp_defer_0) {
					array_free(&prefix);
				}
				// Defer end
			return _t2;
		}
	}
	int _t3 = -1;
		// Defer begin
		if (string_index_kmp_defer_0) {
			array_free(&prefix);
		}
		// Defer end
	return _t3;
}

int string_index_any(string s, string chars) {
	for (int i = 0; i < s.len; ++i) {
		u8 ss = s.str[i];
		for (int _t1 = 0; _t1 < chars.len; ++_t1) {
			u8 c = chars.str[_t1];
			if (c == ss) {
				return i;
			}
		}
	}
	return -1;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL int string_index_last_(string s, string p) {
	if (p.len > s.len || p.len == 0) {
		return -1;
	}
	int i = (int)(s.len - p.len);
	for (;;) {
		if (!(i >= 0)) break;
		int j = 0;
		for (;;) {
			if (!(j < p.len && s.str[(int)(i + j)] == p.str[j])) break;
			j++;
		}
		if (j == p.len) {
			return i;
		}
		i--;
	}
	return -1;
}

// Attr: [direct_array_access]
int string_index_after(string s, string p, int start) {
	if (p.len > s.len) {
		return -1;
	}
	int strt = start;
	if (start < 0) {
		strt = 0;
	}
	if (start >= s.len) {
		return -1;
	}
	int i = strt;
	for (;;) {
		if (!(i < s.len)) break;
		int j = 0;
		int ii = i;
		for (;;) {
			if (!(j < p.len && s.str[ii] == p.str[j])) break;
			j++;
			ii++;
		}
		if (j == p.len) {
			return i;
		}
		i++;
	}
	return -1;
}

// Attr: [direct_array_access]
int string_index_u8(string s, u8 c) {
	for (int i = 0; i < s.len; ++i) {
		u8 b = s.str[i];
		if (b == c) {
			return i;
		}
	}
	return -1;
}

// Attr: [direct_array_access]
int string_index_u8_last(string s, u8 c) {
	for (int i = (int)(s.len - 1); i >= 0; i--) {
		if (s.str[i] == c) {
			return i;
		}
	}
	return -1;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
// Attr: [inline]
inline int string_last_index_u8(string s, u8 c) {
	return string_index_u8_last(s, c);
}

// Attr: [direct_array_access]
int string_count(string s, string substr) {
	if (s.len == 0 || substr.len == 0) {
		return 0;
	}
	if (substr.len > s.len) {
		return 0;
	}
	int n = 0;
	if (substr.len == 1) {
		u8 target = substr.str[ 0];
		for (int _t3 = 0; _t3 < s.len; ++_t3) {
			u8 letter = s.str[_t3];
			if (letter == target) {
				n++;
			}
		}
		return n;
	}
	int i = 0;
	for (;;) {
		i = string_index_after(s, substr, i);
		if (i == -1) {
			return n;
		}
		i += substr.len;
		n++;
	}
	return 0;
}

bool string_contains_u8(string s, u8 x) {
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 c = s.str[_t1];
		if (x == c) {
			return true;
		}
	}
	return false;
}

bool string_contains(string s, string substr) {
	if (substr.len == 0) {
		return true;
	}
	if (substr.len == 1) {
		return string_contains_u8(s, substr.str[0]);
	}
	return string_index_(s, substr) != -1;
}

bool string_contains_any(string s, string chars) {
	for (int _t1 = 0; _t1 < chars.len; ++_t1) {
		u8 c = chars.str[_t1];
		if (string_contains_u8(s, c)) {
			return true;
		}
	}
	return false;
}

bool string_contains_only(string s, string chars) {
	if (chars.len == 0) {
		return false;
	}
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 ch = s.str[_t2];
		int res = 0;
		for (int i = 0; i < chars.len && res == 0; i++) {
			res += (int[]){(ch == chars.str[i])?1:0}[0];
		}
		if (res == 0) {
			return false;
		}
	}
	return true;
}

bool string_contains_any_substr(string s, Array_string substrs) {
	if (substrs.len == 0) {
		return true;
	}
	for (int _t2 = 0; _t2 < substrs.len; ++_t2) {
		string sub = ((string*)substrs.data)[_t2];
		if (string_contains(s, sub)) {
			return true;
		}
	}
	return false;
}

// Attr: [direct_array_access]
bool string_starts_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (s.str[i] != p.str[i]) {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
bool string_ends_with(string s, string p) {
	if (p.len > s.len) {
		return false;
	}
	for (int i = 0; i < p.len; ++i) {
		if (p.str[i] != s.str[(int)((int)(s.len - p.len) + i)]) {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_to_lower(string s) {
	{ // Unsafe block
		u8* b = malloc_noscan((int)(s.len + 1));
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'A' && s.str[i] <= 'Z') {
				b[i] = (u8)(s.str[i] + 32);
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
bool string_is_lower(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 'A' && s.str[ i] <= 'Z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_to_upper(string s) {
	{ // Unsafe block
		u8* b = malloc_noscan((int)(s.len + 1));
		for (int i = 0; i < s.len; ++i) {
			if (s.str[i] >= 'a' && s.str[i] <= 'z') {
				b[i] = (u8)(s.str[i] - 32);
			} else {
				b[i] = s.str[i];
			}
		}
		b[s.len] = 0;
		return tos(b, s.len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
bool string_is_upper(string s) {
	for (int i = 0; i < s.len; ++i) {
		if (s.str[ i] >= 'a' && s.str[ i] <= 'z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
string string_capitalize(string s) {
	if (s.len == 0) {
		return _SLIT("");
	}
	u8 s0 = s.str[ 0];
	string letter = u8_ascii_str(s0);
	string uletter = string_to_upper(letter);
	if (s.len == 1) {
		return uletter;
	}
	string srest = string_substr(s, 1, 2147483647);
	string res = string__plus(uletter, srest);
	return res;
}

// Attr: [direct_array_access]
string string_uncapitalize(string s) {
	if (s.len == 0) {
		return _SLIT("");
	}
	u8 s0 = s.str[ 0];
	string letter = u8_ascii_str(s0);
	string uletter = string_to_lower(letter);
	if (s.len == 1) {
		return uletter;
	}
	string srest = string_substr(s, 1, 2147483647);
	string res = string__plus(uletter, srest);
	return res;
}

// Attr: [direct_array_access]
bool string_is_capital(string s) {
	if (s.len == 0 || !(s.str[ 0] >= 'A' && s.str[ 0] <= 'Z')) {
		return false;
	}
	for (int i = 1; i < s.len; ++i) {
		if (s.str[ i] >= 'A' && s.str[ i] <= 'Z') {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
bool string_starts_with_capital(string s) {
	if (s.len == 0 || !(s.str[ 0] >= 'A' && s.str[ 0] <= 'Z')) {
		return false;
	}
	return true;
}

string string_title(string s) {
	Array_string words = string_split(s, _SLIT(" "));
	Array_string tit = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		array_push((array*)&tit, _MOV((string[]){ string_capitalize(word) }));
	}
	string title = Array_string_join(tit, _SLIT(" "));
	return title;
}

bool string_is_title(string s) {
	Array_string words = string_split(s, _SLIT(" "));
	for (int _t1 = 0; _t1 < words.len; ++_t1) {
		string word = ((string*)words.data)[_t1];
		if (!string_is_capital(word)) {
			return false;
		}
	}
	return true;
}

string string_find_between(string s, string start, string end) {
	int start_pos = string_index_(s, start);
	if (start_pos == -1) {
		return _SLIT("");
	}
	string val = string_substr(s, (int)(start_pos + start.len), 2147483647);
	int end_pos = string_index_(val, end);
	if (end_pos == -1) {
		return val;
	}
	return string_substr(val, 0, end_pos);
}

// Attr: [inline]
inline string string_trim_space(string s) {
	return string_trim(s, _SLIT(" \n\t\v\f\r"));
}

string string_trim(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	multi_return_int_int mr_41487 = string_trim_indexes(s, cutset);
	int left = mr_41487.arg0;
	int right = mr_41487.arg1;
	return string_substr(s, left, right);
}

// Attr: [direct_array_access]
multi_return_int_int string_trim_indexes(string s, string cutset) {
	int pos_left = 0;
	int pos_right = (int)(s.len - 1);
	bool cs_match = true;
	for (;;) {
		if (!(pos_left <= s.len && pos_right >= -1 && cs_match)) break;
		cs_match = false;
		for (int _t1 = 0; _t1 < cutset.len; ++_t1) {
			u8 cs = cutset.str[_t1];
			if (s.str[ pos_left] == cs) {
				pos_left++;
				cs_match = true;
				break;
			}
		}
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			u8 cs = cutset.str[_t2];
			if (s.str[ pos_right] == cs) {
				pos_right--;
				cs_match = true;
				break;
			}
		}
		if (pos_left > pos_right) {
			return (multi_return_int_int){.arg0=0, .arg1=0};
		}
	}
	return (multi_return_int_int){.arg0=pos_left, .arg1=(int)(pos_right + 1)};
}

// Attr: [direct_array_access]
string string_trim_left(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos = 0;
	for (;;) {
		if (!(pos < s.len)) break;
		bool found = false;
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			u8 cs = cutset.str[_t2];
			if (s.str[ pos] == cs) {
				found = true;
				break;
			}
		}
		if (!found) {
			break;
		}
		pos++;
	}
	return string_substr(s, pos, 2147483647);
}

// Attr: [direct_array_access]
string string_trim_right(string s, string cutset) {
	if (s.len < 1 || cutset.len < 1) {
		return string_clone(s);
	}
	int pos = (int)(s.len - 1);
	for (;;) {
		if (!(pos >= 0)) break;
		bool found = false;
		for (int _t2 = 0; _t2 < cutset.len; ++_t2) {
			u8 cs = cutset.str[_t2];
			if (s.str[ pos] == cs) {
				found = true;
			}
		}
		if (!found) {
			break;
		}
		pos--;
	}
	if (pos < 0) {
		return _SLIT("");
	}
	return string_substr(s, 0, (int)(pos + 1));
}

string string_trim_string_left(string s, string str) {
	if (string_starts_with(s, str)) {
		return string_substr(s, str.len, 2147483647);
	}
	return string_clone(s);
}

string string_trim_string_right(string s, string str) {
	if (string_ends_with(s, str)) {
		return string_substr(s, 0, (int)(s.len - str.len));
	}
	return string_clone(s);
}

int compare_strings(string* a, string* b) {
	if (string__lt(*a, *b)) {
		return -1;
	}
	if (string__lt(*b, *a)) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_strings_by_len(string* a, string* b) {
	if (a->len < b->len) {
		return -1;
	}
	if (a->len > b->len) {
		return 1;
	}
	return 0;
}

VV_LOCAL_SYMBOL int compare_lower_strings(string* a, string* b) {
	string aa = string_to_lower(/*rec*/*a);
	string bb = string_to_lower(/*rec*/*b);
	return compare_strings(&aa, &bb);
}

// Attr: [inline]
inline void Array_string_sort_ignore_case(Array_string* s) {
	array_sort_with_compare(s, (voidptr)compare_lower_strings);
}

// Attr: [inline]
inline void Array_string_sort_by_len(Array_string* s) {
	array_sort_with_compare(s, (voidptr)compare_strings_by_len);
}

// Attr: [inline]
inline string string_str(string s) {
	return string_clone(s);
}

VV_LOCAL_SYMBOL u8 string_at(string s, int idx) {
	#if !defined(CUSTOM_DEFINE_no_bounds_checking)
	{
		if (idx < 0 || idx >= s.len) {
			_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT("string index out of range: "), /*100 &int*/0xfe07, {.d_i32 = idx}}, {_SLIT(" / "), /*100 &int*/0xfe07, {.d_i32 = s.len}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	#endif
	return s.str[idx];
}

VV_LOCAL_SYMBOL _option_u8 string_at_with_check(string s, int idx) {
	if (idx < 0 || idx >= s.len) {
		return (_option_u8){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	{ // Unsafe block
		_option_u8 _t2;
		_option_ok(&(u8[]) { s.str[idx] }, (_option*)(&_t2), sizeof(u8));
		return _t2;
	}
	return (_option_u8){0};
}

// Attr: [inline]
inline bool u8_is_space(u8 c) {
	return c == 32 || (c > 8 && c < 14) || c == 0x85 || c == 0xa0;
}

// Attr: [inline]
inline bool u8_is_digit(u8 c) {
	return c >= '0' && c <= '9';
}

// Attr: [inline]
inline bool u8_is_hex_digit(u8 c) {
	return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}

// Attr: [inline]
inline bool u8_is_oct_digit(u8 c) {
	return c >= '0' && c <= '7';
}

// Attr: [inline]
inline bool u8_is_bin_digit(u8 c) {
	return c == '0' || c == '1';
}

// Attr: [inline]
inline bool u8_is_letter(u8 c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
}

// Attr: [inline]
inline bool u8_is_alnum(u8 c) {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9');
}

// Attr: [manualfree]
// Attr: [unsafe]
void string_free(string* s) {
	if (s->is_lit == -98761234) {
		u8* double_free_msg = ((u8*)("double string.free() detected\n"));
		int double_free_msg_len = vstrlen(double_free_msg);
		#if defined(_VFREESTANDING)
		{
		}
		#else
		{
			_write_buf_to_fd(1, double_free_msg, double_free_msg_len);
		}
		#endif
		return;
	}
	if (s->is_lit == 1 || s->str == 0) {
		return;
	}
	{ // Unsafe block
		_v_free(s->str);
		s->str = ((void*)0);
	}
	s->is_lit = -98761234;
}

string string_before(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_before(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_before_last(string s, string sub) {
	int pos = string_index_last_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, 0, pos);
}

string string_all_after(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, (int)(pos + sub.len), 2147483647);
}

string string_all_after_last(string s, string sub) {
	int pos = string_index_last_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, (int)(pos + sub.len), 2147483647);
}

string string_all_after_first(string s, string sub) {
	int pos = string_index_(s, sub);
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, (int)(pos + sub.len), 2147483647);
}

// Attr: [inline]
inline string string_after(string s, string sub) {
	return string_all_after_last(s, sub);
}

string string_after_char(string s, u8 sub) {
	int pos = -1;
	for (int i = 0; i < s.len; ++i) {
		u8 c = s.str[i];
		if (c == sub) {
			pos = i;
			break;
		}
	}
	if (pos == -1) {
		return string_clone(s);
	}
	return string_substr(s, (int)(pos + 1), 2147483647);
}

string Array_string_join(Array_string a, string sep) {
	if (a.len == 0) {
		return _SLIT("");
	}
	int len = 0;
	for (int _t2 = 0; _t2 < a.len; ++_t2) {
		string val = ((string*)a.data)[_t2];
		len += (int)(val.len + sep.len);
	}
	len -= sep.len;
	string res = ((string){.str = malloc_noscan((int)(len + 1)), .len = len});
	int idx = 0;
	for (int i = 0; i < a.len; ++i) {
		string val = ((string*)a.data)[i];
		{ // Unsafe block
			vmemcpy(((voidptr)(res.str + idx)), val.str, val.len);
			idx += val.len;
		}
		if (i != (int)(a.len - 1)) {
			{ // Unsafe block
				vmemcpy(((voidptr)(res.str + idx)), sep.str, sep.len);
				idx += sep.len;
			}
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}

// Attr: [inline]
inline string Array_string_join_lines(Array_string s) {
	return Array_string_join(s, _SLIT("\n"));
}

// Attr: [direct_array_access]
string string_reverse(string s) {
	if (s.len == 0 || s.len == 1) {
		return string_clone(s);
	}
	string res = ((string){.str = malloc_noscan((int)(s.len + 1)), .len = s.len});
	for (int i = (int)(s.len - 1); i >= 0; i--) {
		{ // Unsafe block
			res.str[(int)((int)(s.len - i) - 1)] = s.str[ i];
		}
	}
	{ // Unsafe block
		res.str[res.len] = 0;
	}
	return res;
}

string string_limit(string s, int max) {
	Array_rune u = string_runes(s);
	if (u.len <= max) {
		return string_clone(s);
	}
	return Array_rune_string(array_slice(u, 0, max));
}

int string_hash(string s) {
	u32 h = ((u32)(0U));
	if (h == 0U && s.len > 0) {
		for (int _t1 = 0; _t1 < s.len; ++_t1) {
			u8 c = s.str[_t1];
			h = (u32)((u32)(h * 31U) + ((u32)(c)));
		}
	}
	return ((int)(h));
}

Array_u8 string_bytes(string s) {
	if (s.len == 0) {
		return __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	}
	Array_u8 buf = __new_array_with_default_noscan(s.len, 0, sizeof(u8), 0);
	vmemcpy(buf.data, s.str, s.len);
	return buf;
}

// Attr: [direct_array_access]
string string_repeat(string s, int count) {
	if (count < 0) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("string.repeat: count is negative: "), /*100 &int*/0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	} else if (count == 0) {
		return _SLIT("");
	} else if (count == 1) {
		return string_clone(s);
	}
	u8* ret = malloc_noscan((int)((int)(s.len * count) + 1));
	for (int i = 0; i < count; ++i) {
		vmemcpy(ret + (int)(i * s.len), s.str, s.len);
	}
	int new_len = (int)(s.len * count);
	{ // Unsafe block
		ret[new_len] = 0;
	}
	return u8_vstring_with_len(ret, new_len);
}

Array_string string_fields(string s) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	int word_start = 0;
	int word_len = 0;
	bool is_in_word = false;
	bool is_space = false;
	for (int i = 0; i < s.len; ++i) {
		u8 c = s.str[i];
		is_space = (c == 32 || c == 9 || c == 10);
		if (!is_space) {
			word_len++;
		}
		if (!is_in_word && !is_space) {
			word_start = i;
			is_in_word = true;
			continue;
		}
		if (is_space && is_in_word) {
			array_push((array*)&res, _MOV((string[]){ string_substr(s, word_start, (int)(word_start + word_len)) }));
			is_in_word = false;
			word_len = 0;
			word_start = 0;
			continue;
		}
	}
	if (is_in_word && word_len > 0) {
		array_push((array*)&res, _MOV((string[]){ string_substr(s, word_start, s.len) }));
	}
	return res;
}

// Attr: [inline]
inline string string_strip_margin(string s) {
	return string_strip_margin_custom(s, '|');
}

// Attr: [direct_array_access]
string string_strip_margin_custom(string s, u8 del) {
	u8 sep = del;
	if (u8_is_space(sep)) {
		println(_SLIT("Warning: `strip_margin` cannot use white-space as a delimiter"));
		println(_SLIT("    Defaulting to `|`"));
		sep = '|';
	}
	u8* ret = malloc_noscan((int)(s.len + 1));
	int count = 0;
	for (int i = 0; i < s.len; i++) {
		if (s.str[ i] == 10 || s.str[ i] == 13) {
			{ // Unsafe block
				ret[count] = s.str[ i];
			}
			count++;
			if (s.str[ i] == 13 && i < (int)(s.len - 1) && s.str[ (int)(i + 1)] == 10) {
				{ // Unsafe block
					ret[count] = s.str[ (int)(i + 1)];
				}
				count++;
				i++;
			}
			for (;;) {
				if (!(s.str[ i] != sep)) break;
				i++;
				if (i >= s.len) {
					break;
				}
			}
		} else {
			{ // Unsafe block
				ret[count] = s.str[ i];
			}
			count++;
		}
	}
	{ // Unsafe block
		ret[count] = 0;
		return u8_vstring_with_len(ret, count);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string string_trim_indent(string s) {
	Array_string lines = string_split_into_lines(s);
	Array_string _t3 = {0};
	Array_string _t3_orig = lines;
	int _t3_len = _t3_orig.len;
	_t3 = __new_array(0, _t3_len, sizeof(string));

	for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
		string it = ((string*) _t3_orig.data)[_t4];
		if (!string_is_blank(it)) {
			array_push((array*)&_t3, &it);
		}
	}
	Array_int _t1 = {0};
	Array_string _t1_orig =_t3;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array_noscan(0, _t1_len, sizeof(int));

	for (int _t5 = 0; _t5 < _t1_len; ++_t5) {
		string it = ((string*) _t1_orig.data)[_t5];
		int _t2 = string_indent_width(it);
		array_push_noscan((array*)&_t1, &_t2);
	}
	Array_int lines_indents =_t1;
	int min_common_indent = ((int)(_const_max_int));
	for (int _t6 = 0; _t6 < lines_indents.len; ++_t6) {
		int line_indent = ((int*)lines_indents.data)[_t6];
		if (line_indent < min_common_indent) {
			min_common_indent = line_indent;
		}
	}
	if (lines.len > 0 && string_is_blank((*(string*)array_first(lines)))) {
		lines = array_slice(lines, 1, 2147483647);
	}
	if (lines.len > 0 && string_is_blank((*(string*)array_last(lines)))) {
		lines = array_slice(lines, 0, (int)(lines.len - 1));
	}
	Array_string trimmed_lines = __new_array_with_default(0, lines.len, sizeof(string), 0);
	for (int _t7 = 0; _t7 < lines.len; ++_t7) {
		string line = ((string*)lines.data)[_t7];
		if (string_is_blank(line)) {
			array_push((array*)&trimmed_lines, _MOV((string[]){ line }));
			continue;
		}
		array_push((array*)&trimmed_lines, _MOV((string[]){ string_substr(line, min_common_indent, 2147483647) }));
	}
	return Array_string_join(trimmed_lines, _SLIT("\n"));
}

int string_indent_width(string s) {
	for (int i = 0; i < s.len; ++i) {
		u8 c = s.str[i];
		if (!u8_is_space(c)) {
			return i;
		}
	}
	return 0;
}

bool string_is_blank(string s) {
	if (s.len == 0) {
		return true;
	}
	for (int _t2 = 0; _t2 < s.len; ++_t2) {
		u8 c = s.str[_t2];
		if (!u8_is_space(c)) {
			return false;
		}
	}
	return true;
}

// Attr: [direct_array_access]
bool string_match_glob(string name, string pattern) {
	int px = 0;
	int nx = 0;
	int next_px = 0;
	int next_nx = 0;
	int plen = pattern.len;
	int nlen = name.len;
	for (;;) {
		if (!(px < plen || nx < nlen)) break;
		if (px < plen) {
			u8 c = pattern.str[ px];

			if (c == ('?')) {
				if (nx < nlen) {
					px++;
					nx++;
					continue;
				}
			}
			else if (c == ('*')) {
				next_px = px;
				next_nx = (int)(nx + 1);
				px++;
				continue;
			}
			else if (c == ('[')) {
				if (nx < nlen) {
					u8 wanted_c = name.str[ nx];
					int bstart = px;
					bool is_inverted = false;
					bool inner_match = false;
					int inner_idx = (int)(bstart + 1);
					int inner_c = 0;
					if (inner_idx < plen) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == '^') {
							is_inverted = true;
							inner_idx++;
						}
					}
					for (; inner_idx < plen; inner_idx++) {
						inner_c = pattern.str[ inner_idx];
						if (inner_c == ']') {
							break;
						}
						if (inner_c == wanted_c) {
							inner_match = true;
							for (;;) {
								if (!(px < plen && pattern.str[ px] != ']')) break;
								px++;
							}
							break;
						}
					}
					if (is_inverted) {
						if (inner_match) {
							return false;
						} else {
							px = inner_idx;
						}
					}
				}
				px++;
				nx++;
				continue;
			}
			else {
				if (nx < nlen && name.str[ nx] == c) {
					px++;
					nx++;
					continue;
				}
			}
		}
		if (0 < next_nx && next_nx <= nlen) {
			px = next_px;
			nx = next_nx;
			continue;
		}
		return false;
	}
	return true;
}

// Attr: [inline]
inline bool string_is_ascii(string s) {
	bool _t2 = false;
	Array_u8 _t2_orig = string_bytes(s);
	int _t2_len = _t2_orig.len;
	for (int _t3 = 0; _t3 < _t2_len; ++_t3) {
		u8 it = ((u8*) _t2_orig.data)[_t3];
		if (it < ((u8)(' ')) || it > ((u8)('~'))) {
			_t2 = true;
			break;
		}
	}
	return !_t2;
}

// Attr: [unsafe]
Array_u8 byteptr_vbytes(byteptr data, int len) {
	return voidptr_vbytes(((voidptr)(data)), len);
}

// Attr: [unsafe]
string byteptr_vstring(byteptr bp) {
	return ((string){.str = bp, .len = vstrlen(bp)});
}

// Attr: [unsafe]
string byteptr_vstring_with_len(byteptr bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 0});
}

// Attr: [unsafe]
string charptr_vstring(charptr cp) {
	return ((string){.str = ((byteptr)(cp)), .len = vstrlen_char(cp), .is_lit = 0});
}

// Attr: [unsafe]
string charptr_vstring_with_len(charptr cp, int len) {
	return ((string){.str = ((byteptr)(cp)), .len = len, .is_lit = 0});
}

// Attr: [unsafe]
string byteptr_vstring_literal(byteptr bp) {
	return ((string){.str = bp, .len = vstrlen(bp), .is_lit = 1});
}

// Attr: [unsafe]
string byteptr_vstring_literal_with_len(byteptr bp, int len) {
	return ((string){.str = bp, .len = len, .is_lit = 1});
}

// Attr: [unsafe]
string charptr_vstring_literal(charptr cp) {
	return ((string){.str = ((byteptr)(cp)), .len = vstrlen_char(cp), .is_lit = 1});
}

// Attr: [unsafe]
string charptr_vstring_literal_with_len(charptr cp, int len) {
	return ((string){.str = ((byteptr)(cp)), .len = len, .is_lit = 1});
}

string StrIntpType_str(StrIntpType x) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (x) {
		case StrIntpType__si_no_str: {
				_t2 = _SLIT("no_str");
				break;
		}
		case StrIntpType__si_c: {
				_t2 = _SLIT("c");
				break;
		}
		case StrIntpType__si_u8: {
				_t2 = _SLIT("u8");
				break;
		}
		case StrIntpType__si_i8: {
				_t2 = _SLIT("i8");
				break;
		}
		case StrIntpType__si_u16: {
				_t2 = _SLIT("u16");
				break;
		}
		case StrIntpType__si_i16: {
				_t2 = _SLIT("i16");
				break;
		}
		case StrIntpType__si_u32: {
				_t2 = _SLIT("u32");
				break;
		}
		case StrIntpType__si_i32: {
				_t2 = _SLIT("i32");
				break;
		}
		case StrIntpType__si_u64: {
				_t2 = _SLIT("u64");
				break;
		}
		case StrIntpType__si_i64: {
				_t2 = _SLIT("i64");
				break;
		}
		case StrIntpType__si_f32: {
				_t2 = _SLIT("f32");
				break;
		}
		case StrIntpType__si_f64: {
				_t2 = _SLIT("f64");
				break;
		}
		case StrIntpType__si_g32: {
				_t2 = _SLIT("f32");
				break;
		}
		case StrIntpType__si_g64: {
				_t2 = _SLIT("f64");
				break;
		}
		case StrIntpType__si_e32: {
				_t2 = _SLIT("f32");
				break;
		}
		case StrIntpType__si_e64: {
				_t2 = _SLIT("f64");
				break;
		}
		case StrIntpType__si_s: {
				_t2 = _SLIT("s");
				break;
		}
		case StrIntpType__si_p: {
				_t2 = _SLIT("p");
				break;
		}
		case StrIntpType__si_vp: {
				_t2 = _SLIT("vp");
				break;
		}
	}
	return _t2;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f32 fabs32(f32 x) {
	return (x < 0 ? (-x) : (x));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 fabs64(f64 x) {
	return (x < 0 ? (-x) : (x));
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 abs64(i64 x) {
	return (x < 0 ? (((u64)(-x))) : (((u64)(x))));
}

u64 get_str_intp_u64_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, u8 in_pad_ch, int in_base, bool in_upper_case) {
	u64 width = (in_width != 0 ? (abs64(in_width)) : (((u64)(0U))));
	u64 align = (in_width > 0 ? (((u64)(32U))) : (((u64)(0U))));
	u64 upper_case = (in_upper_case ? (((u64)(128U))) : (((u64)(0U))));
	u64 sign = (in_sign ? (((u64)(256U))) : (((u64)(0U))));
	u64 precision = (in_precision != 987698 ? (((((u64)((in_precision & 0x7F))) << 9U))) : ((((u64)(0x7FU)) << 9U)));
	u32 tail_zeros = (in_tail_zeros ? ((((u32)(1U)) << 16U)) : (((u32)(0U))));
	u64 base = ((u64)((((u32)((in_base & 0xf))) << 27U)));
	u64 res = ((u64)(((((((((((((u64)(fmt_type)) & 0x1FU)) | align) | upper_case) | sign) | precision) | tail_zeros) | ((((u64)((width & 0x3FFU))) << 17U))) | base) | ((((u64)(in_pad_ch)) << 31U)))));
	return res;
}

u32 get_str_intp_u32_format(StrIntpType fmt_type, int in_width, int in_precision, bool in_tail_zeros, bool in_sign, u8 in_pad_ch, int in_base, bool in_upper_case) {
	u64 width = (in_width != 0 ? (abs64(in_width)) : (((u32)(0U))));
	u32 align = (in_width > 0 ? (((u32)(32U))) : (((u32)(0U))));
	u32 upper_case = (in_upper_case ? (((u32)(128U))) : (((u32)(0U))));
	u32 sign = (in_sign ? (((u32)(256U))) : (((u32)(0U))));
	u32 precision = (in_precision != 987698 ? (((((u32)((in_precision & 0x7F))) << 9U))) : ((((u32)(0x7FU)) << 9U)));
	u32 tail_zeros = (in_tail_zeros ? ((((u32)(1U)) << 16U)) : (((u32)(0U))));
	u32 base = ((u32)((((u32)((in_base & 0xf))) << 27U)));
	u32 res = ((u32)(((((((((((((u32)(fmt_type)) & 0x1FU)) | align) | upper_case) | sign) | precision) | tail_zeros) | ((((u32)((width & 0x3FFU))) << 17U))) | base) | ((((u32)((in_pad_ch & 1))) << 31U)))));
	return res;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL void StrIntpData_process_str_intp_data(StrIntpData* data, strings__Builder* sb) {
	u32 x = data->fmt;
	StrIntpType typ = ((StrIntpType)((x & 0x1FU)));
	int align = ((int)((((x >> 5U)) & 0x01U)));
	bool upper_case = ((((x >> 7U)) & 0x01U)) > 0U;
	int sign = ((int)((((x >> 8U)) & 0x01U)));
	int precision = ((int)((((x >> 9U)) & 0x7FU)));
	bool tail_zeros = ((((x >> 16U)) & 0x01U)) > 0U;
	int width = ((int)(((i16)((((x >> 17U)) & 0x3FFU)))));
	int base = (((int)((x >> 27U))) & 0xF);
	u8 fmt_pad_ch = ((u8)((((x >> 31U)) & 0xFFU)));
	if (typ == StrIntpType__si_no_str) {
		return;
	}
	if (base > 0) {
		base += 2;
	}
	u8 pad_ch = ((u8)(' '));
	if (fmt_pad_ch > 0) {
		pad_ch = '0';
	}
	int len0_set = (width > 0 ? (width) : (-1));
	int len1_set = (precision == 0x7F ? (-1) : (precision));
	bool sign_set = sign == 1;
	strconv__BF_param bf = ((strconv__BF_param){
		.pad_ch = pad_ch,
		.len0 = len0_set,
		.len1 = len1_set,
		.positive = true,
		.sign_flag = sign_set,
		.align = strconv__Align_text__left,
		.allign = strconv__Align_text__right,
		.rm_tail_zero = tail_zeros,
	});
	if (fmt_pad_ch == 0) {
		switch (align) {
			case 0: {
					bf.align = strconv__Align_text__left;
					break;
			}
			case 1: {
					bf.align = strconv__Align_text__right;
					break;
			}
			default: {
					bf.align = strconv__Align_text__left;
					break;
			}
		}
		
	} else {
		bf.align = strconv__Align_text__right;
	}
	{ // Unsafe block
		if (typ == StrIntpType__si_s) {
			string s = _SLIT("");
			if (upper_case) {
				s = string_to_upper(data->d.d_s);
			} else {
				s = string_clone(data->d.d_s);
			}
			if (width == 0) {
				strings__Builder_write_string(sb, s);
			} else {
				strconv__format_str_sb(s, bf, sb);
			}
			string_free(&s);
			return;
		}
		if (typ == StrIntpType__si_i8 || typ == StrIntpType__si_i16 || typ == StrIntpType__si_i32 || typ == StrIntpType__si_i64) {
			i64 d = data->d.d_i64;
			if (typ == StrIntpType__si_i8) {
				d = ((i64)(data->d.d_i8));
			} else if (typ == StrIntpType__si_i16) {
				d = ((i64)(data->d.d_i16));
			} else if (typ == StrIntpType__si_i32) {
				d = ((i64)(data->d.d_i32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = i64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				if (d < 0) {
					bf.positive = false;
				}
				strconv__format_dec_sb(abs64(d), bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				i64 absd = d;
				bool write_minus = false;
				if (d < 0 && pad_ch != ' ') {
					absd = -d;
					write_minus = true;
				}
				string hx = strconv__format_int(absd, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (write_minus) {
					strings__Builder_write_u8(sb, '-');
					bf.len0--;
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_u8 || typ == StrIntpType__si_u16 || typ == StrIntpType__si_u32 || typ == StrIntpType__si_u64) {
			u64 d = data->d.d_u64;
			if (typ == StrIntpType__si_u8) {
				d = ((u64)(data->d.d_u8));
			} else if (typ == StrIntpType__si_u16) {
				d = ((u64)(data->d.d_u16));
			} else if (typ == StrIntpType__si_u32) {
				d = ((u64)(data->d.d_u32));
			}
			if (base == 0) {
				if (width == 0) {
					string d_str = u64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				if (base == 3) {
					base = 2;
				}
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		if (typ == StrIntpType__si_p) {
			u64 d = data->d.d_u64;
			base = 16;
			if (base == 0) {
				if (width == 0) {
					string d_str = u64_str(d);
					strings__Builder_write_string(sb, d_str);
					string_free(&d_str);
					return;
				}
				strconv__format_dec_sb(d, bf, sb);
			} else {
				string hx = strconv__format_uint(d, base);
				if (upper_case) {
					string tmp = hx;
					hx = string_to_upper(hx);
					string_free(&tmp);
				}
				if (width == 0) {
					strings__Builder_write_string(sb, hx);
				} else {
					strconv__format_str_sb(hx, bf, sb);
				}
				string_free(&hx);
			}
			return;
		}
		bool use_default_str = false;
		if (width == 0 && precision == 0x7F) {
			bf.len1 = 3;
			use_default_str = true;
		}
		if (bf.len1 < 0) {
			bf.len1 = 3;
		}
		switch (typ) {
			case StrIntpType__si_f32: {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f32_str(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f32 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_fl(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
			}
			case StrIntpType__si_f64: {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (use_default_str) {
							string f = f64_str(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f64 < 0) {
								bf.positive = false;
							}
							strconv__Float64u f_union = ((strconv__Float64u){.f = data->d.d_f64,});
							if (f_union.u == _const_strconv__double_minus_zero) {
								bf.positive = false;
							}
							string f = strconv__format_fl(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
			}
			case StrIntpType__si_g32: {
					if (use_default_str) {
						#if !defined(CUSTOM_DEFINE_nofloat)
						{
							string f = f32_strg(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
						#endif
					} else {
						if (data->d.d_f32 == _const_strconv__single_plus_zero) {
							string tmp_str = _SLIT("0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f32 == _const_strconv__single_minus_zero) {
							string tmp_str = _SLIT("-0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f32 == _const_strconv__single_plus_infinity) {
							string tmp_str = _SLIT("+inf");
							if (upper_case) {
								tmp_str = _SLIT("+INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f32 == _const_strconv__single_minus_infinity) {
							string tmp_str = _SLIT("-inf");
							if (upper_case) {
								tmp_str = _SLIT("-INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f32 < 0) {
							bf.positive = false;
						}
						f32 d = fabs32(data->d.d_f32);
						if (d < ((f32)(999999.0)) && d >= ((f32)(0.00001))) {
							string f = strconv__format_fl(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
							return;
						}
						string f = strconv__format_es(data->d.d_f32, bf);
						if (upper_case) {
							string tmp = f;
							f = string_to_upper(f);
							string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						string_free(&f);
					}
					break;
			}
			case StrIntpType__si_g64: {
					if (use_default_str) {
						#if !defined(CUSTOM_DEFINE_nofloat)
						{
							string f = f64_strg(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
						#endif
					} else {
						if (data->d.d_f64 == _const_strconv__double_plus_zero) {
							string tmp_str = _SLIT("0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f64 == _const_strconv__double_minus_zero) {
							string tmp_str = _SLIT("-0");
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
							return;
						}
						if (data->d.d_f64 == _const_strconv__double_plus_infinity) {
							string tmp_str = _SLIT("+inf");
							if (upper_case) {
								tmp_str = _SLIT("+INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f64 == _const_strconv__double_minus_infinity) {
							string tmp_str = _SLIT("-inf");
							if (upper_case) {
								tmp_str = _SLIT("-INF");
							}
							strconv__format_str_sb(tmp_str, bf, sb);
							string_free(&tmp_str);
						}
						if (data->d.d_f64 < 0) {
							bf.positive = false;
						}
						f64 d = fabs64(data->d.d_f64);
						if (d < ((f64)(999999.0)) && d >= ((f64)(0.00001))) {
							string f = strconv__format_fl(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
							return;
						}
						string f = strconv__format_es(data->d.d_f64, bf);
						if (upper_case) {
							string tmp = f;
							f = string_to_upper(f);
							string_free(&tmp);
						}
						strings__Builder_write_string(sb, f);
						string_free(&f);
					}
					break;
			}
			case StrIntpType__si_e32: {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						bf.len1 = 6;
						if (use_default_str) {
							string f = f32_str(data->d.d_f32);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f32 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_es(data->d.d_f32, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
			}
			case StrIntpType__si_e64: {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						bf.len1 = 6;
						if (use_default_str) {
							string f = f64_str(data->d.d_f64);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						} else {
							if (data->d.d_f64 < 0) {
								bf.positive = false;
							}
							string f = strconv__format_es(data->d.d_f64, bf);
							if (upper_case) {
								string tmp = f;
								f = string_to_upper(f);
								string_free(&tmp);
							}
							strings__Builder_write_string(sb, f);
							string_free(&f);
						}
					}
					#endif
					break;
			}
			case StrIntpType__si_c: {
					string ss = utf32_to_str(data->d.d_c);
					strings__Builder_write_string(sb, ss);
					string_free(&ss);
					break;
			}
			case StrIntpType__si_vp: {
					string ss = u64_hex(((u64)(data->d.d_vp)));
					strings__Builder_write_string(sb, ss);
					string_free(&ss);
					break;
			}
			case StrIntpType__si_no_str:
			case StrIntpType__si_u8:
			case StrIntpType__si_i8:
			case StrIntpType__si_u16:
			case StrIntpType__si_i16:
			case StrIntpType__si_u32:
			case StrIntpType__si_i32:
			case StrIntpType__si_u64:
			case StrIntpType__si_i64:
			case StrIntpType__si_s:
			case StrIntpType__si_p:
			default: {
					strings__Builder_write_string(sb, _SLIT("***ERROR!***"));
					break;
			}
		}
		
	}
}

// Attr: [direct_array_access]
// Attr: [manualfree]
string str_intp(int data_len, StrIntpData* input_base) {
	strings__Builder res = strings__new_builder(256);
	for (int i = 0; i < data_len; i++) {
		StrIntpData* data = &input_base[i];
		if (data->str.len != 0) {
			strings__Builder_write_string(&res, data->str);
		}
		if (data->fmt != 0U) {
			StrIntpData_process_str_intp_data(data, (voidptr)&/*qq*/res);
		}
	}
	string ret = strings__Builder_str(&res);
	strings__Builder_free(&res);
	return ret;
}

// Attr: [inline]
inline string str_intp_sq(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\"\'\"), "), /*115 &string*/0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), /*115 &string*/0xfe10, {.d_s = in_str}}, {_SLIT("}},{_SLIT(\"\'\"), 0, {.d_c = 0 }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_rune(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\"`\"), "), /*115 &string*/0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), /*115 &string*/0xfe10, {.d_s = in_str}}, {_SLIT("}},{_SLIT(\"`\"), 0, {.d_c = 0 }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_g32(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), /*115 &string*/0xfe10, {.d_s = _const_si_g32_code}}, {_SLIT(", {.d_f32 = "), /*115 &string*/0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [inline]
inline string str_intp_g64(string in_str) {
	return  str_intp(3, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT0, "), /*115 &string*/0xfe10, {.d_s = _const_si_g64_code}}, {_SLIT(", {.d_f64 = "), /*115 &string*/0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
}

// Attr: [manualfree]
string str_intp_sub(string base_str, string in_str) {
	_option_int _t1 = string_index(base_str, _SLIT("%%"));
	if (_t1.state != 0) {
		IError err = _t1.err;
		eprintln(_SLIT("No string interpolation %% parameters"));
		_v_exit(1);
		VUNREACHABLE();
	;
	}
	
 	int index =  (*(int*)_t1.data);
	{ // Unsafe block
		string st_str = string_substr(base_str, 0, index);
		if ((int)(index + 2) < base_str.len) {
			string en_str = string_substr(base_str, (int)(index + 2), 2147483647);
			string res_str =  str_intp(5, _MOV((StrIntpData[]){{_SLIT("str_intp(2, _MOV((StrIntpData[]){{_SLIT(\""), /*115 &string*/0xfe10, {.d_s = st_str}}, {_SLIT("\"), "), /*115 &string*/0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), /*115 &string*/0xfe10, {.d_s = in_str}}, {_SLIT(" }},{_SLIT(\""), /*115 &string*/0xfe10, {.d_s = en_str}}, {_SLIT("\"), 0, {.d_c = 0}}}))"), 0, { .d_c = 0 }}}));
			string_free(&st_str);
			string_free(&en_str);
			return res_str;
		}
		string res2_str =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("str_intp(1, _MOV((StrIntpData[]){{_SLIT(\""), /*115 &string*/0xfe10, {.d_s = st_str}}, {_SLIT("\"), "), /*115 &string*/0xfe10, {.d_s = _const_si_s_code}}, {_SLIT(", {.d_s = "), /*115 &string*/0xfe10, {.d_s = in_str}}, {_SLIT(" }}}))"), 0, { .d_c = 0 }}}));
		string_free(&st_str);
		return res2_str;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

u16* string_to_wide(string _str) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int num_chars = (MultiByteToWideChar(_const_cp_utf8, 0U, ((char*)(_str.str)), _str.len, 0, 0));
			u16* wstr = ((u16*)(malloc_noscan((int)(((int)(num_chars + 1)) * 2))));
			if (wstr != 0) {
				MultiByteToWideChar(_const_cp_utf8, 0U, ((char*)(_str.str)), _str.len, wstr, num_chars);
				memset(((u8*)(wstr)) + (int)(num_chars * 2), 0, 2);
			}
			return wstr;
		}
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [manualfree]
// Attr: [unsafe]
string string_from_wide(u16* _wstr) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			usize wstr_len = wcslen(_wstr);
			return string_from_wide2(_wstr, ((int)(wstr_len)));
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
// Attr: [unsafe]
string string_from_wide2(u16* _wstr, int len) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int num_chars = WideCharToMultiByte(_const_cp_utf8, 0U, _wstr, len, 0, 0, 0, 0);
			u8* str_to = malloc_noscan((int)(num_chars + 1));
			if (str_to != 0) {
				WideCharToMultiByte(_const_cp_utf8, 0U, _wstr, len, ((char*)(str_to)), num_chars, 0, 0);
				memset(str_to + num_chars, 0, 1);
			}
			return tos2(str_to);
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

int utf8_char_len(u8 b) {
	return (int_literal)(((((0xe5000000 >> ((((b >> 3)) & 0x1e)))) & 3)) + 1);
}

string utf32_to_str(u32 code) {
	{ // Unsafe block
		u8* buffer = malloc_noscan(5);
		string res = utf32_to_str_no_malloc(code, buffer);
		if (res.len == 0) {
			_v_free(buffer);
		}
		return res;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
// Attr: [unsafe]
string utf32_to_str_no_malloc(u32 code, u8* buf) {
	{ // Unsafe block
		int len = utf32_decode_to_buffer(code, buf);
		if (len == 0) {
			return _SLIT("");
		}
		buf[len] = 0;
		return tos(buf, len);
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
// Attr: [unsafe]
int utf32_decode_to_buffer(u32 code, u8* buf) {
	{ // Unsafe block
		int icode = ((int)(code));
		u8* buffer = ((u8*)(buf));
		if (icode <= 127) {
			buffer[0] = ((u8)(icode));
			return 1;
		} else if (icode <= 2047) {
			buffer[0] = (192 | ((u8)((icode >> 6))));
			buffer[1] = (128 | ((u8)((icode & 63))));
			return 2;
		} else if (icode <= 65535) {
			buffer[0] = (224 | ((u8)((icode >> 12))));
			buffer[1] = (128 | ((((u8)((icode >> 6))) & 63)));
			buffer[2] = (128 | ((u8)((icode & 63))));
			return 3;
		} else if (icode <= 1114111) {
			buffer[0] = (240 | ((u8)((icode >> 18))));
			buffer[1] = (128 | ((((u8)((icode >> 12))) & 63)));
			buffer[2] = (128 | ((((u8)((icode >> 6))) & 63)));
			buffer[3] = (128 | ((u8)((icode & 63))));
			return 4;
		}
	}
	return 0;
}

int string_utf32_code(string _rune) {
	_result_rune _t2 = Array_u8_utf8_to_utf32(string_bytes(_rune));
	if (_t2.is_error) {
		IError err = _t2.err;
		*(rune*) _t2.data = ((rune)(0));
	}
	
 	return ((int)( (*(rune*)_t2.data)));
}

_result_rune Array_u8_utf8_to_utf32(Array_u8 _bytes) {
	if (_bytes.len == 0) {
		_result_rune _t1;
		_result_ok(&(rune[]) { 0 }, (_result*)(&_t1), sizeof(rune));
		return _t1;
	}
	if (_bytes.len == 1) {
		_result_rune _t2;
		_result_ok(&(rune[]) { ((rune)((*(u8*)array_get(_bytes, 0)))) }, (_result*)(&_t2), sizeof(rune));
		return _t2;
	}
	if (_bytes.len > 4) {
		return (_result_rune){ .is_error=true, .err=_v_error(_SLIT("attempted to decode too many bytes, utf-8 is limited to four bytes maximum")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	u8 b = ((u8)(((int)((*(u8*)array_get(_bytes, 0))))));
	b = (b << _bytes.len);
	rune res = ((rune)(b));
	int shift = (int)(6 - _bytes.len);
	for (int i = 1; i < _bytes.len; i++) {
		rune c = ((rune)((*(u8*)array_get(_bytes, i))));
		res = (((rune)(res)) << shift);
		res |= (c & 63);
		shift = 6;
	}
	_result_rune _t4;
	_result_ok(&(rune[]) { res }, (_result*)(&_t4), sizeof(rune));
	return _t4;
}

int utf8_str_visible_length(string s) {
	int l = 0;
	int ul = 1;
	for (int i = 0; i < s.len; i += ul) {
		u8 c = s.str[i];
		ul = (int_literal)(((((0xe5000000 >> ((((s.str[i] >> 3)) & 0x1e)))) & 3)) + 1);
		if ((int)(i + ul) > s.len) {
			return l;
		}
		l++;
		if (ul == 1) {
			continue;
		}

		if (ul == (2)) {
			u64 r = ((u64)((((((u16)(c)) << 8U)) | s.str[(int)(i + 1)])));
			if (r >= 0xcc80U && r < 0xcdb0U) {
				l--;
			}
		}
		else if (ul == (3)) {
			u64 r = ((u64)((((((u32)(c)) << 16U)) | (((((u32)(s.str[(int)(i + 1)])) << 8U)) | s.str[(int)(i + 2)]))));
			if ((r >= 0xe1aab0U && r <= 0xe1ac7fU) || (r >= 0xe1b780U && r <= 0xe1b87fU) || (r >= 0xe28390U && r <= 0xe2847fU) || (r >= 0xefb8a0U && r <= 0xefb8afU)) {
				l--;
			} else if ((r >= 0xe18480U && r <= 0xe1859fU) || (r >= 0xe2ba80U && r <= 0xe2bf95U) || (r >= 0xe38080U && r <= 0xe4b77fU) || (r >= 0xe4b880U && r <= 0xea807fU) || (r >= 0xeaa5a0U && r <= 0xeaa79fU) || (r >= 0xeab080U && r <= 0xed9eafU) || (r >= 0xefa480U && r <= 0xefac7fU) || (r >= 0xefb8b8U && r <= 0xefb9afU)) {
				l++;
			}
		}
		else if (ul == (4)) {
			u64 r = ((u64)((((((u32)(c)) << 24U)) | ((((((u32)(s.str[(int)(i + 1)])) << 16U)) | ((((u32)(s.str[(int)(i + 2)])) << 8U))) | s.str[(int)(i + 3)]))));
			if ((r >= 0x0f9f8880U && r <= 0xf09f8a8fU) || (r >= 0xf09f8c80U && r <= 0xf09f9c90U) || (r >= 0xf09fa490U && r <= 0xf09fa7afU) || (r >= 0xf0a08080U && r <= 0xf180807fU)) {
				l++;
			}
		}
		else {
		}
	}
	return l;
}

// Attr: [inline]
inline bool ArrayFlags_is_empty(ArrayFlags* e) {
	return ((int)(*e)) == 0;
}

// Attr: [inline]
inline bool ArrayFlags_has(ArrayFlags* e, ArrayFlags flag) {
	return ((((int)(*e)) & (((int)(flag))))) != 0;
}

// Attr: [inline]
inline bool ArrayFlags_all(ArrayFlags* e, ArrayFlags flag) {
	return ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
}

// Attr: [inline]
inline void ArrayFlags_set(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void ArrayFlags_set_all(ArrayFlags* e) {
	{ // Unsafe block
		*e = ((ArrayFlags)(0b1111));
	}
}

// Attr: [inline]
inline void ArrayFlags_clear(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void ArrayFlags_clear_all(ArrayFlags* e) {
	{ // Unsafe block
		*e = ((ArrayFlags)(0));
	}
}

// Attr: [inline]
inline void ArrayFlags_toggle(ArrayFlags* e, ArrayFlags flag) {
	{ // Unsafe block
		*e = ((ArrayFlags)((((int)(*e)) ^ (((int)(flag))))));
	}
}

VV_LOCAL_SYMBOL string net__urllib__error_msg(string message, string val) {
	string msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("net.urllib."), /*115 &string*/0xfe10, {.d_s = message}}, {_SLIT0, 0, { .d_c = 0 }}}));
	if ((val).len != 0) {
		msg =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = msg}}, {_SLIT(" ("), /*115 &string*/0xfe10, {.d_s = val}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	}
	return msg;
}

VV_LOCAL_SYMBOL bool net__urllib__should_escape(u8 c, net__urllib__EncodingMode mode) {
	if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')) {
		bool _t1 = false;
		return _t1;
	}
	if (mode == net__urllib__EncodingMode__encode_host || mode == net__urllib__EncodingMode__encode_zone) {
		if (c == '!' || c == '$' || c == '&' || c == '\\' || c == '(' || c == ')' || c == '*' || c == '+' || c == ',' || c == ';' || c == '=' || c == ':' || c == '[' || c == ']' || c == '<' || c == '>' || c == '"') {
			bool _t2 = false;
			return _t2;
		}
	}
	switch (c) {
		case '-': case '_': case '.': case '~': {
				bool _t3 = false;
				return _t3;
		}
		case '$': case '&': case '+': case ',': case '/': case ':': case ';': case '=': case '?': case '@': {
				switch (mode) {
					case net__urllib__EncodingMode__encode_path: {
							bool _t4 = c == '?';
							return _t4;
					}
					case net__urllib__EncodingMode__encode_path_segment: {
							bool _t5 = c == '/' || c == ';' || c == ',' || c == '?';
							return _t5;
					}
					case net__urllib__EncodingMode__encode_user_password: {
							bool _t6 = c == '@' || c == '/' || c == '?' || c == ':';
							return _t6;
					}
					case net__urllib__EncodingMode__encode_query_component: {
							bool _t7 = true;
							return _t7;
					}
					case net__urllib__EncodingMode__encode_fragment: {
							bool _t8 = false;
							return _t8;
					}
					case net__urllib__EncodingMode__encode_host:
					case net__urllib__EncodingMode__encode_zone:
					default: {
							break;
					}
				}
				
				break;
		}
		default: {
				break;
		}
	}
	
	if (mode == net__urllib__EncodingMode__encode_fragment) {
		switch (c) {
			case '!': case '(': case ')': case '*': {
					bool _t9 = false;
					return _t9;
			}
			default: {
					break;
			}
		}
		
	}
	bool _t10 = true;
	return _t10;
}

_result_string net__urllib__query_unescape(string s) {
	_result_string _t1 = net__urllib__unescape(s, net__urllib__EncodingMode__encode_query_component);
	return _t1;
}

_result_string net__urllib__path_unescape(string s) {
	_result_string _t1 = net__urllib__unescape(s, net__urllib__EncodingMode__encode_path_segment);
	return _t1;
}

VV_LOCAL_SYMBOL _result_string net__urllib__unescape(string s_, net__urllib__EncodingMode mode) {
	string s = s_;
	int n = 0;
	bool has_plus = false;
	for (int i = 0; i < s.len; ) {
		u8 x = string_at(s, i);

		if (x == ('%')) {
			if ((s).len == 0) {
				break;
			}
			n++;
			if ((int)(i + 2) >= s.len || !net__urllib__ishex(string_at(s, (int)(i + 1))) || !net__urllib__ishex(string_at(s, (int)(i + 2)))) {
				if (mode == net__urllib__EncodingMode__encode_query_component && (int)(i + 1) < s.len) {
					s = string__plus(string__plus(string_substr(s, 0, i), _SLIT("%25")), string_substr(s, ((int)(i + 1)), 2147483647));
					i += 4;
					continue;
				}
				s = string_substr(s, i, 2147483647);
				if (s.len > 3) {
					s = string_substr(s, 0, 3);
				}
				return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_const_net__urllib__err_msg_escape, s)), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			if ((int)(i + 3) >= s.len && mode == net__urllib__EncodingMode__encode_host && net__urllib__unhex(string_at(s, (int)(i + 1))) < 8 && !string__eq(string_substr(s, i, (int)(i + 3)), _SLIT("%25"))) {
				return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_const_net__urllib__err_msg_escape, string_substr(s, i, (int)(i + 3)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			if (mode == net__urllib__EncodingMode__encode_zone) {
				if ((int)(i + 3) >= s.len) {
					return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("unescape: invalid escape sequence"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				u8 v = ((((net__urllib__unhex(string_at(s, (int)(i + 1))) << ((u8)(4)))) | net__urllib__unhex(string_at(s, (int)(i + 2)))));
				if (!string__eq(string_substr(s, i, (int)(i + 3)), _SLIT("%25")) && v != ' ' && net__urllib__should_escape(v, net__urllib__EncodingMode__encode_host)) {
					_v_error(net__urllib__error_msg(_const_net__urllib__err_msg_escape, string_substr(s, i, (int)(i + 3))));
				}
			}
			i += 3;
		}
		else if (x == ('+')) {
			has_plus = mode == net__urllib__EncodingMode__encode_query_component;
			i++;
		}
		else {
			if ((mode == net__urllib__EncodingMode__encode_host || mode == net__urllib__EncodingMode__encode_zone) && string_at(s, i) < 0x80 && net__urllib__should_escape(string_at(s, i), mode)) {
				_v_error(net__urllib__error_msg(_SLIT("unescape: invalid character in host name"), string_substr(s, i, (int)(i + 1))));
			}
			i++;
		}
	}
	if (n == 0 && !has_plus) {
		_result_string _t4;
		_result_ok(&(string[]) {  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})) }, (_result*)(&_t4), sizeof(string));
		return _t4;
	}
	if (s.len < (int)(2 * n)) {
		return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("unescape: invalid escape sequence"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	strings__Builder t = strings__new_builder((int)(s.len - (int)(2 * n)));
	for (int i = 0; i < s.len; i++) {
		u8 x = string_at(s, i);

		if (x == ('%')) {
			if ((int)(i + 2) >= s.len) {
				return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("unescape: invalid escape sequence"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			strings__Builder_write_string(&t, u8_ascii_str(((((net__urllib__unhex(string_at(s, (int)(i + 1))) << ((u8)(4)))) | net__urllib__unhex(string_at(s, (int)(i + 2)))))));
			i += 2;
		}
		else if (x == ('+')) {
			if (mode == net__urllib__EncodingMode__encode_query_component) {
				strings__Builder_write_string(&t, _SLIT(" "));
			} else {
				strings__Builder_write_string(&t, _SLIT("+"));
			}
		}
		else {
			strings__Builder_write_string(&t, u8_ascii_str(string_at(s, i)));
		}
	}
	_result_string _t7;
	_result_ok(&(string[]) { strings__Builder_str(&t) }, (_result*)(&_t7), sizeof(string));
	return _t7;
}

string net__urllib__query_escape(string s) {
	string _t1 = net__urllib__escape(s, net__urllib__EncodingMode__encode_query_component);
	return _t1;
}

string net__urllib__path_escape(string s) {
	string _t1 = net__urllib__escape(s, net__urllib__EncodingMode__encode_path_segment);
	return _t1;
}

VV_LOCAL_SYMBOL string net__urllib__escape(string s, net__urllib__EncodingMode mode) {
	int space_count = 0;
	int hex_count = 0;
	u8 c = ((u8)(0));
	for (int i = 0; i < s.len; ++i) {
		c = string_at(s, i);
		if (net__urllib__should_escape(c, mode)) {
			if (c == ' ' && mode == net__urllib__EncodingMode__encode_query_component) {
				space_count++;
			} else {
				hex_count++;
			}
		}
	}
	if (space_count == 0 && hex_count == 0) {
		return s;
	}
	int required = (int)(s.len + (int)(2 * hex_count));
	Array_u8 t = __new_array_with_default_noscan(required, 0, sizeof(u8), 0);
	if (hex_count == 0) {
		copy(&/*arr*/t, string_bytes(s));
		for (int i = 0; i < s.len; ++i) {
			if (string_at(s, i) == ' ') {
				array_set(&t, i, &(u8[]) { '+' });
			}
		}
		string _t2 = Array_u8_bytestr(t);
		return _t2;
	}
	string upperhex = _SLIT("0123456789ABCDEF");
	int j = 0;
	for (int i = 0; i < s.len; ++i) {
		u8 c1 = string_at(s, i);
		if (c1 == ' ' && mode == net__urllib__EncodingMode__encode_query_component) {
			array_set(&t, j, &(u8[]) { '+' });
			j++;
		} else if (net__urllib__should_escape(c1, mode)) {
			array_set(&t, j, &(u8[]) { '%' });
			array_set(&t, (int)(j + 1), &(u8[]) { string_at(upperhex, (c1 >> 4)) });
			array_set(&t, (int)(j + 2), &(u8[]) { string_at(upperhex, (c1 & 15)) });
			j += 3;
		} else {
			array_set(&t, j, &(u8[]) { string_at(s, i) });
			j++;
		}
	}
	string _t3 = Array_u8_bytestr(t);
	return _t3;
}

string net__urllib__URL_debug(net__urllib__URL* url) {
	string _t1 =  str_intp(10, _MOV((StrIntpData[]){{_SLIT("URL{\n  scheme: "), /*115 &string*/0xfe10, {.d_s = url->scheme}}, {_SLIT("\n  opaque: "), /*115 &string*/0xfe10, {.d_s = url->opaque}}, {_SLIT("\n  user: "), /*115 &net.urllib.Userinfo*/0xfe10, {.d_s = str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s = isnil(url->user) ? _SLIT("nil") : net__urllib__Userinfo_str(url->user)}}}))}}, {_SLIT("\n  host: "), /*115 &string*/0xfe10, {.d_s = url->host}}, {_SLIT("\n  path: "), /*115 &string*/0xfe10, {.d_s = url->path}}, {_SLIT("\n  raw_path: "), /*115 &string*/0xfe10, {.d_s = url->raw_path}}, {_SLIT("\n  force_query: "), /*115 &bool*/0xfe10, {.d_s = url->force_query ? _SLIT("true") : _SLIT("false")}}, {_SLIT("\n  raw_query: "), /*115 &string*/0xfe10, {.d_s = url->raw_query}}, {_SLIT("\n  fragment: "), /*115 &string*/0xfe10, {.d_s = url->fragment}}, {_SLIT("\n}"), 0, { .d_c = 0 }}}));
	return _t1;
}

net__urllib__Userinfo* net__urllib__user(string username) {
	net__urllib__Userinfo* _t1 = ((net__urllib__Userinfo*)memdup(&(net__urllib__Userinfo){.username = username,.password = _SLIT(""),.password_set = false,}, sizeof(net__urllib__Userinfo)));
	return _t1;
}

VV_LOCAL_SYMBOL net__urllib__Userinfo* net__urllib__user_password(string username, string password) {
	net__urllib__Userinfo* _t1 = ((net__urllib__Userinfo*)memdup(&(net__urllib__Userinfo){.username = username,.password = password,.password_set = true,}, sizeof(net__urllib__Userinfo)));
	return _t1;
}

VV_LOCAL_SYMBOL bool net__urllib__Userinfo_empty(net__urllib__Userinfo* u) {
	bool _t1 = isnil(u) || ((u->username).len == 0 && (u->password).len == 0);
	return _t1;
}

VV_LOCAL_SYMBOL string net__urllib__Userinfo_str(net__urllib__Userinfo* u) {
	if (net__urllib__Userinfo_empty(u)) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string s = net__urllib__escape(u->username, net__urllib__EncodingMode__encode_user_password);
	if (u->password_set) {
		s = string__plus(s, string__plus(_SLIT(":"), net__urllib__escape(u->password, net__urllib__EncodingMode__encode_user_password)));
	}
	return s;
}

VV_LOCAL_SYMBOL _result_Array_string net__urllib__split_by_scheme(string rawurl) {
	for (int i = 0; i < rawurl.len; ++i) {
		u8 c = string_at(rawurl, i);
		if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
		} else if (('0' <= c && c <= '9') || (c == '+' || c == '-' || c == '.')) {
			if (i == 0) {
				_result_Array_string _t1;
				_result_ok(&(Array_string[]) { new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(""), string_clone(rawurl)})) }, (_result*)(&_t1), sizeof(Array_string));
				return _t1;
			}
		} else if (c == ':') {
			if (i == 0) {
				return (_result_Array_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("split_by_scheme: missing protocol scheme"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			_result_Array_string _t3;
			_result_ok(&(Array_string[]) { new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(string_substr(rawurl, 0, i)), string_clone(string_substr(rawurl, (int_literal)(i + 1), 2147483647))})) }, (_result*)(&_t3), sizeof(Array_string));
			return _t3;
		} else {
			_result_Array_string _t4;
			_result_ok(&(Array_string[]) { new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(""), string_clone(rawurl)})) }, (_result*)(&_t4), sizeof(Array_string));
			return _t4;
		}
	}
	_result_Array_string _t5;
	_result_ok(&(Array_string[]) { new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){_SLIT(""), string_clone(rawurl)})) }, (_result*)(&_t5), sizeof(Array_string));
	return _t5;
}

VV_LOCAL_SYMBOL _result_string net__urllib__get_scheme(string rawurl) {
	_result_Array_string _t1 = net__urllib__split_by_scheme(rawurl);
	if (_t1.is_error) {
		IError err = _t1.err;
		_result_string _t2;
		_result_ok(&(string[]) { IError_name_table[err._typ]._method_msg(err._object) }, (_result*)(&_t2), sizeof(string));
		return _t2;
	}
	
 	Array_string split =  (*(Array_string*)_t1.data);
	_result_string _t3;
	_result_ok(&(string[]) { (*(string*)array_get(split, 0)) }, (_result*)(&_t3), sizeof(string));
	return _t3;
}

VV_LOCAL_SYMBOL multi_return_string_string net__urllib__split(string s, u8 sep, bool cutc) {
	int i = string_index_u8(s, sep);
	if (i < 0) {
		return (multi_return_string_string){.arg0=s, .arg1=_SLIT("")};
	}
	if (cutc) {
		return (multi_return_string_string){.arg0=string_substr(s, 0, i), .arg1=string_substr(s, (int)(i + 1), 2147483647)};
	}
	return (multi_return_string_string){.arg0=string_substr(s, 0, i), .arg1=string_substr(s, i, 2147483647)};
}

_result_net__urllib__URL net__urllib__parse(string rawurl) {
	multi_return_string_string mr_13821 = net__urllib__split(rawurl, '#', true);
	string u = mr_13821.arg0;
	string frag = mr_13821.arg1;
	_result_net__urllib__URL _t1 = net__urllib__parse_url(u, false);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_const_net__urllib__err_msg_parse, u)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__urllib__URL url =  (*(net__urllib__URL*)_t1.data);
	if ((frag).len == 0) {
		_result_net__urllib__URL _t3;
		_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t3), sizeof(net__urllib__URL));
		return _t3;
	}
	_result_string _t4 = net__urllib__unescape(frag, net__urllib__EncodingMode__encode_fragment);
	if (_t4.is_error) {
		IError err = _t4.err;
		return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_const_net__urllib__err_msg_parse, u)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string f =  (*(string*)_t4.data);
	url.fragment = f;
	_result_net__urllib__URL _t6;
	_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t6), sizeof(net__urllib__URL));
	return _t6;
}

VV_LOCAL_SYMBOL _result_net__urllib__URL net__urllib__parse_request_uri(string rawurl) {
	_result_net__urllib__URL _t1 = net__urllib__parse_url(rawurl, true);
	return _t1;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL _result_net__urllib__URL net__urllib__parse_url(string rawurl, bool via_request) {
	if (net__urllib__string_contains_ctl_u8(rawurl)) {
		return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_url: invalid control character in URL"), rawurl)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if ((rawurl).len == 0 && via_request) {
		return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_url: empty URL"), rawurl)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	net__urllib__URL url = ((net__urllib__URL){.scheme = (string){.str=(byteptr)"", .is_lit=1},.opaque = (string){.str=(byteptr)"", .is_lit=1},.user = ((void*)0),.host = (string){.str=(byteptr)"", .is_lit=1},.path = (string){.str=(byteptr)"", .is_lit=1},.raw_path = (string){.str=(byteptr)"", .is_lit=1},.force_query = 0,.raw_query = (string){.str=(byteptr)"", .is_lit=1},.fragment = (string){.str=(byteptr)"", .is_lit=1},});
	if (string__eq(rawurl, _SLIT("*"))) {
		url.path = _SLIT("*");
		_result_net__urllib__URL _t3;
		_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t3), sizeof(net__urllib__URL));
		return _t3;
	}
	_result_Array_string _t4 = net__urllib__split_by_scheme(rawurl);
	if (_t4.is_error) {
		_result_net__urllib__URL _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	Array_string p =  (*(Array_string*)_t4.data);
	url.scheme = (*(string*)array_get(p, 0));
	string rest = (*(string*)array_get(p, 1));
	url.scheme = string_to_lower(url.scheme);
	if (string_ends_with(rest, _SLIT("?")) && !string_contains(string_substr(rest, 0, 1), _SLIT("?"))) {
		url.force_query = true;
		rest = string_substr(rest, 0, (int)(rest.len - 1));
	} else {
		multi_return_string_string mr_15578 = net__urllib__split(rest, '?', true);
		string r = mr_15578.arg0;
		string raw_query = mr_15578.arg1;
		rest = r;
		url.raw_query = raw_query;
	}
	if (!string_starts_with(rest, _SLIT("/"))) {
		if ((url.scheme).len != 0) {
			url.opaque = rest;
			_result_net__urllib__URL _t6;
			_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t6), sizeof(net__urllib__URL));
			return _t6;
		}
		if (via_request) {
			return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_url: invalid URI for request"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_option_int _t8 = string_index(rest, _SLIT(":"));
		if (_t8.state != 0) {
			IError err = _t8.err;
			return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(_SLIT("there should be a : in the URL")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		int colon =  (*(int*)_t8.data);
		_option_int _t10 = string_index(rest, _SLIT("/"));
		if (_t10.state != 0) {
			IError err = _t10.err;
			return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(_SLIT("there should be a / in the URL")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		int slash =  (*(int*)_t10.data);
		if (colon >= 0 && (slash < 0 || colon < slash)) {
			return (_result_net__urllib__URL){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_url: first path segment in URL cannot contain colon"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if ((((url.scheme).len != 0 || !via_request) && !string_starts_with(rest, _SLIT("///"))) && string_starts_with(rest, _SLIT("//"))) {
		multi_return_string_string mr_16675 = net__urllib__split(string_substr(rest, 2, 2147483647), '/', false);
		string authority = mr_16675.arg0;
		string r = mr_16675.arg1;
		rest = r;
		_result_net__urllib__ParseAuthorityRes _t13 = net__urllib__parse_authority(authority);
		if (_t13.is_error) {
			_result_net__urllib__URL _t14;
			memcpy(&_t14, &_t13, sizeof(_result));
			return _t14;
		}
		
 		net__urllib__ParseAuthorityRes a =  (*(net__urllib__ParseAuthorityRes*)_t13.data);
		url.user = a.user;
		url.host = a.host;
	}
	_result_bool _t15 = net__urllib__URL_set_path(&url, rest);
	if (_t15.is_error) {
		_result_net__urllib__URL _t16;
		memcpy(&_t16, &_t15, sizeof(_result));
		return _t16;
	}
	
  (*(bool*)_t15.data);
	_result_net__urllib__URL _t17;
	_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t17), sizeof(net__urllib__URL));
	return _t17;
}

VV_LOCAL_SYMBOL _result_net__urllib__ParseAuthorityRes net__urllib__parse_authority(string authority) {
	int i = string_index_u8_last(authority, '@');
	string host = _SLIT("");
	net__urllib__Userinfo* zuser = net__urllib__user(_SLIT(""));
	if (i < 0) {
		_result_string _t1 = net__urllib__parse_host(authority);
		if (_t1.is_error) {
			_result_net__urllib__ParseAuthorityRes _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 		string h =  (*(string*)_t1.data);
		host = h;
	} else {
		_result_string _t3 = net__urllib__parse_host(string_substr(authority, (int)(i + 1), 2147483647));
		if (_t3.is_error) {
			_result_net__urllib__ParseAuthorityRes _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 		string h =  (*(string*)_t3.data);
		host = h;
	}
	if (i < 0) {
		_result_net__urllib__ParseAuthorityRes _t5;
		_result_ok(&(net__urllib__ParseAuthorityRes[]) { ((net__urllib__ParseAuthorityRes){.user = zuser,.host = host,}) }, (_result*)(&_t5), sizeof(net__urllib__ParseAuthorityRes));
		return _t5;
	}
	string userinfo = string_substr(authority, 0, i);
	if (!net__urllib__valid_userinfo(userinfo)) {
		return (_result_net__urllib__ParseAuthorityRes){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_authority: invalid userinfo"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!string_contains(userinfo, _SLIT(":"))) {
		_result_string _t7 = net__urllib__unescape(userinfo, net__urllib__EncodingMode__encode_user_password);
		if (_t7.is_error) {
			_result_net__urllib__ParseAuthorityRes _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 		string u =  (*(string*)_t7.data);
		userinfo = u;
		zuser = net__urllib__user(userinfo);
	} else {
		multi_return_string_string mr_17751 = net__urllib__split(userinfo, ':', true);
		string username = mr_17751.arg0;
		string password = mr_17751.arg1;
		_result_string _t9 = net__urllib__unescape(username, net__urllib__EncodingMode__encode_user_password);
		if (_t9.is_error) {
			_result_net__urllib__ParseAuthorityRes _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 		string u =  (*(string*)_t9.data);
		username = u;
		_result_string _t11 = net__urllib__unescape(password, net__urllib__EncodingMode__encode_user_password);
		if (_t11.is_error) {
			_result_net__urllib__ParseAuthorityRes _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 		string p =  (*(string*)_t11.data);
		password = p;
		zuser = net__urllib__user_password(username, password);
	}
	_result_net__urllib__ParseAuthorityRes _t13;
	_result_ok(&(net__urllib__ParseAuthorityRes[]) { ((net__urllib__ParseAuthorityRes){.user = zuser,.host = host,}) }, (_result*)(&_t13), sizeof(net__urllib__ParseAuthorityRes));
	return _t13;
}

VV_LOCAL_SYMBOL _result_string net__urllib__parse_host(string host) {
	if (host.len > 0 && string_at(host, 0) == '[') {
		int i = string_index_u8_last(host, ']');
		if (i == -1) {
			return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_host: missing ']' in host"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		string colon_port = string_substr(host, (int)(i + 1), 2147483647);
		if (!net__urllib__valid_optional_port(colon_port)) {
			return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg( str_intp(2, _MOV((StrIntpData[]){{_SLIT("parse_host: invalid port "), /*115 &string*/0xfe10, {.d_s = colon_port}}, {_SLIT(" after host "), 0, { .d_c = 0 }}})), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_option_int _t3;
		if (_t3 = string_index(string_substr(host, 0, i), _SLIT("%25")), _t3.state == 0) {
			int zone = *(int*)_t3.data;
			_result_string _t4 = net__urllib__unescape(string_substr(host, 0, zone), net__urllib__EncodingMode__encode_host);
			if (_t4.is_error) {
				IError err = _t4.err;
				_result_string _t5;
				_result_ok(&(string[]) { IError_name_table[err._typ]._method_msg(err._object) }, (_result*)(&_t5), sizeof(string));
				return _t5;
			}
			
 			string host1 =  (*(string*)_t4.data);
			_result_string _t6 = net__urllib__unescape(string_substr(host, zone, i), net__urllib__EncodingMode__encode_zone);
			if (_t6.is_error) {
				IError err = _t6.err;
				_result_string _t7;
				_result_ok(&(string[]) { IError_name_table[err._typ]._method_msg(err._object) }, (_result*)(&_t7), sizeof(string));
				return _t7;
			}
			
 			string host2 =  (*(string*)_t6.data);
			_result_string _t8 = net__urllib__unescape(string_substr(host, i, 2147483647), net__urllib__EncodingMode__encode_host);
			if (_t8.is_error) {
				IError err = _t8.err;
				_result_string _t9;
				_result_ok(&(string[]) { IError_name_table[err._typ]._method_msg(err._object) }, (_result*)(&_t9), sizeof(string));
				return _t9;
			}
			
 			string host3 =  (*(string*)_t8.data);
			_result_string _t10;
			_result_ok(&(string[]) { string__plus(string__plus(host1, host2), host3) }, (_result*)(&_t10), sizeof(string));
			return _t10;
		}
	} else {
		int i = string_index_u8_last(host, ':');
		if (i != -1) {
			string colon_port = string_substr(host, i, 2147483647);
			if (!net__urllib__valid_optional_port(colon_port)) {
				return (_result_string){ .is_error=true, .err=_v_error(net__urllib__error_msg( str_intp(2, _MOV((StrIntpData[]){{_SLIT("parse_host: invalid port "), /*115 &string*/0xfe10, {.d_s = colon_port}}, {_SLIT(" after host "), 0, { .d_c = 0 }}})), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	_result_string _t12 = net__urllib__unescape(host, net__urllib__EncodingMode__encode_host);
	if (_t12.is_error) {
		IError err = _t12.err;
		_result_string _t13;
		_result_ok(&(string[]) { IError_name_table[err._typ]._method_msg(err._object) }, (_result*)(&_t13), sizeof(string));
		return _t13;
	}
	
 	string h =  (*(string*)_t12.data);
	_result_string _t14;
	_result_ok(&(string[]) { h }, (_result*)(&_t14), sizeof(string));
	return _t14;
}

_result_bool net__urllib__URL_set_path(net__urllib__URL* u, string p) {
	_result_string _t1 = net__urllib__unescape(p, net__urllib__EncodingMode__encode_path);
	if (_t1.is_error) {
		_result_bool _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	u->path =  (*(string*)_t1.data);
	u->raw_path = (string__eq(p, net__urllib__escape(u->path, net__urllib__EncodingMode__encode_path)) ? (_SLIT("")) : (p));
	_result_bool _t3;
	_result_ok(&(bool[]) { true }, (_result*)(&_t3), sizeof(bool));
	return _t3;
}

string net__urllib__URL_escaped_path(net__urllib__URL* u) {
	if ((u->raw_path).len != 0 && net__urllib__valid_encoded_path(u->raw_path)) {
		_result_string _t1 = net__urllib__unescape(u->raw_path, net__urllib__EncodingMode__encode_path);
		if (_t1.is_error) {
			IError err = _t1.err;
			string _t2 = _SLIT("");
			return _t2;
		}
		
  (*(string*)_t1.data);
		string _t3 = u->raw_path;
		return _t3;
	}
	if (string__eq(u->path, _SLIT("*"))) {
		string _t4 = _SLIT("*");
		return _t4;
	}
	string _t5 = net__urllib__escape(u->path, net__urllib__EncodingMode__encode_path);
	return _t5;
}

VV_LOCAL_SYMBOL bool net__urllib__valid_encoded_path(string s) {
	for (int i = 0; i < s.len; ++i) {
		u8 x = string_at(s, i);

		if (x == ('!') || x == ('$') || x == ('&') || x == ('\\') || x == ('(') || x == (')') || x == ('*') || x == ('+') || x == (',') || x == (';') || x == ('=') || x == (':') || x == ('@')) {
		}
		else if (x == ('[') || x == (']')) {
		}
		else if (x == ('%')) {
		}
		else {
			if (net__urllib__should_escape(string_at(s, i), net__urllib__EncodingMode__encode_path)) {
				bool _t1 = false;
				return _t1;
			}
		}
	}
	bool _t2 = true;
	return _t2;
}

VV_LOCAL_SYMBOL bool net__urllib__valid_optional_port(string port) {
	if ((port).len == 0) {
		bool _t1 = true;
		return _t1;
	}
	if (string_at(port, 0) != ':') {
		bool _t2 = false;
		return _t2;
	}
	for (int _t3 = 0; _t3 < string_substr(port, 1, 2147483647).len; ++_t3) {
		u8 b = string_substr(port, 1, 2147483647).str[_t3];
		if (b < '0' || b > '9') {
			bool _t4 = false;
			return _t4;
		}
	}
	bool _t5 = true;
	return _t5;
}

string net__urllib__URL_str(net__urllib__URL* u) {
	strings__Builder buf = strings__new_builder(200);
	if ((u->scheme).len != 0) {
		strings__Builder_write_string(&buf, u->scheme);
		strings__Builder_write_string(&buf, _SLIT(":"));
	}
	if ((u->opaque).len != 0) {
		strings__Builder_write_string(&buf, u->opaque);
	} else {
		if ((u->scheme).len != 0 || (u->host).len != 0 || !net__urllib__Userinfo_empty(u->user)) {
			if ((u->host).len != 0 || (u->path).len != 0 || !net__urllib__Userinfo_empty(u->user)) {
				strings__Builder_write_string(&buf, _SLIT("//"));
			}
			if (!net__urllib__Userinfo_empty(u->user)) {
				strings__Builder_write_string(&buf, net__urllib__Userinfo_str(u->user));
				strings__Builder_write_string(&buf, _SLIT("@"));
			}
			if ((u->host).len != 0) {
				strings__Builder_write_string(&buf, net__urllib__escape(u->host, net__urllib__EncodingMode__encode_host));
			}
		}
		string path = net__urllib__URL_escaped_path(u);
		if ((path).len != 0 && string_at(path, 0) != '/' && (u->host).len != 0) {
			strings__Builder_write_string(&buf, _SLIT("/"));
		}
		if (buf.len == 0) {
			int i = string_index_u8(path, ':');
			if (i > -1) {
				if (i > -1 && string_index_u8(string_substr(path, 0, i), '/') == -1) {
					strings__Builder_write_string(&buf, _SLIT("./"));
				}
			}
		}
		strings__Builder_write_string(&buf, path);
	}
	if (u->force_query || (u->raw_query).len != 0) {
		strings__Builder_write_string(&buf, _SLIT("?"));
		strings__Builder_write_string(&buf, u->raw_query);
	}
	if ((u->fragment).len != 0) {
		strings__Builder_write_string(&buf, _SLIT("#"));
		strings__Builder_write_string(&buf, net__urllib__escape(u->fragment, net__urllib__EncodingMode__encode_fragment));
	}
	string _t1 = strings__Builder_str(&buf);
	return _t1;
}

_result_net__urllib__Values net__urllib__parse_query(string query) {
	net__urllib__Values m = net__urllib__new_values();
	_result_bool _t1 = net__urllib__parse_query_values((voidptr)&/*qq*/m, query);
	if (_t1.is_error) {
		_result_net__urllib__Values _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(bool*)_t1.data);
	_result_net__urllib__Values _t3;
	_result_ok(&(net__urllib__Values[]) { m }, (_result*)(&_t3), sizeof(net__urllib__Values));
	return _t3;
}

VV_LOCAL_SYMBOL net__urllib__Values net__urllib__parse_query_silent(string query) {
	net__urllib__Values m = net__urllib__new_values();
	_result_bool _t1 = net__urllib__parse_query_values((voidptr)&/*qq*/m, query);
	if (_t1.is_error) {
		IError err = _t1.err;
	}
	
  (*(bool*)_t1.data);
	return m;
}

VV_LOCAL_SYMBOL _result_bool net__urllib__parse_query_values(net__urllib__Values* m, string query) {
	bool had_error = false;
	string q = query;
	for (;;) {
		if (!((q).len != 0)) break;
		string key = q;
		int i = string_index_any(key, _SLIT("&;"));
		if (i >= 0) {
			q = string_substr(key, (int)(i + 1), 2147483647);
			key = string_substr(key, 0, i);
		} else {
			q = _SLIT("");
		}
		if ((key).len == 0) {
			continue;
		}
		string value = _SLIT("");
		_option_int _t1;
		if (_t1 = string_index(key, _SLIT("=")), _t1.state == 0) {
			int idx = *(int*)_t1.data;
			i = idx;
			value = string_substr(key, (int)(i + 1), 2147483647);
			key = string_substr(key, 0, i);
		}
		_result_string _t2 = net__urllib__query_unescape(key);
		if (_t2.is_error) {
			IError err = _t2.err;
			had_error = true;
			continue;
		}
		
 		string k =  (*(string*)_t2.data);
		key = k;
		_result_string _t3 = net__urllib__query_unescape(value);
		if (_t3.is_error) {
			IError err = _t3.err;
			had_error = true;
			continue;
		}
		
 		string v =  (*(string*)_t3.data);
		value = v;
		net__urllib__Values_add(m, key, value);
	}
	if (had_error) {
		return (_result_bool){ .is_error=true, .err=_v_error(net__urllib__error_msg(_SLIT("parse_query_values: failed parsing query string"), _SLIT(""))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_bool _t5;
	_result_ok(&(bool[]) { true }, (_result*)(&_t5), sizeof(bool));
	return _t5;
}

string net__urllib__Values_encode(net__urllib__Values v) {
	if (v.len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	strings__Builder buf = strings__new_builder(200);
	for (int _t2 = 0; _t2 < v.data.len; ++_t2) {
		net__urllib__QueryValue qvalue = ((net__urllib__QueryValue*)v.data.data)[_t2];
		string key_kscaped = net__urllib__query_escape(qvalue.key);
		if (buf.len > 0) {
			strings__Builder_write_string(&buf, _SLIT("&"));
		}
		strings__Builder_write_string(&buf, key_kscaped);
		if ((qvalue.value).len == 0) {
			continue;
		}
		strings__Builder_write_string(&buf, _SLIT("="));
		strings__Builder_write_string(&buf, net__urllib__query_escape(qvalue.value));
	}
	string _t3 = strings__Builder_str(&buf);
	return _t3;
}

VV_LOCAL_SYMBOL string net__urllib__resolve_path(string base, string ref) {
	string full = _SLIT("");
	if ((ref).len == 0) {
		full = base;
	} else if (string_at(ref, 0) != '/') {
		int i = string_index_u8_last(base, '/');
		full = string__plus(string_substr(base, 0, (int)(i + 1)), ref);
	} else {
		full = ref;
	}
	if ((full).len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	Array_string dst = __new_array_with_default(0, 0, sizeof(string), 0);
	Array_string src = string_split(full, _SLIT("/"));
	for (int _t2 = 0; _t2 < src.len; ++_t2) {
		string elem = ((string*)src.data)[_t2];

		if (string__eq(elem, _SLIT("."))) {
		}
		else if (string__eq(elem, _SLIT(".."))) {
			if (dst.len > 0) {
				dst = array_slice(dst, 0, (int)(dst.len - 1));
			}
		}
		else {
			array_push((array*)&dst, _MOV((string[]){ string_clone(elem) }));
		}
	}
	string last = (*(string*)array_get(src, (int)(src.len - 1)));
	if (string__eq(last, _SLIT(".")) || string__eq(last, _SLIT(".."))) {
		array_push((array*)&dst, _MOV((string[]){ string_clone(_SLIT("")) }));
	}
	string _t5 = string__plus(_SLIT("/"), string_trim_left(Array_string_join(dst, _SLIT("/")), _SLIT("/")));
	return _t5;
}

bool net__urllib__URL_is_abs(net__urllib__URL* u) {
	bool _t1 = (u->scheme).len != 0;
	return _t1;
}

_result_net__urllib__URL net__urllib__URL_parse(net__urllib__URL* u, string ref) {
	_result_net__urllib__URL _t1 = net__urllib__parse(ref);
	if (_t1.is_error) {
		_result_net__urllib__URL _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__urllib__URL refurl =  (*(net__urllib__URL*)_t1.data);
	_result_net__urllib__URL _t3 = net__urllib__URL_resolve_reference(u, (voidptr)&/*qq*/refurl);
	return _t3;
}

_result_net__urllib__URL net__urllib__URL_resolve_reference(net__urllib__URL* u, net__urllib__URL* ref) {
	net__urllib__URL url = *ref;
	if ((ref->scheme).len == 0) {
		url.scheme = u->scheme;
	}
	if ((ref->scheme).len != 0 || (ref->host).len != 0 || !net__urllib__Userinfo_empty(ref->user)) {
		_result_bool _t1 = net__urllib__URL_set_path(&url, net__urllib__resolve_path(net__urllib__URL_escaped_path(ref), _SLIT("")));
		if (_t1.is_error) {
			_result_net__urllib__URL _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
  (*(bool*)_t1.data);
		_result_net__urllib__URL _t3;
		_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t3), sizeof(net__urllib__URL));
		return _t3;
	}
	if ((ref->opaque).len != 0) {
		url.user = net__urllib__user(_SLIT(""));
		url.host = _SLIT("");
		url.path = _SLIT("");
		_result_net__urllib__URL _t4;
		_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t4), sizeof(net__urllib__URL));
		return _t4;
	}
	if ((ref->path).len == 0 && (ref->raw_query).len == 0) {
		url.raw_query = u->raw_query;
		if ((ref->fragment).len == 0) {
			url.fragment = u->fragment;
		}
	}
	url.host = u->host;
	url.user = u->user;
	_result_bool _t5 = net__urllib__URL_set_path(&url, net__urllib__resolve_path(net__urllib__URL_escaped_path(u), net__urllib__URL_escaped_path(ref)));
	if (_t5.is_error) {
		_result_net__urllib__URL _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
  (*(bool*)_t5.data);
	_result_net__urllib__URL _t7;
	_result_ok(&(net__urllib__URL[]) { url }, (_result*)(&_t7), sizeof(net__urllib__URL));
	return _t7;
}

net__urllib__Values net__urllib__URL_query(net__urllib__URL* u) {
	net__urllib__Values v = net__urllib__parse_query_silent(u->raw_query);
	return v;
}

string net__urllib__URL_request_uri(net__urllib__URL* u) {
	string result = u->opaque;
	if ((result).len == 0) {
		result = net__urllib__URL_escaped_path(u);
		if ((result).len == 0) {
			result = _SLIT("/");
		}
	} else {
		if (string_starts_with(result, _SLIT("//"))) {
			result = string__plus(string__plus(u->scheme, _SLIT(":")), result);
		}
	}
	if (u->force_query || (u->raw_query).len != 0) {
		result = string__plus(result, string__plus(_SLIT("?"), u->raw_query));
	}
	return result;
}

string net__urllib__URL_hostname(net__urllib__URL* u) {
	multi_return_string_string mr_30103 = net__urllib__split_host_port(u->host);
	string host = mr_30103.arg0;
	return host;
}

string net__urllib__URL_port(net__urllib__URL* u) {
	multi_return_string_string mr_30322 = net__urllib__split_host_port(u->host);
	string port = mr_30322.arg1;
	return port;
}

multi_return_string_string net__urllib__split_host_port(string hostport) {
	string host = hostport;
	string port = _SLIT("");
	int colon = string_index_u8_last(host, ':');
	if (colon != -1) {
		if (net__urllib__valid_optional_port(string_substr(host, colon, 2147483647))) {
			port = string_substr(host, (int)(colon + 1), 2147483647);
			host = string_substr(host, 0, colon);
		}
	}
	if (host.len > 1 && string_at(host, 0) == '[' && string_ends_with(host, _SLIT("]"))) {
		host = string_substr(host, 1, (int)(host.len - 1));
	}
	return (multi_return_string_string){.arg0=host, .arg1=port};
}

bool net__urllib__valid_userinfo(string s) {
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 r = s.str[_t1];
		if ('A' <= r && r <= 'Z') {
			continue;
		}
		if ('a' <= r && r <= 'z') {
			continue;
		}
		if ('0' <= r && r <= '9') {
			continue;
		}

		if (r == ('-') || r == ('.') || r == ('_') || r == (':') || r == ('~') || r == ('!') || r == ('$') || r == ('&') || r == ('\\') || r == ('(') || r == (')') || r == ('*') || r == ('+') || r == (',') || r == (';') || r == ('=') || r == ('%') || r == ('@')) {
			continue;
		}
		else {
			bool _t2 = false;
			return _t2;
		}
	}
	bool _t3 = true;
	return _t3;
}

VV_LOCAL_SYMBOL bool net__urllib__string_contains_ctl_u8(string s) {
	for (int i = 0; i < s.len; ++i) {
		u8 b = string_at(s, i);
		if (b < ' ' || b == 0x7f) {
			bool _t1 = true;
			return _t1;
		}
	}
	bool _t2 = false;
	return _t2;
}

bool net__urllib__ishex(u8 c) {
	if ('0' <= c && c <= '9') {
		bool _t1 = true;
		return _t1;
	} else if ('a' <= c && c <= 'f') {
		bool _t2 = true;
		return _t2;
	} else if ('A' <= c && c <= 'F') {
		bool _t3 = true;
		return _t3;
	}
	bool _t4 = false;
	return _t4;
}

VV_LOCAL_SYMBOL u8 net__urllib__unhex(u8 c) {
	if ('0' <= c && c <= '9') {
		u8 _t1 = (rune)(c - '0');
		return _t1;
	} else if ('a' <= c && c <= 'f') {
		u8 _t2 = (rune)((rune)(c - 'a') + 10);
		return _t2;
	} else if ('A' <= c && c <= 'F') {
		u8 _t3 = (rune)((rune)(c - 'A') + 10);
		return _t3;
	}
	u8 _t4 = 0;
	return _t4;
}

net__urllib__Values net__urllib__new_values(void) {
	net__urllib__Values _t1 = ((net__urllib__Values){.data = __new_array_with_default(0, 0, sizeof(net__urllib__QueryValue), 0),.len = 0,});
	return _t1;
}

_option_string net__urllib__Values_get(net__urllib__Values* v, string key) {
	if (v->data.len == 0) {
		return (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	for (int _t2 = 0; _t2 < v->data.len; ++_t2) {
		net__urllib__QueryValue qvalue = ((net__urllib__QueryValue*)v->data.data)[_t2];
		if (string__eq(qvalue.key, key)) {
			_option_string _t3;
			_option_ok(&(string[]) { qvalue.value }, (_option*)(&_t3), sizeof(string));
			return _t3;
		}
	}
	return (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

Array_string net__urllib__Values_get_all(net__urllib__Values* v, string key) {
	if (v->data.len == 0) {
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string values = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t2 = 0; _t2 < v->data.len; ++_t2) {
		net__urllib__QueryValue qvalue = ((net__urllib__QueryValue*)v->data.data)[_t2];
		if (string__eq(qvalue.key, key)) {
			array_push((array*)&values, _MOV((string[]){ string_clone(qvalue.value) }));
		}
	}
	return values;
}

void net__urllib__Values_set(net__urllib__Values* v, string key, string value) {
	bool found = false;
	for (int _t1 = 0; _t1 < v->data.len; ++_t1) {
		net__urllib__QueryValue* qvalue = ((net__urllib__QueryValue*)v->data.data) + _t1;
		if (string__eq(qvalue->key, key)) {
			found = true;
			qvalue->value = value;
		}
	}
	if (!found) {
		net__urllib__Values_add(v, key, value);
	}
}

void net__urllib__Values_add(net__urllib__Values* v, string key, string value) {
	array_push((array*)&v->data, _MOV((net__urllib__QueryValue[]){ ((net__urllib__QueryValue){.key = key,.value = value,}) }));
	v->len = v->data.len;
}

void net__urllib__Values_del(net__urllib__Values* v, string key) {
	for (int idx = 0; idx < v->data.len; ++idx) {
		net__urllib__QueryValue qvalue = ((net__urllib__QueryValue*)v->data.data)[idx];
		if (string__eq(qvalue.key, key)) {
			array_delete(&v->data, idx);
		}
	}
	v->len = v->data.len;
}

Array_string net__urllib__Values_values(net__urllib__Values v) {
	Array_string values = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < v.data.len; ++_t1) {
		net__urllib__QueryValue qvalue = ((net__urllib__QueryValue*)v.data.data)[_t1];
		if ((qvalue.value).len != 0) {
			array_push((array*)&values, _MOV((string[]){ string_clone(qvalue.value) }));
		}
	}
	return values;
}

Map_string_Array_string net__urllib__Values_to_map(net__urllib__Values v) {
	Map_string_Array_string result = new_map(sizeof(string), sizeof(Array_string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	for (int _t1 = 0; _t1 < v.data.len; ++_t1) {
		net__urllib__QueryValue qvalue = ((net__urllib__QueryValue*)v.data.data)[_t1];
		if (_IN_MAP(ADDR(string, qvalue.key), ADDR(map, result))) {
			array_push((array*)&(*(Array_string*)map_get_and_set((map*)&result, &(string[]){qvalue.key}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })), _MOV((string[]){ string_clone(qvalue.value) }));
		} else {
			(*(Array_string*)map_get_and_set((map*)&result, &(string[]){qvalue.key}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) })) = new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string_clone(qvalue.value)}));
		}
	}
	return result;
}

Array_string maps__to_array_T_string_string_string(Map_string_string m, string (*f)(string key, string val)) {
	Array_string a = __new_array_with_default(0, m.len, sizeof(string), 0);
	int _t2 = m.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = m.key_values.len - _t2;
		_t2 = m.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&m.key_values, _t1)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&m.key_values, _t1);
		k = string_clone(k);
		string v = (*(string*)DenseArray_value(&m.key_values, _t1));
		array_push((array*)&a, _MOV((string[]){ string_clone(f(k, v)) }));
	}
	return a;
}

Map_string_x__json2__Any maps__to_map_T_discord__Snowflake_string_string_x__json2__Any(Map_discord__Snowflake_string m, multi_return_string_x__json2__Any (*f)(discord__Snowflake key, string val)) {
	Map_string_x__json2__Any mp = new_map(sizeof(string), sizeof(x__json2__Any), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	int _t2 = m.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = m.key_values.len - _t2;
		_t2 = m.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&m.key_values, _t1)) {continue;}
		discord__Snowflake k = /*key*/ *(discord__Snowflake*)DenseArray_key(&m.key_values, _t1);
		string v = (*(string*)DenseArray_value(&m.key_values, _t1));
		multi_return_string_x__json2__Any mr_844 = f(k, v);
		string x = mr_844.arg0;
		x__json2__Any y = mr_844.arg1;
		map_set(&mp, &(string[]){x}, &(x__json2__Any[]) { y });
	}
	return mp;
}

i64 time__portable_timegm(struct tm* t) {
	int year = (int)(t->tm_year + 1900);
	int month = t->tm_mon;
	if (month > 11) {
		year += (int)(month / 12);
		month %= 12;
	} else if (month < 0) {
		int years_diff = (int)(((int)(11 - month)) / 12);
		year -= years_diff;
		month += (int)(12 * years_diff);
	}
	i64 days_since_1970 = ((i64)(time__days_from_unix_epoch(year, (int)(month + 1), t->tm_mday)));
	i64 _t1 = (i64)((i64)(60 * ((i64)((i64)(60 * ((i64)((i64)(24 * days_since_1970) + t->tm_hour))) + t->tm_min))) + t->tm_sec);
	return _t1;
}

int time__days_from_unix_epoch(int year, int month, int day) {
	int y = (month <= 2 ? ((int)(year - 1)) : (year));
	int era = (int)(y / 400);
	int year_of_the_era = (int)(y - (int)(era * 400));
	int day_of_year = (int)((int)((int)(((int)((int)(153 * ((int)(month + ((month > 2 ? (-3) : (9)))))) + 2)) / 5) + day) - 1);
	int day_of_the_era = (int)((int)((int)((int)(year_of_the_era * 365) + (int)(year_of_the_era / 4)) - (int)(year_of_the_era / 100)) + day_of_year);
	int _t1 = (int)((int)((int)(era * 146097) + day_of_the_era) - 719468);
	return _t1;
}

// Attr: [inline]
inline int time__Time_days_from_unix_epoch(time__Time t) {
	int _t1 = time__days_from_unix_epoch(t.year, t.month, t.day);
	return _t1;
}

time__Time time__date_from_days_after_unix_epoch(int days) {
	multi_return_int_int_int mr_1379 = time__calculate_date_from_offset(((i64)(days)));
	int year = mr_1379.arg0;
	int month = mr_1379.arg1;
	int day = mr_1379.arg2;
	time__Time _t1 = ((time__Time){.year = year,.month = month,.day = day,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	return _t1;
}

VV_LOCAL_SYMBOL time__DateTimeParser time__new_date_time_parser(string datetime, string format) {
	time__DateTimeParser _t1 = ((time__DateTimeParser){.datetime = datetime,.format = format,.current_pos_datetime = 0,});
	return _t1;
}

VV_LOCAL_SYMBOL _result_string time__DateTimeParser_next(time__DateTimeParser* p, int length) {
	if ((int)(p->current_pos_datetime + length) > p->datetime.len) {
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("end of string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string val = string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + length));
	p->current_pos_datetime += length;
	_result_string _t2;
	_result_ok(&(string[]) { val }, (_result*)(&_t2), sizeof(string));
	return _t2;
}

VV_LOCAL_SYMBOL _result_string time__DateTimeParser_peek(time__DateTimeParser* p, int length) {
	if ((int)(p->current_pos_datetime + length) > p->datetime.len) {
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("end of string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_string _t2;
	_result_ok(&(string[]) { string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + length)) }, (_result*)(&_t2), sizeof(string));
	return _t2;
}

VV_LOCAL_SYMBOL _result_int time__DateTimeParser_must_be_int(time__DateTimeParser* p, int length) {
	_result_string _t1 = time__DateTimeParser_next(p, length);
	if (_t1.is_error) {
		_result_int _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string val =  (*(string*)_t1.data);
	if (!string_contains_only(val, _SLIT("0123456789"))) {
		return (_result_int){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected int, found: "), /*115 &string*/0xfe10, {.d_s = val}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t4;
	_result_ok(&(int[]) { string_int(val) }, (_result*)(&_t4), sizeof(int));
	return _t4;
}

VV_LOCAL_SYMBOL _result_int time__DateTimeParser_must_be_int_with_minimum_length(time__DateTimeParser* p, int min, int max, bool allow_leading_zero) {
	int length = (int)((int)(max + 1) - min);
	string val = _SLIT("");
	for (int _t1 = 0; _t1 < length; ++_t1) {
		_result_string _t2 = time__DateTimeParser_peek(p, 1);
		if (_t2.is_error) {
			IError err = _t2.err;
			break;
		}
		
 		string tok =  (*(string*)_t2.data);
		if (!string_contains_only(tok, _SLIT("0123456789"))) {
			break;
		}
		_result_string _t3 = time__DateTimeParser_next(p, 1);
		if (_t3.is_error) {
			_result_int _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
  (*(string*)_t3.data);
		val = string__plus(val, tok);
	}
	if (val.len < min) {
		return (_result_int){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected int with a minimum length of "), /*100 &int*/0xfe07, {.d_i32 = min}}, {_SLIT(", found: "), /*100 &int*/0xfe07, {.d_i32 = val.len}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!allow_leading_zero && string_starts_with(val, _SLIT("0"))) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("0 is not allowed for this format")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t7;
	_result_ok(&(int[]) { string_int(val) }, (_result*)(&_t7), sizeof(int));
	return _t7;
}

VV_LOCAL_SYMBOL _result_void time__DateTimeParser_must_be_string(time__DateTimeParser* p, string must) {
	_result_string _t1 = time__DateTimeParser_next(p, must.len);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string val =  (*(string*)_t1.data);
	if (!string__eq(val, must)) {
		return (_result_void){ .is_error=true, .err=_v_error( str_intp(4, _MOV((StrIntpData[]){{_SLIT("invalid string: \""), /*115 &string*/0xfe10, {.d_s = val}}, {_SLIT("\"!=\""), /*115 &string*/0xfe10, {.d_s = must}}, {_SLIT("\" at: "), /*100 &int*/0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_string time__DateTimeParser_must_be_string_one_of(time__DateTimeParser* p, Array_string oneof) {
	for (int _t1 = 0; _t1 < oneof.len; ++_t1) {
		string must = ((string*)oneof.data)[_t1];
		_result_string _t2 = time__DateTimeParser_peek(p, must.len);
		if (_t2.is_error) {
			IError err = _t2.err;
			continue;
		}
		
 		string val =  (*(string*)_t2.data);
		if (string__eq(val, must)) {
			_result_string _t3;
			_result_ok(&(string[]) { must }, (_result*)(&_t3), sizeof(string));
			return _t3;
		}
	}
	return (_result_string){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("invalid string: must be one of "), /*115 &[]string*/0xfe10, {.d_s = Array_string_str(oneof)}}, {_SLIT(", at: "), /*100 &int*/0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_int time__DateTimeParser_must_be_valid_month(time__DateTimeParser* p) {
	for (int _t1 = 0; _t1 < _const_time__long_months.len; ++_t1) {
		string v = ((string*)_const_time__long_months.data)[_t1];
		if ((int)(p->current_pos_datetime + v.len) < p->datetime.len) {
			string month_name = string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + v.len));
			if (string__eq(v, month_name)) {
				p->current_pos_datetime += v.len;
				_result_int _t2;
				_result_ok(&(int[]) { (int)(Array_string_index(_const_time__long_months, month_name) + 1) }, (_result*)(&_t2), sizeof(int));
				return _t2;
			}
		}
	}
	return (_result_int){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid month name, at: "), /*100 &int*/0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_int time__DateTimeParser_must_be_valid_three_letter_month(time__DateTimeParser* p) {
	if ((int)(p->current_pos_datetime + 3) < p->datetime.len) {
		string letters = string_substr(p->datetime, p->current_pos_datetime, (int)(p->current_pos_datetime + 3));
		for (int m = 1; m <= _const_time__long_months.len; m++) {
			if (string__eq(string_substr(_const_time__months_string, (int)(((int)(m - 1)) * 3), (int)(m * 3)), letters)) {
				p->current_pos_datetime += 3;
				_result_int _t1;
				_result_ok(&(int[]) { m }, (_result*)(&_t1), sizeof(int));
				return _t1;
			}
		}
	}
	return (_result_int){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid three letter month, at: "), /*100 &int*/0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_string time__DateTimeParser_must_be_valid_week_day(time__DateTimeParser* p, int letters) {
	_result_string _t1 = time__DateTimeParser_next(p, letters);
	if (_t1.is_error) {
		_result_string _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string val =  (*(string*)_t1.data);
	for (int _t3 = 0; _t3 < _const_time__long_days.len; ++_t3) {
		string v = ((string*)_const_time__long_days.data)[_t3];
		if (string__eq(string_substr(v, 0, letters), val)) {
			_result_string _t4;
			_result_ok(&(string[]) { v }, (_result*)(&_t4), sizeof(string));
			return _t4;
		}
	}
	return (_result_string){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid month name, at: "), /*100 &int*/0xfe07, {.d_i32 = p->current_pos_datetime}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_Array_string time__extract_tokens(string s) {
	Array_string tokens = __new_array_with_default(0, 0, sizeof(string), 0);
	string current = _SLIT("");
	for (int _t1 = 0; _t1 < s.len; ++_t1) {
		u8 r = s.str[_t1];
		if (string_contains_only(current, u8_ascii_str(r)) || (current).len == 0) {
			current = string__plus(current, u8_ascii_str(r));
		} else {
			array_push((array*)&tokens, _MOV((string[]){ string_clone(current) }));
			current = u8_ascii_str(r);
		}
	}
	if ((current).len != 0) {
		array_push((array*)&tokens, _MOV((string[]){ string_clone(current) }));
	}
	_result_Array_string _t4;
	_result_ok(&(Array_string[]) { tokens }, (_result*)(&_t4), sizeof(Array_string));
	return _t4;
}

VV_LOCAL_SYMBOL _result_time__Time time__DateTimeParser_parse(time__DateTimeParser* p) {
	int year_ = 0;
	int month_ = 0;
	int day_in_month = 0;
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	_result_Array_string _t1 = time__extract_tokens(p->format);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("malformed format string: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	Array_string tokens =  (*(Array_string*)_t1.data);
	for (int _t3 = 0; _t3 < tokens.len; ++_t3) {
		string token = ((string*)tokens.data)[_t3];

		if (string__eq(token, _SLIT("YYYY"))) {
			_result_int _t4 = time__DateTimeParser_must_be_int(p, 4);
			if (_t4.is_error) {
				IError err = _t4.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before the full year was specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			year_ =  (*(int*)_t4.data);
		}
		else if (string__eq(token, _SLIT("YY"))) {
			_result_int _t6 = time__DateTimeParser_must_be_int(p, 2);
			if (_t6.is_error) {
				IError err = _t6.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before the full year was specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			year_ = (int)((int)((int)(time__now().year / 100) * 100) +  (*(int*)_t6.data));
		}
		else if (string__eq(token, _SLIT("M"))) {
			_result_int _t8 = time__DateTimeParser_must_be_int_with_minimum_length(p, 1, 2, false);
			if (_t8.is_error) {
				IError err = _t8.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before the month was specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			month_ =  (*(int*)_t8.data);
			if (month_ < 1 || month_ > 12) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("month must be  between 1 and 12")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("MM"))) {
			_result_int _t11 = time__DateTimeParser_must_be_int(p, 2);
			if (_t11.is_error) {
				IError err = _t11.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before the month was specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			month_ =  (*(int*)_t11.data);
			if (month_ < 1 || month_ > 12) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("month must be  between 01 and 12")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("MMM"))) {
			_result_int _t14 = time__DateTimeParser_must_be_valid_three_letter_month(p);
			if (_t14.is_error) {
				IError err = _t14.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			month_ =  (*(int*)_t14.data);
		}
		else if (string__eq(token, _SLIT("MMMM"))) {
			_result_int _t16 = time__DateTimeParser_must_be_valid_month(p);
			if (_t16.is_error) {
				IError err = _t16.err;
				return (_result_time__Time){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			month_ =  (*(int*)_t16.data);
		}
		else if (string__eq(token, _SLIT("D"))) {
			_result_int _t18 = time__DateTimeParser_must_be_int_with_minimum_length(p, 1, 2, false);
			if (_t18.is_error) {
				IError err = _t18.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before the day was specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			day_in_month =  (*(int*)_t18.data);
			if (day_in_month < 1 || day_in_month > 31) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("day must be  between 1 and 31")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("DD"))) {
			_result_int _t21 = time__DateTimeParser_must_be_int(p, 2);
			if (_t21.is_error) {
				IError err = _t21.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before the month was specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			day_in_month =  (*(int*)_t21.data);
			if (day_in_month < 1 || day_in_month > 31) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("day must be  between 01 and 31")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("H"))) {
			_result_int _t24 = time__DateTimeParser_must_be_int_with_minimum_length(p, 1, 2, true);
			if (_t24.is_error) {
				IError err = _t24.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before hours where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			hour_ =  (*(int*)_t24.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("hour must be  between 0 and 23")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("HH"))) {
			_result_int _t27 = time__DateTimeParser_must_be_int(p, 2);
			if (_t27.is_error) {
				IError err = _t27.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before hours where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			hour_ =  (*(int*)_t27.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("hour must be  between 00 and 23")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("h"))) {
			_result_int _t30 = time__DateTimeParser_must_be_int_with_minimum_length(p, 1, 2, true);
			if (_t30.is_error) {
				IError err = _t30.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before hours where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			hour_ =  (*(int*)_t30.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("hour must be  between 0 and 23")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("hh"))) {
			_result_int _t33 = time__DateTimeParser_must_be_int(p, 2);
			if (_t33.is_error) {
				IError err = _t33.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before hours where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			hour_ =  (*(int*)_t33.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("hour must be  between 00 and 23")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("k"))) {
			_result_int _t36 = time__DateTimeParser_must_be_int(p, 1);
			if (_t36.is_error) {
				IError err = _t36.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before hours where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			hour_ =  (*(int*)_t36.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("hour must be  between 0 and 23")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("kk"))) {
			_result_int _t39 = time__DateTimeParser_must_be_int(p, 2);
			if (_t39.is_error) {
				IError err = _t39.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before hours where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			hour_ =  (*(int*)_t39.data);
			if (hour_ < 0 || hour_ > 23) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("hour must be  between 00 and 23")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("m"))) {
			_result_int _t42 = time__DateTimeParser_must_be_int(p, 1);
			if (_t42.is_error) {
				IError err = _t42.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before minutes where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			minute_ =  (*(int*)_t42.data);
			if (minute_ < 0 || minute_ > 59) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("minute must be between 0 and 59")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("mm"))) {
			_result_int _t45 = time__DateTimeParser_must_be_int(p, 2);
			if (_t45.is_error) {
				IError err = _t45.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before minutes where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			minute_ =  (*(int*)_t45.data);
			if (minute_ < 0 || minute_ > 59) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("minute must be between 00 and 59")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("s"))) {
			_result_int _t48 = time__DateTimeParser_must_be_int(p, 1);
			if (_t48.is_error) {
				IError err = _t48.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before seconds where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			second_ =  (*(int*)_t48.data);
			if (second_ < 0 || second_ > 59) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("second must be between 0 and 59")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (string__eq(token, _SLIT("ss"))) {
			_result_int _t51 = time__DateTimeParser_must_be_int(p, 2);
			if (_t51.is_error) {
				IError err = _t51.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("end of string reached before seconds where specified")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			second_ =  (*(int*)_t51.data);
			if (second_ < 0 || second_ > 59) {
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("second must be between 00 and 59")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else {
			_result_void _t54 = time__DateTimeParser_must_be_string(p, token);
			if (_t54.is_error) {
				IError err = _t54.err;
				return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 ;
		}
	}
	if (month_ == 2) {
		int feb_days_in_year = (time__is_leap_year(year_) ? (29) : (28));
		if (day_in_month > feb_days_in_year) {
			return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("February has only 28 days in the given year")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	} else if (day_in_month == 31 && !(month_ == 1 || month_ == 3 || month_ == 5 || month_ == 7 || month_ == 8 || month_ == 10 || month_ == 12)) {
		string month_name = time__Time_custom_format(((time__Time){.year = 0,.month = month_,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,}), _SLIT("MMMM"));
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = month_name}}, {_SLIT(" has only 30 days"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_time__Time _t58;
	_result_ok(&(time__Time[]) { time__new_time(((time__Time){
		.year = year_,
		.month = month_,
		.day = day_in_month,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.nanosecond = 0,
		.__v_unix = 0,
		.is_local = 0,
		.microsecond = 0,
	})) }, (_result*)(&_t58), sizeof(time__Time));
	return _t58;
}

string time__Time_format(time__Time t) {
	string _t1 =  str_intp(6, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT(" "), /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_format_ss(time__Time t) {
	string _t1 =  str_intp(7, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT(" "), /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_format_ss_milli(time__Time t) {
	string _t1 =  str_intp(8, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT(" "), /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), /*100 &int*/0x8006fe27, {.d_i32 = ((int)(t.nanosecond / 1000000))}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_format_ss_micro(time__Time t) {
	string _t1 =  str_intp(8, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT(" "), /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), /*100 &int*/0x800cfe27, {.d_i32 = ((int)(t.nanosecond / 1000))}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_format_ss_nano(time__Time t) {
	string _t1 =  str_intp(8, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT(" "), /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), /*100 &int*/0x8012fe27, {.d_i32 = t.nanosecond}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_format_rfc3339(time__Time t) {
	time__Time u = time__Time_local_to_utc(&t);
	string _t1 =  str_intp(8, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8008fe27, {.d_i32 = u.year}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = u.month}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = u.day}}, {_SLIT("T"), /*100 &int*/0x8004fe27, {.d_i32 = u.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = u.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = u.second}}, {_SLIT("."), /*100 &int*/0x8006fe27, {.d_i32 = ((int)(u.nanosecond / 1000000))}}, {_SLIT("Z"), 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_format_rfc3339_nano(time__Time t) {
	time__Time u = time__Time_local_to_utc(&t);
	string _t1 =  str_intp(8, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8008fe27, {.d_i32 = u.year}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = u.month}}, {_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = u.day}}, {_SLIT("T"), /*100 &int*/0x8004fe27, {.d_i32 = u.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = u.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = u.second}}, {_SLIT("."), /*100 &int*/0x8012fe27, {.d_i32 = (u.nanosecond)}}, {_SLIT("Z"), 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_hhmm(time__Time t) {
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_hhmmss(time__Time t) {
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string time__Time_hhmm12(time__Time t) {
	string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm12);
	return _t1;
}

string time__Time_ymmdd(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__hyphen, time__FormatDate__yyyymmdd);
	return _t1;
}

string time__Time_ddmmy(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__dot, time__FormatDate__ddmmyyyy);
	return _t1;
}

string time__Time_md(time__Time t) {
	string _t1 = time__Time_get_fmt_date_str(t, time__FormatDelimiter__space, time__FormatDate__mmmd);
	return _t1;
}

VV_LOCAL_SYMBOL string time__ordinal_suffix(int n) {
	if (n > 3 && n < 21) {
		string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = n}}, {_SLIT("th"), 0, { .d_c = 0 }}}));
		return _t1;
	}
	int /*A*/ _t2 = (int)(n % 10);
		switch (_t2) {
		case 1: {
				string _t3 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = n}}, {_SLIT("st"), 0, { .d_c = 0 }}}));
				return _t3;
		}
		case 2: {
				string _t4 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = n}}, {_SLIT("nd"), 0, { .d_c = 0 }}}));
				return _t4;
		}
		case 3: {
				string _t5 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = n}}, {_SLIT("rd"), 0, { .d_c = 0 }}}));
				return _t5;
		}
		default: {
				string _t6 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = n}}, {_SLIT("th"), 0, { .d_c = 0 }}}));
				return _t6;
		}
	}
	
	return (string){.str=(byteptr)"", .is_lit=1};
}

string time__Time_custom_format(time__Time t, string s) {
	Array_string tokens = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < s.len; ) {
		for (int j = 4; j > 0; j--) {
			if (i > (int)(s.len - j)) {
				continue;
			}
			if (j == 1 || (j == 2 && Array_string_contains(_const_time__tokens_2, string_substr(s, i, (int)(i + j)))) || (j == 3 && Array_string_contains(_const_time__tokens_3, string_substr(s, i, (int)(i + j)))) || (j == 4 && Array_string_contains(_const_time__tokens_4, string_substr(s, i, (int)(i + j))))) {
				array_push((array*)&tokens, _MOV((string[]){ string_clone(string_substr(s, i, (int)(i + j))) }));
				i += ((int)(j - 1));
				break;
			}
		}
		i++;
	}
	strings__Builder sb = strings__new_builder(128);
	for (int _t2 = 0; _t2 < tokens.len; ++_t2) {
		string token = ((string*)tokens.data)[_t2];

		if (string__eq(token, _SLIT("M"))) {
			strings__Builder_write_string(&sb, int_str(t.month));
		}
		else if (string__eq(token, _SLIT("MM"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("Mo"))) {
			strings__Builder_write_string(&sb, time__ordinal_suffix(t.month));
		}
		else if (string__eq(token, _SLIT("MMM"))) {
			strings__Builder_write_string(&sb, string_substr((*(string*)array_get(_const_time__long_months, (int)(t.month - 1))), 0, 3));
		}
		else if (string__eq(token, _SLIT("MMMM"))) {
			strings__Builder_write_string(&sb, (*(string*)array_get(_const_time__long_months, (int)(t.month - 1))));
		}
		else if (string__eq(token, _SLIT("D"))) {
			strings__Builder_write_string(&sb, int_str(t.day));
		}
		else if (string__eq(token, _SLIT("DD"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("Do"))) {
			strings__Builder_write_string(&sb, time__ordinal_suffix(t.day));
		}
		else if (string__eq(token, _SLIT("DDD"))) {
			strings__Builder_write_string(&sb, int_str(((int)((int)(t.day + (*(int*)array_get(_const_time__days_before, (int)(t.month - 1)))) + (int[]){(time__is_leap_year(t.year))?1:0}[0]))));
		}
		else if (string__eq(token, _SLIT("DDDD"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8006fe27, {.d_i32 = (int)((int)(t.day + (*(int*)array_get(_const_time__days_before, (int)(t.month - 1)))) + (int[]){(time__is_leap_year(t.year))?1:0}[0])}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("DDDo"))) {
			strings__Builder_write_string(&sb, time__ordinal_suffix((int)((int)(t.day + (*(int*)array_get(_const_time__days_before, (int)(t.month - 1)))) + (int[]){(time__is_leap_year(t.year))?1:0}[0])));
		}
		else if (string__eq(token, _SLIT("d"))) {
			strings__Builder_write_string(&sb, int_str(time__Time_day_of_week(&t)));
		}
		else if (string__eq(token, _SLIT("dd"))) {
			strings__Builder_write_string(&sb, string_substr((*(string*)array_get(_const_time__long_days, (int)(time__Time_day_of_week(&t) - 1))), 0, 2));
		}
		else if (string__eq(token, _SLIT("ddd"))) {
			strings__Builder_write_string(&sb, string_substr((*(string*)array_get(_const_time__long_days, (int)(time__Time_day_of_week(&t) - 1))), 0, 3));
		}
		else if (string__eq(token, _SLIT("dddd"))) {
			strings__Builder_write_string(&sb, (*(string*)array_get(_const_time__long_days, (int)(time__Time_day_of_week(&t) - 1))));
		}
		else if (string__eq(token, _SLIT("YY"))) {
			strings__Builder_write_string(&sb, string_substr(int_str(t.year), 2, 4));
		}
		else if (string__eq(token, _SLIT("YYYY"))) {
			strings__Builder_write_string(&sb, int_str(t.year));
		}
		else if (string__eq(token, _SLIT("H"))) {
			strings__Builder_write_string(&sb, int_str(t.hour));
		}
		else if (string__eq(token, _SLIT("HH"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("h"))) {
			int h = (int)((int)(((int)(t.hour + 11)) % 12) + 1);
			strings__Builder_write_string(&sb, int_str(h));
		}
		else if (string__eq(token, _SLIT("hh"))) {
			int h = (int)((int)(((int)(t.hour + 11)) % 12) + 1);
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = h}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("i"))) {
			int h = (t.hour > 12 ? ((int)(t.hour - 12)) : (t.hour));
			strings__Builder_write_string(&sb, int_str(h));
		}
		else if (string__eq(token, _SLIT("ii"))) {
			int h = (t.hour > 12 ? ((int)(t.hour - 12)) : (t.hour));
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = h}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("m"))) {
			strings__Builder_write_string(&sb, int_str(t.minute));
		}
		else if (string__eq(token, _SLIT("mm"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("s"))) {
			strings__Builder_write_string(&sb, int_str(t.second));
		}
		else if (string__eq(token, _SLIT("ss"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("k"))) {
			strings__Builder_write_string(&sb, int_str(((int)(t.hour + 1))));
		}
		else if (string__eq(token, _SLIT("kk"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = ((int)(t.hour + 1))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("w"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*103 &f64*/0x1000f, {.d_f64 = time__mceil((int)(((int)((int)(t.day + (*(int*)array_get(_const_time__days_before, (int)(t.month - 1)))) + (int[]){(time__is_leap_year(t.year))?1:0}[0])) / 7))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("ww"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*103 &f64*/0x8005002f, {.d_f64 = time__mceil((int)(((int)((int)(t.day + (*(int*)array_get(_const_time__days_before, (int)(t.month - 1)))) + (int[]){(time__is_leap_year(t.year))?1:0}[0])) / 7))}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("wo"))) {
			strings__Builder_write_string(&sb, time__ordinal_suffix(((int)(time__mceil((int)(((int)((int)(t.day + (*(int*)array_get(_const_time__days_before, (int)(t.month - 1)))) + (int[]){(time__is_leap_year(t.year))?1:0}[0])) / 7))))));
		}
		else if (string__eq(token, _SLIT("Q"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = (int)(((int)(t.month % 4)) + 1)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("QQ"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = (int)(((int)(t.month % 4)) + 1)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("Qo"))) {
			strings__Builder_write_string(&sb, time__ordinal_suffix((int)(((int)(t.month % 4)) + 1)));
		}
		else if (string__eq(token, _SLIT("c"))) {
			strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = (int)(time__Time_day_of_week(&t) + 1)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		else if (string__eq(token, _SLIT("N"))) {
			strings__Builder_write_string(&sb, _SLIT("AD"));
		}
		else if (string__eq(token, _SLIT("NN"))) {
			strings__Builder_write_string(&sb, _SLIT("Anno Domini"));
		}
		else if (string__eq(token, _SLIT("Z"))) {
			int hours = (int)(time__offset() / _const_time__seconds_per_hour);
			if (hours >= 0) {
				strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("+"), /*100 &int*/0xfe07, {.d_i32 = hours}}, {_SLIT0, 0, { .d_c = 0 }}})));
			} else {
				hours = -hours;
				strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("-"), /*100 &int*/0xfe07, {.d_i32 = hours}}, {_SLIT0, 0, { .d_c = 0 }}})));
			}
		}
		else if (string__eq(token, _SLIT("ZZ"))) {
			int hours = (int)(time__offset() / _const_time__seconds_per_hour);
			if (hours >= 0) {
				strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("+"), /*100 &int*/0x8004fe27, {.d_i32 = hours}}, {_SLIT("00"), 0, { .d_c = 0 }}})));
			} else {
				hours = -hours;
				strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = hours}}, {_SLIT("00"), 0, { .d_c = 0 }}})));
			}
		}
		else if (string__eq(token, _SLIT("ZZZ"))) {
			int hours = (int)(time__offset() / _const_time__seconds_per_hour);
			if (hours >= 0) {
				strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("+"), /*100 &int*/0x8004fe27, {.d_i32 = hours}}, {_SLIT(":00"), 0, { .d_c = 0 }}})));
			} else {
				hours = -hours;
				strings__Builder_write_string(&sb,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("-"), /*100 &int*/0x8004fe27, {.d_i32 = hours}}, {_SLIT(":00"), 0, { .d_c = 0 }}})));
			}
		}
		else if (string__eq(token, _SLIT("a"))) {
			if (t.hour < 12) {
				strings__Builder_write_string(&sb, _SLIT("am"));
			} else {
				strings__Builder_write_string(&sb, _SLIT("pm"));
			}
		}
		else if (string__eq(token, _SLIT("A"))) {
			if (t.hour < 12) {
				strings__Builder_write_string(&sb, _SLIT("AM"));
			} else {
				strings__Builder_write_string(&sb, _SLIT("PM"));
			}
		}
		else {
			strings__Builder_write_string(&sb, token);
		}
	}
	string _t3 = strings__Builder_str(&sb);
	return _t3;
}

string time__Time_clean(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm24);
		return _t1;
	}
	if (t.year == znow.year) {
		string _t2 = time__Time_get_fmt_str(t, time__FormatDelimiter__space, time__FormatTime__hhmm24, time__FormatDate__mmmd);
		return _t2;
	}
	string _t3 = time__Time_format(t);
	return _t3;
}

string time__Time_clean12(time__Time t) {
	time__Time znow = time__now();
	if (t.month == znow.month && t.year == znow.year && t.day == znow.day) {
		string _t1 = time__Time_get_fmt_time_str(t, time__FormatTime__hhmm12);
		return _t1;
	}
	if (t.year == znow.year) {
		string _t2 = time__Time_get_fmt_str(t, time__FormatDelimiter__space, time__FormatTime__hhmm12, time__FormatDate__mmmd);
		return _t2;
	}
	string _t3 = time__Time_format(t);
	return _t3;
}

string time__Time_get_fmt_time_str(time__Time t, time__FormatTime fmt_time) {
	if (fmt_time == time__FormatTime__no_time) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string tp = (t.hour > 11 ? (_SLIT("p.m.")) : (_SLIT("a.m.")));
	int hour_ = (t.hour > 12 ? ((int)(t.hour - 12)) : t.hour == 0 ? (12) : (t.hour));
	string _t3 = (string){.str=(byteptr)"", .is_lit=1};
	switch (fmt_time) {
		case time__FormatTime__hhmm12: {
				_t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = hour_}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = tp}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatTime__hhmm24: {
				_t3 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatTime__hhmmss12: {
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = hour_}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = tp}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatTime__hhmmss24: {
				_t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatTime__hhmmss24_milli: {
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), /*100 &int*/0x8006fe27, {.d_i32 = ((int)(t.nanosecond / 1000000))}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatTime__hhmmss24_micro: {
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), /*100 &int*/0x800cfe27, {.d_i32 = ((int)(t.nanosecond / 1000))}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatTime__hhmmss24_nano: {
				_t3 =  str_intp(5, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT("."), /*100 &int*/0x800cfe27, {.d_i32 = t.nanosecond}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatTime__no_time:
		default: {
				_t3 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown enumeration "), /*115 &time.FormatTime*/0xfe10, {.d_s = time__FormatTime_str(fmt_time)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
	}
	string _t2 = _t3;
	return _t2;
}

string time__Time_get_fmt_date_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate__no_date) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string month = time__Time_smonth(&t);
	string year =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = ((int)(t.year % 100))}}, {_SLIT0, 0, { .d_c = 0 }}}));
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (fmt_date) {
		case time__FormatDate__ddmmyy: {
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), /*115 &string*/0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__ddmmyyyy: {
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__mmddyy: {
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), /*115 &string*/0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__mmddyyyy: {
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__mmmd: {
				_t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = month}}, {_SLIT("|"), /*100 &int*/0xfe07, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__mmmdd: {
				_t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = month}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__mmmddyy: {
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = month}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), /*115 &string*/0xfe10, {.d_s = year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__mmmddyyyy: {
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = month}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT("|"), /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__yyyymmdd: {
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0x8008fe27, {.d_i32 = t.year}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__yymmdd: {
				_t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = year}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.month}}, {_SLIT("|"), /*100 &int*/0x8004fe27, {.d_i32 = t.day}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
		case time__FormatDate__no_date:
		default: {
				_t2 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown enumeration "), /*115 &time.FormatDate*/0xfe10, {.d_s = time__FormatDate_str(fmt_date)}}, {_SLIT0, 0, { .d_c = 0 }}}));
				break;
		}
	}
	string res = _t2;
	string del = ((fmt_dlmtr == (time__FormatDelimiter__dot))? (_SLIT(".")) : (fmt_dlmtr == (time__FormatDelimiter__hyphen))? (_SLIT("-")) : (fmt_dlmtr == (time__FormatDelimiter__slash))? (_SLIT("/")) : (fmt_dlmtr == (time__FormatDelimiter__space))? (_SLIT(" ")) : (_SLIT("")));
	res = string_replace(res, _SLIT("|"), del);
	return res;
}

string time__Time_get_fmt_str(time__Time t, time__FormatDelimiter fmt_dlmtr, time__FormatTime fmt_time, time__FormatDate fmt_date) {
	if (fmt_date == time__FormatDate__no_date) {
		if (fmt_time == time__FormatTime__no_time) {
			string _t1 = _SLIT("");
			return _t1;
		} else {
			string _t2 = time__Time_get_fmt_time_str(t, fmt_time);
			return _t2;
		}
	} else {
		if (fmt_time != time__FormatTime__no_time) {
			string dstr = time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
			string tstr = time__Time_get_fmt_time_str(t, fmt_time);
			string _t3 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = dstr}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = tstr}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t3;
		} else {
			string _t4 = time__Time_get_fmt_date_str(t, fmt_dlmtr, fmt_date);
			return _t4;
		}
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string time__Time_utc_string(time__Time t) {
	string day_str = time__Time_weekday_str(&t);
	string month_str = time__Time_smonth(&t);
	string utc_string =  str_intp(8, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = day_str}}, {_SLIT(", "), /*100 &int*/0xfe07, {.d_i32 = t.day}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = month_str}}, {_SLIT(" "), /*100 &int*/0xfe07, {.d_i32 = t.year}}, {_SLIT(" "), /*100 &int*/0x8004fe27, {.d_i32 = t.hour}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.minute}}, {_SLIT(":"), /*100 &int*/0x8004fe27, {.d_i32 = t.second}}, {_SLIT(" UTC"), 0, { .d_c = 0 }}}));
	return utc_string;
}

VV_LOCAL_SYMBOL f64 time__mceil(f64 x) {
	if (x > 0) {
		f64 _t1 = (int)(1 + ((int)(x)));
		return _t1;
	}
	if (x < 0) {
		f64 _t2 = -((int)(-x));
		return _t2;
	}
	f64 _t3 = 0;
	return _t3;
}

// Attr: [inline]
inline bool time__Time__eq(time__Time t1, time__Time t2) {
	bool _t1 = t1.__v_unix == t2.__v_unix && t1.nanosecond == t2.nanosecond;
	return _t1;
}

// Attr: [inline]
inline bool time__Time__lt(time__Time t1, time__Time t2) {
	bool _t1 = t1.__v_unix < t2.__v_unix || (t1.__v_unix == t2.__v_unix && t1.nanosecond < t2.nanosecond);
	return _t1;
}

// Attr: [inline]
inline time__Duration time__Time__minus(time__Time lhs, time__Time rhs) {
	i64 unixs = ((i64)((i64)(lhs.__v_unix - rhs.__v_unix))) * _const_time__second;
	int nanos = (int)(lhs.nanosecond - rhs.nanosecond);
	time__Duration _t1 = (i64)(unixs + nanos);
	return _t1;
}

_result_time__Time time__parse_rfc3339(string s) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("datetime string is empty")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string sn = string_replace_each(s, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("t"), _SLIT("T"), _SLIT("z"), _SLIT("Z")})));
	_result_time__Time _t2 = time__parse_iso8601(sn);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(time__Time*) _t2.data = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	}
	
 	time__Time t =  (*(time__Time*)_t2.data);
	if (!time__Time__eq(t, ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,}))) {
		_result_time__Time _t3;
		_result_ok(&(time__Time[]) { t }, (_result*)(&_t3), sizeof(time__Time));
		return _t3;
	}
	_option_int _t4 = string_index(sn, _SLIT("T"));
	if (_t4.state != 0) {
		IError err = _t4.err;
		*(int*) _t4.data = -1;
	}
	
 	int t_i =  (*(int*)_t4.data);
	Array_string parts = (t_i != -1 ? (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(string_substr(sn, 0, t_i)), string_clone(string_substr(sn, (int)(t_i + 1), 2147483647))}))) : (string_split(sn, _SLIT(" "))));
	if (!string_contains_any((*(string*)array_get(parts, 0)), _SLIT(" Z")) && string_contains((*(string*)array_get(parts, 0)), _SLIT("-"))) {
		_result_multi_return_int_int_int _t5 = time__parse_iso8601_date(sn);
		if (_t5.is_error) {
			_result_time__Time _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 		multi_return_int_int_int mr_1049 =  (*(multi_return_int_int_int*)_t5.data);
		int year = mr_1049.arg0;
		int month = mr_1049.arg1;
		int day = mr_1049.arg2;
		t = time__new_time(((time__Time){.year = year,.month = month,.day = day,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,}));
		_result_time__Time _t7;
		_result_ok(&(time__Time[]) { t }, (_result*)(&_t7), sizeof(time__Time));
		return _t7;
	}
	if (!string_contains((*(string*)array_get(parts, 0)), _SLIT("-")) && string_contains((*(string*)array_get(parts, 0)), _SLIT(":"))) {
		int hour_ = 0;
		int minute_ = 0;
		int second_ = 0;
		int microsecond_ = 0;
		int nanosecond_ = 0;
		i64 unix_offset = ((i64)(0));
		bool is_local_time = true;
		_result_multi_return_int_int_int_int_int_i64_bool _t8 = time__parse_iso8601_time((*(string*)array_get(parts, 0)));
		if (_t8.is_error) {
			_result_time__Time _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		
 		multi_return_int_int_int_int_int_i64_bool mr_1464 =  (*(multi_return_int_int_int_int_int_i64_bool*)_t8.data);
		hour_ = mr_1464.arg0;
		minute_ = mr_1464.arg1;
		second_ = mr_1464.arg2;
		microsecond_ = mr_1464.arg3;
		nanosecond_ = mr_1464.arg4;
		unix_offset = mr_1464.arg5;
		is_local_time = mr_1464.arg6;
		t = time__new_time(((time__Time){.year = 0,.month = 0,.day = 0,.hour = hour_,.minute = minute_,.second = second_,.nanosecond = nanosecond_,.__v_unix = 0,.is_local = 0,.microsecond = 0,}));
		if (is_local_time) {
			_result_time__Time _t10;
			_result_ok(&(time__Time[]) { t }, (_result*)(&_t10), sizeof(time__Time));
			return _t10;
		}
		i64 unix_time = t.__v_unix;
		if (unix_offset < 0) {
			unix_time -= (-unix_offset);
		} else if (unix_offset > 0) {
			unix_time += unix_offset;
		}
		t = time__unix_nanosecond(((i64)(unix_time)), t.nanosecond);
		_result_time__Time _t11;
		_result_ok(&(time__Time[]) { t }, (_result*)(&_t11), sizeof(time__Time));
		return _t11;
	}
	return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(9, _SLIT("malformed date")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_time__Time time__parse(string s) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("datetime string is empty")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_int _t2 = string_index(s, _SLIT(" "));
	if (_t2.state != 0) {
		IError err = _t2.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(1, _SLIT("string has no space between date and time")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int pos =  (*(int*)_t2.data);
	string symd = string_substr(s, 0, pos);
	Array_string ymd = string_split(symd, _SLIT("-"));
	if (ymd.len != 3) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(2, _SLIT("date must be in the form of y-m-d")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string shms = string_substr(s, pos, 2147483647);
	Array_string hms = string_split(shms, _SLIT(":"));
	if (hms.len != 3) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(9, _SLIT("time must be in the form of H:i:s")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string hour_ = string_substr((*(string*)array_get(hms, 0)), 1, 2147483647);
	string minute_ = (*(string*)array_get(hms, 1));
	string second_ = (*(string*)array_get(hms, 2));
	_result_int _t6 = strconv__atoi((*(string*)array_get(ymd, 0)));
	if (_t6.is_error) {
		IError err = _t6.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid year format: "), /*115 &string*/0xfe10, {.d_s = (*(string*)array_get(ymd, 0))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int iyear =  (*(int*)_t6.data);
	_result_int _t8 = strconv__atoi((*(string*)array_get(ymd, 1)));
	if (_t8.is_error) {
		IError err = _t8.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid month format: "), /*115 &string*/0xfe10, {.d_s = (*(string*)array_get(ymd, 1))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int imonth =  (*(int*)_t8.data);
	_result_int _t10 = strconv__atoi((*(string*)array_get(ymd, 2)));
	if (_t10.is_error) {
		IError err = _t10.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid day format: "), /*115 &string*/0xfe10, {.d_s = (*(string*)array_get(ymd, 2))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int iday =  (*(int*)_t10.data);
	_result_int _t12 = strconv__atoi(hour_);
	if (_t12.is_error) {
		IError err = _t12.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid hour format: "), /*115 &string*/0xfe10, {.d_s = hour_}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int ihour =  (*(int*)_t12.data);
	_result_int _t14 = strconv__atoi(minute_);
	if (_t14.is_error) {
		IError err = _t14.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid minute format: "), /*115 &string*/0xfe10, {.d_s = minute_}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int iminute =  (*(int*)_t14.data);
	_result_int _t16 = strconv__atoi(second_);
	if (_t16.is_error) {
		IError err = _t16.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid second format: "), /*115 &string*/0xfe10, {.d_s = second_}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int isecond =  (*(int*)_t16.data);
	if (iyear > 9999 || iyear < -9999) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(3, _SLIT("year must be between -10000 and 10000")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (imonth > 12 || imonth < 1) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(4, _SLIT("month must be between 1 and 12")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (iday > 31 || iday < 1) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(5, _SLIT("day must be between 1 and 31")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (ihour > 23 || ihour < 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(6, _SLIT("hours must be between 0 and 24")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (iminute > 59 || iminute < 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(7, _SLIT("minutes must be between 0 and 60")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (isecond > 59 || isecond < 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(8, _SLIT("seconds must be between 0 and 60")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	time__Time res = time__new_time(((time__Time){
		.year = iyear,
		.month = imonth,
		.day = iday,
		.hour = ihour,
		.minute = iminute,
		.second = isecond,
		.nanosecond = 0,
		.__v_unix = 0,
		.is_local = 0,
		.microsecond = 0,
	}));
	_result_time__Time _t24;
	_result_ok(&(time__Time[]) { res }, (_result*)(&_t24), sizeof(time__Time));
	return _t24;
}

_result_time__Time time__parse_format(string s, string format) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("datetime string is empty")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	time__DateTimeParser p = time__new_date_time_parser(s, format);
	_result_time__Time _t2 = time__DateTimeParser_parse(&p);
	return _t2;
}

_result_time__Time time__parse_iso8601(string s) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("datetime string is empty")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_int _t2 = string_index(s, _SLIT("T"));
	if (_t2.state != 0) {
		IError err = _t2.err;
		*(int*) _t2.data = -1;
	}
	
 	int t_i =  (*(int*)_t2.data);
	Array_string parts = (t_i != -1 ? (new_array_from_c_array(2, 2, sizeof(string), _MOV((string[2]){string_clone(string_substr(s, 0, t_i)), string_clone(string_substr(s, (int)(t_i + 1), 2147483647))}))) : (string_split(s, _SLIT(" "))));
	if (!(parts.len == 1 || parts.len == 2)) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(12, _SLIT("malformed date")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_multi_return_int_int_int _t4 = time__parse_iso8601_date((*(string*)array_get(parts, 0)));
	if (_t4.is_error) {
		_result_time__Time _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	multi_return_int_int_int mr_5485 =  (*(multi_return_int_int_int*)_t4.data);
	int year = mr_5485.arg0;
	int month = mr_5485.arg1;
	int day = mr_5485.arg2;
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	int nanosecond_ = 0;
	i64 unix_offset = ((i64)(0));
	bool is_local_time = true;
	if (parts.len == 2) {
		_result_multi_return_int_int_int_int_int_i64_bool _t6 = time__parse_iso8601_time((*(string*)array_get(parts, 1)));
		if (_t6.is_error) {
			_result_time__Time _t7;
			memcpy(&_t7, &_t6, sizeof(_result));
			return _t7;
		}
		
 		multi_return_int_int_int_int_int_i64_bool mr_5759 =  (*(multi_return_int_int_int_int_int_i64_bool*)_t6.data);
		hour_ = mr_5759.arg0;
		minute_ = mr_5759.arg1;
		second_ = mr_5759.arg2;
		microsecond_ = mr_5759.arg3;
		nanosecond_ = mr_5759.arg4;
		unix_offset = mr_5759.arg5;
		is_local_time = mr_5759.arg6;
	}
	time__Time t = time__new_time(((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hour_,
		.minute = minute_,
		.second = second_,
		.nanosecond = nanosecond_,
		.__v_unix = 0,
		.is_local = 0,
		.microsecond = 0,
	}));
	if (is_local_time) {
		_result_time__Time _t8;
		_result_ok(&(time__Time[]) { t }, (_result*)(&_t8), sizeof(time__Time));
		return _t8;
	}
	i64 unix_time = t.__v_unix;
	if (unix_offset < 0) {
		unix_time -= (-unix_offset);
	} else if (unix_offset > 0) {
		unix_time += unix_offset;
	}
	t = time__unix_nanosecond(((i64)(unix_time)), t.nanosecond);
	_result_time__Time _t9;
	_result_ok(&(time__Time[]) { t }, (_result*)(&_t9), sizeof(time__Time));
	return _t9;
}

_result_time__Time time__parse_rfc2822(string s) {
	if ((s).len == 0) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(0, _SLIT("datetime string is empty")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_string fields = string_split(s, _SLIT(" "));
	if (fields.len < 5) {
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(1,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("datetime string must have 5 components, has: "), /*100 &int*/0xfe07, {.d_i32 = fields.len}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_int _t3 = string_index(_const_time__months_string, (*(string*)array_get(fields, 2)));
	if (_t3.state != 0) {
		IError err = _t3.err;
		return (_result_time__Time){ .is_error=true, .err=time__error_invalid_time(2, _SLIT("invalid month format")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int pos =  (*(int*)_t3.data);
	int mm = (int)((int)(pos / 3) + 1);
	{ // Unsafe block
		u8* tmstr = malloc_noscan((int)(s.len * 2));
		int count = snprintf(((char*)(tmstr)), ((int)(s.len * 2)), "%s-%02d-%s %s", (*(string*)array_get(fields, 3)).str, mm, (*(string*)array_get(fields, 1)).str, (*(string*)array_get(fields, 4)).str);
		_result_time__Time _t5 = time__parse(tos(tmstr, count));
		return _t5;
	}
	return (_result_time__Time){0};
}

VV_LOCAL_SYMBOL _result_multi_return_int_int_int time__parse_iso8601_date(string s) {
	int year = 0;
	int month = 0;
	int day = 0;
	u8 dummy = ((u8)(0));
	int count = sscanf(((char*)(s.str)), "%4d-%2d-%2d%c", &year, &month, &day, &dummy);
	if (count != 3) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=time__error_invalid_time(10,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("datetime string must have 3 components, but has "), /*100 &int*/0xfe07, {.d_i32 = count}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (year > 9999) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=time__error_invalid_time(13, _SLIT("year must be smaller than 10000")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (month > 12) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=time__error_invalid_time(14, _SLIT("month must be smaller than 12")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (day > 31) {
		return (_result_multi_return_int_int_int){ .is_error=true, .err=time__error_invalid_time(15, _SLIT("day must be smaller than 31")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_multi_return_int_int_int _t5;
	_result_ok(&(multi_return_int_int_int[]) { (multi_return_int_int_int){.arg0=year, .arg1=month, .arg2=day} }, (_result*)(&_t5), sizeof(multi_return_int_int_int));
	return _t5;
}

VV_LOCAL_SYMBOL _result_multi_return_int_int_int_int_int_i64_bool time__parse_iso8601_time(string s) {
	int hour_ = 0;
	int minute_ = 0;
	int second_ = 0;
	int microsecond_ = 0;
	int nanosecond_ = 0;
	rune plus_min_z = 'a';
	int offset_hour = 0;
	int offset_minute = 0;
	int count = 0;
	count = sscanf(((char*)(s.str)), "%2d:%2d:%2d.%9d%c", &hour_, &minute_, &second_, &nanosecond_, ((char*)(&plus_min_z)));
	if (count == 5 && plus_min_z == 'Z') {
		int ndigits = 0;
		_option_int _t1;
		if (_t1 = string_index(s, _SLIT(".")), _t1.state == 0) {
			int pos = *(int*)_t1.data;
			pos++;
			for (; pos < s.len && u8_is_digit(string_at(s, pos)); pos++) {
				ndigits++;
			}
		}
		for (;;) {
			if (!(ndigits < 9)) break;
			nanosecond_ *= 10;
			ndigits++;
		}
		microsecond_ = (int)(nanosecond_ / 1000);
	} else {
		count = sscanf(((char*)(s.str)), "%2d:%2d:%2d.%9d%c%2d:%2d", &hour_, &minute_, &second_, &microsecond_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
		if (count < 4) {
			count = sscanf(((char*)(s.str)), "%2d:%2d:%2d%c%2d:%2d", &hour_, &minute_, &second_, ((char*)(&plus_min_z)), &offset_hour, &offset_minute);
			count++;
		}
		if (count < 4) {
			return (_result_multi_return_int_int_int_int_int_i64_bool){ .is_error=true, .err=time__error_invalid_time(10, _SLIT("malformed date")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		nanosecond_ = (int)(microsecond_ * 1000);
	}
	bool is_local_time = plus_min_z == 'a' && count == 4;
	bool is_utc = plus_min_z == 'Z' && count == 5;
	if (!(count == 7 || is_local_time || is_utc)) {
		return (_result_multi_return_int_int_int_int_int_i64_bool){ .is_error=true, .err=time__error_invalid_time(11, _SLIT("malformed date")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (plus_min_z != '+' && plus_min_z != '-' && !is_utc && !is_local_time) {
		return (_result_multi_return_int_int_int_int_int_i64_bool){ .is_error=true, .err=time__error_invalid_time(12, _SLIT("missing timezone")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int unix_offset = 0;
	if (offset_hour > 0) {
		unix_offset += (int)(3600 * offset_hour);
	}
	if (offset_minute > 0) {
		unix_offset += (int)(60 * offset_minute);
	}
	if (plus_min_z == '+') {
		unix_offset *= -1;
	}
	_result_multi_return_int_int_int_int_int_i64_bool _t5;
	_result_ok(&(multi_return_int_int_int_int_int_i64_bool[]) { (multi_return_int_int_int_int_int_i64_bool){.arg0=hour_, .arg1=minute_, .arg2=second_, .arg3=microsecond_, .arg4=nanosecond_, .arg5=unix_offset, .arg6=is_local_time} }, (_result*)(&_t5), sizeof(multi_return_int_int_int_int_int_i64_bool));
	return _t5;
}

string time__TimeParseError_msg(time__TimeParseError err) {
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Invalid time format code: "), /*100 &int*/0xfe07, {.d_i32 = err.code}}, {_SLIT(", error: "), /*115 &string*/0xfe10, {.d_s = err.message}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL IError time__error_invalid_time(int code, string message) {
	IError _t1 = I_time__TimeParseError_to_Interface_IError(((time__TimeParseError*)memdup(&(time__TimeParseError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),.code = code,.message = message,}, sizeof(time__TimeParseError))));
	return _t1;
}

time__StopWatch time__new_stopwatch(time__StopWatchOptions opts) {
	u64 initial = ((u64)(0U));
	if (opts.auto_start) {
		initial = time__sys_mono_now();
	}
	time__StopWatch _t1 = ((time__StopWatch){.elapsed = 0U,.start = initial,.end = 0U,});
	return _t1;
}

void time__StopWatch_start(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0U;
}

void time__StopWatch_restart(time__StopWatch* t) {
	t->start = time__sys_mono_now();
	t->end = 0U;
	t->elapsed = 0U;
}

void time__StopWatch_stop(time__StopWatch* t) {
	t->end = time__sys_mono_now();
}

void time__StopWatch_pause(time__StopWatch* t) {
	if (t->start > 0U) {
		if (t->end == 0U) {
			t->elapsed += (u64)(time__sys_mono_now() - t->start);
		} else {
			t->elapsed += (u64)(t->end - t->start);
		}
	}
	t->start = 0U;
}

time__Duration time__StopWatch_elapsed(time__StopWatch t) {
	if (t.start > 0U) {
		if (t.end == 0U) {
			time__Duration _t1 = ((((i64)((u64)((u64)(time__sys_mono_now() - t.start) + t.elapsed)))));
			return _t1;
		} else {
			time__Duration _t2 = ((((i64)((u64)((u64)(t.end - t.start) + t.elapsed)))));
			return _t2;
		}
	}
	time__Duration _t3 = ((((i64)(t.elapsed))));
	return _t3;
}

// TypeDecl
time__Time time__now(void) {
	time__Time _t1 = time__win_now();
	return _t1;
	time__Time _t2 = time__linux_now();
	return _t2;
}

time__Time time__utc(void) {
	time__Time _t1 = time__win_utc();
	return _t1;
	time__Time _t2 = time__linux_utc();
	return _t2;
}

time__Time time__new_time(time__Time t) {
	if (t.__v_unix != 0) {
		return t;
	}
	struct tm tt = ((struct tm){
		.tm_year = (int)(t.year - 1900),
		.tm_mon = (int)(t.month - 1),
		.tm_mday = t.day,
		.tm_hour = t.hour,
		.tm_min = t.minute,
		.tm_sec = t.second,
	});
	i64 utime = time__make_unix_time(tt);
	time__Time _t2 = ((time__Time){.year = (t).year,.month = (t).month,.day = (t).day,.hour = (t).hour,.minute = (t).minute,.second = (t).second,.nanosecond = (t).nanosecond,.__v_unix = utime,.is_local = (t).is_local,.microsecond = (t).microsecond,});
	return _t2;
}

i64 time__ticks(void) {
	#if defined(_WIN32)
	{
		i64 _t2 = GetTickCount();
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

string time__Time_str(time__Time t) {
	string _t1 = time__Time_format_ss(t);
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__convert_ctime(struct tm t, int nanosecond) {
	time__Time _t1 = ((time__Time){
		.year = (int)(t.tm_year + 1900),
		.month = (int)(t.tm_mon + 1),
		.day = t.tm_mday,
		.hour = t.tm_hour,
		.minute = t.tm_min,
		.second = t.tm_sec,
		.nanosecond = nanosecond,
		.__v_unix = time__make_unix_time(t),
		.is_local = true,
		.microsecond = 0,
	});
	return _t1;
}

string time__Time_strftime(time__Time t, string fmt) {
	struct tm* tm = ((struct tm*)memdup(&(struct tm){.tm_year = 0,.tm_mon = 0,.tm_mday = 0,.tm_hour = 0,.tm_min = 0,.tm_sec = 0,}, sizeof(struct tm)));
	#if defined(_WIN32)
	{
		tm = gmtime(((voidptr)(&t.__v_unix)));
	}
	#else
	{
	}
	#endif
	Array_fixed_char_1024 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	char* fmt_c = ((char*)(fmt.str));
	strftime(&buf[0], ((usize)(sizeof(Array_fixed_char_1024))), fmt_c, tm);
	string _t2 = cstring_to_vstring(((char*)(&buf[0])));
	return _t2;
}

int time__Duration_sys_milliseconds(time__Duration d) {
	if (d > 2147483647 * _const_time__millisecond) {
		int _t1 = -1;
		return _t1;
	} else if (d <= 0) {
		int _t2 = 0;
		return _t2;
	} else {
		int _t3 = ((int)(d / _const_time__millisecond));
		return _t3;
	}
	return 0;
}

time__Time time__Time__static__new(time__Time t) {
	time__Time _t1 = time__new_time(t);
	return _t1;
}

string time__Time_smonth(time__Time* t) {
	if (t->month <= 0 || t->month > 12) {
		string _t1 = _SLIT("---");
		return _t1;
	}
	int i = (int)(t->month - 1);
	string _t2 = string_substr(_const_time__months_string, (int)(i * 3), (int)(((int)(i + 1)) * 3));
	return _t2;
}

// Attr: [inline]
inline i64 time__Time_unix_time(time__Time* t) {
	i64 _t1 = t->__v_unix;
	return _t1;
}

// Attr: [inline]
inline i64 time__Time_unix_time_milli(time__Time* t) {
	i64 _t1 = (i64)((i64)(t->__v_unix * 1000) + ((i64)(((i64)(t->nanosecond)) / 1000000)));
	return _t1;
}

// Attr: [inline]
inline i64 time__Time_unix_time_micro(time__Time* t) {
	i64 _t1 = (i64)((i64)(t->__v_unix * 1000000) + ((i64)(((i64)(t->nanosecond)) / 1000)));
	return _t1;
}

// Attr: [inline]
inline i64 time__Time_unix_time_nano(time__Time* t) {
	i64 _t1 = (i64)((i64)(t->__v_unix * 1000000000) + ((i64)(t->nanosecond)));
	return _t1;
}

time__Time time__Time_add(time__Time* t, time__Duration d) {
	i64 unixs = t->__v_unix;
	i64 nanos = (i64)(((i64)(t->nanosecond)) + time__Duration_nanoseconds(d));
	unixs += nanos / _const_time__second;
	nanos = nanos % _const_time__second;
	if (nanos < 0) {
		unixs--;
		nanos += _const_time__second;
	}
	if (t->is_local) {
		time__Time _t1 = time__Time_as_local(ADDR(time__Time, time__unix_nanosecond(unixs, ((int)(nanos)))));
		return _t1;
	}
	time__Time _t2 = time__unix_nanosecond(unixs, ((int)(nanos)));
	return _t2;
}

time__Time time__Time_add_seconds(time__Time* t, int seconds) {
	time__Time _t1 = time__Time_add(t, seconds * _const_time__second);
	return _t1;
}

time__Time time__Time_add_days(time__Time* t, int days) {
	time__Time _t1 = time__Time_add(t, (int)(days * 24) * _const_time__hour);
	return _t1;
}

time__Duration time__since(time__Time t) {
	time__Duration _t1 = time__Time__minus(time__now(), t);
	return _t1;
}

string time__Time_relative(time__Time* t) {
	time__Time znow = time__now();
	i64 secs = (i64)(znow.__v_unix - t->__v_unix);
	string prefix = _SLIT("");
	string suffix = _SLIT("");
	if (secs < 0) {
		secs *= -1;
		prefix = _SLIT("in ");
	} else {
		suffix = _SLIT(" ago");
	}
	if (secs < (int_literal)(_const_time__seconds_per_minute / 2)) {
		string _t1 = _SLIT("now");
		return _t1;
	}
	if (secs < _const_time__seconds_per_hour) {
		i64 m = (i64)(secs / _const_time__seconds_per_minute);
		if (m == 1) {
			string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT("1 minute"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t2;
		}
		string _t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = m}}, {_SLIT(" minutes"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t3;
	}
	if (secs < (int_literal)(_const_time__seconds_per_hour * 24)) {
		i64 h = (i64)(secs / _const_time__seconds_per_hour);
		if (h == 1) {
			string _t4 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT("1 hour"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t4;
		}
		string _t5 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = h}}, {_SLIT(" hours"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t5;
	}
	if (secs < (int_literal)((int_literal)(_const_time__seconds_per_hour * 24) * 7)) {
		i64 d = (i64)((i64)(secs / _const_time__seconds_per_hour) / 24);
		if (d == 1) {
			string _t6 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT("1 day"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t6;
		}
		string _t7 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = d}}, {_SLIT(" days"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t7;
	}
	if (secs < (int_literal)((int_literal)(_const_time__seconds_per_hour * 24) * _const_time__days_in_year)) {
		if (string__eq(prefix, _SLIT("in "))) {
			string _t8 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("on "), /*115 &string*/0xfe10, {.d_s = time__Time_md(/*rec*/*t)}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t8;
		}
		string _t9 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("last "), /*115 &string*/0xfe10, {.d_s = time__Time_md(/*rec*/*t)}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t9;
	}
	i64 y = (i64)((i64)((i64)(secs / _const_time__seconds_per_hour) / 24) / _const_time__days_in_year);
	if (y == 1) {
		string _t10 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT("1 year"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t10;
	}
	string _t11 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = y}}, {_SLIT(" years"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t11;
}

string time__Time_relative_short(time__Time* t) {
	time__Time znow = time__now();
	i64 secs = (i64)(znow.__v_unix - t->__v_unix);
	string prefix = _SLIT("");
	string suffix = _SLIT("");
	if (secs < 0) {
		secs *= -1;
		prefix = _SLIT("in ");
	} else {
		suffix = _SLIT(" ago");
	}
	if (secs < (int_literal)(_const_time__seconds_per_minute / 2)) {
		string _t1 = _SLIT("now");
		return _t1;
	}
	if (secs < _const_time__seconds_per_hour) {
		i64 m = (i64)(secs / _const_time__seconds_per_minute);
		if (m == 1) {
			string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT("1m"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t2;
		}
		string _t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = m}}, {_SLIT("m"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t3;
	}
	if (secs < (int_literal)(_const_time__seconds_per_hour * 24)) {
		i64 h = (i64)(secs / _const_time__seconds_per_hour);
		if (h == 1) {
			string _t4 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT("1h"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t4;
		}
		string _t5 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = h}}, {_SLIT("h"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t5;
	}
	if (secs < (int_literal)((int_literal)(_const_time__seconds_per_hour * 24) * _const_time__days_in_year)) {
		i64 d = (i64)((i64)(secs / _const_time__seconds_per_hour) / 24);
		if (d == 1) {
			string _t6 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT("1d"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
			return _t6;
		}
		string _t7 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = d}}, {_SLIT("d"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t7;
	}
	i64 y = (i64)((i64)((i64)(secs / _const_time__seconds_per_hour) / 24) / _const_time__days_in_year);
	if (y == 1) {
		string _t8 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT("1y"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t8;
	}
	string _t9 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = prefix}}, {_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = y}}, {_SLIT("y"), /*115 &string*/0xfe10, {.d_s = suffix}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t9;
}

int time__day_of_week(int y, int m, int d) {
	Array_int t = new_array_from_c_array_noscan(12, 12, sizeof(int), _MOV((int[12]){
			0, 3, 2, 5, 0, 3, 5, 1, 4,
			6, 2, 4}));
	int sy = y;
	if (m < 3) {
		sy = (int)(sy - 1);
	}
	int _t1 = (int)((int)(((int)((int)((int)((int)((int)((int)(sy + (int)(sy / 4)) - (int)(sy / 100)) + (int)(sy / 400)) + (*(int*)array_get(t, (int)(m - 1)))) + d) - 1)) % 7) + 1);
	return _t1;
}

int time__Time_day_of_week(time__Time* t) {
	int _t1 = time__day_of_week(t->year, t->month, t->day);
	return _t1;
}

int time__Time_year_day(time__Time* t) {
	int yday = (int)(t->day + (*(int*)array_get(_const_time__days_before, (int)(t->month - 1))));
	if (time__is_leap_year(t->year) && t->month > 2) {
		int _t1 = (int)(yday + 1);
		return _t1;
	}
	return yday;
}

string time__Time_weekday_str(time__Time* t) {
	int i = (int)(time__Time_day_of_week(t) - 1);
	string _t1 = string_substr((*(string*)array_get(_const_time__long_days, i)), 0, 3);
	return _t1;
}

string time__Time_long_weekday_str(time__Time* t) {
	int i = (int)(time__Time_day_of_week(t) - 1);
	string _t1 = (*(string*)array_get(_const_time__long_days, i));
	return _t1;
}

bool time__is_leap_year(int year) {
	bool _t1 = (int)(year % 4) == 0 && ((int)(year % 100) != 0 || (int)(year % 400) == 0);
	return _t1;
}

_result_int time__days_in_month(int month, int year) {
	if (month > 12 || month < 1) {
		return (_result_int){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid month: "), /*100 &int*/0xfe07, {.d_i32 = month}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int extra = (month == 2 && time__is_leap_year(year) ? (1) : (0));
	int res = (int)((*(int*)array_get(_const_time__month_days, (int)(month - 1))) + extra);
	_result_int _t2;
	_result_ok(&(int[]) { res }, (_result*)(&_t2), sizeof(int));
	return _t2;
}

string time__Time_debug(time__Time* t) {
	string _t1 =  str_intp(9, _MOV((StrIntpData[]){{_SLIT("Time{ year: "), /*100 &int*/0x8008fe27, {.d_i32 = t->year}}, {_SLIT(" month: "), /*100 &int*/0x8004fe27, {.d_i32 = t->month}}, {_SLIT(" day: "), /*100 &int*/0x8004fe27, {.d_i32 = t->day}}, {_SLIT(" hour: "), /*100 &int*/0x8004fe27, {.d_i32 = t->hour}}, {_SLIT(" minute: "), /*100 &int*/0x8004fe27, {.d_i32 = t->minute}}, {_SLIT(" second: "), /*100 &int*/0x8004fe27, {.d_i32 = t->second}}, {_SLIT(" nanosecond: "), /*100 &int*/0x8012fe27, {.d_i32 = t->nanosecond}}, {_SLIT(" unix: "), /*100 &i64*/0x800efe29, {.d_i64 = t->__v_unix}}, {_SLIT(" }"), 0, { .d_c = 0 }}}));
	return _t1;
}

// TypeDecl
i64 time__Duration_nanoseconds(time__Duration d) {
	i64 _t1 = ((i64)(d));
	return _t1;
}

i64 time__Duration_microseconds(time__Duration d) {
	i64 _t1 = ((i64)(d)) / _const_time__microsecond;
	return _t1;
}

i64 time__Duration_milliseconds(time__Duration d) {
	i64 _t1 = ((i64)(d)) / _const_time__millisecond;
	return _t1;
}

f64 time__Duration_seconds(time__Duration d) {
	f64 _t1 = (f64)(((f64)(d)) / ((f64)(_const_time__second)));
	return _t1;
}

f64 time__Duration_minutes(time__Duration d) {
	f64 _t1 = (f64)(((f64)(d)) / ((f64)(_const_time__minute)));
	return _t1;
}

f64 time__Duration_hours(time__Duration d) {
	f64 _t1 = (f64)(((f64)(d)) / ((f64)(_const_time__hour)));
	return _t1;
}

f64 time__Duration_days(time__Duration d) {
	f64 _t1 = (f64)(((f64)(d)) / ((f64)(_const_time__hour * 24)));
	return _t1;
}

string time__Duration_str(time__Duration d) {
	if (time__Duration_alias_eq(d, _const_time__infinite)) {
		string _t1 = _SLIT("inf");
		return _t1;
	}
	i64 t = ((i64)(d));
	i64 hr = t / _const_time__hour;
	t -= hr * _const_time__hour;
	i64 min = t / _const_time__minute;
	t -= min * _const_time__minute;
	i64 sec = t / _const_time__second;
	t -= sec * _const_time__second;
	i64 ms = t / _const_time__millisecond;
	t -= ms * _const_time__millisecond;
	i64 us = t / _const_time__microsecond;
	t -= us * _const_time__microsecond;
	i64 ns = t;
	if (hr > 0) {
		string _t2 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = hr}}, {_SLIT(":"), /*100 &i64*/0x8004fe29, {.d_i64 = min}}, {_SLIT(":"), /*100 &i64*/0x8004fe29, {.d_i64 = sec}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t2;
	}
	if (min > 0) {
		string _t3 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = min}}, {_SLIT(":"), /*100 &i64*/0x8004fe29, {.d_i64 = sec}}, {_SLIT("."), /*100 &i64*/0x8006fe29, {.d_i64 = ms}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return _t3;
	}
	if (sec > 0) {
		string _t4 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = sec}}, {_SLIT("."), /*100 &i64*/0x8006fe29, {.d_i64 = ms}}, {_SLIT("s"), 0, { .d_c = 0 }}}));
		return _t4;
	}
	if (ms > 0) {
		string _t5 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = ms}}, {_SLIT("."), /*100 &i64*/0x8006fe29, {.d_i64 = us}}, {_SLIT("ms"), 0, { .d_c = 0 }}}));
		return _t5;
	}
	if (us > 0) {
		string _t6 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = us}}, {_SLIT("."), /*100 &i64*/0x8006fe29, {.d_i64 = ns}}, {_SLIT("us"), 0, { .d_c = 0 }}}));
		return _t6;
	}
	string _t7 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = ns}}, {_SLIT("ns"), 0, { .d_c = 0 }}}));
	return _t7;
}

string time__Duration_debug(time__Duration d) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	i64 x = ((i64)(d));
	string sign = _SLIT("");
	if (x < 0) {
		sign = _SLIT("- ");
		x = -x;
	}
	Map_string_i64 _t1 = new_map_init_noscan_value(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 6, sizeof(string), sizeof(i64),
			_MOV((string[6]){
				_SLIT("days"), 
				_SLIT("h"), 
				_SLIT("m"), 
				_SLIT("s"), 
				_SLIT("ms"), 
				_SLIT("us"), 
			}),
			_MOV((i64[6]){
				24 * _const_time__hour, 
				_const_time__hour, 
				_const_time__minute, 
				_const_time__second, 
				_const_time__millisecond, 
				_const_time__microsecond, 
			})
		)
	
	;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		string label = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t2);
		label = string_clone(label);
		i64 v = (*(i64*)DenseArray_value(&_t1.key_values, _t2));
		if (x > v) {
			i64 xx = (i64)(x / v);
			x = (i64)(x % v);
			array_push((array*)&res, _MOV((string[]){ string_clone(string__plus(i64_str(xx), label)) }));
		}
	}
	if (x > 0) {
		array_push((array*)&res, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &i64*/0xfe09, {.d_i64 = x}}, {_SLIT("ns"), 0, { .d_c = 0 }}}))) }));
	}
	string _t7 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("Duration: "), /*115 &string*/0xfe10, {.d_s = sign}}, {_SLIT0, /*115 &string*/0xfe10, {.d_s = Array_string_join(res, _SLIT(", "))}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t7;
}

int time__offset(void) {
	time__Time t = time__utc();
	time__Time local = time__Time_local(&t);
	int _t1 = ((int)((i64)(local.__v_unix - t.__v_unix)));
	return _t1;
}

time__Time time__Time_local_to_utc(time__Time* t) {
	if (!t->is_local) {
		return *t;
	}
	time__Time _t3 = time__Time_add(t, -time__offset() * _const_time__second);
	time__Time _t2 = ((time__Time){.year = _t3.year,.month = _t3.month,.day = _t3.day,.hour = _t3.hour,.minute = _t3.minute,.second = _t3.second,.nanosecond = _t3.nanosecond,.__v_unix = _t3.__v_unix,.is_local = false,.microsecond = _t3.microsecond,});
	return _t2;
}

time__Time time__Time_utc_to_local(time__Time* u) {
	if (u->is_local) {
		return *u;
	}
	time__Time _t3 = time__Time_add(u, time__offset() * _const_time__second);
	time__Time _t2 = ((time__Time){.year = _t3.year,.month = _t3.month,.day = _t3.day,.hour = _t3.hour,.minute = _t3.minute,.second = _t3.second,.nanosecond = _t3.nanosecond,.__v_unix = _t3.__v_unix,.is_local = true,.microsecond = _t3.microsecond,});
	return _t2;
}

time__Time time__Time_as_local(time__Time* t) {
	time__Time _t1 = ((time__Time){.year = (t)->year,.month = (t)->month,.day = (t)->day,.hour = (t)->hour,.minute = (t)->minute,.second = (t)->second,.nanosecond = (t)->nanosecond,.__v_unix = (t)->__v_unix,.is_local = true,.microsecond = (t)->microsecond,});
	return _t1;
}

time__Time time__Time_as_utc(time__Time* t) {
	time__Time _t1 = ((time__Time){.year = (t)->year,.month = (t)->month,.day = (t)->day,.hour = (t)->hour,.minute = (t)->minute,.second = (t)->second,.nanosecond = (t)->nanosecond,.__v_unix = (t)->__v_unix,.is_local = false,.microsecond = (t)->microsecond,});
	return _t1;
}

bool time__Time_is_utc(time__Time* t) {
	bool _t1 = !t->is_local;
	return _t1;
}

VV_LOCAL_SYMBOL i64 time__make_unix_time(struct tm t) {
	i64 _t1 = time__portable_timegm(&t);
	return _t1;
}

VV_LOCAL_SYMBOL u64 time__init_win_time_freq(void) {
	u64 f = ((u64)(0U));
	QueryPerformanceFrequency(((voidptr)(&f)));
	return f;
}

VV_LOCAL_SYMBOL u64 time__init_win_time_start(void) {
	u64 s = ((u64)(0U));
	QueryPerformanceCounter(((voidptr)(&s)));
	return s;
}

u64 time__sys_mono_now(void) {
	u64 tm = ((u64)(0U));
	QueryPerformanceCounter(((voidptr)(&tm)));
	u64 _t1 = (u64)((u64)(((u64)(tm - _const_time__start_time)) * 1000000000U) / _const_time__freq_time);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 time__vpc_now(void) {
	u64 tm = ((u64)(0U));
	QueryPerformanceCounter(((voidptr)(&tm)));
	return tm;
}

VV_LOCAL_SYMBOL i64 time__local_as_unix_time(void) {
	C__time_t t = time(0);
	struct tm* tm = localtime(&t);
	i64 _t1 = time__make_unix_time(*tm);
	return _t1;
}

time__Time time__Time_local(time__Time* t) {
	if (t->is_local) {
		return *t;
	}
	time__SystemTime st_utc = ((time__SystemTime){
		.year = ((u16)(t->year)),
		.month = ((u16)(t->month)),
		.day_of_week = 0,
		.day = ((u16)(t->day)),
		.hour = ((u16)(t->hour)),
		.minute = ((u16)(t->minute)),
		.second = ((u16)(t->second)),
		.millisecond = ((u16)((int)(t->nanosecond / 1000000))),
	});
	time__SystemTime st_local = ((time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,});
	SystemTimeToTzSpecificLocalTime(((void*)0), ((voidptr)(&st_utc)), ((voidptr)(&st_local)));
	time__Time t_local = ((time__Time){
		.year = st_local.year,
		.month = st_local.month,
		.day = st_local.day,
		.hour = st_local.hour,
		.minute = st_local.minute,
		.second = st_local.second,
		.nanosecond = (int)(((int)(st_local.millisecond)) * 1000000),
		.__v_unix = time__SystemTime_unix_time(st_local),
		.is_local = 0,
		.microsecond = 0,
	});
	return t_local;
}

VV_LOCAL_SYMBOL time__Time time__win_now(void) {
	struct _FILETIME ft_utc = ((struct _FILETIME){.dwLowDateTime = 0,.dwHighDateTime = 0,});
	GetSystemTimeAsFileTime(&ft_utc);
	time__SystemTime st_utc = ((time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,});
	FileTimeToSystemTime(&ft_utc, ((voidptr)(&st_utc)));
	time__SystemTime st_local = ((time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,});
	SystemTimeToTzSpecificLocalTime(((void*)0), ((voidptr)(&st_utc)), ((voidptr)(&st_local)));
	time__Time t = ((time__Time){
		.year = st_local.year,
		.month = st_local.month,
		.day = st_local.day,
		.hour = st_local.hour,
		.minute = st_local.minute,
		.second = st_local.second,
		.nanosecond = (int)(((int)(st_local.millisecond)) * 1000000),
		.__v_unix = time__SystemTime_unix_time(st_local),
		.is_local = true,
		.microsecond = 0,
	});
	return t;
}

VV_LOCAL_SYMBOL time__Time time__win_utc(void) {
	struct _FILETIME ft_utc = ((struct _FILETIME){.dwLowDateTime = 0,.dwHighDateTime = 0,});
	GetSystemTimeAsFileTime(&ft_utc);
	time__SystemTime st_utc = ((time__SystemTime){.year = 0,.month = 0,.day_of_week = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.millisecond = 0,});
	FileTimeToSystemTime(&ft_utc, ((voidptr)(&st_utc)));
	time__Time t = ((time__Time){
		.year = st_utc.year,
		.month = st_utc.month,
		.day = st_utc.day,
		.hour = st_utc.hour,
		.minute = st_utc.minute,
		.second = st_utc.second,
		.nanosecond = (int)(((int)(st_utc.millisecond)) * 1000000),
		.__v_unix = time__SystemTime_unix_time(st_utc),
		.is_local = false,
		.microsecond = 0,
	});
	return t;
}

VV_LOCAL_SYMBOL i64 time__SystemTime_unix_time(time__SystemTime st) {
	struct tm tt = ((struct tm){
		.tm_year = (u16)(st.year - 1900U),
		.tm_mon = (u16)(st.month - 1U),
		.tm_mday = st.day,
		.tm_hour = st.hour,
		.tm_min = st.minute,
		.tm_sec = st.second,
	});
	i64 _t1 = time__make_unix_time(tt);
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__darwin_now(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__linux_now(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__solaris_now(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__darwin_utc(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__linux_utc(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	return _t1;
}

VV_LOCAL_SYMBOL time__Time time__solaris_utc(void) {
	time__Time _t1 = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	return _t1;
}

void time__sleep(time__Duration duration) {
	Sleep(((int)(duration / _const_time__millisecond)));
}

time__Time time__unix(i64 abs) {
	i64 day_offset = (i64)(abs / _const_time__seconds_per_day);
	if ((i64)(abs % _const_time__seconds_per_day) < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_516 = time__calculate_date_from_offset(day_offset);
	int year = mr_516.arg0;
	int month = mr_516.arg1;
	int day = mr_516.arg2;
	multi_return_int_int_int mr_572 = time__calculate_time_from_offset((i64)(abs % _const_time__seconds_per_day));
	int hr = mr_572.arg0;
	int min = mr_572.arg1;
	int sec = mr_572.arg2;
	time__Time _t1 = ((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.nanosecond = 0,
		.__v_unix = abs,
		.is_local = 0,
		.microsecond = 0,
	});
	return _t1;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
time__Time time__unix2(i64 abs, int microsecond) {
	time__Time _t1 = time__unix_nanosecond(abs, (int)(microsecond * 1000));
	return _t1;
}

time__Time time__unix_microsecond(i64 abs, int microsecond) {
	time__Time _t1 = time__unix_nanosecond(abs, (int)(microsecond * 1000));
	return _t1;
}

time__Time time__unix_nanosecond(i64 abs, int nanosecond) {
	i64 day_offset = (i64)(abs / _const_time__seconds_per_day);
	if ((i64)(abs % _const_time__seconds_per_day) < 0) {
		day_offset--;
	}
	multi_return_int_int_int mr_1601 = time__calculate_date_from_offset(day_offset);
	int year = mr_1601.arg0;
	int month = mr_1601.arg1;
	int day = mr_1601.arg2;
	multi_return_int_int_int mr_1657 = time__calculate_time_from_offset((i64)(abs % _const_time__seconds_per_day));
	int hr = mr_1657.arg0;
	int min = mr_1657.arg1;
	int sec = mr_1657.arg2;
	time__Time _t1 = ((time__Time){
		.year = year,
		.month = month,
		.day = day,
		.hour = hr,
		.minute = min,
		.second = sec,
		.nanosecond = nanosecond,
		.__v_unix = abs,
		.is_local = 0,
		.microsecond = 0,
	});
	return _t1;
}

VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_date_from_offset(i64 day_offset_) {
	i64 day_offset = day_offset_;
	day_offset += 719468;
	int era = 0;
	if (day_offset >= 0) {
		era = ((int)((i64)(day_offset / _const_time__days_per_400_years)));
	} else {
		era = ((int)((i64)(((i64)((i64)(day_offset - _const_time__days_per_400_years) - 1)) / _const_time__days_per_400_years)));
	}
	i64 doe = (i64)(day_offset - (int)(era * _const_time__days_per_400_years));
	i64 yoe = (i64)(((i64)((i64)((i64)(doe - (i64)(doe / ((int_literal)(_const_time__days_per_4_years - 1)))) + (i64)(doe / _const_time__days_per_100_years)) - (i64)(doe / ((int_literal)(_const_time__days_per_400_years - 1))))) / _const_time__days_in_year);
	int y = ((int)((i64)(yoe + (int)(era * 400))));
	i64 doy = (i64)(doe - ((i64)((i64)((i64)(_const_time__days_in_year * yoe) + (i64)(yoe / 4)) - (i64)(yoe / 100))));
	i64 mp = (i64)(((i64)((i64)(5 * doy) + 2)) / 153);
	int d = ((int)((i64)((i64)(doy - (i64)(((i64)((i64)(153 * mp) + 2)) / 5)) + 1)));
	int m = ((int)(mp));
	if (mp < 10) {
		m += 3;
	} else {
		m -= 9;
	}
	if (m <= 2) {
		y += 1;
	}
	return (multi_return_int_int_int){.arg0=y, .arg1=m, .arg2=d};
}

VV_LOCAL_SYMBOL multi_return_int_int_int time__calculate_time_from_offset(i64 second_offset_) {
	i64 second_offset = second_offset_;
	if (second_offset < 0) {
		second_offset += _const_time__seconds_per_day;
	}
	i64 hour_ = (i64)(second_offset / _const_time__seconds_per_hour);
	second_offset %= _const_time__seconds_per_hour;
	i64 min = (i64)(second_offset / _const_time__seconds_per_minute);
	second_offset %= _const_time__seconds_per_minute;
	return (multi_return_int_int_int){.arg0=((int)(hour_)), .arg1=((int)(min)), .arg2=((int)(second_offset))};
}

int arrays__fold_T_discord__Intents_int(Array_discord__Intents __v_array, int init, int (*fold_op)(int acc, discord__Intents elem)) {
	int value = init;
	for (int _t1 = 0; _t1 < __v_array.len; ++_t1) {
		discord__Intents e = ((discord__Intents*)__v_array.data)[_t1];
		value = fold_op(value, e);
	}
	return value;
}

Array_string arrays__map_indexed_T_x__json2__Any_string(Array_x__json2__Any __v_array, string (*transform)(int idx, x__json2__Any elem)) {
	Array_string result = __new_array_with_default(0, __v_array.len, sizeof(string), 0);
	for (int i = 0; i < __v_array.len; ++i) {
		x__json2__Any v = ((x__json2__Any*)__v_array.data)[i];
		array_push((array*)&result, _MOV((string[]){ string_clone(transform(i, v)) }));
	}
	return result;
}

// Attr: [unsafe]
VV_LOCAL_SYMBOL void arrays__memswap(voidptr x, voidptr y, usize len) {
	isize block_size = ((isize)(sizeof(arrays__Block)));
	usize i = ((usize)(0));
	for (;;) {
		if (!((usize)(i + ((usize)(block_size))) <= len)) break;
		arrays__Block *t_ = HEAP(arrays__Block, (((arrays__Block){.x = 0,.y = 0,.z = 0,.w = 0,})));
		voidptr t = ((voidptr)(&(*(t_))));
		usize xi = (usize)(((usize)(x)) + i);
		usize yi = (usize)(((usize)(y)) + i);
		{ // Unsafe block
			vmemcpy(t, ((voidptr)(xi)), block_size);
			vmemcpy(((voidptr)(xi)), ((voidptr)(yi)), block_size);
			vmemcpy(t, ((voidptr)(yi)), block_size);
		}
		i += ((usize)(block_size));
	}
	if (i < len) {
		arrays__UnalignedBlock *t_ = HEAP(arrays__UnalignedBlock, (((arrays__UnalignedBlock){.x = 0,.y = 0,.z = 0,.w = 0,})));
		voidptr t = ((voidptr)(&(*(t_))));
		isize rem = ((isize)((usize)(len - i)));
		usize xi = (usize)(((usize)(x)) + i);
		usize yi = (usize)(((usize)(y)) + i);
		{ // Unsafe block
			vmemcpy(t, ((voidptr)(xi)), rem);
			vmemcpy(((voidptr)(xi)), ((voidptr)(yi)), rem);
			vmemcpy(((voidptr)(yi)), t, rem);
		}
	}
}

Array_string arrays__uniq_T_string(Array_string a) {
	Array_string res = __new_array_with_default(0, (int)(a.len / 10), sizeof(string), 0);
	int j = -1;
	if (a.len > 0) {
		j = 0;
		array_push((array*)&res, _MOV((string[]){ string_clone((*(string*)array_get(a, 0))) }));
	}
	for (int idx = 0; idx < a.len; ++idx) {
		string e = ((string*)a.data)[idx];
		if (string__eq((*(string*)array_get(a, j)), e)) {
			continue;
		}
		j = idx;
		array_push((array*)&res, _MOV((string[]){ string_clone(e) }));
	}
	return res;
}

Array_string arrays__distinct_T_string(Array_string a) {
	Array_string _t2 = array_clone_to_depth(ADDR(Array_string,a), 0);
	qsort(_t2.data, _t2.len, _t2.element_size, (int (*)(const void *, const void *))&compare_6313278466669073374_string);
	Array_string _t1 = arrays__uniq_T_string(_t2);
	return _t1;
}

int encoding__base64__encode_in_buffer(Array_u8 data, u8* buffer) {
	int _t1 = encoding__base64__encode_from_buffer(buffer, data.data, data.len);
	return _t1;
}

VV_LOCAL_SYMBOL int encoding__base64__encode_from_buffer(u8* dest, u8* src, int src_len) {
	if (src_len == 0) {
		int _t1 = 0;
		return _t1;
	}
	int output_length = (int)(4 * ((int)(((int)(src_len + 2)) / 3)));
	u8* d = src;
	u8* b = dest;
	u8* etable = _const_encoding__base64__enc_table.str;
	int di = 0;
	int si = 0;
	int n = (int)(((int)(src_len / 3)) * 3);
	for (;;) {
		if (!(si < n)) break;
		{ // Unsafe block
			u32 val = (((((u32)(d[(int)(si + 0)])) << 16U) | (((u32)(d[(int)(si + 1)])) << 8U)) | ((u32)(d[(int)(si + 2)])));
			b[(int)(di + 0)] = etable[((val >> 18U) & 0x3FU)];
			b[(int)(di + 1)] = etable[((val >> 12U) & 0x3FU)];
			b[(int)(di + 2)] = etable[((val >> 6U) & 0x3FU)];
			b[(int)(di + 3)] = etable[(val & 0x3FU)];
		}
		si += 3;
		di += 4;
	}
	int remain = (int)(src_len - si);
	if (remain == 0) {
		return output_length;
	}
	{ // Unsafe block
		u32 val = (((u32)(d[(int)(si + 0)])) << 16U);
		if (remain == 2) {
			val |= (((u32)(d[(int)(si + 1)])) << 8U);
		}
		b[(int)(di + 0)] = etable[((val >> 18U) & 0x3FU)];
		b[(int)(di + 1)] = etable[((val >> 12U) & 0x3FU)];
		switch (remain) {
			case 2: {
					b[(int)(di + 2)] = etable[((val >> 6U) & 0x3FU)];
					b[(int)(di + 3)] = ((u8)('='));
					break;
			}
			case 1: {
					b[(int)(di + 2)] = ((u8)('='));
					b[(int)(di + 3)] = ((u8)('='));
					break;
			}
			default: {
					_v_panic(_SLIT("base64: This case should never occur."));
					VUNREACHABLE();
					break;
			}
		}
		
	}
	return output_length;
}

int encoding__base64__decode_in_buffer(string* data, u8* buffer) {
	int _t1 = encoding__base64__decode_from_buffer(buffer, data->str, data->len);
	return _t1;
}

int encoding__base64__decode_in_buffer_bytes(Array_u8 data, u8* buffer) {
	int _t1 = encoding__base64__decode_from_buffer(buffer, data.data, data.len);
	return _t1;
}

VV_LOCAL_SYMBOL int encoding__base64__decode_from_buffer(u8* dest, u8* src, int src_len) {
	if (src_len < 4) {
		int _t1 = 0;
		return _t1;
	}
	int padding = 0;
	if (src[(int)(src_len - 1)] == '=') {
		if (src[(int)(src_len - 2)] == '=') {
			padding = 2;
		} else {
			padding = 1;
		}
	}
	u8* d = src;
	u8* b = dest;
	{ // Unsafe block
		int n_decoded_bytes = 0;
		int si = 0;
		encoding__base64__B64_64_datablock datablock_64 = ((encoding__base64__B64_64_datablock){.data = 0U,});
		encoding__base64__B64_32_datablock datablock_32 = ((encoding__base64__B64_32_datablock){.data = 0U,});
		for (;;) {
			if (!((int)(src_len - si) >= 8)) break;
			datablock_64.data = encoding__base64__assemble64(((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 0)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 1)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 2)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 3)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 4)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 5)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 6)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 7)], 123)])));
			#if defined(TARGET_ORDER_IS_LITTLE)
			{
				b[(int)(n_decoded_bytes + 0)] = datablock_64.data_byte[7];
				b[(int)(n_decoded_bytes + 1)] = datablock_64.data_byte[6];
				b[(int)(n_decoded_bytes + 2)] = datablock_64.data_byte[5];
				b[(int)(n_decoded_bytes + 3)] = datablock_64.data_byte[4];
				b[(int)(n_decoded_bytes + 4)] = datablock_64.data_byte[3];
				b[(int)(n_decoded_bytes + 5)] = datablock_64.data_byte[2];
			}
			#else
			{
				b[(int)(n_decoded_bytes + 0)] = datablock_64.data_byte[0];
				b[(int)(n_decoded_bytes + 1)] = datablock_64.data_byte[1];
				b[(int)(n_decoded_bytes + 2)] = datablock_64.data_byte[2];
				b[(int)(n_decoded_bytes + 3)] = datablock_64.data_byte[3];
				b[(int)(n_decoded_bytes + 4)] = datablock_64.data_byte[4];
				b[(int)(n_decoded_bytes + 5)] = datablock_64.data_byte[5];
			}
			#endif
			n_decoded_bytes += 6;
			si += 8;
		}
		for (;;) {
			if (!((int)(src_len - si) >= 4)) break;
			datablock_32.data = encoding__base64__assemble32(((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 0)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 1)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 2)], 123)])), ((u8)(_const_encoding__base64__index[v_fixed_index(d[(int)(si + 3)], 123)])));
			#if defined(TARGET_ORDER_IS_LITTLE)
			{
				b[(int)(n_decoded_bytes + 0)] = datablock_32.data_byte[3];
				b[(int)(n_decoded_bytes + 1)] = datablock_32.data_byte[2];
				b[(int)(n_decoded_bytes + 2)] = datablock_32.data_byte[1];
				b[(int)(n_decoded_bytes + 3)] = datablock_32.data_byte[0];
			}
			#else
			{
				b[(int)(n_decoded_bytes + 0)] = datablock_32.data_byte[0];
				b[(int)(n_decoded_bytes + 1)] = datablock_32.data_byte[1];
				b[(int)(n_decoded_bytes + 2)] = datablock_32.data_byte[2];
				b[(int)(n_decoded_bytes + 3)] = datablock_32.data_byte[3];
			}
			#endif
			n_decoded_bytes += 3;
			si += 4;
		}
		int _t4 = (int)(n_decoded_bytes - padding);
		return _t4;
	}
	return 0;
}

Array_u8 encoding__base64__decode(string data) {
	i64 size = (i64)((i64)(((i64)(data.len)) * 3) / 4);
	if (size <= 0 || (int)(data.len % 4) != 0) {
		Array_u8 _t1 = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
		return _t1;
	}
	size = (((i64)(size + 3)) & ~0x03);
	{ // Unsafe block
		u8* buffer = _v_malloc(((int)(size)));
		int n = encoding__base64__decode_in_buffer((voidptr)&/*qq*/data, buffer);
		Array_u8 _t2 = u8_vbytes(buffer, n);
		return _t2;
	}
	return __new_array_noscan(0, 0, sizeof(u8));
}

string encoding__base64__decode_str(string data) {
	int size = (int)((int)(data.len * 3) / 4);
	if (size <= 0 || (int)(data.len % 4) != 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	{ // Unsafe block
		u8* buffer = malloc_noscan((int)(size + 1));
		buffer[size] = 0;
		int blen = encoding__base64__decode_in_buffer((voidptr)&/*qq*/data, buffer);
		string _t2 = tos(buffer, blen);
		return _t2;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

string encoding__base64__encode(Array_u8 data) {
	string _t1 = encoding__base64__alloc_and_encode(data.data, data.len);
	return _t1;
}

string encoding__base64__encode_str(string data) {
	string _t1 = encoding__base64__alloc_and_encode(data.str, data.len);
	return _t1;
}

VV_LOCAL_SYMBOL string encoding__base64__alloc_and_encode(u8* src, int len) {
	if (len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	int size = (int)(4 * ((int)(((int)(len + 2)) / 3)));
	if (size <= 0) {
		string _t2 = _SLIT("");
		return _t2;
	}
	{ // Unsafe block
		u8* buffer = malloc_noscan((int)(size + 1));
		buffer[size] = 0;
		int blen = encoding__base64__encode_from_buffer(buffer, src, len);
		string _t3 = tos(buffer, blen);
		return _t3;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

Array_u8 encoding__base64__url_decode(string data) {
	string result = string_replace_each(data, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("-"), _SLIT("+"), _SLIT("_"), _SLIT("/")})));
	int /*A*/ _t1 = (int)(result.len % 4);
		switch (_t1) {
		case 2: {
				result = string__plus(result, _SLIT("=="));
				break;
		}
		case 3: {
				result = string__plus(result, _SLIT("="));
				break;
		}
		default: {
				break;
		}
	}
	
	Array_u8 _t2 = encoding__base64__decode(result);
	return _t2;
}

string encoding__base64__url_decode_str(string data) {
	string result = string_replace_each(data, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("-"), _SLIT("+"), _SLIT("_"), _SLIT("/")})));
	int /*A*/ _t1 = (int)(result.len % 4);
		switch (_t1) {
		case 2: {
				result = string__plus(result, _SLIT("=="));
				break;
		}
		case 3: {
				result = string__plus(result, _SLIT("="));
				break;
		}
		default: {
				break;
		}
	}
	
	string _t2 = encoding__base64__decode_str(result);
	return _t2;
}

string encoding__base64__url_encode(Array_u8 data) {
	string _t1 = string_replace_each(encoding__base64__encode(data), new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("+"), _SLIT("-"), _SLIT("/"), _SLIT("_"), _SLIT("="), _SLIT("")})));
	return _t1;
}

string encoding__base64__url_encode_str(string data) {
	string _t1 = string_replace_each(encoding__base64__encode_str(data), new_array_from_c_array(6, 6, sizeof(string), _MOV((string[6]){_SLIT("+"), _SLIT("-"), _SLIT("/"), _SLIT("_"), _SLIT("="), _SLIT("")})));
	return _t1;
}

VV_LOCAL_SYMBOL u64 encoding__base64__assemble64(u8 n1, u8 n2, u8 n3, u8 n4, u8 n5, u8 n6, u8 n7, u8 n8) {
	u64 _t1 = ((((((((((u64)(n1)) << 58U) | (((u64)(n2)) << 52U)) | (((u64)(n3)) << 46U)) | (((u64)(n4)) << 40U)) | (((u64)(n5)) << 34U)) | (((u64)(n6)) << 28U)) | (((u64)(n7)) << 22U)) | (((u64)(n8)) << 16U));
	return _t1;
}

VV_LOCAL_SYMBOL u32 encoding__base64__assemble32(u8 n1, u8 n2, u8 n3, u8 n4) {
	u32 _t1 = ((((((u32)(n1)) << 26U) | (((u32)(n2)) << 20U)) | (((u32)(n3)) << 14U)) | (((u32)(n4)) << 8U));
	return _t1;
}

strings__textscanner__TextScanner strings__textscanner__new(string input) {
	strings__textscanner__TextScanner _t1 = ((strings__textscanner__TextScanner){.input = input,.ilen = input.len,.pos = 0,});
	return _t1;
}

// Attr: [unsafe]
void strings__textscanner__TextScanner_free(strings__textscanner__TextScanner* ss) {
	string_free(&ss->input);
}

// Attr: [inline]
inline int strings__textscanner__TextScanner_remaining(strings__textscanner__TextScanner* ss) {
	int _t1 = (int)(ss->ilen - ss->pos);
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_next(strings__textscanner__TextScanner* ss) {
	if (ss->pos < ss->ilen) {
		int opos = ss->pos;
		ss->pos++;
		int _t1 = ss->input.str[ opos];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

// Attr: [inline]
inline void strings__textscanner__TextScanner_skip(strings__textscanner__TextScanner* ss) {
	if ((int)(ss->pos + 1) < ss->ilen) {
		ss->pos++;
	}
}

// Attr: [inline]
inline void strings__textscanner__TextScanner_skip_n(strings__textscanner__TextScanner* ss, int n) {
	ss->pos += n;
	if (ss->pos > ss->ilen) {
		ss->pos = ss->ilen;
	}
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_peek(strings__textscanner__TextScanner* ss) {
	if (ss->pos < ss->ilen) {
		int _t1 = ss->input.str[ ss->pos];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_peek_n(strings__textscanner__TextScanner* ss, int n) {
	if ((int)(ss->pos + n) < ss->ilen) {
		int _t1 = ss->input.str[ (int)(ss->pos + n)];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

// Attr: [inline]
inline void strings__textscanner__TextScanner_back(strings__textscanner__TextScanner* ss) {
	if (ss->pos > 0) {
		ss->pos--;
	}
}

void strings__textscanner__TextScanner_back_n(strings__textscanner__TextScanner* ss, int n) {
	ss->pos -= n;
	if (ss->pos < 0) {
		ss->pos = 0;
	}
	if (ss->pos > ss->ilen) {
		ss->pos = ss->ilen;
	}
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_peek_back(strings__textscanner__TextScanner* ss) {
	int _t1 = strings__textscanner__TextScanner_peek_back_n(ss, 1);
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_peek_back_n(strings__textscanner__TextScanner* ss, int n) {
	int offset = (int)(n + 1);
	if (ss->pos >= offset) {
		int _t1 = ss->input.str[ (int)(ss->pos - offset)];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline int strings__textscanner__TextScanner_current(strings__textscanner__TextScanner* ss) {
	if (ss->pos > 0) {
		int _t1 = ss->input.str[ (int)(ss->pos - 1)];
		return _t1;
	}
	int _t2 = -1;
	return _t2;
}

void strings__textscanner__TextScanner_reset(strings__textscanner__TextScanner* ss) {
	ss->pos = 0;
}

void strings__textscanner__TextScanner_goto_end(strings__textscanner__TextScanner* ss) {
	ss->pos = ss->ilen;
}

// Attr: [inline]
inline string dl__get_shared_library_extension(void) {
	string _t2;
	#if defined(_WIN32)
		_t2 = _SLIT(".dll");
		;
	#elif defined(__APPLE__)
	#else
	#endif
	string _t1 = _t2;
	return _t1;
}

// Attr: [inline]
inline string dl__get_libname(string libname) {
	string _t1 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = libname}}, {_SLIT0, /*115 &string*/0xfe10, {.d_s = _const_dl__dl_ext}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

_result_voidptr dl__open_opt(string filename, int flags) {
	voidptr shared_object_handle = dl__open(filename, flags);
	if (shared_object_handle == 0) {
		string e = dl__dlerror();
		return (_result_voidptr){ .is_error=true, .err=_v_error(e), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_voidptr _t2;
	_result_ok(&(voidptr[]) { shared_object_handle }, (_result*)(&_t2), sizeof(voidptr));
	return _t2;
}

_result_voidptr dl__sym_opt(voidptr shared_object_handle, string symbol) {
	voidptr sym_handle = dl__sym(shared_object_handle, symbol);
	if (sym_handle == 0) {
		string e = dl__dlerror();
		return (_result_voidptr){ .is_error=true, .err=_v_error(e), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_voidptr _t2;
	_result_ok(&(voidptr[]) { sym_handle }, (_result*)(&_t2), sizeof(voidptr));
	return _t2;
}

voidptr dl__open(string filename, int flags) {
	voidptr res = LoadLibrary(string_to_wide(filename));
	return res;
}

bool dl__close(voidptr handle) {
	bool _t1 = FreeLibrary(handle);
	return _t1;
}

voidptr dl__sym(voidptr handle, string symbol) {
	voidptr _t1 = GetProcAddress(handle, ((voidptr)(symbol.str)));
	return _t1;
}

string dl__dlerror(void) {
	int cerr = ((int)(GetLastError()));
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("error code "), /*100 &int*/0xfe07, {.d_i32 = cerr}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

io__BufferedReader* io__new_buffered_reader(io__BufferedReaderConfig o) {
	if (o.cap <= 0) {
		_v_panic(_SLIT("new_buffered_reader should be called with a positive `cap`"));
		VUNREACHABLE();
	}
	io__BufferedReader* r = ((io__BufferedReader*)memdup(&(io__BufferedReader){.reader = o.reader,.buf = __new_array_with_default_noscan(o.cap, o.cap, sizeof(u8), 0),.offset = 0,.len = 0,.fails = 0,.mfails = o.retries,.end_of_stream = 0,.total_read = 0,}, sizeof(io__BufferedReader)));
	return r;
}

_result_int io__BufferedReader_read(io__BufferedReader* r, Array_u8* buf) {
	if (r->end_of_stream) {
		return (_result_int){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (io__BufferedReader_needs_fill(/*rec*/*r)) {
		if (!io__BufferedReader_fill_buffer(r)) {
			return (_result_int){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	int read = copy(buf, array_slice(r->buf, r->offset, r->len));
	if (read == 0) {
		return (_result_int){ .is_error=true, .err=I_io__NotExpected_to_Interface_IError(((io__NotExpected*)memdup(&(io__NotExpected){.cause = _SLIT("invalid copy of buffer"),.code = -1,}, sizeof(io__NotExpected)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	r->offset += read;
	r->total_read += read;
	_result_int _t4;
	_result_ok(&(int[]) { read }, (_result*)(&_t4), sizeof(int));
	return _t4;
}

void io__BufferedReader_free(io__BufferedReader* r) {
	array_free(&r->buf);
}

VV_LOCAL_SYMBOL bool io__BufferedReader_fill_buffer(io__BufferedReader* r) {
	if (r->end_of_stream) {
		bool _t1 = true;
		return _t1;
	}
	r->offset = 0;
	r->len = 0;
	_result_int _t2 = io__Reader_name_table[r->reader._typ]._method_read(r->reader._object, &/*arr*/r->buf);
	if (_t2.is_error) {
		IError err = _t2.err;
		r->end_of_stream = true;
		bool _t3 = false;
		return _t3;
	}
	
 	r->len =  (*(int*)_t2.data);
	if (r->len == 0) {
		r->fails++;
	} else {
		r->fails = 0;
	}
	if (r->fails >= r->mfails) {
		r->end_of_stream = true;
		bool _t4 = false;
		return _t4;
	}
	bool _t5 = true;
	return _t5;
}

VV_LOCAL_SYMBOL bool io__BufferedReader_needs_fill(io__BufferedReader r) {
	bool _t1 = r.offset >= r.len;
	return _t1;
}

bool io__BufferedReader_end_of_stream(io__BufferedReader r) {
	bool _t1 = r.end_of_stream;
	return _t1;
}

_result_string io__BufferedReader_read_line(io__BufferedReader* r) {
	if (r->end_of_stream) {
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_u8 line = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	for (;;) {
		if (io__BufferedReader_needs_fill(/*rec*/*r)) {
			if (!io__BufferedReader_fill_buffer(r)) {
				if (line.len == 0) {
					return (_result_string){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				_result_string _t3;
				_result_ok(&(string[]) { Array_u8_bytestr(line) }, (_result*)(&_t3), sizeof(string));
				return _t3;
			}
		}
		int i = r->offset;
		for (; i < r->len; i++) {
			r->total_read++;
			u8 c = (*(u8*)array_get(r->buf, i));
			if (c == '\n') {
				if (i != 0 && (*(u8*)array_get(r->buf, (int)(i - 1))) == '\r') {
					int x = (int)(i - 1);
					_PUSH_MANY_noscan(&line, (array_slice(r->buf, r->offset, x)), _t4, Array_u8);
				} else {
					_PUSH_MANY_noscan(&line, (array_slice(r->buf, r->offset, i)), _t5, Array_u8);
				}
				r->offset = (int)(i + 1);
				_result_string _t6;
				_result_ok(&(string[]) { Array_u8_bytestr(line) }, (_result*)(&_t6), sizeof(string));
				return _t6;
			}
		}
		_PUSH_MANY_noscan(&line, (array_slice(r->buf, r->offset, i)), _t7, Array_u8);
		r->offset = i;
	}
	return (_result_string){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_void io__cp(io__Reader* src, io__Writer* dst) {
	Array_u8 buf = __new_array_with_default_noscan(_const_io__buf_max_len, 0, sizeof(u8), 0);
	for (;;) {
		_result_int _t1 = io__Reader_name_table[src->_typ]._method_read(src->_object, &/*arr*/buf);
		if (_t1.is_error) {
			IError err = _t1.err;
			break;
		}
		
 		int len =  (*(int*)_t1.data);
		_result_int _t2 = io__Writer_name_table[dst->_typ]._method_write(dst->_object, array_slice(buf, 0, len));
		if (_t2.is_error) {
			IError err = _t2.err;
			return (_result_void){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
  (*(int*)_t2.data);
	}
	array_free(&buf);
	return (_result_void){0};
}

io__Writer io__new_multi_writer(Array_io__Writer writers) {
	io__Writer _t1 = /*&io.Writer*/I_io__MultiWriter_to_Interface_io__Writer(((io__MultiWriter*)memdup(&(io__MultiWriter){.writers = writers,}, sizeof(io__MultiWriter))));
	return _t1;
}

_result_int io__MultiWriter_write(io__MultiWriter* m, Array_u8 buf) {
	for (int _t1 = 0; _t1 < m->writers.len; ++_t1) {
		io__Writer* w = ((io__Writer*)m->writers.data) + _t1;
		_result_int _t2 = io__Writer_name_table[w->_typ]._method_write(w->_object, buf);
		if (_t2.is_error) {
			_result_int _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 		int n =  (*(int*)_t2.data);
		if (n != buf.len) {
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("io: incomplete write to writer of MultiWriter")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_int _t5;
	_result_ok(&(int[]) { buf.len }, (_result*)(&_t5), sizeof(int));
	return _t5;
}

VV_LOCAL_SYMBOL string io__NotExpected_msg(io__NotExpected err) {
	string _t1 = err.cause;
	return _t1;
}

VV_LOCAL_SYMBOL int io__NotExpected_code(io__NotExpected err) {
	int _t1 = err.code;
	return _t1;
}

_result_Array_u8 io__read_all(io__ReadAllConfig config) {
	io__Reader r = config.reader;
	bool read_till_eof = config.read_to_end_of_stream;
	Array_u8 b = __new_array_with_default_noscan(_const_io__read_all_len, 0, sizeof(u8), 0);
	int read = 0;
	for (;;) {
		_result_int _t1 = io__Reader_name_table[r._typ]._method_read(r._object, &/*111*/(array[]){array_slice(b, read, 2147483647)}[0]);
		if (_t1.is_error) {
			IError err = _t1.err;
			break;
		}
		
 		int new_read =  (*(int*)_t1.data);
		read += new_read;
		if (!read_till_eof && read == 0) {
			break;
		}
		if (b.len == read) {
			array_grow_len_noscan(&b, _const_io__read_all_grow_len);
		}
	}
	_result_Array_u8 _t2;
	_result_ok(&(Array_u8[]) { array_slice(b, 0, read) }, (_result*)(&_t2), sizeof(Array_u8));
	return _t2;
}

_result_Array_u8 io__read_any(io__Reader* r) {
	Array_u8 b = __new_array_with_default_noscan(_const_io__read_all_len, 0, sizeof(u8), 0);
	int read = 0;
	for (;;) {
		_result_int _t1 = io__Reader_name_table[r->_typ]._method_read(r->_object, &/*111*/(array[]){array_slice(b, read, 2147483647)}[0]);
		if (_t1.is_error) {
			IError err = _t1.err;
			return (_result_Array_u8){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		int new_read =  (*(int*)_t1.data);
		read += new_read;
		if (new_read == 0) {
			break;
		}
		if (b.len == read) {
			array_grow_len_noscan(&b, _const_io__read_all_grow_len);
		}
	}
	_result_Array_u8 _t3;
	_result_ok(&(Array_u8[]) { array_slice(b, 0, read) }, (_result*)(&_t3), sizeof(Array_u8));
	return _t3;
}

_result_int io__ReaderWriterImpl_read(io__ReaderWriterImpl* r, Array_u8* buf) {
	_result_int _t1 = io__Reader_name_table[r->r._typ]._method_read(r->r._object, buf);
	return _t1;
}

_result_int io__ReaderWriterImpl_write(io__ReaderWriterImpl* r, Array_u8 buf) {
	_result_int _t1 = io__Writer_name_table[r->w._typ]._method_write(r->w._object, buf);
	return _t1;
}

io__ReaderWriterImpl io__make_readerwriter(io__Reader r, io__Writer w) {
	io__ReaderWriterImpl _t1 = ((io__ReaderWriterImpl){.r = r,.w = w,});
	return _t1;
}

VV_LOCAL_SYMBOL u32 net__http__chunked__ChunkScanner_read_chunk_size(net__http__chunked__ChunkScanner* s) {
	u32 n = ((u32)(0U));
	for (;;) {
		if (s->pos >= s->text.len) {
			break;
		}
		u8 c = string_at(s->text, s->pos);
		if (!u8_is_hex_digit(c)) {
			break;
		}
		n = (n << 4U);
		n += ((u32)(net__http__chunked__unhex(c)));
		s->pos++;
	}
	return n;
}

VV_LOCAL_SYMBOL u8 net__http__chunked__unhex(u8 c) {
	if ('0' <= c && c <= '9') {
		u8 _t1 = (rune)(c - '0');
		return _t1;
	} else if ('a' <= c && c <= 'f') {
		u8 _t2 = (rune)((rune)(c - 'a') + 10);
		return _t2;
	} else if ('A' <= c && c <= 'F') {
		u8 _t3 = (rune)((rune)(c - 'A') + 10);
		return _t3;
	}
	u8 _t4 = 0;
	return _t4;
}

VV_LOCAL_SYMBOL void net__http__chunked__ChunkScanner_skip_crlf(net__http__chunked__ChunkScanner* s) {
	s->pos += 2;
}

VV_LOCAL_SYMBOL _result_string net__http__chunked__ChunkScanner_read_chunk(net__http__chunked__ChunkScanner* s, u32 chunksize) {
	int startpos = s->pos;
	s->pos += ((int)(chunksize));
	if (s->pos > s->text.len) {
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("invalid chunksize")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_string _t2;
	_result_ok(&(string[]) { string_substr(s->text, startpos, s->pos) }, (_result*)(&_t2), sizeof(string));
	return _t2;
}

_result_string net__http__chunked__decode(string text) {
	strings__Builder sb = strings__new_builder(100);
	net__http__chunked__ChunkScanner cscanner = ((net__http__chunked__ChunkScanner){.pos = 0,.text = text,});
	for (;;) {
		u32 csize = net__http__chunked__ChunkScanner_read_chunk_size(&cscanner);
		if (0 == csize) {
			break;
		}
		net__http__chunked__ChunkScanner_skip_crlf(&cscanner);
		_result_string _t1 = net__http__chunked__ChunkScanner_read_chunk(&cscanner, csize);
		if (_t1.is_error) {
			_result_string _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 		string ch =  (*(string*)_t1.data);
		strings__Builder_write_string(&sb, ch);
		net__http__chunked__ChunkScanner_skip_crlf(&cscanner);
	}
	net__http__chunked__ChunkScanner_skip_crlf(&cscanner);
	_result_string _t3;
	_result_ok(&(string[]) { strings__Builder_str(&sb) }, (_result*)(&_t3), sizeof(string));
	return _t3;
}

#if defined(_WIN32)
#else
#endif
u64 sync__stdatomic__add_u64(u64* ptr, int delta) {
	atomic_fetch_add_u64(((voidptr)(ptr)), delta);
	u64 _t1 = *ptr;
	return _t1;
}

u64 sync__stdatomic__sub_u64(u64* ptr, int delta) {
	atomic_fetch_sub_u64(((voidptr)(ptr)), delta);
	u64 _t1 = *ptr;
	return _t1;
}

i64 sync__stdatomic__add_i64(i64* ptr, int delta) {
	atomic_fetch_add_u64(((voidptr)(ptr)), delta);
	i64 _t1 = *ptr;
	return _t1;
}

i64 sync__stdatomic__sub_i64(i64* ptr, int delta) {
	atomic_fetch_sub_u64(((voidptr)(ptr)), delta);
	i64 _t1 = *ptr;
	return _t1;
}

void sync__stdatomic__store_u64(u64* ptr, u64 val) {
	atomic_store_u64(((voidptr)(ptr)), val);
}

u64 sync__stdatomic__load_u64(u64* ptr) {
	u64 _t1 = atomic_load_u64(((voidptr)(ptr)));
	return _t1;
}

void sync__stdatomic__store_i64(i64* ptr, i64 val) {
	atomic_store_u64(((voidptr)(ptr)), val);
}

i64 sync__stdatomic__load_i64(i64* ptr) {
	i64 _t1 = ((i64)(atomic_load_u64(((voidptr)(ptr)))));
	return _t1;
}

bool encoding__utf8__validate_str(string str) {
	bool _t1 = encoding__utf8__validate(str.str, str.len);
	return _t1;
}

bool encoding__utf8__validate(u8* data, int len) {
	encoding__utf8__Utf8State state = ((encoding__utf8__Utf8State){.index = 0,.subindex = 0,.failed = 0,});
	for (int i = 0; i < len; i++) {
		u8 s = data[i];
		if (s == 0) {
			break;
		}
		encoding__utf8__Utf8State_next_state(&state, s);
		if (state.failed) {
			bool _t1 = false;
			return _t1;
		}
	}
	bool _t2 = !state.failed && state.subindex <= 0;
	return _t2;
}

VV_LOCAL_SYMBOL bool encoding__utf8__Utf8State_seq(encoding__utf8__Utf8State* s, bool r0, bool r1, bool is_tail) {
	if (s->subindex == 0 || (s->index > 1 && s->subindex == 1) || (s->index >= 6 && s->subindex == 2)) {
		if ((s->subindex == 0 && r0) || (s->subindex == 1 && r1) || (s->subindex == 2 && is_tail)) {
			s->subindex++;
			bool _t1 = true;
			return _t1;
		}
	} else {
		s->failed = true;
		if (is_tail) {
			s->index = 0;
			s->subindex = 0;
			s->failed = false;
		}
		bool _t2 = true;
		return _t2;
	}
	s->index++;
	s->subindex = 0;
	bool _t3 = false;
	return _t3;
}

VV_LOCAL_SYMBOL void encoding__utf8__Utf8State_next_state(encoding__utf8__Utf8State* s, u8 c) {
	if (s->index == 0) {
		if ((c >= (int_literal)(0x00 + 1) && c <= 0x7F) || c == 0x00) {
			return;
		}
		s->index++;
		s->subindex = 0;
	}
	bool is_tail = c >= 0x80 && c <= 0xBF;
	if (s->index == 1 && encoding__utf8__Utf8State_seq(s, c >= 0xC2 && c <= 0xDF, false, is_tail)) {
		return;
	}
	if (s->index == 2 && encoding__utf8__Utf8State_seq(s, c == 0xE0, c >= 0xA0 && c <= 0xBF, is_tail)) {
		return;
	}
	if (s->index == 3 && encoding__utf8__Utf8State_seq(s, c >= 0xE1 && c <= 0xEC, c >= 0x80 && c <= 0xBF, is_tail)) {
		return;
	}
	if (s->index == 4 && encoding__utf8__Utf8State_seq(s, c == 0xED, c >= 0x80 && c <= 0x9F, is_tail)) {
		return;
	}
	if (s->index == 5 && encoding__utf8__Utf8State_seq(s, c >= 0xEE && c <= 0xEF, c >= 0x80 && c <= 0xBF, is_tail)) {
		return;
	}
	if (s->index == 6 && encoding__utf8__Utf8State_seq(s, c == 0xF0, c >= 0x90 && c <= 0xBF, is_tail)) {
		return;
	}
	if (s->index == 7 && encoding__utf8__Utf8State_seq(s, c >= 0xF1 && c <= 0xF3, c >= 0x80 && c <= 0xBF, is_tail)) {
		return;
	}
	if (s->index == 8 && encoding__utf8__Utf8State_seq(s, c == 0xF4, c >= 0x80 && c <= 0x8F, is_tail)) {
		return;
	}
	s->failed = true;
}

VV_LOCAL_SYMBOL bool encoding__utf8__is_excluding_latin(encoding__utf8__RangeTable* table, rune r) {
	Array_encoding__utf8__Range16* r16 = &table->r16;
	int off = table->latin_offset;
	if (r16->len > off && ((u32)(r)) < ((u32)((*(encoding__utf8__Range16*)array_get((*r16), (int)(r16->len - 1))).hi))) {
		bool _t1 = encoding__utf8__is_16(array_slice((*r16), off, 2147483647), ((u16)(r)));
		return _t1;
	}
	Array_encoding__utf8__Range32* r32 = &table->r32;
	if (r32->len > 0 && r >= ((rune)((*(encoding__utf8__Range32*)array_get((*r32), 0)).lo))) {
		bool _t2 = encoding__utf8__is_32(*r32, ((u32)(r)));
		return _t2;
	}
	bool _t3 = false;
	return _t3;
}

VV_LOCAL_SYMBOL bool encoding__utf8__is_16(Array_encoding__utf8__Range16 ranges, u16 r) {
	if (ranges.len <= _const_encoding__utf8__linear_max && r <= _const_encoding__utf8__max_latin_1) {
		for (int _t1 = 0; _t1 < ranges.len; ++_t1) {
			encoding__utf8__Range16 range = ((encoding__utf8__Range16*)ranges.data)[_t1];
			if (r < range.lo) {
				bool _t2 = false;
				return _t2;
			}
			if (r <= range.hi) {
				bool _t3 = range.stride == 1U || (u16)(((u16)(r - range.lo)) % range.stride) == 0U;
				return _t3;
			}
		}
		bool _t4 = false;
		return _t4;
	}
	int low = 0;
	int high = ranges.len;
	for (;;) {
		if (!(low < high)) break;
		int medium = (int)(low + (int)(((int)(high - low)) / 2));
		encoding__utf8__Range16 range = (*(encoding__utf8__Range16*)array_get(ranges, medium));
		if (range.lo <= r && r <= range.hi) {
			bool _t5 = range.stride == 1U || (u16)(((u16)(r - range.lo)) % range.stride) == 0U;
			return _t5;
		}
		if (r < range.lo) {
			high = medium;
		} else {
			low = (int)(medium + 1);
		}
	}
	bool _t6 = false;
	return _t6;
}

VV_LOCAL_SYMBOL bool encoding__utf8__is_32(Array_encoding__utf8__Range32 ranges, u32 r) {
	if (ranges.len <= _const_encoding__utf8__linear_max && r <= _const_encoding__utf8__max_latin_1) {
		for (int _t1 = 0; _t1 < ranges.len; ++_t1) {
			encoding__utf8__Range32 range = ((encoding__utf8__Range32*)ranges.data)[_t1];
			if (r < range.lo) {
				bool _t2 = false;
				return _t2;
			}
			if (r <= range.hi) {
				bool _t3 = range.stride == 1U || (u32)(((u32)(r - range.lo)) % range.stride) == 0U;
				return _t3;
			}
		}
		bool _t4 = false;
		return _t4;
	}
	int low = 0;
	int high = ranges.len;
	for (;;) {
		if (!(low < high)) break;
		int medium = (int)(low + (int)(((int)(high - low)) / 2));
		encoding__utf8__Range32 range = (*(encoding__utf8__Range32*)array_get(ranges, medium));
		if (range.lo <= r && r <= range.hi) {
			bool _t5 = range.stride == 1U || (u32)(((u32)(r - range.lo)) % range.stride) == 0U;
			return _t5;
		}
		if (r < range.lo) {
			high = medium;
		} else {
			low = (int)(medium + 1);
		}
	}
	bool _t6 = false;
	return _t6;
}

int encoding__utf8__len(string s) {
	if (s.len == 0) {
		int _t1 = 0;
		return _t1;
	}
	int count = 0;
	int index = 0;
	for (;;) {
		int ch_len = utf8_char_len(string_at(s, index));
		index += ch_len;
		count++;
		if (index >= s.len) {
			break;
		}
	}
	return count;
}

int encoding__utf8__get_uchar(string s, int index) {
	int res = 0;
	int ch_len = 0;
	if (s.len > 0) {
		ch_len = utf8_char_len(string_at(s, index));
		if (ch_len == 1) {
			int _t1 = ((u16)(string_at(s, index)));
			return _t1;
		}
		if (ch_len > 1 && ch_len < 5) {
			int lword = 0;
			for (int i = 0; i < ch_len; i++) {
				lword = ((int)(((((u32)(lword)) << 8U) | ((u32)(string_at(s, (int)(index + i)))))));
			}
			if (ch_len == 2) {
				res = ((((lword & 0x1f00)) >> 2) | ((lword & 0x3f)));
			} else if (ch_len == 3) {
				res = (((((lword & 0x0f0000)) >> 4) | (((lword & 0x3f00)) >> 2)) | ((lword & 0x3f)));
			} else if (ch_len == 4) {
				res = (((((((lword & 0x07000000)) >> 6)) | ((((lword & 0x003f0000)) >> 4))) | ((((lword & 0x00003F00)) >> 2))) | ((lword & 0x0000003f)));
			}
		}
	}
	return res;
}

string encoding__utf8__raw_index(string s, int index) {
	Array_rune r = __new_array_with_default_noscan(0, 0, sizeof(rune), 0);
	for (int i = 0; i < s.len; i++) {
		if ((int)(r.len - 1) == index) {
			break;
		}
		u8 b = string_at(s, i);
		int ch_len = ((((0xe5000000 >> ((((b >> 3)) & 0x1e)))) & 3));
		rune _t2; /* if prepend */
		if (ch_len > 0) {
			i += ch_len;
			_t2 = ((rune)(encoding__utf8__get_uchar(s, (int)(i - ch_len))));
		} else {
			_t2 = ((rune)(b));
		}
		array_push_noscan((array*)&r, _MOV((rune[]){  _t2 }));
	}
	string _t3 = rune_str((*(rune*)array_get(r, index)));
	return _t3;
}

string encoding__utf8__reverse(string s) {
	int len_s = encoding__utf8__len(s);
	if (len_s == 0 || len_s == 1) {
		string _t1 = string_clone(s);
		return _t1;
	}
	Array_string str_array = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int i = 0; i < len_s; ++i) {
		array_push((array*)&str_array, _MOV((string[]){ string_clone(encoding__utf8__raw_index(s, i)) }));
	}
	str_array = array_reverse(str_array);
	string _t3 = Array_string_join(str_array, _SLIT(""));
	return _t3;
}

string encoding__utf8__to_upper(string s) {
	string _t1 = encoding__utf8__convert_case(s, true);
	return _t1;
}

string encoding__utf8__to_lower(string s) {
	string _t1 = encoding__utf8__convert_case(s, false);
	return _t1;
}

bool encoding__utf8__is_punct(string s, int index) {
	bool _t1 = encoding__utf8__is_uchar_punct(encoding__utf8__get_uchar(s, index));
	return _t1;
}

bool encoding__utf8__is_control(rune r) {
	if (r > _const_encoding__utf8__max_latin_1) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = _const_encoding__utf8__props[v_fixed_index(((u8)(r)), 256)] == 1;
	return _t2;
}

bool encoding__utf8__is_letter(rune r) {
	if ((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z')) {
		bool _t1 = true;
		return _t1;
	} else if (r <= _const_encoding__utf8__max_latin_1) {
		bool _t2 = (_const_encoding__utf8__props[v_fixed_index(((u8)(r)), 256)] & _const_encoding__utf8__p_l_mask) != 0;
		return _t2;
	}
	bool _t3 = encoding__utf8__is_excluding_latin((voidptr)&/*qq*/_const_encoding__utf8__letter_table, r);
	return _t3;
}

bool encoding__utf8__is_space(rune r) {
	if (r <= _const_encoding__utf8__max_latin_1) {
		switch (r) {
			case '\t': case '\n': case '\v': case '\f': case '\r': case ' ': case 0x85: case 0xA0: {
					bool _t1 = true;
					return _t1;
			}
			default: {
					bool _t2 = false;
					return _t2;
			}
		}
		
	}
	bool _t3 = encoding__utf8__is_excluding_latin((voidptr)&/*qq*/_const_encoding__utf8__white_space_table, r);
	return _t3;
}

bool encoding__utf8__is_number(rune r) {
	if (r <= _const_encoding__utf8__max_latin_1) {
		bool _t1 = (_const_encoding__utf8__props[v_fixed_index(((u8)(r)), 256)] & _const_encoding__utf8__p_n) != 0;
		return _t1;
	}
	bool _t2 = encoding__utf8__is_excluding_latin((voidptr)&/*qq*/_const_encoding__utf8__number_table, r);
	return _t2;
}

bool encoding__utf8__is_uchar_punct(int uchar) {
	bool _t1 = encoding__utf8__find_punct_in_table(uchar, _const_encoding__utf8__unicode_punct_western) != 0;
	return _t1;
}

bool encoding__utf8__is_global_punct(string s, int index) {
	bool _t1 = encoding__utf8__is_uchar_global_punct(encoding__utf8__get_uchar(s, index));
	return _t1;
}

bool encoding__utf8__is_uchar_global_punct(int uchar) {
	bool _t1 = encoding__utf8__find_punct_in_table(uchar, _const_encoding__utf8__unicode_punct) != 0;
	return _t1;
}

VV_LOCAL_SYMBOL int encoding__utf8__utf8_to_lower(int in_cp) {
	int cp = in_cp;
	if ((0x0041 <= cp && 0x005a >= cp) || (0x00c0 <= cp && 0x00d6 >= cp) || (0x00d8 <= cp && 0x00de >= cp) || (0x0391 <= cp && 0x03a1 >= cp) || (0x03a3 <= cp && 0x03ab >= cp) || (0x0410 <= cp && 0x042f >= cp)) {
		cp += 32;
	} else if (0x0400 <= cp && 0x040f >= cp) {
		cp += 80;
	} else if ((0x0100 <= cp && 0x012f >= cp) || (0x0132 <= cp && 0x0137 >= cp) || (0x014a <= cp && 0x0177 >= cp) || (0x0182 <= cp && 0x0185 >= cp) || (0x01a0 <= cp && 0x01a5 >= cp) || (0x01de <= cp && 0x01ef >= cp) || (0x01f8 <= cp && 0x021f >= cp) || (0x0222 <= cp && 0x0233 >= cp) || (0x0246 <= cp && 0x024f >= cp) || (0x03d8 <= cp && 0x03ef >= cp) || (0x0460 <= cp && 0x0481 >= cp) || (0x048a <= cp && 0x04ff >= cp)) {
		cp |= 0x1;
	} else if ((0x0139 <= cp && 0x0148 >= cp) || (0x0179 <= cp && 0x017e >= cp) || (0x01af <= cp && 0x01b0 >= cp) || (0x01b3 <= cp && 0x01b6 >= cp) || (0x01cd <= cp && 0x01dc >= cp)) {
		cp += 1;
		cp &= ~0x1;
	} else if ((0x0531 <= cp && 0x0556 >= cp) || (0x10A0 <= cp && 0x10C5 >= cp)) {
		cp += 0x30;
	} else if (((0x1E00 <= cp && 0x1E94 >= cp) || (0x1EA0 <= cp && 0x1EF8 >= cp)) && (cp & 1) == 0) {
		cp += 1;
	} else if (0x24B6 <= cp && 0x24CF >= cp) {
		cp += 0x1a;
	} else if (0xFF21 <= cp && 0xFF3A >= cp) {
		cp += 0x19;
	} else if ((0x1F08 <= cp && 0x1F0F >= cp) || (0x1F18 <= cp && 0x1F1D >= cp) || (0x1F28 <= cp && 0x1F2F >= cp) || (0x1F38 <= cp && 0x1F3F >= cp) || (0x1F48 <= cp && 0x1F4D >= cp) || (0x1F68 <= cp && 0x1F6F >= cp) || (0x1F88 <= cp && 0x1F8F >= cp) || (0x1F98 <= cp && 0x1F9F >= cp) || (0x1FA8 <= cp && 0x1FAF >= cp)) {
		cp -= 8;
	} else {
		switch (cp) {
			case 0x0178: {
					cp = 0x00ff;
					break;
			}
			case 0x0243: {
					cp = 0x0180;
					break;
			}
			case 0x018e: {
					cp = 0x01dd;
					break;
			}
			case 0x023d: {
					cp = 0x019a;
					break;
			}
			case 0x0220: {
					cp = 0x019e;
					break;
			}
			case 0x01b7: {
					cp = 0x0292;
					break;
			}
			case 0x01c4: {
					cp = 0x01c6;
					break;
			}
			case 0x01c7: {
					cp = 0x01c9;
					break;
			}
			case 0x01ca: {
					cp = 0x01cc;
					break;
			}
			case 0x01f1: {
					cp = 0x01f3;
					break;
			}
			case 0x01f7: {
					cp = 0x01bf;
					break;
			}
			case 0x0187: {
					cp = 0x0188;
					break;
			}
			case 0x018b: {
					cp = 0x018c;
					break;
			}
			case 0x0191: {
					cp = 0x0192;
					break;
			}
			case 0x0198: {
					cp = 0x0199;
					break;
			}
			case 0x01a7: {
					cp = 0x01a8;
					break;
			}
			case 0x01ac: {
					cp = 0x01ad;
					break;
			}
			case 0x01af: {
					cp = 0x01b0;
					break;
			}
			case 0x01b8: {
					cp = 0x01b9;
					break;
			}
			case 0x01bc: {
					cp = 0x01bd;
					break;
			}
			case 0x01f4: {
					cp = 0x01f5;
					break;
			}
			case 0x023b: {
					cp = 0x023c;
					break;
			}
			case 0x0241: {
					cp = 0x0242;
					break;
			}
			case 0x03fd: {
					cp = 0x037b;
					break;
			}
			case 0x03fe: {
					cp = 0x037c;
					break;
			}
			case 0x03ff: {
					cp = 0x037d;
					break;
			}
			case 0x037f: {
					cp = 0x03f3;
					break;
			}
			case 0x0386: {
					cp = 0x03ac;
					break;
			}
			case 0x0388: {
					cp = 0x03ad;
					break;
			}
			case 0x0389: {
					cp = 0x03ae;
					break;
			}
			case 0x038a: {
					cp = 0x03af;
					break;
			}
			case 0x038c: {
					cp = 0x03cc;
					break;
			}
			case 0x038e: {
					cp = 0x03cd;
					break;
			}
			case 0x038f: {
					cp = 0x03ce;
					break;
			}
			case 0x0370: {
					cp = 0x0371;
					break;
			}
			case 0x0372: {
					cp = 0x0373;
					break;
			}
			case 0x0376: {
					cp = 0x0377;
					break;
			}
			case 0x03f4: {
					cp = 0x03b8;
					break;
			}
			case 0x03cf: {
					cp = 0x03d7;
					break;
			}
			case 0x03f9: {
					cp = 0x03f2;
					break;
			}
			case 0x03f7: {
					cp = 0x03f8;
					break;
			}
			case 0x03fa: {
					cp = 0x03fb;
					break;
			}
			case 0x1F59: {
					cp = 0x1F51;
					break;
			}
			case 0x1F5B: {
					cp = 0x1F53;
					break;
			}
			case 0x1F5D: {
					cp = 0x1F55;
					break;
			}
			case 0x1F5F: {
					cp = 0x1F57;
					break;
			}
			case 0x1FB8: {
					cp = 0x1FB0;
					break;
			}
			case 0x1FB9: {
					cp = 0x1FB1;
					break;
			}
			case 0x1FD8: {
					cp = 0x1FD0;
					break;
			}
			case 0x1FD9: {
					cp = 0x1FD1;
					break;
			}
			case 0x1FE8: {
					cp = 0x1FE0;
					break;
			}
			case 0x1FE9: {
					cp = 0x1FE1;
					break;
			}
			default: {
					break;
			}
		}
		
	}
	return cp;
}

VV_LOCAL_SYMBOL int encoding__utf8__utf8_to_upper(int in_cp) {
	int cp = in_cp;
	if ((0x0061 <= cp && 0x007a >= cp) || (0x00e0 <= cp && 0x00f6 >= cp) || (0x00f8 <= cp && 0x00fe >= cp) || (0x03b1 <= cp && 0x03c1 >= cp) || (0x03c3 <= cp && 0x03cb >= cp) || (0x0430 <= cp && 0x044f >= cp)) {
		cp -= 32;
	} else if (0x0450 <= cp && 0x045f >= cp) {
		cp -= 80;
	} else if ((0x0100 <= cp && 0x012f >= cp) || (0x0132 <= cp && 0x0137 >= cp) || (0x014a <= cp && 0x0177 >= cp) || (0x0182 <= cp && 0x0185 >= cp) || (0x01a0 <= cp && 0x01a5 >= cp) || (0x01de <= cp && 0x01ef >= cp) || (0x01f8 <= cp && 0x021f >= cp) || (0x0222 <= cp && 0x0233 >= cp) || (0x0246 <= cp && 0x024f >= cp) || (0x03d8 <= cp && 0x03ef >= cp) || (0x0460 <= cp && 0x0481 >= cp) || (0x048a <= cp && 0x04ff >= cp)) {
		cp &= ~0x1;
	} else if ((0x0139 <= cp && 0x0148 >= cp) || (0x0179 <= cp && 0x017e >= cp) || (0x01af <= cp && 0x01b0 >= cp) || (0x01b3 <= cp && 0x01b6 >= cp) || (0x01cd <= cp && 0x01dc >= cp)) {
		cp -= 1;
		cp |= 0x1;
	} else if ((0x0561 <= cp && 0x0586 >= cp) || (0x10D0 <= cp && 0x10F5 >= cp)) {
		cp -= 0x30;
	} else if (((0x1E01 <= cp && 0x1E95 >= cp) || (0x1EA1 <= cp && 0x1EF9 >= cp)) && (cp & 1) == 1) {
		cp -= 1;
	} else if (0x24D0 <= cp && 0x24E9 >= cp) {
		cp -= 0x1a;
	} else if (0xFF41 <= cp && 0xFF5A >= cp) {
		cp -= 0x19;
	} else if ((0x1F00 <= cp && 0x1F07 >= cp) || (0x1F10 <= cp && 0x1F15 >= cp) || (0x1F20 <= cp && 0x1F27 >= cp) || (0x1F30 <= cp && 0x1F37 >= cp) || (0x1F40 <= cp && 0x1F45 >= cp) || (0x1F60 <= cp && 0x1F67 >= cp) || (0x1F80 <= cp && 0x1F87 >= cp) || (0x1F90 <= cp && 0x1F97 >= cp) || (0x1FA0 <= cp && 0x1FA7 >= cp)) {
		cp += 8;
	} else {
		switch (cp) {
			case 0x00ff: {
					cp = 0x0178;
					break;
			}
			case 0x0180: {
					cp = 0x0243;
					break;
			}
			case 0x01dd: {
					cp = 0x018e;
					break;
			}
			case 0x019a: {
					cp = 0x023d;
					break;
			}
			case 0x019e: {
					cp = 0x0220;
					break;
			}
			case 0x0292: {
					cp = 0x01b7;
					break;
			}
			case 0x01c6: {
					cp = 0x01c4;
					break;
			}
			case 0x01c9: {
					cp = 0x01c7;
					break;
			}
			case 0x01cc: {
					cp = 0x01ca;
					break;
			}
			case 0x01f3: {
					cp = 0x01f1;
					break;
			}
			case 0x01bf: {
					cp = 0x01f7;
					break;
			}
			case 0x0188: {
					cp = 0x0187;
					break;
			}
			case 0x018c: {
					cp = 0x018b;
					break;
			}
			case 0x0192: {
					cp = 0x0191;
					break;
			}
			case 0x0199: {
					cp = 0x0198;
					break;
			}
			case 0x01a8: {
					cp = 0x01a7;
					break;
			}
			case 0x01ad: {
					cp = 0x01ac;
					break;
			}
			case 0x01b0: {
					cp = 0x01af;
					break;
			}
			case 0x01b9: {
					cp = 0x01b8;
					break;
			}
			case 0x01bd: {
					cp = 0x01bc;
					break;
			}
			case 0x01f5: {
					cp = 0x01f4;
					break;
			}
			case 0x023c: {
					cp = 0x023b;
					break;
			}
			case 0x0242: {
					cp = 0x0241;
					break;
			}
			case 0x037b: {
					cp = 0x03fd;
					break;
			}
			case 0x037c: {
					cp = 0x03fe;
					break;
			}
			case 0x037d: {
					cp = 0x03ff;
					break;
			}
			case 0x03f3: {
					cp = 0x037f;
					break;
			}
			case 0x03ac: {
					cp = 0x0386;
					break;
			}
			case 0x03ad: {
					cp = 0x0388;
					break;
			}
			case 0x03ae: {
					cp = 0x0389;
					break;
			}
			case 0x03af: {
					cp = 0x038a;
					break;
			}
			case 0x03cc: {
					cp = 0x038c;
					break;
			}
			case 0x03cd: {
					cp = 0x038e;
					break;
			}
			case 0x03ce: {
					cp = 0x038f;
					break;
			}
			case 0x0371: {
					cp = 0x0370;
					break;
			}
			case 0x0373: {
					cp = 0x0372;
					break;
			}
			case 0x0377: {
					cp = 0x0376;
					break;
			}
			case 0x03d1: {
					cp = 0x0398;
					break;
			}
			case 0x03d7: {
					cp = 0x03cf;
					break;
			}
			case 0x03f2: {
					cp = 0x03f9;
					break;
			}
			case 0x03f8: {
					cp = 0x03f7;
					break;
			}
			case 0x03fb: {
					cp = 0x03fa;
					break;
			}
			case 0x1F51: {
					cp = 0x1F59;
					break;
			}
			case 0x1F53: {
					cp = 0x1F5B;
					break;
			}
			case 0x1F55: {
					cp = 0x1F5D;
					break;
			}
			case 0x1F57: {
					cp = 0x1F5F;
					break;
			}
			case 0x1FB0: {
					cp = 0x1FB8;
					break;
			}
			case 0x1FB1: {
					cp = 0x1FB9;
					break;
			}
			case 0x1FD0: {
					cp = 0x1FD8;
					break;
			}
			case 0x1FD1: {
					cp = 0x1FD9;
					break;
			}
			case 0x1FE0: {
					cp = 0x1FE8;
					break;
			}
			case 0x1FE1: {
					cp = 0x1FE9;
					break;
			}
			default: {
					break;
			}
		}
		
	}
	return cp;
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL string encoding__utf8__convert_case(string s, bool upper_flag) {
	int index = 0;
	int tab_char = 0;
	u8* str_res = malloc_noscan((int)(s.len + 1));
	for (;;) {
		int ch_len = utf8_char_len(s.str[ index]);
		if (ch_len == 1) {
			if (upper_flag == true) {
				{ // Unsafe block
					u8 c = s.str[ index];
					str_res[index] = (c >= 0x61 && c <= 0x7a ? ((c & 0xdf)) : (c));
				}
			} else {
				{ // Unsafe block
					u8 c = s.str[ index];
					str_res[index] = (c >= 0x41 && c <= 0x5a ? ((c | 0x20)) : (c));
				}
			}
		} else if (ch_len > 1 && ch_len < 5) {
			int lword = 0;
			for (int i = 0; i < ch_len; i++) {
				lword = ((int)(((((u32)(lword)) << 8U) | ((u32)(s.str[ (int)(index + i)])))));
			}
			int res = 0;
			if (ch_len == 2) {
				res = ((((lword & 0x1f00)) >> 2) | ((lword & 0x3f)));
			} else if (ch_len == 3) {
				res = (((((lword & 0x0f0000)) >> 4) | (((lword & 0x3f00)) >> 2)) | ((lword & 0x3f)));
			} else if (ch_len == 4) {
				res = (((((((lword & 0x07000000)) >> 6)) | ((((lword & 0x003f0000)) >> 4))) | ((((lword & 0x00003F00)) >> 2))) | ((lword & 0x0000003f)));
			}
			if (upper_flag == false) {
				tab_char = encoding__utf8__utf8_to_lower(res);
			} else {
				tab_char = encoding__utf8__utf8_to_upper(res);
			}
			if (ch_len == 2) {
				u8 ch0 = (((u8)((((tab_char >> 6)) & 0x1f))) | 0xc0);
				u8 ch1 = (((u8)((((tab_char >> 0)) & 0x3f))) | 0x80);
				{ // Unsafe block
					str_res[(int)(index + 0)] = ch0;
					str_res[(int)(index + 1)] = ch1;
				}
			} else if (ch_len == 3) {
				u8 ch0 = (((u8)((((tab_char >> 12)) & 0x0f))) | 0xe0);
				u8 ch1 = (((u8)((((tab_char >> 6)) & 0x3f))) | 0x80);
				u8 ch2 = (((u8)((((tab_char >> 0)) & 0x3f))) | 0x80);
				{ // Unsafe block
					str_res[(int)(index + 0)] = ch0;
					str_res[(int)(index + 1)] = ch1;
					str_res[(int)(index + 2)] = ch2;
				}
			} else if (ch_len == 4) {
				for (int i = 0; i < ch_len; ++i) {
					{ // Unsafe block
						str_res[(int)(index + i)] = s.str[ (int)(index + i)];
					}
				}
			}
		} else {
			for (int i = 0; i < ch_len; ++i) {
				{ // Unsafe block
					str_res[(int)(index + i)] = s.str[ (int)(index + i)];
				}
			}
		}
		index += ch_len;
		if (index >= s.len) {
			break;
		}
	}
	{ // Unsafe block
		str_res[index] = 0;
		string _t1 = tos(str_res, s.len);
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [direct_array_access]
VV_LOCAL_SYMBOL int encoding__utf8__find_punct_in_table(int in_code, Array_int in_table) {
	int first_index = 0;
	int last_index = (in_table.len);
	int index = 0;
	int x = 0;
	for (;;) {
		index = (((int)(first_index + last_index)) >> 1);
		x = ((int*)in_table.data)[index];
		if (x == in_code) {
			return index;
		} else if (x > in_code) {
			last_index = index;
		} else {
			first_index = index;
		}
		if (((int)(last_index - first_index)) <= 1) {
			break;
		}
	}
	int _t2 = 0;
	return _t2;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u16 encoding__binary__big_endian_u16(Array_u8 b) {
	{u8 _ = ((u8*)b.data)[1];}
	;
	u16 _t1 = (((u16)(((u8*)b.data)[1])) | ((((u16)(((u8*)b.data)[0])) << ((u16)(8U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u16 encoding__binary__big_endian_u16_at(Array_u8 b, int o) {
	{u8 _ = ((u8*)b.data)[o];}
	;
	{u8 _ = ((u8*)b.data)[(int)(o + 1)];}
	;
	u16 _t1 = (((u16)(((u8*)b.data)[(int)(o + 1)])) | ((((u16)(((u8*)b.data)[o])) << ((u16)(8U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u16 encoding__binary__big_endian_u16_end(Array_u8 b) {
	u16 _t1 = encoding__binary__big_endian_u16_at(b, (int)(b.len - 2));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u16(Array_u8* b, u16 v) {
	{u8 _ = ((u8*)b->data)[1];}
	;
	((u8*)b->data)[0] = ((u8)((v >> ((u16)(8U)))));
	((u8*)b->data)[1] = ((u8)(v));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u16_at(Array_u8* b, u16 v, int o) {
	{u8 _ = ((u8*)b->data)[o];}
	;
	{u8 _ = ((u8*)b->data)[(int)(o + 1)];}
	;
	((u8*)b->data)[o] = ((u8)((v >> ((u16)(8U)))));
	((u8*)b->data)[(int)(o + 1)] = ((u8)(v));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u16_end(Array_u8* b, u16 v) {
	encoding__binary__big_endian_put_u16_at(b, v, (int)(b->len - 2));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u32 encoding__binary__big_endian_u32(Array_u8 b) {
	{u8 _ = ((u8*)b.data)[3];}
	;
	u32 _t1 = (((((u32)(((u8*)b.data)[3])) | ((((u32)(((u8*)b.data)[2])) << ((u32)(8U))))) | ((((u32)(((u8*)b.data)[1])) << ((u32)(16U))))) | ((((u32)(((u8*)b.data)[0])) << ((u32)(24U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u32 encoding__binary__big_endian_u32_at(Array_u8 b, int o) {
	{u8 _ = ((u8*)b.data)[o];}
	;
	{u8 _ = ((u8*)b.data)[(int)(o + 3)];}
	;
	u32 _t1 = (((((u32)(((u8*)b.data)[(int)(o + 3)])) | ((((u32)(((u8*)b.data)[(int)(o + 2)])) << ((u32)(8U))))) | ((((u32)(((u8*)b.data)[(int)(o + 1)])) << ((u32)(16U))))) | ((((u32)(((u8*)b.data)[o])) << ((u32)(24U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u32 encoding__binary__big_endian_u32_end(Array_u8 b) {
	u32 _t1 = encoding__binary__big_endian_u32_at(b, (int)(b.len - 4));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u32(Array_u8* b, u32 v) {
	{u8 _ = ((u8*)b->data)[3];}
	;
	((u8*)b->data)[0] = ((u8)((v >> ((u32)(24U)))));
	((u8*)b->data)[1] = ((u8)((v >> ((u32)(16U)))));
	((u8*)b->data)[2] = ((u8)((v >> ((u32)(8U)))));
	((u8*)b->data)[3] = ((u8)(v));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u32_at(Array_u8* b, u32 v, int o) {
	{u8 _ = ((u8*)b->data)[o];}
	;
	{u8 _ = ((u8*)b->data)[(int)(o + 3)];}
	;
	((u8*)b->data)[o] = ((u8)((v >> ((u32)(24U)))));
	((u8*)b->data)[(int)(o + 1)] = ((u8)((v >> ((u32)(16U)))));
	((u8*)b->data)[(int)(o + 2)] = ((u8)((v >> ((u32)(8U)))));
	((u8*)b->data)[(int)(o + 3)] = ((u8)(v));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u32_end(Array_u8* b, u32 v) {
	encoding__binary__big_endian_put_u32_at(b, v, (int)(b->len - 4));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u64 encoding__binary__big_endian_u64(Array_u8 b) {
	{u8 _ = ((u8*)b.data)[7];}
	;
	u64 _t1 = (((((((((u64)(((u8*)b.data)[7])) | ((((u64)(((u8*)b.data)[6])) << ((u64)(8U))))) | ((((u64)(((u8*)b.data)[5])) << ((u64)(16U))))) | ((((u64)(((u8*)b.data)[4])) << ((u64)(24U))))) | ((((u64)(((u8*)b.data)[3])) << ((u64)(32U))))) | ((((u64)(((u8*)b.data)[2])) << ((u64)(40U))))) | ((((u64)(((u8*)b.data)[1])) << ((u64)(48U))))) | ((((u64)(((u8*)b.data)[0])) << ((u64)(56U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u64 encoding__binary__big_endian_u64_at(Array_u8 b, int o) {
	{u8 _ = ((u8*)b.data)[o];}
	;
	{u8 _ = ((u8*)b.data)[(int)(o + 7)];}
	;
	u64 _t1 = (((((((((u64)(((u8*)b.data)[(int)(o + 7)])) | ((((u64)(((u8*)b.data)[(int)(o + 6)])) << ((u64)(8U))))) | ((((u64)(((u8*)b.data)[(int)(o + 5)])) << ((u64)(16U))))) | ((((u64)(((u8*)b.data)[(int)(o + 4)])) << ((u64)(24U))))) | ((((u64)(((u8*)b.data)[(int)(o + 3)])) << ((u64)(32U))))) | ((((u64)(((u8*)b.data)[(int)(o + 2)])) << ((u64)(40U))))) | ((((u64)(((u8*)b.data)[(int)(o + 1)])) << ((u64)(48U))))) | ((((u64)(((u8*)b.data)[o])) << ((u64)(56U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u64 encoding__binary__big_endian_u64_end(Array_u8 b) {
	u64 _t1 = encoding__binary__big_endian_u64_at(b, (int)(b.len - 8));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u64(Array_u8* b, u64 v) {
	{u8 _ = ((u8*)b->data)[7];}
	;
	((u8*)b->data)[0] = ((u8)((v >> ((u64)(56U)))));
	((u8*)b->data)[1] = ((u8)((v >> ((u64)(48U)))));
	((u8*)b->data)[2] = ((u8)((v >> ((u64)(40U)))));
	((u8*)b->data)[3] = ((u8)((v >> ((u64)(32U)))));
	((u8*)b->data)[4] = ((u8)((v >> ((u64)(24U)))));
	((u8*)b->data)[5] = ((u8)((v >> ((u64)(16U)))));
	((u8*)b->data)[6] = ((u8)((v >> ((u64)(8U)))));
	((u8*)b->data)[7] = ((u8)(v));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u64_at(Array_u8* b, u64 v, int o) {
	{u8 _ = ((u8*)b->data)[o];}
	;
	{u8 _ = ((u8*)b->data)[(int)(o + 7)];}
	;
	((u8*)b->data)[o] = ((u8)((v >> ((u64)(56U)))));
	((u8*)b->data)[(int)(o + 1)] = ((u8)((v >> ((u64)(48U)))));
	((u8*)b->data)[(int)(o + 2)] = ((u8)((v >> ((u64)(40U)))));
	((u8*)b->data)[(int)(o + 3)] = ((u8)((v >> ((u64)(32U)))));
	((u8*)b->data)[(int)(o + 4)] = ((u8)((v >> ((u64)(24U)))));
	((u8*)b->data)[(int)(o + 5)] = ((u8)((v >> ((u64)(16U)))));
	((u8*)b->data)[(int)(o + 6)] = ((u8)((v >> ((u64)(8U)))));
	((u8*)b->data)[(int)(o + 7)] = ((u8)(v));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__big_endian_put_u64_end(Array_u8* b, u64 v) {
	encoding__binary__big_endian_put_u64_at(b, v, (int)(b->len - 8));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u16 encoding__binary__little_endian_u16(Array_u8 b) {
	{u8 _ = ((u8*)b.data)[1];}
	;
	u16 _t1 = (((u16)(((u8*)b.data)[0])) | ((((u16)(((u8*)b.data)[1])) << ((u16)(8U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u16 encoding__binary__little_endian_u16_at(Array_u8 b, int o) {
	{u8 _ = ((u8*)b.data)[o];}
	;
	{u8 _ = ((u8*)b.data)[(int)(o + 1)];}
	;
	u16 _t1 = (((u16)(((u8*)b.data)[o])) | ((((u16)(((u8*)b.data)[(int)(o + 1)])) << ((u16)(8U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u16 encoding__binary__little_endian_u16_end(Array_u8 b) {
	u16 _t1 = encoding__binary__little_endian_u16_at(b, (int)(b.len - 2));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u16(Array_u8* b, u16 v) {
	{u8 _ = ((u8*)b->data)[1];}
	;
	((u8*)b->data)[0] = ((u8)(v));
	((u8*)b->data)[1] = ((u8)((v >> ((u16)(8U)))));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u16_at(Array_u8* b, u16 v, int o) {
	{u8 _ = ((u8*)b->data)[o];}
	;
	{u8 _ = ((u8*)b->data)[(int)(o + 1)];}
	;
	((u8*)b->data)[o] = ((u8)(v));
	((u8*)b->data)[(int)(o + 1)] = ((u8)((v >> ((u16)(8U)))));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u16_end(Array_u8* b, u16 v) {
	encoding__binary__little_endian_put_u16_at(b, v, (int)(b->len - 2));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u32 encoding__binary__little_endian_u32(Array_u8 b) {
	{u8 _ = ((u8*)b.data)[3];}
	;
	u32 _t1 = (((((u32)(((u8*)b.data)[0])) | ((((u32)(((u8*)b.data)[1])) << ((u32)(8U))))) | ((((u32)(((u8*)b.data)[2])) << ((u32)(16U))))) | ((((u32)(((u8*)b.data)[3])) << ((u32)(24U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u32 encoding__binary__little_endian_u32_at(Array_u8 b, int o) {
	{u8 _ = ((u8*)b.data)[o];}
	;
	{u8 _ = ((u8*)b.data)[(int)(o + 3)];}
	;
	u32 _t1 = (((((u32)(((u8*)b.data)[o])) | ((((u32)(((u8*)b.data)[(int)(o + 1)])) << ((u32)(8U))))) | ((((u32)(((u8*)b.data)[(int)(o + 2)])) << ((u32)(16U))))) | ((((u32)(((u8*)b.data)[(int)(o + 3)])) << ((u32)(24U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u32 encoding__binary__little_endian_u32_end(Array_u8 b) {
	u32 _t1 = encoding__binary__little_endian_u32_at(b, (int)(b.len - 4));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u32(Array_u8* b, u32 v) {
	{u8 _ = ((u8*)b->data)[3];}
	;
	((u8*)b->data)[0] = ((u8)(v));
	((u8*)b->data)[1] = ((u8)((v >> ((u32)(8U)))));
	((u8*)b->data)[2] = ((u8)((v >> ((u32)(16U)))));
	((u8*)b->data)[3] = ((u8)((v >> ((u32)(24U)))));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u32_at(Array_u8* b, u32 v, int o) {
	{u8 _ = ((u8*)b->data)[o];}
	;
	{u8 _ = ((u8*)b->data)[(int)(o + 3)];}
	;
	((u8*)b->data)[o] = ((u8)(v));
	((u8*)b->data)[(int)(o + 1)] = ((u8)((v >> ((u32)(8U)))));
	((u8*)b->data)[(int)(o + 2)] = ((u8)((v >> ((u32)(16U)))));
	((u8*)b->data)[(int)(o + 3)] = ((u8)((v >> ((u32)(24U)))));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u32_end(Array_u8* b, u32 v) {
	encoding__binary__little_endian_put_u32_at(b, v, (int)(b->len - 4));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u64 encoding__binary__little_endian_u64(Array_u8 b) {
	{u8 _ = ((u8*)b.data)[7];}
	;
	u64 _t1 = (((((((((u64)(((u8*)b.data)[0])) | ((((u64)(((u8*)b.data)[1])) << ((u64)(8U))))) | ((((u64)(((u8*)b.data)[2])) << ((u64)(16U))))) | ((((u64)(((u8*)b.data)[3])) << ((u64)(24U))))) | ((((u64)(((u8*)b.data)[4])) << ((u64)(32U))))) | ((((u64)(((u8*)b.data)[5])) << ((u64)(40U))))) | ((((u64)(((u8*)b.data)[6])) << ((u64)(48U))))) | ((((u64)(((u8*)b.data)[7])) << ((u64)(56U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u64 encoding__binary__little_endian_u64_at(Array_u8 b, int o) {
	{u8 _ = ((u8*)b.data)[o];}
	;
	{u8 _ = ((u8*)b.data)[(int)(o + 7)];}
	;
	u64 _t1 = (((((((((u64)(((u8*)b.data)[o])) | ((((u64)(((u8*)b.data)[(int)(o + 1)])) << ((u64)(8U))))) | ((((u64)(((u8*)b.data)[(int)(o + 2)])) << ((u64)(16U))))) | ((((u64)(((u8*)b.data)[(int)(o + 3)])) << ((u64)(24U))))) | ((((u64)(((u8*)b.data)[(int)(o + 4)])) << ((u64)(32U))))) | ((((u64)(((u8*)b.data)[(int)(o + 5)])) << ((u64)(40U))))) | ((((u64)(((u8*)b.data)[(int)(o + 6)])) << ((u64)(48U))))) | ((((u64)(((u8*)b.data)[(int)(o + 7)])) << ((u64)(56U)))));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline u64 encoding__binary__little_endian_u64_end(Array_u8 b) {
	u64 _t1 = encoding__binary__little_endian_u64_at(b, (int)(b.len - 8));
	return _t1;
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u64(Array_u8* b, u64 v) {
	{u8 _ = ((u8*)b->data)[7];}
	;
	((u8*)b->data)[0] = ((u8)(v));
	((u8*)b->data)[1] = ((u8)((v >> ((u64)(8U)))));
	((u8*)b->data)[2] = ((u8)((v >> ((u64)(16U)))));
	((u8*)b->data)[3] = ((u8)((v >> ((u64)(24U)))));
	((u8*)b->data)[4] = ((u8)((v >> ((u64)(32U)))));
	((u8*)b->data)[5] = ((u8)((v >> ((u64)(40U)))));
	((u8*)b->data)[6] = ((u8)((v >> ((u64)(48U)))));
	((u8*)b->data)[7] = ((u8)((v >> ((u64)(56U)))));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u64_at(Array_u8* b, u64 v, int o) {
	{u8 _ = ((u8*)b->data)[o];}
	;
	{u8 _ = ((u8*)b->data)[(int)(o + 7)];}
	;
	((u8*)b->data)[o] = ((u8)(v));
	((u8*)b->data)[(int)(o + 1)] = ((u8)((v >> ((u64)(8U)))));
	((u8*)b->data)[(int)(o + 2)] = ((u8)((v >> ((u64)(16U)))));
	((u8*)b->data)[(int)(o + 3)] = ((u8)((v >> ((u64)(24U)))));
	((u8*)b->data)[(int)(o + 4)] = ((u8)((v >> ((u64)(32U)))));
	((u8*)b->data)[(int)(o + 5)] = ((u8)((v >> ((u64)(40U)))));
	((u8*)b->data)[(int)(o + 6)] = ((u8)((v >> ((u64)(48U)))));
	((u8*)b->data)[(int)(o + 7)] = ((u8)((v >> ((u64)(56U)))));
}

// Attr: [direct_array_access]
// Attr: [inline]
inline void encoding__binary__little_endian_put_u64_end(Array_u8* b, u64 v) {
	encoding__binary__little_endian_put_u64_at(b, v, (int)(b->len - 8));
}

// Attr: [deprecated]
// Attr: [deprecated_after]
u64 net__conv__htn64(u64 host) {
	u64 _t1 = net__conv__hton64(host);
	return _t1;
}

u64 net__conv__hton64(u64 host) {
	#if defined(TARGET_ORDER_IS_LITTLE)
	{
		u64 _t2 = (((((((((((host >> 56U)) & 0x00000000000000FFU)) | ((((host >> 40U)) & 0x000000000000FF00U))) | ((((host >> 24U)) & 0x0000000000FF0000U))) | ((((host >> 8U)) & 0x00000000FF000000U))) | ((((host << 8U)) & 0x000000FF00000000U))) | ((((host << 24U)) & 0x0000FF0000000000U))) | ((((host << 40U)) & 0x00FF000000000000U))) | ((((host << 56U)) & 0xFF00000000000000U)));
		return _t2;
	}
	#else
	{
		return host;
	}
	#endif
	return 0;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
u32 net__conv__htn32(u32 host) {
	u32 _t1 = net__conv__hton32(host);
	return _t1;
}

u32 net__conv__hton32(u32 host) {
	#if defined(TARGET_ORDER_IS_LITTLE)
	{
		u32 _t2 = (((((((host >> 24U)) & 0x000000FFU)) | ((((host >> 8U)) & 0x0000FF00U))) | ((((host << 8U)) & 0x00FF0000U))) | ((((host << 24U)) & 0xFF000000U)));
		return _t2;
	}
	#else
	{
		return host;
	}
	#endif
	return 0;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
u16 net__conv__htn16(u16 host) {
	u16 _t1 = net__conv__hton16(host);
	return _t1;
}

u16 net__conv__hton16(u16 host) {
	#if defined(TARGET_ORDER_IS_LITTLE)
	{
		u16 _t2 = (((((host >> 8U)) & 0x00FFU)) | ((((host << 8U)) & 0xFF00U)));
		return _t2;
	}
	#else
	{
		return host;
	}
	#endif
	return 0;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
u64 net__conv__nth64(u64 net) {
	u64 _t1 = net__conv__ntoh64(net);
	return _t1;
}

u64 net__conv__ntoh64(u64 net) {
	u64 _t1 = net__conv__hton64(net);
	return _t1;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
u32 net__conv__nth32(u32 net) {
	u32 _t1 = net__conv__ntoh32(net);
	return _t1;
}

u32 net__conv__ntoh32(u32 net) {
	u32 _t1 = net__conv__hton32(net);
	return _t1;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
u16 net__conv__nth16(u16 net) {
	u16 _t1 = net__conv__ntoh16(net);
	return _t1;
}

u16 net__conv__ntoh16(u16 net) {
	u16 _t1 = net__conv__hton16(net);
	return _t1;
}

_result_Array_u8 net__conv__u64tovarint(u64 n) {
	if (n > (((u64)(1U)) << 62U)) {
		return (_result_Array_u8){ .is_error=true, .err=_v_error(_SLIT("cannot encode more than 2^62-1")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	bool /*A*/ _t2 = true;
		u8 msb = ((_t2 == (n < 64U))? (((u8)(0b00))) : (_t2 == (n < 16384U))? (((u8)(0b01))) : (_t2 == (n < 1073741824U))? (((u8)(0b10))) : (((u8)(0b11))));
	int len = (1 << msb);
	Array_u8 result = __new_array_with_default_noscan(len, 0, sizeof(u8), 0);
	u64 tn = n;
	for (int i = 0; i < len; ++i) {
		array_set(&result, (int)((int)(len - 1) - i), &(u8[]) { ((u8)((u64)(tn % 256U))) });
		tn /= 256U;
	}
	(*(u8*)array_get(result, 0)) |= (msb << 6);
	_result_Array_u8 _t3;
	_result_ok(&(Array_u8[]) { result }, (_result*)(&_t3), sizeof(Array_u8));
	return _t3;
}

_result_multi_return_u64_u8 net__conv__varinttou64(Array_u8 b) {
	if (b.len == 0) {
		return (_result_multi_return_u64_u8){ .is_error=true, .err=_v_error(_SLIT("cannot parse vluint from empty byte array")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	u8 msb = ((*(u8*)array_get(b, 0)) >> 6);
	u8 len = ((u8)((1 << msb)));
	if (len > b.len) {
		return (_result_multi_return_u64_u8){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("expected "), /*117 &u8*/0xfe02, {.d_u8 = len}}, {_SLIT(" bytes but got "), /*100 &int*/0xfe07, {.d_i32 = b.len}}, {_SLIT(" bytes"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	u64 n = ((u64)(((*(u8*)array_get(b, 0)) & 0b00111111)));
	for (u8 i = 1; i < len; ++i) {
		n = (u64)((u64)(n * 256U) + (*(u8*)array_get(b, i)));
	}
	_result_multi_return_u64_u8 _t3;
	_result_ok(&(multi_return_u64_u8[]) { (multi_return_u64_u8){.arg0=n, .arg1=len} }, (_result*)(&_t3), sizeof(multi_return_u64_u8));
	return _t3;
}

// Attr: [inline]
inline u64 hash__wyhash_c(u8* key, u64 len, u64 seed) {
	u64 _t1 = wyhash(key, len, seed, ((u64*)(_wyp)));
	return _t1;
}

// Attr: [inline]
inline u64 hash__wyhash64_c(u64 a, u64 b) {
	u64 _t1 = wyhash64(a, b);
	return _t1;
}

// Attr: [inline]
inline u64 hash__sum64_string(string key, u64 seed) {
	u64 _t1 = hash__wyhash_c(key.str, ((u64)(key.len)), seed);
	return _t1;
}

// Attr: [inline]
inline u64 hash__sum64(Array_u8 key, u64 seed) {
	u64 _t1 = hash__wyhash_c(((u8*)(key.data)), ((u64)(key.len)), seed);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyrotr(u64 v, u32 k) {
	u64 _t1 = (((v >> k)) | ((v << ((u32)(64 - k)))));
	return _t1;
}

// Attr: [inline]
inline u64 hash__wymum(u64 a, u64 b) {
	u32 mask32 = ((u32)(4294967295U));
	u64 x0 = (a & mask32);
	u64 x1 = (a >> 32U);
	u64 y0 = (b & mask32);
	u64 y1 = (b >> 32U);
	u64 w0 = (u64)(x0 * y0);
	u64 t = (u64)((u64)(x1 * y0) + ((w0 >> 32U)));
	u64 w1 = (t & mask32);
	u64 w2 = (t >> 32U);
	w1 += (u64)(x0 * y1);
	u64 hi = (u64)((u64)((u64)(x1 * y1) + w2) + ((w1 >> 32U)));
	u64 lo = (u64)(a * b);
	u64 _t1 = (hi ^ lo);
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr3(u8* p, u64 k) {
	{ // Unsafe block
		u64 _t1 = ((((((u64)(p[0])) << 16U)) | ((((u64)(p[(k >> 1U)])) << 8U))) | ((u64)(p[(u64)(k - 1U)])));
		return _t1;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr4(u8* p) {
	{ // Unsafe block
		u64 _t1 = (((((u32)(p[0])) | ((((u32)(p[1])) << ((u32)(8U))))) | ((((u32)(p[2])) << ((u32)(16U))))) | ((((u32)(p[3])) << ((u32)(24U)))));
		return _t1;
	}
	return 0;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 hash__wyr8(u8* p) {
	{ // Unsafe block
		u64 _t1 = (((((((((u64)(p[0])) | ((((u64)(p[1])) << 8U))) | ((((u64)(p[2])) << 16U))) | ((((u64)(p[3])) << 24U))) | ((((u64)(p[4])) << 32U))) | ((((u64)(p[5])) << 40U))) | ((((u64)(p[6])) << 48U))) | ((((u64)(p[7])) << 56U)));
		return _t1;
	}
	return 0;
}

Array_string os__args_after(string cut_word) {
	if (_const_os__args.len == 0) {
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string cargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!Array_string_contains(_const_os__args, cut_word)) {
		cargs = array_clone_to_depth(&_const_os__args, 0);
	} else {
		bool found = false;
		array_push((array*)&cargs, _MOV((string[]){ string_clone((*(string*)array_get(_const_os__args, 0))) }));
		Array_string _t3 = array_slice(_const_os__args, 1, 2147483647);
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			string a = ((string*)_t3.data)[_t4];
			if (string__eq(a, cut_word)) {
				found = true;
				continue;
			}
			if (!found) {
				continue;
			}
			array_push((array*)&cargs, _MOV((string[]){ string_clone(a) }));
		}
	}
	return cargs;
}

Array_string os__args_before(string cut_word) {
	if (_const_os__args.len == 0) {
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string cargs = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!Array_string_contains(_const_os__args, cut_word)) {
		cargs = array_clone_to_depth(&_const_os__args, 0);
	} else {
		array_push((array*)&cargs, _MOV((string[]){ string_clone((*(string*)array_get(_const_os__args, 0))) }));
		Array_string _t3 = array_slice(_const_os__args, 1, 2147483647);
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			string a = ((string*)_t3.data)[_t4];
			if (string__eq(a, cut_word)) {
				break;
			}
			array_push((array*)&cargs, _MOV((string[]){ string_clone(a) }));
		}
	}
	return cargs;
}

// Attr: [inline]
inline bool os__debugger_present(void) {
	bool _t1 = IsDebuggerPresent();
	return _t1;
	bool _t2 = false;
	return _t2;
}

string os__getenv(string key) {
	_option_string _t2 = os__getenv_opt(key);
	if (_t2.state != 0) {
		IError err = _t2.err;
		*(string*) _t2.data = _SLIT("");
	}
	
 	string _t1 =  (*(string*)_t2.data);
	return _t1;
}

// Attr: [manualfree]
_option_string os__getenv_opt(string key) {
	bool os__getenv_opt_defer_0 = false;
	u16* kw;
	{ // Unsafe block
		#if defined(_WIN32)
		{
			kw = string_to_wide(key);
			os__getenv_opt_defer_0 = true;
			voidptr s = _wgetenv(kw);
			if (s == 0) {
				_option_string _t2 = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
					// Defer begin
					if (os__getenv_opt_defer_0) {
						#if defined(_WIN32)
							_v_free(((voidptr)(kw)));
						
						#endif
					}
					// Defer end
				return _t2;
			}
			_option_string _t3;
			_option_ok(&(string[]) { string_from_wide(s) }, (_option*)(&_t3), sizeof(string));
				// Defer begin
				if (os__getenv_opt_defer_0) {
					#if defined(_WIN32)
						_v_free(((voidptr)(kw)));
					
					#endif
				}
				// Defer end
			return _t3;
		}
		#else
		{
		}
		#endif
	}
	return (_option_string){0};
}

int os__setenv(string name, string value, bool overwrite) {
	#if defined(_WIN32)
	{
		string format =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = name}}, {_SLIT("="), /*115 &string*/0xfe10, {.d_s = value}}, {_SLIT0, 0, { .d_c = 0 }}}));
		if (overwrite) {
			{ // Unsafe block
				int _t2 = _putenv(((char*)(format.str)));
				return _t2;
			}
		} else {
			if (os__getenv(name).len == 0) {
				{ // Unsafe block
					int _t3 = _putenv(((char*)(format.str)));
					return _t3;
				}
			}
		}
		int _t4 = -1;
		return _t4;
	}
	#else
	{
	}
	#endif
	return 0;
}

int os__unsetenv(string name) {
	#if defined(_WIN32)
	{
		string format =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = name}}, {_SLIT("="), 0, { .d_c = 0 }}}));
		int _t2 = _putenv(((char*)(format.str)));
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

Map_string_string os__environ(void) {
	Map_string_string res = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	#if defined(_WIN32)
	{
		u16* estrings = GetEnvironmentStringsW();
		string eline = _SLIT("");
		for (u16* c = estrings; *c != 0U; ) {
			eline = string_from_wide(c);
			int eq_index = string_index_u8(eline, '=');
			if (eq_index > 0) {
				map_set(&res, &(string[]){string_substr(eline, 0, eq_index)}, &(string[]) { string_substr(eline, (int)(eq_index + 1), 2147483647) });
			}
			{ // Unsafe block
				c = c + eline.len + 1;
			}
		}
		FreeEnvironmentStringsW(estrings);
	}
	#else
	{
	}
	#endif
	return res;
}

int os__fd_close(int fd) {
	if (fd == -1) {
		int _t1 = 0;
		return _t1;
	}
	int _t2 = close(fd);
	return _t2;
}

void os__fd_write(int fd, string s) {
	if (fd == -1) {
		return;
	}
	u8* sp = s.str;
	int remaining = s.len;
	for (;;) {
		if (!(remaining > 0)) break;
		int written = write(fd, sp, remaining);
		if (written < 0) {
			return;
		}
		remaining = (int)(remaining - written);
		sp = ((voidptr)(sp + written));
	}
}

Array_string os__fd_slurp(int fd) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	if (fd == -1) {
		return res;
	}
	for (;;) {
		multi_return_string_int mr_886 = os__fd_read(fd, 4096);
		string s = mr_886.arg0;
		int b = mr_886.arg1;
		if (b <= 0) {
			break;
		}
		array_push((array*)&res, _MOV((string[]){ string_clone(s) }));
	}
	return res;
}

multi_return_string_int os__fd_read(int fd, int maxbytes) {
	if (fd == -1) {
		return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
	}
	{ // Unsafe block
		u8* buf = malloc_noscan((int)(maxbytes + 1));
		int nbytes = read(fd, buf, maxbytes);
		if (nbytes < 0) {
			_v_free(buf);
			return (multi_return_string_int){.arg0=_SLIT(""), .arg1=nbytes};
		}
		buf[nbytes] = 0;
		return (multi_return_string_int){.arg0=tos(buf, nbytes), .arg1=nbytes};
	}
	return (multi_return_string_int){0};
}

bool os__fd_is_pending(int fd) {
	fd_set read_set = ((fd_set){EMPTY_STRUCT_INITIALIZATION});
	FD_ZERO(&read_set);
	FD_SET(fd, &read_set);
	struct timeval ts = ((struct timeval){.tv_sec = 0U,.tv_usec = 0U,});
	int res = select((int)(fd + 1), &read_set, NULL, NULL, &ts);
	if (res > 0) {
		if (FD_ISSET(fd, &read_set) != 0) {
			bool _t1 = true;
			return _t1;
		}
	}
	bool _t2 = false;
	return _t2;
}

VV_LOCAL_SYMBOL string os__NotExpected_msg(os__NotExpected err) {
	string _t1 = err.cause;
	return _t1;
}

VV_LOCAL_SYMBOL int os__NotExpected_code(os__NotExpected err) {
	int _t1 = err.code;
	return _t1;
}

VV_LOCAL_SYMBOL string os__fix_windows_path(string path) {
	string p = path;
	p = string_replace(path, _SLIT("/"), _SLIT("\\"));
	return p;
}

_result_os__File os__open_file(string path, string mode, Array_int options) {
	int flags = 0;
	bool seek_to_end = false;
	for (int _t1 = 0; _t1 < mode.len; ++_t1) {
		u8 m = mode.str[_t1];

		if (m == ('w')) {
			flags |= ((_const_os__o_create | _const_os__o_trunc) | _const_os__o_wronly);
		}
		else if (m == ('a')) {
			flags |= ((_const_os__o_create | _const_os__o_append) | _const_os__o_wronly);
			seek_to_end = true;
		}
		else if (m == ('r')) {
			flags |= _const_os__o_rdonly;
		}
		else if (m == ('b')) {
			flags |= _const_os__o_binary;
		}
		else if (m == ('s')) {
			flags |= _const_os__o_sync;
		}
		else if (m == ('n')) {
			flags |= _const_os__o_nonblock;
		}
		else if (m == ('c')) {
			flags |= _const_os__o_noctty;
		}
		else if (m == ('+')) {
			flags &= ~_const_os__o_wronly;
			flags |= _const_os__o_rdwr;
		}
		else {
		}
	}
	if (string__eq(mode, _SLIT("r+"))) {
		flags = _const_os__o_rdwr;
	}
	int permission = 0666;
	if (options.len > 0) {
		permission = (*(int*)array_get(options, 0));
	}
	if (permission < 0600) {
		permission = 0x0100;
	} else {
		permission = (0x0100 | 0x0080);
	}
	string p = os__fix_windows_path(path);
	int _t2;
	#if defined(_WIN32)
		_t2 = _wopen(string_to_wide(p), flags, permission);
		;
	#else
	#endif
	int fd = _t2;
	if (fd == -1) {
		return (_result_os__File){ .is_error=true, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	FILE* cfile = fdopen(fd, ((char*)(mode.str)));
	if (isnil(cfile)) {
		return (_result_os__File){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to open or create file \""), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (seek_to_end) {
		#if defined(_WIN32)
		{
			_fseeki64(cfile, 0U, SEEK_END);
		}
		#else
		{
		}
		#endif
	}
	_result_os__File _t6;
	_result_ok(&(os__File[]) { ((os__File){.cfile = cfile,.fd = fd,.is_opened = true,}) }, (_result*)(&_t6), sizeof(os__File));
	return _t6;
}

_result_os__File os__open(string path) {
	_result_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.is_error) {
		_result_os__File _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	FILE* cfile =  (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	_result_os__File _t3;
	_result_ok(&(os__File[]) { ((os__File){.cfile = cfile,.fd = fd,.is_opened = true,}) }, (_result*)(&_t3), sizeof(os__File));
	return _t3;
}

_result_os__File os__create(string path) {
	_result_FILE_ptr _t1 = os__vfopen(path, _SLIT("wb"));
	if (_t1.is_error) {
		_result_os__File _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	FILE* cfile =  (*(FILE**)_t1.data);
	int fd = os__fileno(cfile);
	_result_os__File _t3;
	_result_ok(&(os__File[]) { ((os__File){.cfile = cfile,.fd = fd,.is_opened = true,}) }, (_result*)(&_t3), sizeof(os__File));
	return _t3;
}

os__File os__stdin(void) {
	os__File _t1 = ((os__File){.cfile = stdin,.fd = 0,.is_opened = true,});
	return _t1;
}

os__File os__stdout(void) {
	os__File _t1 = ((os__File){.cfile = stdout,.fd = 1,.is_opened = true,});
	return _t1;
}

os__File os__stderr(void) {
	os__File _t1 = ((os__File){.cfile = stderr,.fd = 2,.is_opened = true,});
	return _t1;
}

bool os__File_eof(os__File* f) {
	FILE* cfile = ((FILE*)(f->cfile));
	bool _t1 = feof(cfile) != 0;
	return _t1;
}

_result_void os__File_reopen(os__File* f, string path, string mode) {
	string p = os__fix_windows_path(path);
	FILE* cfile = ((FILE*)(((void*)0)));
	#if defined(_WIN32)
	{
		cfile = _wfreopen(string_to_wide(p), string_to_wide(mode), f->cfile);
	}
	#else
	{
	}
	#endif
	if (isnil(cfile)) {
		return (_result_void){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to reopen file \""), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	f->cfile = cfile;
	return (_result_void){0};
}

_result_int os__File_read(os__File* f, Array_u8* buf) {
	if (buf->len == 0) {
		return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)memdup(&(os__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int nbytes = ((int)(fread(buf->data, 1, buf->len, ((FILE*)(f->cfile)))));
	if (nbytes <= 0) {
		if (feof(((FILE*)(f->cfile))) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)memdup(&(os__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ferror(((FILE*)(f->cfile))) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__NotExpected_to_Interface_IError(((os__NotExpected*)memdup(&(os__NotExpected){.cause = _SLIT("unexpected error from fread"),.code = -1,}, sizeof(os__NotExpected)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_int _t4;
	_result_ok(&(int[]) { nbytes }, (_result*)(&_t4), sizeof(int));
	return _t4;
}

_result_int os__File_write(os__File* f, Array_u8 buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int written = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
	if (written == 0 && buf.len != 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t3;
	_result_ok(&(int[]) { written }, (_result*)(&_t3), sizeof(int));
	return _t3;
}

_result_int os__File_writeln(os__File* f, string s) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int written = ((int)(fwrite(s.str, 1, s.len, f->cfile)));
	if (written == 0 && s.len != 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int x = fputs("\n", f->cfile);
	if (x < 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("could not add newline")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t4;
	_result_ok(&(int[]) { (int)(written + 1) }, (_result*)(&_t4), sizeof(int));
	return _t4;
}

_result_int os__File_write_string(os__File* f, string s) {
		_result_void _t1 = os__File_write_full_buffer(f, s.str, ((usize)(s.len)));
	if (_t1.is_error) {
		_result_int _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_int _t3;
	_result_ok(&(int[]) { s.len }, (_result*)(&_t3), sizeof(int));
	return _t3;
}

_result_int os__File_write_to(os__File* f, u64 pos, Array_u8 buf) {
	if (!f->is_opened) {
		return (_result_int){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
			if (res == 0 && buf.len != 0) {
				return (_result_int){ .is_error=true, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			_fseeki64(f->cfile, 0U, SEEK_END);
			_result_int _t5;
			_result_ok(&(int[]) { res }, (_result*)(&_t5), sizeof(int));
			return _t5;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		int res = ((int)(fwrite(buf.data, 1, buf.len, f->cfile)));
		if (res == 0 && buf.len != 0) {
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("0 bytes written")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		fseek(f->cfile, 0, SEEK_END);
		_result_int _t8;
		_result_ok(&(int[]) { res }, (_result*)(&_t8), sizeof(int));
		return _t8;
	}
	#endif
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("Could not write to file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

// Attr: [unsafe]
int os__File_write_ptr(os__File* f, voidptr data, int size) {
	int _t1 = ((int)(fwrite(data, 1, size, f->cfile)));
	return _t1;
}

// Attr: [unsafe]
_result_void os__File_write_full_buffer(os__File* f, voidptr buffer, usize buffer_len) {
	if (buffer_len <= ((usize)(0))) {
		return (_result_void){0};
	}
	if (!f->is_opened) {
		return (_result_void){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	u8* ptr = ((u8*)(buffer));
	i64 remaining_bytes = ((i64)(buffer_len));
	for (;;) {
		if (!(remaining_bytes > 0)) break;
		{ // Unsafe block
			i64 x = ((i64)(fwrite(ptr, 1, remaining_bytes, f->cfile)));
			ptr += x;
			remaining_bytes -= x;
			if (x <= 0) {
				return (_result_void){ .is_error=true, .err=_v_error(_SLIT("C.fwrite returned 0")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	return (_result_void){0};
}

// Attr: [unsafe]
int os__File_write_ptr_at(os__File* f, voidptr data, int size, u64 pos) {
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			int res = ((int)(fwrite(data, 1, size, f->cfile)));
			_fseeki64(f->cfile, 0U, SEEK_END);
			return res;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		int res = ((int)(fwrite(data, 1, size, f->cfile)));
		fseek(f->cfile, 0, SEEK_END);
		return res;
	}
	#endif
	int _t6 = 0;
	return _t6;
}

VV_LOCAL_SYMBOL _result_int os__fread(voidptr ptr, int item_size, int items, FILE* stream) {
	int nbytes = ((int)(fread(ptr, item_size, items, stream)));
	if (nbytes <= 0) {
		if (feof(stream) != 0) {
			return (_result_int){ .is_error=true, .err=I_os__Eof_to_Interface_IError(((os__Eof*)memdup(&(os__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ferror(stream) != 0) {
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("file read error")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_int _t3;
	_result_ok(&(int[]) { nbytes }, (_result*)(&_t3), sizeof(int));
	return _t3;
}

Array_u8 os__File_read_bytes(os__File* f, int size) {
	Array_u8 _t1 = os__File_read_bytes_at(f, size, 0U);
	return _t1;
}

Array_u8 os__File_read_bytes_at(os__File* f, int size, u64 pos) {
	Array_u8 arr = __new_array_with_default_noscan(size, 0, sizeof(u8), 0);
	_result_int _t1 = os__File_read_bytes_into(f, pos, &/*arr*/arr);
	if (_t1.is_error) {
		IError err = _t1.err;
		Array_u8 _t2 = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
		return _t2;
	}
	
 	int nreadbytes =  (*(int*)_t1.data);
	Array_u8 _t3 = array_slice(arr, 0, nreadbytes);
	return _t3;
}

_result_int os__File_read_bytes_into_newline(os__File* f, Array_u8* buf) {
	if (buf->len == 0) {
		return (_result_int){ .is_error=true, .err=_v_error(string__plus(_SLIT("read_bytes_into_newline"), _SLIT(": `buf.len` == 0"))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int newline = 10;
	int c = 0;
	int buf_ptr = 0;
	int nbytes = 0;
	FILE* stream = ((FILE*)(f->cfile));
	for (;;) {
		if (!((buf_ptr < buf->len))) break;
		c = getc(stream);

		if (c == (EOF)) {
			if (feof(stream) != 0) {
				_result_int _t2;
				_result_ok(&(int[]) { nbytes }, (_result*)(&_t2), sizeof(int));
				return _t2;
			}
			if (ferror(stream) != 0) {
				return (_result_int){ .is_error=true, .err=_v_error(_SLIT("file read error")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		else if (c == (newline)) {
			array_set(buf, buf_ptr, &(u8[]) { ((u8)(c)) });
			nbytes++;
			_result_int _t4;
			_result_ok(&(int[]) { nbytes }, (_result*)(&_t4), sizeof(int));
			return _t4;
		}
		else {
			array_set(buf, buf_ptr, &(u8[]) { ((u8)(c)) });
			buf_ptr++;
			nbytes++;
		}
	}
	_result_int _t5;
	_result_ok(&(int[]) { nbytes }, (_result*)(&_t5), sizeof(int));
	return _t5;
}

_result_int os__File_read_bytes_into(os__File* f, u64 pos, Array_u8* buf) {
	if (buf->len == 0) {
		return (_result_int){ .is_error=true, .err=_v_error(string__plus(_SLIT("read_bytes_into"), _SLIT(": `buf.len` == 0"))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
			_result_int _t4 = os__fread(buf->data, 1, buf->len, f->cfile);
			if (_t4.is_error) {
				_result_int _t5;
				memcpy(&_t5, &_t4, sizeof(_result));
				return _t5;
			}
			
 			int nbytes =  (*(int*)_t4.data);
			_result_int _t6;
			_result_ok(&(int[]) { nbytes }, (_result*)(&_t6), sizeof(int));
			return _t6;
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		_result_int _t8 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t8.is_error) {
			_result_int _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		
 		int nbytes =  (*(int*)_t8.data);
		_result_int _t10;
		_result_ok(&(int[]) { nbytes }, (_result*)(&_t10), sizeof(int));
		return _t10;
	}
	#endif
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("Could not read file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_int os__File_read_from(os__File* f, u64 pos, Array_u8* buf) {
	if (buf->len == 0) {
		_result_int _t1;
		_result_ok(&(int[]) { 0 }, (_result*)(&_t1), sizeof(int));
		return _t1;
	}
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			_fseeki64(f->cfile, pos, SEEK_SET);
		}
		#else
		{
		}
		#endif
		_result_int _t4 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t4.is_error) {
			_result_int _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 		int nbytes =  (*(int*)_t4.data);
		_result_int _t6;
		_result_ok(&(int[]) { nbytes }, (_result*)(&_t6), sizeof(int));
		return _t6;
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		fseek(f->cfile, pos, SEEK_SET);
		_result_int _t8 = os__fread(buf->data, 1, buf->len, f->cfile);
		if (_t8.is_error) {
			_result_int _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		
 		int nbytes =  (*(int*)_t8.data);
		_result_int _t10;
		_result_ok(&(int[]) { nbytes }, (_result*)(&_t10), sizeof(int));
		return _t10;
	}
	#endif
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("Could not read file")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_int os__File_read_into_ptr(os__File* f, u8* ptr, int max_size) {
	_result_int _t1 = os__fread(ptr, 1, max_size, f->cfile);
	return _t1;
}

void os__File_flush(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	fflush(f->cfile);
}

string os__FileNotOpenedError_msg(os__FileNotOpenedError err) {
	string _t1 = _SLIT("os: file not opened");
	return _t1;
}

string os__SizeOfTypeIs0Error_msg(os__SizeOfTypeIs0Error err) {
	string _t1 = _SLIT("os: size of type is 0");
	return _t1;
}

VV_LOCAL_SYMBOL IError os__error_file_not_opened(void) {
	IError _t1 = /*&IError*/I_os__FileNotOpenedError_to_Interface_IError(((os__FileNotOpenedError*)memdup(&(os__FileNotOpenedError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__FileNotOpenedError))));
	return _t1;
}

VV_LOCAL_SYMBOL IError os__error_size_of_type_0(void) {
	IError _t1 = /*&IError*/I_os__SizeOfTypeIs0Error_to_Interface_IError(((os__SizeOfTypeIs0Error*)memdup(&(os__SizeOfTypeIs0Error){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__SizeOfTypeIs0Error))));
	return _t1;
}

_result_void os__File_seek(os__File* f, i64 pos, os__SeekMode mode) {
	if (!f->is_opened) {
		return (_result_void){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int whence = ((int)(mode));
	int res = 0;
	#if defined(TARGET_IS_64BIT)
	{
		#if defined(_WIN32)
		{
			res = _fseeki64(f->cfile, pos, whence);
		}
		#else
		{
		}
		#endif
	}
	#endif
	#if defined(TARGET_IS_32BIT)
	{
		res = fseek(f->cfile, pos, whence);
	}
	#endif
	if (res == -1) {
		return (_result_void){ .is_error=true, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

_result_i64 os__File_tell(os__File* f) {
	if (!f->is_opened) {
		return (_result_i64){ .is_error=true, .err=os__error_file_not_opened(), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	isize pos = ((isize)(0));
	#if defined(_WIN32)
	{
		pos = _telli64(f->fd);
	}
	#else
	{
	}
	#endif
	if (pos == -1) {
		return (_result_i64){ .is_error=true, .err=_v_error(os__posix_get_error_msg(errno)), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_i64 _t4;
	_result_ok(&(i64[]) { pos }, (_result*)(&_t4), sizeof(i64));
	return _t4;
}

bool os__is_abs_path(string path) {
	if (path.len == 0) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = os__is_unc_path(path) || os__is_drive_rooted(path) || os__is_normal_path(path);
	return _t2;
	bool _t3 = string_at(path, 0) == _const_os__fslash;
	return _t3;
}

string os__abs_path(string path) {
	string wd = os__getwd();
	if (path.len == 0) {
		return wd;
	}
	string npath = os__norm_path(path);
	if (string__eq(npath, _const_os__dot_str)) {
		return wd;
	}
	if (!os__is_abs_path(npath)) {
		strings__Builder sb = strings__new_builder(npath.len);
		strings__Builder_write_string(&sb, wd);
		strings__Builder_write_string(&sb, _const_os__path_separator);
		strings__Builder_write_string(&sb, npath);
		string _t3 = os__norm_path(strings__Builder_str(&sb));
		return _t3;
	}
	return npath;
}

// Attr: [direct_array_access]
string os__norm_path(string path) {
	if (path.len == 0) {
		return _const_os__dot_str;
	}
	bool rooted = os__is_abs_path(path);
	int volume_len = os__win_volume_len(path);
	string volume = string_substr(path, 0, volume_len);
	if (volume_len != 0 && string_contains(volume, _const_os__fslash_str)) {
		volume = string_replace(volume, _const_os__fslash_str, _const_os__path_separator);
	}
	string cpath = os__clean_path(string_substr(path, volume_len, 2147483647));
	if (cpath.len == 0 && volume_len == 0) {
		return _const_os__dot_str;
	}
	Array_string spath = string_split(cpath, _const_os__path_separator);
	if (!Array_string_contains(spath, _const_os__dot_dot)) {
		string _t3 = (volume_len != 0 ? (string__plus(volume, cpath)) : (cpath));
		return _t3;
	}
	int spath_len = spath.len;
	strings__Builder sb = strings__new_builder(cpath.len);
	if (rooted) {
		strings__Builder_write_string(&sb, _const_os__path_separator);
	}
	Array_string new_path = __new_array_with_default(0, spath_len, sizeof(string), 0);
	int backlink_count = 0;
	for (int i = (int)(spath_len - 1); i >= 0; i--) {
		string part = ((string*)spath.data)[i];
		if (string__eq(part, _const_os__empty_str)) {
			continue;
		}
		if (string__eq(part, _const_os__dot_dot)) {
			backlink_count++;
			continue;
		}
		if (backlink_count != 0) {
			backlink_count--;
			continue;
		}
		array_prepend(&new_path, &(string[]){part});
	}
	if (backlink_count != 0 && !rooted) {
		for (int i = 0; i < backlink_count; ++i) {
			strings__Builder_write_string(&sb, _const_os__dot_dot);
			if (new_path.len == 0 && i == (int)(backlink_count - 1)) {
				break;
			}
			strings__Builder_write_string(&sb, _const_os__path_separator);
		}
	}
	strings__Builder_write_string(&sb, Array_string_join(new_path, _const_os__path_separator));
	string res = strings__Builder_str(&sb);
	if (res.len == 0) {
		if (volume_len != 0) {
			return volume;
		}
		if (!rooted) {
			return _const_os__dot_str;
		}
		return _const_os__path_separator;
	}
	if (volume_len != 0) {
		string _t7 = string__plus(volume, res);
		return _t7;
	}
	return res;
}

_result_string os__existing_path(string path) {
	IError err = _v_error(_SLIT("path does not exist"));
	if (path.len == 0) {
		return (_result_string){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (os__exists(path)) {
		_result_string _t2;
		_result_ok(&(string[]) { path }, (_result*)(&_t2), sizeof(string));
		return _t2;
	}
	int volume_len = 0;
	volume_len = os__win_volume_len(path);
	if (volume_len > 0 && os__is_slash(string_at(path, (int)(volume_len - 1)))) {
		volume_len++;
	}
	strings__textscanner__TextScanner sc = strings__textscanner__new(string_substr(path, volume_len, 2147483647));
	string recent_path = string_substr(path, 0, volume_len);
	for (;;) {
		if (!(strings__textscanner__TextScanner_next(&sc) != -1)) break;
		u8 curr = ((u8)(strings__textscanner__TextScanner_current(&sc)));
		int peek = strings__textscanner__TextScanner_peek(&sc);
		int back = strings__textscanner__TextScanner_peek_back(&sc);
		if (os__is_curr_dir_ref(back, curr, peek)) {
			continue;
		}
		int range = (int)((int)(sc.ilen - strings__textscanner__TextScanner_remaining(&sc)) + volume_len);
		if (os__is_slash(curr) && !os__is_slash(((u8)(peek)))) {
			recent_path = string_substr(path, 0, range);
			continue;
		}
		if (!os__is_slash(curr) && (peek == -1 || os__is_slash(((u8)(peek))))) {
			string curr_path = string_substr(path, 0, range);
			if (os__exists(curr_path)) {
				recent_path = curr_path;
				continue;
			}
			if (recent_path.len == 0) {
				break;
			}
			_result_string _t3;
			_result_ok(&(string[]) { recent_path }, (_result*)(&_t3), sizeof(string));
			return _t3;
		}
	}
	return (_result_string){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL string os__clean_path(string path) {
	if (path.len == 0) {
		return _const_os__empty_str;
	}
	strings__Builder sb = strings__new_builder(path.len);
	strings__textscanner__TextScanner sc = strings__textscanner__new(path);
	for (;;) {
		if (!(strings__textscanner__TextScanner_next(&sc) != -1)) break;
		u8 curr = ((u8)(strings__textscanner__TextScanner_current(&sc)));
		int back = strings__textscanner__TextScanner_peek_back(&sc);
		int peek = strings__textscanner__TextScanner_peek(&sc);
		if (back != -1 && os__is_slash(((u8)(back))) && os__is_slash(curr)) {
			continue;
		}
		if (os__is_curr_dir_ref(back, curr, peek)) {
			if (peek != -1 && os__is_slash(((u8)(peek)))) {
				strings__textscanner__TextScanner_skip_n(&sc, 1);
			}
			continue;
		}
		if (curr == _const_os__fslash) {
			strings__Builder_write_u8(&sb, _const_os__bslash);
			continue;
		}
		strings__Builder_write_u8(&sb, ((u8)(strings__textscanner__TextScanner_current(&sc))));
	}
	string res = strings__Builder_str(&sb);
	if (res.len > 1 && os__is_slash(string_at(res, (int)(res.len - 1)))) {
		string _t2 = string_substr(res, 0, (int)(res.len - 1));
		return _t2;
	}
	return res;
}

string os__to_slash(string path) {
	if (string__eq(_const_os__path_separator, _SLIT("/"))) {
		return path;
	}
	string _t2 = string_replace(path, _const_os__path_separator, _SLIT("/"));
	return _t2;
}

string os__from_slash(string path) {
	if (string__eq(_const_os__path_separator, _SLIT("/"))) {
		return path;
	}
	string _t2 = string_replace(path, _SLIT("/"), _const_os__path_separator);
	return _t2;
}

VV_LOCAL_SYMBOL int os__win_volume_len(string path) {
	int plen = path.len;
	if (plen < 2) {
		int _t1 = 0;
		return _t1;
	}
	if (os__has_drive_letter(path)) {
		int _t2 = 2;
		return _t2;
	}
	if (plen >= 5 && os__starts_w_slash_slash(path) && !os__is_slash(string_at(path, 2))) {
		for (int i = 3; i < plen; i++) {
			if (os__is_slash(string_at(path, i))) {
				if ((int)(i + 1) >= plen || os__is_slash(string_at(path, (int)(i + 1)))) {
					break;
				}
				i++;
				for (; i < plen; i++) {
					if (os__is_slash(string_at(path, i))) {
						return i;
					}
				}
				return i;
			}
		}
	}
	int _t5 = 0;
	return _t5;
}

VV_LOCAL_SYMBOL bool os__is_slash(u8 b) {
	bool _t1 = b == _const_os__bslash || b == _const_os__fslash;
	return _t1;
	bool _t2 = b == _const_os__fslash;
	return _t2;
}

VV_LOCAL_SYMBOL bool os__is_unc_path(string path) {
	bool _t1 = os__win_volume_len(path) >= 5 && os__starts_w_slash_slash(path);
	return _t1;
}

VV_LOCAL_SYMBOL bool os__has_drive_letter(string path) {
	bool _t1 = path.len >= 2 && u8_is_letter(string_at(path, 0)) && string_at(path, 1) == ':';
	return _t1;
}

VV_LOCAL_SYMBOL bool os__starts_w_slash_slash(string path) {
	bool _t1 = path.len >= 2 && os__is_slash(string_at(path, 0)) && os__is_slash(string_at(path, 1));
	return _t1;
}

VV_LOCAL_SYMBOL bool os__is_drive_rooted(string path) {
	bool _t1 = path.len >= 3 && os__has_drive_letter(path) && os__is_slash(string_at(path, 2));
	return _t1;
}

VV_LOCAL_SYMBOL bool os__is_normal_path(string path) {
	int plen = path.len;
	if (plen == 0) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = (plen == 1 && os__is_slash(string_at(path, 0))) || (plen >= 2 && os__is_slash(string_at(path, 0)) && !os__is_slash(string_at(path, 1)));
	return _t2;
}

VV_LOCAL_SYMBOL bool os__is_curr_dir_ref(int byte_one, int byte_two, int byte_three) {
	if (((u8)(byte_two)) != _const_os__dot) {
		bool _t1 = false;
		return _t1;
	}
	bool _t2 = (byte_one < 0 || os__is_slash(((u8)(byte_one)))) && (byte_three < 0 || os__is_slash(((u8)(byte_three))));
	return _t2;
}

string os__windows_volume(string path) {
	int volume_len = os__win_volume_len(path);
	if (volume_len == 0) {
		return _const_os__empty_str;
	}
	string _t2 = string_substr(path, 0, volume_len);
	return _t2;
}

u32 os__FilePermission_bitmask(os__FilePermission p) {
	u32 mask = ((u32)(0U));
	if (p.read) {
		mask |= 4U;
	}
	if (p.write) {
		mask |= 2U;
	}
	if (p.execute) {
		mask |= 1U;
	}
	return mask;
}

u32 os__FileMode_bitmask(os__FileMode m) {
	u32 _t1 = (((os__FilePermission_bitmask(m.owner) << 6U) | (os__FilePermission_bitmask(m.group) << 3U)) | os__FilePermission_bitmask(m.others));
	return _t1;
}

os__FileMode os__inode(string path) {
	struct stat attr;
	stat(((char*)(path.str)), &attr);
	os__FileType typ = os__FileType__regular;
	if ((attr.st_mode & ((u32)(S_IFMT))) == ((u32)(S_IFDIR))) {
		typ = os__FileType__directory;
	}
	#if defined(_WIN32)
	{
		os__FileMode _t2 = ((os__FileMode){.typ = typ,.owner = ((os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0U,}),.group = ((os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0U,}),.others = ((os__FilePermission){.read = ((attr.st_mode & ((u32)(S_IREAD)))) != 0U,.write = ((attr.st_mode & ((u32)(S_IWRITE)))) != 0U,.execute = ((attr.st_mode & ((u32)(S_IEXEC)))) != 0U,}),});
		return _t2;
	}
	#else
	{
	}
	#endif
	return (os__FileMode){.owner = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},.group = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},.others = (os__FilePermission){.read = 0,.write = 0,.execute = 0,},};
}

// TypeDecl
_result_void os__open_uri(string uri) {
	string vopen_uri_cmd = os__getenv(_SLIT("VOPEN_URI_CMD"));
	if ((vopen_uri_cmd).len != 0) {
		os__Result result = os__execute( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = vopen_uri_cmd}}, {_SLIT(" \""), /*115 &string*/0xfe10, {.d_s = uri}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
		if (result.exit_code != 0) {
			return (_result_void){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unable to open url: "), /*115 &string*/0xfe10, {.d_s = result.output}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		return (_result_void){0};
	}
	_result_voidptr _t2 = dl__open_opt(_SLIT("shell32"), _const_dl__rtld_now);
	if (_t2.is_error) {
		_result_void _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	voidptr handle =  (*(voidptr*)_t2.data);
	_result_voidptr _t4 = dl__sym_opt(handle, _SLIT("ShellExecuteW"));
	if (_t4.is_error) {
		_result_void _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	void (*func) (voidptr , u16* , u16* , u16* , u16* , int ) = ((os__ShellExecuteWin)( (*(voidptr*)_t4.data)));
	func(NULL, string_to_wide(_SLIT("open")), string_to_wide(uri), NULL, NULL, SW_SHOWNORMAL);
	dl__close(handle);
	return (_result_void){0};
}

// Attr: [manualfree]
_result_Array_u8 os__read_bytes(string path) {
	bool os__read_bytes_defer_0 = false;
	FILE* fp;
	_result_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.is_error) {
		_result_Array_u8 _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	fp =  (*(FILE**)_t1.data);
	os__read_bytes_defer_0 = true;
	_result_int _t3 = os__find_cfile_size(fp);
	if (_t3.is_error) {
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
		_result_Array_u8 _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	int fsize =  (*(int*)_t3.data);
	if (fsize == 0) {
		_result_strings__Builder _t5 = os__slurp_file_in_builder(fp);
		if (_t5.is_error) {
			// Defer begin
			if (os__read_bytes_defer_0) {
				fclose(fp);
			}
			// Defer end
			_result_Array_u8 _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 		strings__Builder sb =  (*(strings__Builder*)_t5.data);
		_result_Array_u8 _t7;
		_result_ok(&(Array_u8[]) { strings__Builder_reuse_as_plain_u8_array(&sb) }, (_result*)(&_t7), sizeof(Array_u8));
			// Defer begin
			if (os__read_bytes_defer_0) {
				fclose(fp);
			}
			// Defer end
		return _t7;
	}
	Array_u8 res = __new_array_with_default_noscan(fsize, 0, sizeof(u8), 0);
	int nr_read_elements = ((int)(fread(res.data, 1, fsize, fp)));
	if (nr_read_elements == 0 && fsize > 0) {
		_result_Array_u8 _t8 = (_result_Array_u8){ .is_error=true, .err=_v_error(_SLIT("fread failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__read_bytes_defer_0) {
				fclose(fp);
			}
			// Defer end
		return _t8;
	}
	array_trim(&res, nr_read_elements);
	_result_Array_u8 _t9;
	_result_ok(&(Array_u8[]) { res }, (_result*)(&_t9), sizeof(Array_u8));
		// Defer begin
		if (os__read_bytes_defer_0) {
			fclose(fp);
		}
		// Defer end
	return _t9;
}

VV_LOCAL_SYMBOL _result_int os__find_cfile_size(FILE* fp) {
	int cseek = fseek(fp, 0, SEEK_END);
	isize raw_fsize = ftell(fp);
	if (raw_fsize != 0 && cseek != 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("fseek failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (cseek != 0 && raw_fsize < 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("ftell failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int len = ((int)(raw_fsize));
	if (((i64)(len)) < raw_fsize) {
		return (_result_int){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("int("), /*100 &isize*/0xfe09, {.d_i64 = raw_fsize}}, {_SLIT(") cast results in "), /*100 &int*/0xfe07, {.d_i32 = len}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	rewind(fp);
	_result_int _t4;
	_result_ok(&(int[]) { len }, (_result*)(&_t4), sizeof(int));
	return _t4;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL _result_strings__Builder os__slurp_file_in_builder(FILE* fp) {
	Array_fixed_u8_4096 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	strings__Builder sb = strings__new_builder(_const_os__buf_size);
	for (;;) {
		_result_int _t1 = os__fread(&buf[0], 1, _const_os__buf_size, fp);
		if (_t1.is_error) {
			IError err = _t1.err;
			if ((err)._typ == _IError_os__Eof_index) {
				break;
			}
			strings__Builder_free(&sb);
			return (_result_strings__Builder){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		int read_bytes =  (*(int*)_t1.data);
		strings__Builder_write_ptr(&sb, &buf[0], read_bytes);
	}
	_result_strings__Builder _t3;
	_result_ok(&(strings__Builder[]) { sb }, (_result*)(&_t3), sizeof(strings__Builder));
	return _t3;
}

// Attr: [manualfree]
_result_string os__read_file(string path) {
	bool os__read_file_defer_0 = false;
	FILE* fp;
	string mode = _SLIT("rb");
	_result_FILE_ptr _t1 = os__vfopen(path, mode);
	if (_t1.is_error) {
		_result_string _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	fp =  (*(FILE**)_t1.data);
	os__read_file_defer_0 = true;
	_result_int _t3 = os__find_cfile_size(fp);
	if (_t3.is_error) {
		// Defer begin
		if (os__read_file_defer_0) {
			fclose(fp);
		}
		// Defer end
		_result_string _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	int allocate =  (*(int*)_t3.data);
	if (allocate == 0) {
		_result_strings__Builder _t5 = os__slurp_file_in_builder(fp);
		if (_t5.is_error) {
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
			_result_string _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 		strings__Builder sb =  (*(strings__Builder*)_t5.data);
		string res = strings__Builder_str(&sb);
		strings__Builder_free(&sb);
		_result_string _t7;
		_result_ok(&(string[]) { res }, (_result*)(&_t7), sizeof(string));
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
		return _t7;
	}
	{ // Unsafe block
		u8* str = malloc_noscan((int)(allocate + 1));
		int nelements = ((int)(fread(str, 1, allocate, fp)));
		int is_eof = ((int)(feof(fp)));
		int is_error = ((int)(ferror(fp)));
		if (is_eof == 0 && is_error != 0) {
			_v_free(str);
			_result_string _t8 = (_result_string){ .is_error=true, .err=_v_error(_SLIT("fread failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
				// Defer begin
				if (os__read_file_defer_0) {
					fclose(fp);
				}
				// Defer end
			return _t8;
		}
		str[nelements] = 0;
		if (nelements == 0) {
			_result_string _t9;
			_result_ok(&(string[]) { u8_vstring(str) }, (_result*)(&_t9), sizeof(string));
				// Defer begin
				if (os__read_file_defer_0) {
					fclose(fp);
				}
				// Defer end
			return _t9;
		}
		_result_string _t10;
		_result_ok(&(string[]) { u8_vstring_with_len(str, nelements) }, (_result*)(&_t10), sizeof(string));
			// Defer begin
			if (os__read_file_defer_0) {
				fclose(fp);
			}
			// Defer end
		return _t10;
	}
	return (_result_string){0};
}

_result_void os__truncate(string path, u64 len) {
	bool os__truncate_defer_0 = false;
	int fp;
	int _t1;
	#if defined(_WIN32)
		_t1 = _wopen(string_to_wide(path), (_const_os__o_wronly | _const_os__o_trunc), 0);
		;
	#else
	#endif
	fp = _t1;
	if (fp < 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	os__truncate_defer_0 = true;
	#if defined(_WIN32)
	{
		if (_chsize_s(fp, len) != 0) {
			_result_void _t4 = (_result_void){ .is_error=true, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
				// Defer begin
				if (os__truncate_defer_0) {
					close(fp);
				}
				// Defer end
			return _t4;
		}
	}
	#else
	{
	}
	#endif
		// Defer begin
		if (os__truncate_defer_0) {
			close(fp);
		}
		// Defer end
	return (_result_void){0};
}

VV_LOCAL_SYMBOL void os__eprintln_unknown_file_size(void) {
	eprintln(string__plus(_SLIT("os.file_size() Cannot determine file-size: "), os__posix_get_error_msg(errno)));
}

u64 os__file_size(string path) {
	struct stat s;
	{ // Unsafe block
		#if defined(TARGET_IS_64BIT)
		{
			#if defined(_WIN32)
			{
				struct __stat64 swin = ((struct __stat64){.st_size = 0,.st_mode = 0,.st_mtime = 0,});
				if (_wstat64(string_to_wide(path), ((voidptr)(&swin))) != 0U) {
					os__eprintln_unknown_file_size();
					u64 _t3 = 0U;
					return _t3;
				}
				u64 _t4 = swin.st_size;
				return _t4;
			}
			#else
			{
			}
			#endif
		}
		#endif
		#if defined(TARGET_IS_32BIT)
		{
			#if defined(_WIN32)
			{
				if (_wstat(string_to_wide(path), ((voidptr)(&s))) != 0) {
					os__eprintln_unknown_file_size();
					u64 _t7 = 0U;
					return _t7;
				}
				u64 _t8 = ((u64)(s.st_size));
				return _t8;
			}
			#else
			{
			}
			#endif
		}
		#endif
	}
	u64 _t9 = 0U;
	return _t9;
}

_result_void os__rename_dir(string src, string dst) {
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, _SLIT("/"), _SLIT("\\"));
		string w_dst = string_replace(dst, _SLIT("/"), _SLIT("\\"));
		int ret = _wrename(string_to_wide(w_src), string_to_wide(w_dst));
		if (ret != 0) {
			return (_result_void){ .is_error=true, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("failed to rename "), /*115 &string*/0xfe10, {.d_s = src}}, {_SLIT(" to "), /*115 &string*/0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(ret))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

_result_void os__rename(string src, string dst) {
	string rdst = dst;
	if (os__is_dir(rdst)) {
		rdst = os__join_path_single(string_trim_right(rdst, _const_os__path_separator), os__file_name(string_trim_right(src, _const_os__path_separator)));
	}
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, _SLIT("/"), _SLIT("\\"));
		string w_dst = string_replace(rdst, _SLIT("/"), _SLIT("\\"));
		int ret = _wrename(string_to_wide(w_src), string_to_wide(w_dst));
		if (ret != 0) {
			return (_result_void){ .is_error=true, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("failed to rename "), /*115 &string*/0xfe10, {.d_s = src}}, {_SLIT(" to "), /*115 &string*/0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(ret))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

_result_void os__cp(string src, string dst) {
	#if defined(_WIN32)
	{
		string w_src = string_replace(src, _SLIT("/"), _SLIT("\\"));
		string w_dst = string_replace(dst, _SLIT("/"), _SLIT("\\"));
		if (CopyFile(string_to_wide(w_src), string_to_wide(w_dst), false) == 0) {
			u32 result = GetLastError();
			return (_result_void){ .is_error=true, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("failed to copy "), /*115 &string*/0xfe10, {.d_s = src}}, {_SLIT(" to "), /*115 &string*/0xfe10, {.d_s = dst}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(result))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

_result_FILE_ptr os__vfopen(string path, string mode) {
	if (path.len == 0) {
		return (_result_FILE_ptr){ .is_error=true, .err=_v_error(_SLIT("vfopen called with \"\"")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	voidptr fp = ((void*)0);
	#if defined(_WIN32)
	{
		fp = _wfopen(string_to_wide(path), string_to_wide(mode));
	}
	#else
	{
	}
	#endif
	if (isnil(fp)) {
		return (_result_FILE_ptr){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to open file \""), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	} else {
		_result_FILE_ptr _t4;
		_result_ok(&(FILE*[]) { fp }, (_result*)(&_t4), sizeof(FILE*));
		return _t4;
	}
	return (_result_FILE_ptr){0};
}

int os__fileno(voidptr cfile) {
	#if defined(_WIN32)
	{
		int _t2 = _fileno(cfile);
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL voidptr os__vpopen(string path) {
	#if defined(_WIN32)
	{
		string mode = _SLIT("rb");
		u16* wpath = string_to_wide(path);
		voidptr _t2 = _wpopen(wpath, string_to_wide(mode));
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL multi_return_int_bool os__posix_wait4_to_exit_status(int waitret) {
	#if defined(_WIN32)
	{
		return (multi_return_int_bool){.arg0=waitret, .arg1=false};
	}
	#else
	{
	}
	#endif
	return (multi_return_int_bool){0};
}

string os__posix_get_error_msg(int code) {
	char* ptr_text = strerror(code);
	if (ptr_text == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string _t2 = tos3(ptr_text);
	return _t2;
}

VV_LOCAL_SYMBOL int os__vpclose(voidptr f) {
	#if defined(_WIN32)
	{
		int _t2 = _pclose(f);
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

int os__system(string cmd) {
	int ret = 0;
	#if defined(_WIN32)
	{
		string wcmd = (cmd.len > 1 && string_at(cmd, 0) == '"' && string_at(cmd, 1) != '"' ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), /*115 &string*/0xfe10, {.d_s = cmd}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) : (cmd));
		flush_stdout();
		flush_stderr();
		{ // Unsafe block
			ret = _wsystem(string_to_wide(wcmd));
		}
	}
	#else
	{
	}
	#endif
	if (ret == -1) {
		os__print_c_errno();
	}
	return ret;
}

bool os__exists(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		bool _t2 = _waccess(string_to_wide(p), _const_os__f_ok) != -1;
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_executable(string path) {
	string p = os__real_path(path);
	bool _t1 = os__exists(p) && (string_ends_with(p, _SLIT(".exe")) || string_ends_with(p, _SLIT(".bat")) || string_ends_with(p, _SLIT(".cmd")));
	return _t1;
	bool _t2 = access(((char*)(path.str)), _const_os__x_ok) != -1;
	return _t2;
}

// Attr: [manualfree]
bool os__is_writable(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u16* wp = string_to_wide(p);
		bool res = _waccess(wp, _const_os__w_ok) != -1;
		_v_free(wp);
		string_free(&p);
		return res;
	}
	#else
	{
	}
	#endif
	return 0;
}

// Attr: [manualfree]
bool os__is_readable(string path) {
	#if defined(_WIN32)
	{
		string p = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u16* wp = string_to_wide(p);
		bool res = _waccess(wp, _const_os__r_ok) != -1;
		_v_free(wp);
		string_free(&p);
		return res;
	}
	#else
	{
	}
	#endif
	return 0;
}

_result_void os__rm(string path) {
	int rc = 0;
	#if defined(_WIN32)
	{
		rc = _wremove(string_to_wide(path));
	}
	#else
	{
	}
	#endif
	if (rc == -1) {
		return (_result_void){ .is_error=true, .err=_v_error(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to remove \""), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\": "), 0, { .d_c = 0 }}})), os__posix_get_error_msg(errno))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

_result_void os__rmdir(string path) {
	#if defined(_WIN32)
	{
		bool rc = RemoveDirectory(string_to_wide(path));
		if (!rc) {
			return (_result_void){ .is_error=true, .err=_v_error(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to remove \""), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\": "), 0, { .d_c = 0 }}})), os__posix_get_error_msg(errno))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

VV_LOCAL_SYMBOL void os__print_c_errno(void) {
	int e = errno;
	string se = tos_clone(((u8*)(strerror(e))));
	eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("errno="), /*100 &int*/0xfe07, {.d_i32 = e}}, {_SLIT(" err="), /*115 &string*/0xfe10, {.d_s = se}}, {_SLIT0, 0, { .d_c = 0 }}})));
}

string os__get_raw_line(void) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int max_line_chars = 256;
			u8* buf = malloc_noscan((int)(max_line_chars * 2));
			voidptr h_input = GetStdHandle(STD_INPUT_HANDLE);
			u32 bytes_read = ((u32)(0U));
			if (os__is_atty(0) > 0) {
				bool x = ReadConsole(h_input, buf, (int)(max_line_chars * 2), ((voidptr)(&bytes_read)), 0);
				if (!x) {
					string _t2 = tos(buf, 0);
					return _t2;
				}
				string _t3 = string_from_wide2(((u16*)(buf)), ((int)(bytes_read)));
				return _t3;
			}
			int offset = 0;
			for (;;) {
				u8* pos = buf + offset;
				bool res = ReadFile(h_input, pos, 1U, ((voidptr)(&bytes_read)), 0);
				if (!res && offset == 0) {
					string _t4 = tos(buf, 0);
					return _t4;
				}
				if (!res || bytes_read == 0U) {
					break;
				}
				if (*pos == '\n') {
					offset++;
					break;
				}
				offset++;
			}
			string _t5 = u8_vstring_with_len(buf, offset);
			return _t5;
		}
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

Array_u8 os__get_raw_stdin(void) {
	#if defined(_WIN32)
	{
		{ // Unsafe block
			int block_bytes = 512;
			int old_size = block_bytes;
			u8* buf = malloc_noscan(block_bytes);
			voidptr h_input = GetStdHandle(STD_INPUT_HANDLE);
			int bytes_read = 0;
			int offset = 0;
			for (;;) {
				u8* pos = buf + offset;
				bool res = ReadFile(h_input, pos, block_bytes, ((voidptr)(&bytes_read)), 0);
				offset += bytes_read;
				if (!res) {
					break;
				}
				int new_size = (int)((int)(offset + block_bytes) + ((int)(block_bytes - bytes_read)));
				buf = realloc_data(buf, old_size, new_size);
				old_size = new_size;
			}
			Array_u8 _t2 = ((array){.data = ((voidptr)(buf)),.offset = 0,.len = offset,.cap = offset,.flags = 0,.element_size = 1,});
			return _t2;
		}
	}
	#else
	{
	}
	#endif
	return __new_array_noscan(0, 0, sizeof(u8));
}

// Attr: [manualfree]
string os__executable(void) {
	bool os__executable_defer_0 = false;
	voidptr file;
	bool os__executable_defer_1 = false;
	string sret;
	Array_fixed_u8_8192 result = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	u16* pu16_result = ((u16*)(&result[0]));
	u32 len = GetModuleFileName(0, pu16_result, 512U);
	u32 attrs = GetFileAttributesW(pu16_result);
	u32 is_set = (attrs & 0x400U);
	if (is_set != 0U) {
		file = CreateFile(pu16_result, 0x80000000U, 1U, 0, 3U, 0x80U, 0);
		if (file != ((voidptr)(-1))) {
			os__executable_defer_0 = true;
			Array_fixed_u8_8192 final_path = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
			u32 final_len = GetFinalPathNameByHandleW(file, ((u16*)(&final_path[0])), _const_os__max_path_buffer_size, 0U);
			if (final_len < ((u32)(_const_os__max_path_buffer_size))) {
				sret = string_from_wide2(((u16*)(&final_path[0])), ((int)(final_len)));
				os__executable_defer_1 = true;
				string sret_slice = string_substr(sret, 4, 2147483647);
				string res = string_clone(sret_slice);
				string _t1 = res;
					// Defer begin
					if (os__executable_defer_1) {
						string_free(&sret);
					}
					// Defer end
					// Defer begin
					if (os__executable_defer_0) {
						CloseHandle(file);
					}
					// Defer end
				return _t1;
			} else {
				eprintln(_SLIT("os.executable() saw that the executable file path was too long"));
			}
		}
	}
	string res = string_from_wide2(pu16_result, ((int)(len)));
	string _t2 = res;
		// Defer begin
		if (os__executable_defer_1) {
			string_free(&sret);
		}
		// Defer end
		// Defer begin
		if (os__executable_defer_0) {
			CloseHandle(file);
		}
		// Defer end
	return _t2;
	string _t3 = os__executable_fallback();
		// Defer begin
		if (os__executable_defer_1) {
			string_free(&sret);
		}
		// Defer end
		// Defer begin
		if (os__executable_defer_0) {
			CloseHandle(file);
		}
		// Defer end
	return _t3;
}

bool os__is_dir(string path) {
	#if defined(_WIN32)
	{
		string w_path = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u32 attr = GetFileAttributesW(string_to_wide(w_path));
		if (attr == ((u32)(INVALID_FILE_ATTRIBUTES))) {
			bool _t2 = false;
			return _t2;
		}
		if ((((int)(attr)) & FILE_ATTRIBUTE_DIRECTORY) != 0) {
			bool _t3 = true;
			return _t3;
		}
		bool _t4 = false;
		return _t4;
	}
	#else
	{
	}
	#endif
	return 0;
}

bool os__is_link(string path) {
	#if defined(_WIN32)
	{
		string path_ = string_replace(path, _SLIT("/"), _SLIT("\\"));
		u32 attr = GetFileAttributesW(string_to_wide(path_));
		bool _t2 = ((int)(attr)) != ((int)(INVALID_FILE_ATTRIBUTES)) && ((attr & 0x400U)) != 0U;
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

VV_LOCAL_SYMBOL os__PathKind os__kind_of_existing_path(string path) {
	os__PathKind res = ((os__PathKind){.is_dir = 0,.is_link = 0,});
	#if defined(_WIN32)
	{
		u32 attr = GetFileAttributesW(string_to_wide(path));
		if (attr != ((u32)(INVALID_FILE_ATTRIBUTES))) {
			if (((((int)(attr)) & FILE_ATTRIBUTE_DIRECTORY)) != 0) {
				res.is_dir = true;
			}
			if (((((int)(attr)) & 0x400)) != 0) {
				res.is_link = true;
			}
		}
	}
	#else
	{
	}
	#endif
	return res;
}

_result_void os__chdir(string path) {
	int _t1;
	#if defined(_WIN32)
		_t1 = _wchdir(string_to_wide(path));
		;
	#else
	#endif
	int ret = _t1;
	if (ret == -1) {
		return (_result_void){ .is_error=true, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

// Attr: [manualfree]
string os__getwd(void) {
	{ // Unsafe block
		Array_fixed_u8_8192 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
		#if defined(_WIN32)
		{
			if (_wgetcwd(((u16*)(&buf[0])), _const_os__max_path_len) == 0) {
				string _t2 = _SLIT("");
				return _t2;
			}
			string res = string_from_wide(((u16*)(&buf[0])));
			return res;
		}
		#else
		{
		}
		#endif
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string os__real_path(string fpath) {
	bool os__real_path_defer_0 = false;
	u16* fpath_wide;
	bool os__real_path_defer_1 = false;
	voidptr file;
	Array_fixed_u8_8192 fullpath = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	string res = _SLIT("");
	#if defined(_WIN32)
	{
		u16* pu16_fullpath = ((u16*)(&fullpath[0]));
		fpath_wide = string_to_wide(fpath);
		os__real_path_defer_0 = true;
		file = CreateFile(fpath_wide, 0x80000000U, 1U, 0, 3U, 0x80U, 0);
		if (file != ((voidptr)(-1))) {
			os__real_path_defer_1 = true;
			u32 final_len = GetFinalPathNameByHandleW(file, pu16_fullpath, _const_os__max_path_buffer_size, 0U);
			if (final_len < ((u32)(_const_os__max_path_buffer_size))) {
				string rt = string_from_wide2(pu16_fullpath, ((int)(final_len)));
				string srt = string_substr(rt, 4, 2147483647);
				string_free(&res);
				res = string_clone(srt);
			} else {
				eprintln(_SLIT("os.real_path() saw that the file path was too long"));
				string_free(&res);
				string _t2 = string_clone(fpath);
					// Defer begin
					if (os__real_path_defer_1) {
						#if defined(_WIN32)
							CloseHandle(file);
						
						#endif
					}
					// Defer end
					// Defer begin
					if (os__real_path_defer_0) {
						#if defined(_WIN32)
							_v_free(((voidptr)(fpath_wide)));
						
						#endif
					}
					// Defer end
				return _t2;
			}
		} else {
			u32 ret = GetFullPathName(fpath_wide, _const_os__max_path_len, pu16_fullpath, 0);
			if (ret == 0U) {
				string_free(&res);
				string _t3 = string_clone(fpath);
					// Defer begin
					if (os__real_path_defer_1) {
						#if defined(_WIN32)
							CloseHandle(file);
						
						#endif
					}
					// Defer end
					// Defer begin
					if (os__real_path_defer_0) {
						#if defined(_WIN32)
							_v_free(((voidptr)(fpath_wide)));
						
						#endif
					}
					// Defer end
				return _t3;
			}
			string_free(&res);
			res = string_from_wide(pu16_fullpath);
		}
	}
	#else
	{
	}
	#endif
	os__normalize_drive_letter(res);
	string _t4 = res;
		// Defer begin
		if (os__real_path_defer_1) {
			#if defined(_WIN32)
				CloseHandle(file);
			
			#endif
		}
		// Defer end
		// Defer begin
		if (os__real_path_defer_0) {
			#if defined(_WIN32)
				_v_free(((voidptr)(fpath_wide)));
			
			#endif
		}
		// Defer end
	return _t4;
}

// Attr: [direct_array_access]
// Attr: [manualfree]
// Attr: [unsafe]
VV_LOCAL_SYMBOL void os__normalize_drive_letter(string path) {
	if (path.len > 2 && path.str[ 0] >= 'a' && path.str[ 0] <= 'z' && path.str[ 1] == ':' && path.str[ 2] == _const_os__path_separator.str[ 0]) {
		{ // Unsafe block
			u8* x = &path.str[0];
			*x = (u8)(*x - 32);
		}
	}
}

int os__fork(void) {
	int pid = -1;
	_v_panic(_SLIT("os.fork not supported in windows"));
	VUNREACHABLE();
	return pid;
}

int os__wait(void) {
	int pid = -1;
	_v_panic(_SLIT("os.wait not supported in windows"));
	VUNREACHABLE();
	return pid;
}

i64 os__file_last_mod_unix(string path) {
	struct stat attr;
	stat(((char*)(path.str)), &attr);
	i64 _t1 = ((i64)(attr.st_mtime));
	return _t1;
}

void os__flush(void) {
	fflush(stdout);
}

_result_void os__chmod(string path, int mode) {
	if (chmod(((char*)(path.str)), mode) != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(string__plus(_SLIT("chmod failed: "), os__posix_get_error_msg(errno)), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

_result_void os__chown(string path, int owner, int group) {
	#if defined(_WIN32)
	{
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("os.chown() not implemented for Windows")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

_result_os__File os__open_append(string path) {
	os__File file = ((os__File){.cfile = 0,.fd = 0,.is_opened = 0,});
	#if defined(_WIN32)
	{
		u16* wpath = string_to_wide(string_replace(path, _SLIT("/"), _SLIT("\\")));
		string mode = _SLIT("ab");
		file = ((os__File){.cfile = _wfopen(wpath, string_to_wide(mode)),.fd = 0,.is_opened = 0,});
	}
	#else
	{
	}
	#endif
	if (isnil(file.cfile)) {
		return (_result_os__File){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to create(append) file \""), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	file.is_opened = true;
	_result_os__File _t3;
	_result_ok(&(os__File[]) { file }, (_result*)(&_t3), sizeof(os__File));
	return _t3;
}

_result_void os__execvp(string cmdpath, Array_string cmdargs) {
	Array_char_ptr cargs = __new_array_with_default(0, 0, sizeof(char*), 0);
	array_push((array*)&cargs, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < cmdargs.len; ++i) {
		array_push((array*)&cargs, _MOV((char*[]){ ((char*)((*(string*)array_get(cmdargs, i)).str)) }));
	}
	array_push((array*)&cargs, _MOV((char*[]){ ((char*)(0)) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
		res = _execvp(((char*)(cmdpath.str)), cargs.data);
	}
	#else
	{
	}
	#endif
	if (res == -1) {
		return (_result_void){ .is_error=true, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_v_exit(res);
	VUNREACHABLE();
	return (_result_void){0};
}

_result_void os__execve(string cmdpath, Array_string cmdargs, Array_string envs) {
	Array_char_ptr cargv = __new_array_with_default(0, 0, sizeof(char*), 0);
	Array_char_ptr cenvs = __new_array_with_default(0, 0, sizeof(char*), 0);
	array_push((array*)&cargv, _MOV((char*[]){ ((char*)(cmdpath.str)) }));
	for (int i = 0; i < cmdargs.len; ++i) {
		array_push((array*)&cargv, _MOV((char*[]){ ((char*)((*(string*)array_get(cmdargs, i)).str)) }));
	}
	for (int i = 0; i < envs.len; ++i) {
		array_push((array*)&cenvs, _MOV((char*[]){ ((char*)((*(string*)array_get(envs, i)).str)) }));
	}
	array_push((array*)&cargv, _MOV((char*[]){ ((char*)(0)) }));
	array_push((array*)&cenvs, _MOV((char*[]){ ((char*)(0)) }));
	int res = ((int)(0));
	#if defined(_WIN32)
	{
		res = _execve(((char*)(cmdpath.str)), cargv.data, cenvs.data);
	}
	#else
	{
	}
	#endif
	if (res == -1) {
		return (_result_void){ .is_error=true, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

int os__is_atty(int fd) {
	#if defined(_WIN32)
	{
		u32 mode = ((u32)(0U));
		voidptr osfh = ((voidptr)(_get_osfhandle(fd)));
		GetConsoleMode(osfh, ((voidptr)(&mode)));
		int _t2 = ((int)(mode));
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

_result_void os__write_file_array(string path, array buffer) {
	_result_os__File _t1 = os__create(path);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	os__File f =  (*(os__File*)_t1.data);
		_result_void _t3 = os__File_write_full_buffer(&f, buffer.data, ((usize)((int)(buffer.len * buffer.element_size))));
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (_result_void){0};
}

_result_Array_string os__glob(Array_string patterns) {
	Array_string matches = __new_array_with_default(0, 0, sizeof(string), 0);
	for (int _t1 = 0; _t1 < patterns.len; ++_t1) {
		string pattern = ((string*)patterns.data)[_t1];
		_result_void _t2 = os__native_glob_pattern(pattern, &/*arr*/matches);
		if (_t2.is_error) {
			_result_Array_string _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
	}
	qsort(matches.data, matches.len, matches.element_size, (int (*)(const void *, const void *))&compare_7820091384837918046_string);
	_result_Array_string _t4;
	_result_ok(&(Array_string[]) { matches }, (_result*)(&_t4), sizeof(Array_string));
	return _t4;
}

IError os__last_error(void) {
	#if defined(_WIN32)
	{
		int code = ((int)(GetLastError()));
		string msg = os__get_error_msg(code);
		IError _t2 = error_with_code(msg, code);
		return _t2;
	}
	#else
	{
	}
	#endif
	return (IError){0};
}

// Attr: [unsafe]
void os__Result_free(os__Result* result) {
	string_free(&result->output);
}

VV_LOCAL_SYMBOL string os__executable_fallback(void) {
	if (_const_os__args.len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string exepath = (*(string*)array_get(_const_os__args, 0));
	if (!string_contains(exepath, _SLIT(".exe"))) {
		exepath = string__plus(exepath, _SLIT(".exe"));
	}
	if (!os__is_abs_path(exepath)) {
		string other_separator = (string__eq(_const_os__path_separator, _SLIT("/")) ? (_SLIT("\\")) : (_SLIT("/")));
		string rexepath = string_replace(exepath, other_separator, _const_os__path_separator);
		if (string_contains(rexepath, _const_os__path_separator)) {
			exepath = os__join_path_single(_const_os__wd_at_startup, exepath);
		} else {
			_result_string _t2 = os__find_abs_path_of_executable(exepath);
			if (_t2.is_error) {
				IError err = _t2.err;
				*(string*) _t2.data = _SLIT("");
			}
			
 			string foundpath =  (*(string*)_t2.data);
			if (foundpath.len > 0) {
				exepath = foundpath;
			}
		}
	}
	exepath = os__real_path(exepath);
	return exepath;
}

_result_void os__cp_all(string src, string dst, bool overwrite) {
	string source_path = os__real_path(src);
	string dest_path = os__real_path(dst);
	if (!os__exists(source_path)) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("Source path doesn't exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__is_dir(source_path)) {
		string fname = os__file_name(source_path);
		string adjusted_path = (os__is_dir(dest_path) ? (os__join_path_single(dest_path, fname)) : (dest_path));
		if (os__exists(adjusted_path)) {
			if (overwrite) {
				_result_void _t2 = os__rm(adjusted_path);
				if (_t2.is_error) {
					_result_void _t3;
					memcpy(&_t3, &_t2, sizeof(_result));
					return _t3;
				}
				
 ;
			} else {
				return (_result_void){ .is_error=true, .err=_v_error(_SLIT("Destination file path already exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		_result_void _t5 = os__cp(source_path, adjusted_path);
		if (_t5.is_error) {
			_result_void _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
		return (_result_void){0};
	}
	if (!os__exists(dest_path)) {
		_result_void _t7 = os__mkdir(dest_path, ((os__MkdirParams){.mode = 0777,}));
		if (_t7.is_error) {
			_result_void _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 ;
	}
	if (!os__is_dir(dest_path)) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("Destination path is not a valid directory")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_Array_string _t10 = os__ls(source_path);
	if (_t10.is_error) {
		_result_void _t11;
		memcpy(&_t11, &_t10, sizeof(_result));
		return _t11;
	}
	
 	Array_string files =  (*(Array_string*)_t10.data);
	for (int _t12 = 0; _t12 < files.len; ++_t12) {
		string file = ((string*)files.data)[_t12];
		string sp = os__join_path_single(source_path, file);
		string dp = os__join_path_single(dest_path, file);
		if (os__is_dir(sp)) {
			if (!os__exists(dp)) {
				_result_void _t13 = os__mkdir(dp, ((os__MkdirParams){.mode = 0777,}));
				if (_t13.is_error) {
					_result_void _t14;
					memcpy(&_t14, &_t13, sizeof(_result));
					return _t14;
				}
				
 ;
			}
		}
		_result_void _t15 = os__cp_all(sp, dp, overwrite);
		if (_t15.is_error) {
			IError err = _t15.err;
			_result_void _t16 = os__rmdir(dp);
			if (_t16.is_error) {
				IError err = _t16.err;
				return (_result_void){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 ;
			return (_result_void){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 ;
	}
	return (_result_void){0};
}

_result_void os__mv_by_cp(string source, string target) {
	_result_void _t1 = os__cp(source, target);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_void _t3 = os__rm(source);
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	return (_result_void){0};
}

_result_void os__mv(string source, string target) {
	_result_void _t1 = os__rename(source, target);
	if (_t1.is_error) {
		IError err = _t1.err;
		_result_void _t2 = os__mv_by_cp(source, target);
		if (_t2.is_error) {
			_result_void _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
	;
	}
	
 ;
	return (_result_void){0};
}

// Attr: [manualfree]
_result_Array_string os__read_lines(string path) {
	_result_string _t1 = os__read_file(path);
	if (_t1.is_error) {
		_result_Array_string _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string buf =  (*(string*)_t1.data);
	Array_string res = string_split_into_lines(buf);
	string_free(&buf);
	_result_Array_string _t3;
	_result_ok(&(Array_string[]) { res }, (_result*)(&_t3), sizeof(Array_string));
	return _t3;
}

string os__sigint_to_signal_name(int si) {
	switch (si) {
		case 1: {
				string _t1 = _SLIT("SIGHUP");
				return _t1;
		}
		case 2: {
				string _t2 = _SLIT("SIGINT");
				return _t2;
		}
		case 3: {
				string _t3 = _SLIT("SIGQUIT");
				return _t3;
		}
		case 4: {
				string _t4 = _SLIT("SIGILL");
				return _t4;
		}
		case 6: {
				string _t5 = _SLIT("SIGABRT");
				return _t5;
		}
		case 8: {
				string _t6 = _SLIT("SIGFPE");
				return _t6;
		}
		case 9: {
				string _t7 = _SLIT("SIGKILL");
				return _t7;
		}
		case 11: {
				string _t8 = _SLIT("SIGSEGV");
				return _t8;
		}
		case 13: {
				string _t9 = _SLIT("SIGPIPE");
				return _t9;
		}
		case 14: {
				string _t10 = _SLIT("SIGALRM");
				return _t10;
		}
		case 15: {
				string _t11 = _SLIT("SIGTERM");
				return _t11;
		}
		default: {
				break;
		}
	}
	
	string _t12 = _SLIT("unknown");
	return _t12;
}

_result_void os__rmdir_all(string path) {
	string ret_err = _SLIT("");
	_result_Array_string _t1 = os__ls(path);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	Array_string items =  (*(Array_string*)_t1.data);
	for (int _t3 = 0; _t3 < items.len; ++_t3) {
		string item = ((string*)items.data)[_t3];
		string fullpath = os__join_path_single(path, item);
		if (os__is_dir(fullpath) && !os__is_link(fullpath)) {
			_result_void _t4 = os__rmdir_all(fullpath);
			if (_t4.is_error) {
				IError err = _t4.err;
				ret_err = IError_name_table[err._typ]._method_msg(err._object);
			}
			
 ;
		} else {
			_result_void _t5 = os__rm(fullpath);
			if (_t5.is_error) {
				IError err = _t5.err;
				ret_err = IError_name_table[err._typ]._method_msg(err._object);
			}
			
 ;
		}
	}
	_result_void _t6 = os__rmdir(path);
	if (_t6.is_error) {
		IError err = _t6.err;
		ret_err = IError_name_table[err._typ]._method_msg(err._object);
	}
	
 ;
	if (ret_err.len > 0) {
		return (_result_void){ .is_error=true, .err=_v_error(ret_err), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

// Attr: [manualfree]
bool os__is_dir_empty(string path) {
	_result_Array_string _t1 = os__ls(path);
	if (_t1.is_error) {
		IError err = _t1.err;
		bool _t2 = true;
		return _t2;
	}
	
 	Array_string items =  (*(Array_string*)_t1.data);
	bool res = items.len == 0;
	array_free(&items);
	return res;
}

string os__file_ext(string opath) {
	if (opath.len < 3) {
		string _t1 = _SLIT("");
		return _t1;
	}
	string path = os__file_name(opath);
	int pos = string_index_u8_last(path, '.');
	if (pos == -1) {
		string _t2 = _SLIT("");
		return _t2;
	}
	if ((int)(pos + 1) >= path.len || pos == 0) {
		string _t3 = _SLIT("");
		return _t3;
	}
	string _t4 = string_substr(path, pos, 2147483647);
	return _t4;
}

string os__dir(string opath) {
	if ((opath).len == 0) {
		string _t1 = _SLIT(".");
		return _t1;
	}
	string other_separator = (string__eq(_const_os__path_separator, _SLIT("/")) ? (_SLIT("\\")) : (_SLIT("/")));
	string path = string_replace(opath, other_separator, _const_os__path_separator);
	_option_int _t2 = string_index_last(path, _const_os__path_separator);
	if (_t2.state != 0) {
		IError err = _t2.err;
		string _t3 = _SLIT(".");
		return _t3;
	}
	
 	int pos =  (*(int*)_t2.data);
	if (pos == 0 && string__eq(_const_os__path_separator, _SLIT("/"))) {
		string _t4 = _SLIT("/");
		return _t4;
	}
	string _t5 = string_substr(path, 0, pos);
	return _t5;
}

string os__base(string opath) {
	if ((opath).len == 0) {
		string _t1 = _SLIT(".");
		return _t1;
	}
	string other_separator = (string__eq(_const_os__path_separator, _SLIT("/")) ? (_SLIT("\\")) : (_SLIT("/")));
	string path = string_replace(opath, other_separator, _const_os__path_separator);
	if (string__eq(path, _const_os__path_separator)) {
		return _const_os__path_separator;
	}
	if (string_ends_with(path, _const_os__path_separator)) {
		string path2 = string_substr(path, 0, (int)(path.len - 1));
		_option_int _t3 = string_index_last(path2, _const_os__path_separator);
		if (_t3.state != 0) {
			IError err = _t3.err;
			string _t4 = string_clone(path2);
			return _t4;
		}
		
 		int pos =  (*(int*)_t3.data);
		string _t5 = string_substr(path2, (int)(pos + 1), 2147483647);
		return _t5;
	}
	_option_int _t6 = string_index_last(path, _const_os__path_separator);
	if (_t6.state != 0) {
		IError err = _t6.err;
		string _t7 = string_clone(path);
		return _t7;
	}
	
 	int pos =  (*(int*)_t6.data);
	string _t8 = string_substr(path, (int)(pos + 1), 2147483647);
	return _t8;
}

string os__file_name(string opath) {
	string other_separator = (string__eq(_const_os__path_separator, _SLIT("/")) ? (_SLIT("\\")) : (_SLIT("/")));
	string path = string_replace(opath, other_separator, _const_os__path_separator);
	string _t1 = string_all_after_last(path, _const_os__path_separator);
	return _t1;
}

_option_string os__input_opt(string prompt) {
	print(prompt);
	os__flush();
	string res = os__get_raw_line();
	if (res.len > 0) {
		_option_string _t1;
		_option_ok(&(string[]) { string_trim_right(res, _SLIT("\r\n")) }, (_option*)(&_t1), sizeof(string));
		return _t1;
	}
	return (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

string os__input(string prompt) {
	_option_string _t1 = os__input_opt(prompt);
	if (_t1.state != 0) {
		IError err = _t1.err;
		string _t2 = _SLIT("<EOF>");
		return _t2;
	}
	
 	string res =  (*(string*)_t1.data);
	return res;
}

string os__get_line(void) {
	string str = os__get_raw_line();
	string _t1 = string_trim_right(str, _SLIT("\r\n"));
	return _t1;
	string _t2 = string_trim_right(str, _SLIT("\n"));
	return _t2;
}

Array_string os__get_lines(void) {
	string line = _SLIT("");
	Array_string inputstr = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		array_push((array*)&inputstr, _MOV((string[]){ string_clone(line) }));
	}
	return inputstr;
}

string os__get_lines_joined(void) {
	string line = _SLIT("");
	string inputstr = _SLIT("");
	for (;;) {
		line = os__get_line();
		if (line.len <= 0) {
			break;
		}
		line = string_trim_space(line);
		inputstr = string__plus(inputstr, line);
	}
	return inputstr;
}

string os__get_raw_lines_joined(void) {
	string line = _SLIT("");
	Array_string lines = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		line = os__get_raw_line();
		if (line.len <= 0) {
			break;
		}
		array_push((array*)&lines, _MOV((string[]){ string_clone(line) }));
	}
	string res = Array_string_join(lines, _SLIT(""));
	return res;
}

string os__user_os(void) {
	string _t1 = _SLIT("windows");
	return _t1;
	if ((os__getenv(_SLIT("TERMUX_VERSION"))).len != 0) {
		string _t2 = _SLIT("termux");
		return _t2;
	}
	string _t3 = _SLIT("unknown");
	return _t3;
}

_result_Array_string os__user_names(void) {
	#if defined(_WIN32)
	{
		os__Result result = os__execute(_SLIT("wmic useraccount get name"));
		if (result.exit_code != 0) {
			return (_result_Array_string){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Failed to get user names. Exited with code "), /*100 &int*/0xfe07, {.d_i32 = result.exit_code}}, {_SLIT(": "), /*115 &string*/0xfe10, {.d_s = result.output}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		Array_string users = string_split_into_lines(result.output);
		array_delete(&users, (int)(users.len - 1));
		_result_Array_string _t3;
		_result_ok(&(Array_string[]) { users }, (_result*)(&_t3), sizeof(Array_string));
		return _t3;
	}
	#else
	{
	}
	#endif
	return (_result_Array_string){0};
}

string os__home_dir(void) {
	#if defined(_WIN32)
	{
		string _t2 = os__getenv(_SLIT("USERPROFILE"));
		return _t2;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

string os__expand_tilde_to_home(string path) {
	if (string__eq(path, _SLIT("~"))) {
		string _t1 = string_trim_right(os__home_dir(), _const_os__path_separator);
		return _t1;
	}
	if (string_starts_with(path, string__plus(_SLIT("~"), _const_os__path_separator))) {
		string _t2 = string_replace_once(path, string__plus(_SLIT("~"), _const_os__path_separator), string__plus(string_trim_right(os__home_dir(), _const_os__path_separator), _const_os__path_separator));
		return _t2;
	}
	return path;
}

_result_void os__write_file(string path, string text) {
	_result_os__File _t1 = os__create(path);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	os__File f =  (*(os__File*)_t1.data);
		_result_void _t3 = os__File_write_full_buffer(&f, text.str, ((usize)(text.len)));
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	os__File_close(&f);
	return (_result_void){0};
}

string os__ExecutableNotFoundError_msg(os__ExecutableNotFoundError err) {
	string _t1 = _SLIT("os: failed to find executable");
	return _t1;
}

VV_LOCAL_SYMBOL IError os__error_failed_to_find_executable(void) {
	IError _t1 = /*&IError*/I_os__ExecutableNotFoundError_to_Interface_IError(((os__ExecutableNotFoundError*)memdup(&(os__ExecutableNotFoundError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(os__ExecutableNotFoundError))));
	return _t1;
}

_result_string os__find_abs_path_of_executable(string exepath) {
	if ((exepath).len == 0) {
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("expected non empty `exepath`")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	for (int _t2 = 0; _t2 < _const_os__executable_suffixes.len; ++_t2) {
		string suffix = ((string*)_const_os__executable_suffixes.data)[_t2];
		string fexepath = string__plus(exepath, suffix);
		if (os__is_abs_path(fexepath)) {
			_result_string _t3;
			_result_ok(&(string[]) { os__real_path(fexepath) }, (_result*)(&_t3), sizeof(string));
			return _t3;
		}
		string res = _SLIT("");
		string path = os__getenv(_SLIT("PATH"));
		Array_string paths = string_split(path, _const_os__path_delimiter);
		for (int _t4 = 0; _t4 < paths.len; ++_t4) {
			string p = ((string*)paths.data)[_t4];
			string found_abs_path = os__join_path_single(p, fexepath);
			if (os__exists(found_abs_path) && os__is_executable(found_abs_path)) {
				res = found_abs_path;
				break;
			}
		}
		if (res.len > 0) {
			_result_string _t5;
			_result_ok(&(string[]) { os__real_path(res) }, (_result*)(&_t5), sizeof(string));
			return _t5;
		}
	}
	return (_result_string){ .is_error=true, .err=os__error_failed_to_find_executable(), .data={EMPTY_STRUCT_INITIALIZATION} };
}

bool os__exists_in_system_path(string prog) {
	_result_string _t1 = os__find_abs_path_of_executable(prog);
	if (_t1.is_error) {
		IError err = _t1.err;
		bool _t2 = false;
		return _t2;
	}
	
  (*(string*)_t1.data);
	bool _t3 = true;
	return _t3;
}

bool os__is_file(string path) {
	bool _t1 = os__exists(path) && !os__is_dir(path);
	return _t1;
}

// Attr: [manualfree]
string os__join_path(string base, Array_string dirs) {
	bool os__join_path_defer_0 = false;
	strings__Builder sb;
	bool os__join_path_defer_1 = false;
	string sbase;
	sb = strings__new_builder((int)(base.len + (int)(dirs.len * 50)));
	os__join_path_defer_0 = true;
	sbase = string_trim_right(base, _SLIT("\\/"));
	os__join_path_defer_1 = true;
	strings__Builder_write_string(&sb, sbase);
	for (int _t1 = 0; _t1 < dirs.len; ++_t1) {
		string d = ((string*)dirs.data)[_t1];
		if ((d).len != 0) {
			strings__Builder_write_string(&sb, _const_os__path_separator);
			strings__Builder_write_string(&sb, d);
		}
	}
	string res = strings__Builder_str(&sb);
	if ((sbase).len == 0) {
		res = string_trim_left(res, _const_os__path_separator);
	}
	if (string_contains(res, _SLIT("/./"))) {
		res = string_replace(res, _SLIT("/./"), _SLIT("/"));
	}
	string _t2 = res;
		// Defer begin
		if (os__join_path_defer_1) {
			string_free(&sbase);
		}
		// Defer end
		// Defer begin
		if (os__join_path_defer_0) {
			strings__Builder_free(&sb);
		}
		// Defer end
	return _t2;
}

// Attr: [manualfree]
string os__join_path_single(string base, string elem) {
	bool os__join_path_single_defer_0 = false;
	strings__Builder sb;
	bool os__join_path_single_defer_1 = false;
	string sbase;
	sb = strings__new_builder((int)((int)(base.len + elem.len) + 1));
	os__join_path_single_defer_0 = true;
	sbase = string_trim_right(base, _SLIT("\\/"));
	os__join_path_single_defer_1 = true;
	if ((base).len != 0) {
		strings__Builder_write_string(&sb, sbase);
		strings__Builder_write_string(&sb, _const_os__path_separator);
	}
	strings__Builder_write_string(&sb, elem);
	string _t1 = strings__Builder_str(&sb);
		// Defer begin
		if (os__join_path_single_defer_1) {
			string_free(&sbase);
		}
		// Defer end
		// Defer begin
		if (os__join_path_single_defer_0) {
			strings__Builder_free(&sb);
		}
		// Defer end
	return _t1;
}

Array_string os__walk_ext(string path, string ext) {
	Array_string res = __new_array_with_default(0, 0, sizeof(string), 0);
	os__impl_walk_ext(path, ext, &/*arr*/res);
	return res;
}

VV_LOCAL_SYMBOL void os__impl_walk_ext(string path, string ext, Array_string* out) {
	if (!os__is_dir(path)) {
		return;
	}
	_result_Array_string _t1 = os__ls(path);
	if (_t1.is_error) {
		IError err = _t1.err;
		return;
	}
	
 	Array_string files =  (*(Array_string*)_t1.data);
	string separator = (string_ends_with(path, _const_os__path_separator) ? (_SLIT("")) : (_const_os__path_separator));
	for (int _t2 = 0; _t2 < files.len; ++_t2) {
		string file = ((string*)files.data)[_t2];
		if (string_starts_with(file, _SLIT("."))) {
			continue;
		}
		string p = string__plus(string__plus(path, separator), file);
		if (os__is_dir(p) && !os__is_link(p)) {
			os__impl_walk_ext(p, ext, out);
		} else if (string_ends_with(file, ext)) {
			array_push((array*)out, _MOV((string[]){ string_clone(p) }));
		}
	}
}

void os__walk(string path, void (*f)(string )) {
	if (path.len == 0) {
		return;
	}
	if (!os__is_dir(path)) {
		return;
	}
	Array_string remaining = __new_array_with_default(0, 1000, sizeof(string), 0);
	string clean_path = string_trim_right(path, _const_os__path_separator);
	#if defined(_WIN32)
	{
		array_push((array*)&remaining, _MOV((string[]){ string_clone(string_replace(clean_path, _SLIT("/"), _SLIT("\\"))) }));
	}
	#else
	{
	}
	#endif
	for (;;) {
		if (!(remaining.len > 0)) break;
		string cpath = (*(string*)array_pop(&remaining));
		os__PathKind pkind = os__kind_of_existing_path(cpath);
		if (pkind.is_link || !pkind.is_dir) {
			f(cpath);
			continue;
		}
		_result_Array_string _t3 = os__ls(cpath);
		if (_t3.is_error) {
			IError err = _t3.err;
			continue;
		}
		
 		Array_string files =  (*(Array_string*)_t3.data);
		for (int idx = (int)(files.len - 1); idx >= 0; idx--) {
			array_push((array*)&remaining, _MOV((string[]){ string_clone(string__plus(string__plus(cpath, _const_os__path_separator), (*(string*)array_get(files, idx)))) }));
		}
	}
}

// TypeDecl
void os__walk_with_context(string path, voidptr context, void (*fcb)(voidptr , string )) {
	if (path.len == 0) {
		return;
	}
	if (!os__is_dir(path)) {
		return;
	}
	Array_string remaining = __new_array_with_default(0, 1000, sizeof(string), 0);
	string clean_path = string_trim_right(path, _const_os__path_separator);
	#if defined(_WIN32)
	{
		array_push((array*)&remaining, _MOV((string[]){ string_clone(string_replace(clean_path, _SLIT("/"), _SLIT("\\"))) }));
	}
	#else
	{
	}
	#endif
	int loops = 0;
	for (;;) {
		if (!(remaining.len > 0)) break;
		loops++;
		string cpath = (*(string*)array_pop(&remaining));
		if (loops > 1) {
			fcb(context, cpath);
		}
		os__PathKind pkind = os__kind_of_existing_path(cpath);
		if (pkind.is_link || !pkind.is_dir) {
			continue;
		}
		_result_Array_string _t3 = os__ls(cpath);
		if (_t3.is_error) {
			IError err = _t3.err;
			continue;
		}
		
 		Array_string files =  (*(Array_string*)_t3.data);
		for (int idx = (int)(files.len - 1); idx >= 0; idx--) {
			array_push((array*)&remaining, _MOV((string[]){ string_clone(string__plus(string__plus(cpath, _const_os__path_separator), (*(string*)array_get(files, idx)))) }));
		}
	}
}

void os__log(string s) {
	println(string__plus(_SLIT("os.log: "), s));
}

_result_void os__mkdir_all(string opath, os__MkdirParams params) {
	if (os__exists(opath)) {
		if (os__is_dir(opath)) {
			return (_result_void){0};
		}
		return (_result_void){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("path `"), /*115 &string*/0xfe10, {.d_s = opath}}, {_SLIT("` already exists, and is not a folder"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string other_separator = (string__eq(_const_os__path_separator, _SLIT("/")) ? (_SLIT("\\")) : (_SLIT("/")));
	string path = string_replace(opath, other_separator, _const_os__path_separator);
	string p = (string_starts_with(path, _const_os__path_separator) ? (_const_os__path_separator) : (_SLIT("")));
	Array_string path_parts = string_split(string_trim_left(path, _const_os__path_separator), _const_os__path_separator);
	for (int _t2 = 0; _t2 < path_parts.len; ++_t2) {
		string subdir = ((string*)path_parts.data)[_t2];
		p = string__plus(p, string__plus(subdir, _const_os__path_separator));
		if (os__exists(p) && os__is_dir(p)) {
			continue;
		}
		_result_void _t3 = os__mkdir(p, params);
		if (_t3.is_error) {
			IError err = _t3.err;
			return (_result_void){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("folder: "), /*115 &string*/0xfe10, {.d_s = p}}, {_SLIT(", error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 ;
	}
	return (_result_void){0};
}

string os__cache_dir(void) {
	string xdg_cache_home = os__getenv(_SLIT("XDG_CACHE_HOME"));
	if ((xdg_cache_home).len != 0) {
		if (!os__is_dir(xdg_cache_home) && !os__is_link(xdg_cache_home)) {
			_result_void _t1 = os__mkdir_all(xdg_cache_home, ((os__MkdirParams){.mode = 0700U,}));
			if (_t1.is_error) {
				IError err = _t1.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			
 ;
		}
		return xdg_cache_home;
	}
	string cdir = os__join_path_single(os__home_dir(), _SLIT(".cache"));
	if (!os__is_dir(cdir) && !os__is_link(cdir)) {
		_result_void _t3 = os__mkdir(cdir, ((os__MkdirParams){.mode = 0777,}));
		if (_t3.is_error) {
			IError err = _t3.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
	}
	return cdir;
}

string os__temp_dir(void) {
	string path = os__getenv(_SLIT("TMPDIR"));
	if ((path).len == 0) {
		path = os__getenv(_SLIT("TEMP"));
		if ((path).len == 0) {
			path = os__getenv(_SLIT("TMP"));
		}
		if ((path).len == 0) {
			path = _SLIT("C:/tmp");
		}
	}
	_result_string _t1 = os__get_long_path(path);
	if (_t1.is_error) {
		IError err = _t1.err;
		*(string*) _t1.data = path;
	}
	
 	path =  (*(string*)_t1.data);
	if ((path).len == 0) {
		path = _SLIT("/tmp");
	}
	return path;
}

string os__vtmp_dir(void) {
	string vtmp = os__getenv(_SLIT("VTMP"));
	if (vtmp.len > 0) {
		return vtmp;
	}
	int uid = os__getuid();
	vtmp = os__join_path_single(os__temp_dir(),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("v_"), /*100 &int*/0xfe07, {.d_i32 = uid}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (!os__exists(vtmp) || !os__is_dir(vtmp)) {
		_result_void _t2 = os__mkdir_all(vtmp, ((os__MkdirParams){.mode = 0700U,}));
		if (_t2.is_error) {
			IError err = _t2.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
 ;
	}
	os__setenv(_SLIT("VTMP"), vtmp, true);
	return vtmp;
}

VV_LOCAL_SYMBOL string os__default_vmodules_path(void) {
	string hdir = os__home_dir();
	string res = os__join_path_single(hdir, _SLIT(".vmodules"));
	return res;
}

string os__vmodules_dir(void) {
	Array_string paths = os__vmodules_paths();
	if (paths.len > 0) {
		string _t1 = (*(string*)array_get(paths, 0));
		return _t1;
	}
	string _t2 = os__default_vmodules_path();
	return _t2;
}

Array_string os__vmodules_paths(void) {
	bool os__vmodules_paths_defer_0 = false;
	bool os__vmodules_paths_defer_1 = false;
	string path = os__getenv(_SLIT("VMODULES"));
	if ((path).len == 0) {
		path = os__default_vmodules_path();
	}
	os__vmodules_paths_defer_0 = true;
	Array_string splitted = string_split(path, _const_os__path_delimiter);
	os__vmodules_paths_defer_1 = true;
	Array_string list = __new_array_with_default(0, splitted.len, sizeof(string), 0);
	for (int i = 0; i < splitted.len; ++i) {
		string si = (*(string*)array_get(splitted, i));
		string trimmed = string_trim_right(si, _const_os__path_separator);
		array_push((array*)&list, _MOV((string[]){ string_clone(trimmed) }));
	}
	Array_string _t2 = list;
		// Defer begin
		if (os__vmodules_paths_defer_1) {
		}
		// Defer end
		// Defer begin
		if (os__vmodules_paths_defer_0) {
		}
		// Defer end
	return _t2;
}

// Attr: [manualfree]
string os__resource_abs_path(string path) {
	string exe = os__executable();
	string dexe = os__dir(exe);
	string base_path = os__real_path(dexe);
	string vresource = os__getenv(_SLIT("V_RESOURCE_PATH"));
	if (vresource.len != 0) {
		string_free(&base_path);
		base_path = vresource;
	}
	string fp = os__join_path_single(base_path, path);
	string res = os__real_path(fp);
	{ // Unsafe block
		string_free(&fp);
		string_free(&vresource);
		string_free(&base_path);
		string_free(&dexe);
		string_free(&exe);
	}
	return res;
}

os__Result os__execute_or_panic(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed    cmd: "), /*115 &string*/0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed   code: "), /*100 &int*/0xfe07, {.d_i32 = res.exit_code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		_v_panic(res.output);
		VUNREACHABLE();
	}
	return res;
}

os__Result os__execute_or_exit(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed    cmd: "), /*115 &string*/0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed   code: "), /*100 &int*/0xfe07, {.d_i32 = res.exit_code}}, {_SLIT0, 0, { .d_c = 0 }}})));
		eprintln(res.output);
		_v_exit(1);
		VUNREACHABLE();
	}
	return res;
}

_result_os__Result os__execute_opt(string cmd) {
	os__Result res = os__execute(cmd);
	if (res.exit_code != 0) {
		return (_result_os__Result){ .is_error=true, .err=_v_error(res.output), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_os__Result _t2;
	_result_ok(&(os__Result[]) { res }, (_result*)(&_t2), sizeof(os__Result));
	return _t2;
}

string os__quoted_path(string path) {
	#if defined(_WIN32)
	{
		string _t2 = (string_ends_with(path, _const_os__path_separator) ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), /*115 &string*/0xfe10, {.d_s = string__plus(path, _const_os__path_separator)}}, {_SLIT("\""), 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\""), 0, { .d_c = 0 }}}))));
		return _t2;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

_result_string os__config_dir(void) {
	#if defined(_WIN32)
	{
		string app_data = os__getenv(_SLIT("AppData"));
		if ((app_data).len != 0) {
			_result_string _t2;
			_result_ok(&(string[]) { app_data }, (_result*)(&_t2), sizeof(string));
			return _t2;
		}
	}
	#elif defined(__APPLE__) || defined(__DARWIN__) || defined(__TARGET_IOS__)
	{
	}
	#else
	{
	}
	#endif
	return (_result_string){ .is_error=true, .err=_v_error(_SLIT("Cannot find config directory")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL Array_string os__init_os_args_wide(int argc, u8** argv) {
	Array_string args_ = __new_array_with_default(argc, 0, sizeof(string), &(string[]){_SLIT("")});
	for (int i = 0; i < argc; ++i) {
		array_set(&args_, i, &(string[]) { string_from_wide(((u16*)(argv[i]))) });
	}
	return args_;
}

VV_LOCAL_SYMBOL _result_void os__native_glob_pattern(string pattern, Array_string* matches) {
	bool os__native_glob_pattern_defer_0 = false;
	voidptr h_find_files;
	os__Win32finddata find_file_data = ((os__Win32finddata){.dw_file_attributes = 0,.ft_creation_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.ft_last_access_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.ft_last_write_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.n_file_size_high = 0,.n_file_size_low = 0,.dw_reserved0 = 0,.dw_reserved1 = 0,.c_file_name = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_alternate_file_name = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.dw_file_type = 0,.dw_creator_type = 0,.w_finder_flags = 0,});
	u16* wpattern = string_to_wide(string_replace(pattern, _SLIT("/"), _SLIT("\\")));
	h_find_files = FindFirstFile(wpattern, ((voidptr)(&find_file_data)));
	os__native_glob_pattern_defer_0 = true;
	if (h_find_files == INVALID_HANDLE_VALUE) {
		_result_void _t1 = (_result_void){ .is_error=true, .err=_v_error(string__plus(_SLIT("os.glob(): Could not get a file handle: "), os__get_error_msg(((int)(GetLastError()))))), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__native_glob_pattern_defer_0) {
				FindClose(h_find_files);
			}
			// Defer end
		return _t1;
	}
	string fname = string_from_wide(&find_file_data.c_file_name[0]);
	if (!(string__eq(fname, _SLIT(".")) || string__eq(fname, _SLIT("..")))) {
		string fp = string_replace(fname, _SLIT("\\"), _SLIT("/"));
		if ((find_file_data.dw_file_attributes & ((u32)(FILE_ATTRIBUTE_DIRECTORY))) > 0U) {
			fp = string__plus(fp, _SLIT("/"));
		}
		array_push((array*)matches, _MOV((string[]){ string_clone(fp) }));
	}
	for (int i = 0; FindNextFile(h_find_files, ((voidptr)(&find_file_data))) > 0; i++) {
		string filename = string_from_wide(&find_file_data.c_file_name[0]);
		if (string__eq(filename, _SLIT(".")) || string__eq(filename, _SLIT(".."))) {
			continue;
		}
		string fpath = string_replace(filename, _SLIT("\\"), _SLIT("/"));
		if ((find_file_data.dw_file_attributes & ((u32)(FILE_ATTRIBUTE_DIRECTORY))) > 0U) {
			fpath = string__plus(fpath, _SLIT("/"));
		}
		array_push((array*)matches, _MOV((string[]){ string_clone(fpath) }));
	}
		// Defer begin
		if (os__native_glob_pattern_defer_0) {
			FindClose(h_find_files);
		}
		// Defer end
	return (_result_void){0};
}

_result_void os__utime(string path, int actime, int modtime) {
	struct _utimbuf u = ((struct _utimbuf){.actime = actime,.modtime = modtime,});
	if (_utime(((char*)(path.str)), ((voidptr)(&u))) != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(os__posix_get_error_msg(errno), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

_result_Array_string os__ls(string path) {
	if (path.len == 0) {
		return (_result_Array_string){ .is_error=true, .err=_v_error(_SLIT("ls() expects a folder, not an empty string")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	os__Win32finddata find_file_data = ((os__Win32finddata){.dw_file_attributes = 0,.ft_creation_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.ft_last_access_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.ft_last_write_time = (os__Filetime){.dw_low_date_time = 0,.dw_high_date_time = 0,},.n_file_size_high = 0,.n_file_size_low = 0,.dw_reserved0 = 0,.dw_reserved1 = 0,.c_file_name = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.c_alternate_file_name = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.dw_file_type = 0,.dw_creator_type = 0,.w_finder_flags = 0,});
	Array_string dir_files = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!os__is_dir(path)) {
		return (_result_Array_string){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("ls() couldnt open dir \""), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\": directory does not exist"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string path_files =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT("\\*"), 0, { .d_c = 0 }}}));
	voidptr h_find_files = FindFirstFile(string_to_wide(path_files), ((voidptr)(&find_file_data)));
	if (h_find_files == INVALID_HANDLE_VALUE) {
		return (_result_Array_string){ .is_error=true, .err=_v_error(string__plus(_SLIT("ls(): Could not get a file handle: "), os__get_error_msg(((int)(GetLastError()))))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string first_filename = string_from_wide(&find_file_data.c_file_name[0]);
	if (!string__eq(first_filename, _SLIT(".")) && !string__eq(first_filename, _SLIT(".."))) {
		array_push((array*)&dir_files, _MOV((string[]){ string_clone(first_filename) }));
	}
	for (;;) {
		if (!(FindNextFile(h_find_files, ((voidptr)(&find_file_data))) > 0)) break;
		string filename = string_from_wide(&find_file_data.c_file_name[0]);
		if (!string__eq(filename, _SLIT(".")) && !string__eq(filename, _SLIT(".."))) {
			array_push((array*)&dir_files, _MOV((string[]){ string_clone(string_clone(filename)) }));
		}
	}
	FindClose(h_find_files);
	_result_Array_string _t6;
	_result_ok(&(Array_string[]) { dir_files }, (_result*)(&_t6), sizeof(Array_string));
	return _t6;
}

_result_void os__mkdir(string path, os__MkdirParams params) {
	if (string__eq(path, _SLIT("."))) {
		return (_result_void){0};
	}
	string apath = os__real_path(path);
	if (!CreateDirectory(string_to_wide(apath), 0)) {
		return (_result_void){ .is_error=true, .err=_v_error(string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT("mkdir failed for \""), /*115 &string*/0xfe10, {.d_s = apath}}, {_SLIT("\", because CreateDirectory returned: "), 0, { .d_c = 0 }}})), os__get_error_msg(((int)(GetLastError()))))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

os__HANDLE os__get_file_handle(string path) {
	_result_FILE_ptr _t1 = os__vfopen(path, _SLIT("rb"));
	if (_t1.is_error) {
		IError err = _t1.err;
		os__HANDLE _t2 = ((_const_os__invalid_handle_value));
		return _t2;
	}
	
 	FILE* cfile =  (*(FILE**)_t1.data);
	os__HANDLE handle = ((os__HANDLE)(_get_osfhandle(os__fileno(cfile))));
	return handle;
}

_result_string os__get_module_filename(os__HANDLE handle) {
	{ // Unsafe block
		int sz = 4096;
		u16* buf = ((u16*)(malloc_noscan(4096)));
		for (;;) {
			int status = ((int)(GetModuleFileNameW(handle, ((voidptr)(&buf)), sz)));

			if (status == (_const_os__success)) {
				_result_string _t1;
				_result_ok(&(string[]) { string_from_wide2(buf, sz) }, (_result*)(&_t1), sizeof(string));
				return _t1;
			}
			else {
				return (_result_string){ .is_error=true, .err=_v_error(_SLIT("Cannot get file name from handle")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	_v_panic(_SLIT("this should be unreachable"));
	VUNREACHABLE();
	return (_result_string){0};
}

VV_LOCAL_SYMBOL voidptr os__ptr_win_get_error_msg(u32 code) {
	voidptr buf = ((void*)0);
	if (code > ((u32)(_const_os__max_error_code))) {
		return buf;
	}
	FormatMessageW(((_const_os__format_message_allocate_buffer | _const_os__format_message_from_system) | _const_os__format_message_ignore_inserts), 0, code, 0U, ((voidptr)(&buf)), 0U, 0);
	return buf;
}

string os__get_error_msg(int code) {
	if (code < 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	voidptr ptr_text = os__ptr_win_get_error_msg(((u32)(code)));
	if (ptr_text == 0) {
		string _t2 = _SLIT("");
		return _t2;
	}
	string _t3 = string_from_wide(ptr_text);
	return _t3;
}

os__Result os__execute(string cmd) {
	if (string_contains(cmd, _SLIT(";")) || string_contains(cmd, _SLIT("&&")) || string_contains(cmd, _SLIT("||")) || string_contains(cmd, _SLIT("\n"))) {
		os__Result _t1 = ((os__Result){.exit_code = -1,.output = _SLIT(";, &&, || and \\n are not allowed in shell commands"),});
		return _t1;
	}
	os__Result _t2 = os__raw_execute(cmd);
	return _t2;
}

// Attr: [unsafe]
os__Result os__raw_execute(string cmd) {
	u32* child_stdin = ((u32*)(0));
	u32* child_stdout_read = ((u32*)(0));
	u32* child_stdout_write = ((u32*)(0));
	os__SecurityAttributes sa = ((os__SecurityAttributes){.n_length = 0,.lp_security_descriptor = 0,.b_inherit_handle = 0,});
	sa.n_length = sizeof(SECURITY_ATTRIBUTES);
	sa.b_inherit_handle = true;
	bool create_pipe_ok = CreatePipe(((voidptr)(&child_stdout_read)), ((voidptr)(&child_stdout_write)), ((voidptr)(&sa)), 0U);
	if (!create_pipe_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		os__Result _t1 = ((os__Result){.exit_code = error_num,.output =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("exec failed (CreatePipe): "), /*115 &string*/0xfe10, {.d_s = error_msg}}, {_SLIT0, 0, { .d_c = 0 }}})),});
		return _t1;
	}
	bool set_handle_info_ok = SetHandleInformation(child_stdout_read, HANDLE_FLAG_INHERIT, 0U);
	if (!set_handle_info_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		os__Result _t2 = ((os__Result){.exit_code = error_num,.output =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("exec failed (SetHandleInformation): "), /*115 &string*/0xfe10, {.d_s = error_msg}}, {_SLIT0, 0, { .d_c = 0 }}})),});
		return _t2;
	}
	os__ProcessInformation proc_info = ((os__ProcessInformation){.h_process = 0,.h_thread = 0,.dw_process_id = 0,.dw_thread_id = 0,});
	os__StartupInfo start_info = ((os__StartupInfo){
		.cb = sizeof(os__StartupInfo),
		.lp_reserved = ((void*)0),
		.lp_desktop = ((void*)0),
		.lp_title = ((void*)0),
		.dw_x = 0,
		.dw_y = 0,
		.dw_x_size = 0,
		.dw_y_size = 0,
		.dw_x_count_chars = 0,
		.dw_y_count_chars = 0,
		.dw_fill_attributes = 0,
		.dw_flags = ((u32)(STARTF_USESTDHANDLES)),
		.w_show_window = 0,
		.cb_reserved2 = 0,
		.lp_reserved2 = ((void*)0),
		.h_std_input = child_stdin,
		.h_std_output = child_stdout_write,
		.h_std_error = child_stdout_write,
	});
	string pcmd = cmd;
	if (string_contains(cmd, _SLIT("./"))) {
		pcmd = string_replace(pcmd, _SLIT("./"), _SLIT(".\\"));
	}
	if (string_contains(cmd, _SLIT("2>"))) {
		pcmd =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cmd /c \""), /*115 &string*/0xfe10, {.d_s = pcmd}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
	} else {
		pcmd =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("cmd /c \""), /*115 &string*/0xfe10, {.d_s = pcmd}}, {_SLIT(" 2>&1\""), 0, { .d_c = 0 }}}));
	}
	Array_fixed_u16_32768 command_line = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	ExpandEnvironmentStringsW(string_to_wide(pcmd), ((voidptr)(&command_line)), 32768U);
	bool create_process_ok = CreateProcessW(0, &command_line[0], 0, 0, TRUE, 0U, 0, 0, ((voidptr)(&start_info)), ((voidptr)(&proc_info)));
	if (!create_process_ok) {
		int error_num = ((int)(GetLastError()));
		string error_msg = os__get_error_msg(error_num);
		os__Result _t3 = ((os__Result){.exit_code = error_num,.output =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("exec failed (CreateProcess) with code "), /*100 &int*/0xfe07, {.d_i32 = error_num}}, {_SLIT(": "), /*115 &string*/0xfe10, {.d_s = error_msg}}, {_SLIT(" cmd: "), /*115 &string*/0xfe10, {.d_s = cmd}}, {_SLIT0, 0, { .d_c = 0 }}})),});
		return _t3;
	}
	CloseHandle(child_stdin);
	CloseHandle(child_stdout_write);
	Array_fixed_u8_4096 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	u32 bytes_read = ((u32)(0U));
	strings__Builder read_data = strings__new_builder(1024);
	for (;;) {
		bool result = false;
		{ // Unsafe block
			result = ReadFile(child_stdout_read, &buf[0], 1000U, ((voidptr)(&bytes_read)), 0);
			strings__Builder_write_ptr(&read_data, &buf[0], ((int)(bytes_read)));
		}
		if (result == false || ((int)(bytes_read)) == 0) {
			break;
		}
	}
	string soutput = strings__Builder_str(&read_data);
	strings__Builder_free(&read_data);
	u32 exit_code = ((u32)(0U));
	WaitForSingleObject(proc_info.h_process, INFINITE);
	GetExitCodeProcess(proc_info.h_process, ((voidptr)(&exit_code)));
	CloseHandle(proc_info.h_process);
	CloseHandle(proc_info.h_thread);
	os__Result _t4 = ((os__Result){.exit_code = ((int)(exit_code)),.output = soutput,});
	return _t4;
}

_result_void os__symlink(string origin, string target) {
	#if defined(TARGET_IS_64BIT) || defined(TARGET_IS_32BIT)
	{
		int flags = 0;
		if (os__is_dir(origin)) {
			flags ^= 1;
		}
		flags ^= 2;
		int res = CreateSymbolicLinkW(string_to_wide(target), string_to_wide(origin), flags);
		if (res != 1) {
			return (_result_void){ .is_error=true, .err=_v_error(os__get_error_msg(((int)(GetLastError())))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (!os__exists(target)) {
			return (_result_void){ .is_error=true, .err=_v_error(_SLIT("C.CreateSymbolicLinkW reported success, but symlink still does not exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		return (_result_void){0};
	}
	#endif
	return (_result_void){ .is_error=true, .err=_v_error(_SLIT("could not symlink")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_void os__link(string origin, string target) {
	int res = CreateHardLinkW(string_to_wide(target), string_to_wide(origin), NULL);
	if (res != 1) {
		return (_result_void){ .is_error=true, .err=_v_error(os__get_error_msg(((int)(GetLastError())))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__exists(target)) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("C.CreateHardLinkW reported success, but link still does not exist")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

void os__File_close(os__File* f) {
	if (!f->is_opened) {
		return;
	}
	f->is_opened = false;
	fflush(f->cfile);
	fclose(f->cfile);
}

// TypeDecl
void os__add_vectored_exception_handler(bool first, int (*handler)(ExceptionPointers* )) {
	AddVectoredExceptionHandler((u32[]){(first)?1:0}[0], ((voidptr)(handler)));
}

os__Uname os__uname(void) {
	_result_string _t1 = os__hostname();
	if (_t1.is_error) {
		IError err = _t1.err;
		*(string*) _t1.data = _SLIT("");
	}
	
 	string nodename =  (*(string*)_t1.data);
	string machine = os__getenv(_SLIT("PROCESSOR_ARCHITECTURE"));
	string version_info = os__execute(_SLIT("cmd /d/c ver")).output;
	string version_n = string_trim_space(string_replace((*(string*)array_get((string_split(version_info, _SLIT(" "))), 3)), _SLIT("]"), _SLIT("")));
	os__Uname _t2 = ((os__Uname){.sysname = _SLIT("Windows_NT"),.nodename = nodename,.release = string_trim_space(Array_string_join(array_slice((string_split(version_n, _SLIT("."))), 0, 2), _SLIT("."))),.version = string_trim_space((*(string*)array_get((string_split(version_n, _SLIT("."))), 2))),.machine = string_trim_space(machine),});
	return _t2;
}

_result_string os__hostname(void) {
	Array_fixed_u16_255 hostname = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	u32 size = ((u32)(255U));
	bool res = GetComputerNameW(&hostname[0], ((voidptr)(&size)));
	if (!res) {
		return (_result_string){ .is_error=true, .err=_v_error(os__get_error_msg(((int)(GetLastError())))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_string _t2;
	_result_ok(&(string[]) { string_from_wide(&hostname[0]) }, (_result*)(&_t2), sizeof(string));
	return _t2;
}

_result_string os__loginname(void) {
	Array_fixed_u16_255 loginname = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	u32 size = ((u32)(255U));
	bool res = GetUserNameW(&loginname[0], ((voidptr)(&size)));
	if (!res) {
		return (_result_string){ .is_error=true, .err=_v_error(os__get_error_msg(((int)(GetLastError())))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_string _t2;
	_result_ok(&(string[]) { string_from_wide(&loginname[0]) }, (_result*)(&_t2), sizeof(string));
	return _t2;
}

_result_void os__ensure_folder_is_writable(string folder) {
	if (!os__exists(folder)) {
		return (_result_void){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), /*115 &string*/0xfe10, {.d_s = folder}}, {_SLIT("` does not exist"), 0, { .d_c = 0 }}})), 1), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!os__is_dir(folder)) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("`folder` is not a folder"), 2), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string tmp_folder_name = string__plus(_SLIT("tmp_perm_check_pid_"), int_str(os__getpid()));
	string tmp_perm_check = os__join_path_single(folder, tmp_folder_name);
	_result_void _t3 = os__write_file(tmp_perm_check, _SLIT("test"));
	if (_t3.is_error) {
		IError err = _t3.err;
		return (_result_void){ .is_error=true, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("cannot write to folder \""), /*115 &string*/0xfe10, {.d_s = folder}}, {_SLIT("\": "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})), 3), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 ;
	_result_void _t5 = os__rm(tmp_perm_check);
	if (_t5.is_error) {
		_result_void _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 ;
	return (_result_void){0};
}

// Attr: [inline]
inline int os__getpid(void) {
	int _t1 = _getpid();
	return _t1;
}

// Attr: [inline]
inline int os__getppid(void) {
	int _t1 = 0;
	return _t1;
}

// Attr: [inline]
inline int os__getuid(void) {
	int _t1 = 0;
	return _t1;
}

// Attr: [inline]
inline int os__geteuid(void) {
	int _t1 = 0;
	return _t1;
}

// Attr: [inline]
inline int os__getgid(void) {
	int _t1 = 0;
	return _t1;
}

// Attr: [inline]
inline int os__getegid(void) {
	int _t1 = 0;
	return _t1;
}

void os__posix_set_permission_bit(string path_s, u32 mode, bool enable) {
}

_result_void os__Command_start(os__Command* c) {
	_v_panic(_SLIT("not implemented"));
	VUNREACHABLE();
	return (_result_void){0};
}

string os__Command_read_line(os__Command* c) {
	_v_panic(_SLIT("not implemented"));
	VUNREACHABLE();
	return (string){.str=(byteptr)"", .is_lit=1};
}

_result_void os__Command_close(os__Command* c) {
	_v_panic(_SLIT("not implemented"));
	VUNREACHABLE();
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_string os__get_long_path(string path) {
	bool os__get_long_path_defer_0 = false;
	u16* input_short_path;
	if (!string_contains(path, _SLIT("~"))) {
		_result_string _t1;
		_result_ok(&(string[]) { path }, (_result*)(&_t1), sizeof(string));
		return _t1;
	}
	input_short_path = string_to_wide(path);
	os__get_long_path_defer_0 = true;
	Array_fixed_u16_4096 long_path_buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	u32 res = GetLongPathName(input_short_path, &long_path_buf[0], sizeof(Array_fixed_u16_4096));
	if (res == 0U) {
		_result_string _t2 = (_result_string){ .is_error=true, .err=_v_error(os__get_error_msg(((int)(GetLastError())))), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__get_long_path_defer_0) {
				_v_free(input_short_path);
			}
			// Defer end
		return _t2;
	}
	string long_path = string_from_wide(&long_path_buf[0]);
	_result_string _t3;
	_result_ok(&(string[]) { long_path }, (_result*)(&_t3), sizeof(string));
		// Defer begin
		if (os__get_long_path_defer_0) {
			_v_free(input_short_path);
		}
		// Defer end
	return _t3;
}

int os__page_size(void) {
	SYSTEM_INFO sinfo = ((SYSTEM_INFO){.dwNumberOfProcessors = 0,.dwPageSize = 0,});
	GetSystemInfo(&sinfo);
	int _t1 = ((int)(sinfo.dwPageSize));
	return _t1;
}

_result_string os__input_password(string prompt) {
	bool os__input_password_defer_0 = false;
	voidptr std_handle;
	u32 mode;
	if (os__is_atty(1) <= 0 || string__eq(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("Could not obtain password discretely.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	std_handle = GetStdHandle(STD_INPUT_HANDLE);
	mode = ((u32)(0U));
	GetConsoleMode(std_handle, ((voidptr)(&mode)));
	SetConsoleMode(std_handle, (mode & (~((u32)(ENABLE_ECHO_INPUT)))));
	os__input_password_defer_0 = true;
	_option_string _t2 = os__input_opt(prompt);
	if (_t2.state != 0) {
		IError err = _t2.err;
		_result_string _t3 = (_result_string){ .is_error=true, .err=_v_error(_SLIT("Failed to read password")), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (os__input_password_defer_0) {
				SetConsoleMode(std_handle, *&mode);
				println(_SLIT(""));
			}
			// Defer end
		return _t3;
	}
	
 	string password =  (*(string*)_t2.data);
	_result_string _t4;
	_result_ok(&(string[]) { password }, (_result*)(&_t4), sizeof(string));
		// Defer begin
		if (os__input_password_defer_0) {
			SetConsoleMode(std_handle, *&mode);
			println(_SLIT(""));
		}
		// Defer end
	return _t4;
}

void os__Process_signal_kill(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_kill(p);
	p->status = os__ProcessState__aborted;
	return;
}

void os__Process_signal_pgkill(os__Process* p) {
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__signal_pgkill(p);
	return;
}

void os__Process_signal_stop(os__Process* p) {
	if (p->status != os__ProcessState__running) {
		return;
	}
	os__Process__signal_stop(p);
	p->status = os__ProcessState__stopped;
	return;
}

void os__Process_signal_continue(os__Process* p) {
	if (p->status != os__ProcessState__stopped) {
		return;
	}
	os__Process__signal_continue(p);
	p->status = os__ProcessState__running;
	return;
}

void os__Process_wait(os__Process* p) {
	if (p->status == os__ProcessState__not_started) {
		os__Process__spawn(p);
	}
	if (!(p->status == os__ProcessState__running || p->status == os__ProcessState__stopped)) {
		return;
	}
	os__Process__wait(p);
	return;
}

void os__Process_close(os__Process* p) {
	if (p->status == os__ProcessState__not_started || p->status == os__ProcessState__closed) {
		return;
	}
	p->status = os__ProcessState__closed;
}

// Attr: [unsafe]
void os__Process_free(os__Process* p) {
	os__Process_close(p);
	{ // Unsafe block
		string_free(&p->filename);
		string_free(&p->err);
		array_free(&p->args);
		array_free(&p->env);
	}
}

VV_LOCAL_SYMBOL int os__Process__spawn(os__Process* p) {
	if (!p->env_is_custom) {
		p->env = __new_array_with_default(0, 0, sizeof(string), 0);
		Map_string_string current_environment = os__environ();
		int _t2 = current_environment.key_values.len;
		for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
			int _t3 = current_environment.key_values.len - _t2;
			_t2 = current_environment.key_values.len;
			if (_t3 < 0) {
				_t1 = -1;
				continue;
			}
			if (!DenseArray_has_index(&current_environment.key_values, _t1)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&current_environment.key_values, _t1);
			k = string_clone(k);
			string v = (*(string*)DenseArray_value(&current_environment.key_values, _t1));
			array_push((array*)&p->env, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = k}}, {_SLIT("="), /*115 &string*/0xfe10, {.d_s = v}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
		}
	}
	int pid = 0;
	#if defined(_WIN32)
	{
		pid = os__Process_win_spawn_process(p);
	}
	#else
	{
	}
	#endif
	p->pid = pid;
	p->status = os__ProcessState__running;
	int _t6 = 0;
	return _t6;
}

bool os__Process_is_alive(os__Process* p) {
	bool res = false;
	if (p->status == os__ProcessState__running || p->status == os__ProcessState__stopped) {
		res = os__Process__is_alive(p);
	}
	return res;
}

void os__Process_set_redirect_stdio(os__Process* p) {
	p->use_stdio_ctl = true;
	return;
}

void os__Process_stdin_write(os__Process* p, string s) {
	os__Process__check_redirection_call(p, _SLIT("Process.stdin_write"));
	os__Process__write_to(p, os__ChildProcessPipeKind__stdin, s);
}

string os__Process_stdout_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("Process.stdout_slurp"));
	string res = os__Process__slurp_from(p, os__ChildProcessPipeKind__stdout);
	return res;
}

string os__Process_stderr_slurp(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("Process.stderr_slurp"));
	string res = os__Process__slurp_from(p, os__ChildProcessPipeKind__stderr);
	return res;
}

string os__Process_stdout_read(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("Process.stdout_read"));
	string res = os__Process__read_from(p, os__ChildProcessPipeKind__stdout);
	return res;
}

string os__Process_stderr_read(os__Process* p) {
	os__Process__check_redirection_call(p, _SLIT("Process.stderr_read"));
	string res = os__Process__read_from(p, os__ChildProcessPipeKind__stderr);
	return res;
}

_option_string os__Process_pipe_read(os__Process* p, os__ChildProcessPipeKind pkind) {
	os__Process__check_redirection_call(p, _SLIT("Process.pipe_read"));
	if (!os__Process__is_pending(p, pkind)) {
		return (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string res = os__Process__read_from(p, pkind);
	_option_string _t2;
	_option_ok(&(string[]) { res }, (_option*)(&_t2), sizeof(string));
	return _t2;
}

bool os__Process_is_pending(os__Process* p, os__ChildProcessPipeKind pkind) {
	os__Process__check_redirection_call(p, _SLIT("Process.is_pending"));
	bool res = os__Process__is_pending(p, pkind);
	return res;
}

VV_LOCAL_SYMBOL string os__Process__read_from(os__Process* p, os__ChildProcessPipeKind pkind) {
	#if defined(_WIN32)
	{
		multi_return_string_int mr_6300 = os__Process_win_read_string(p, ((int)(pkind)), 4096);
		string s = mr_6300.arg0;
		return s;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string os__Process__slurp_from(os__Process* p, os__ChildProcessPipeKind pkind) {
	#if defined(_WIN32)
	{
		string _t2 = os__Process_win_slurp(p, ((int)(pkind)));
		return _t2;
	}
	#else
	{
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL void os__Process__write_to(os__Process* p, os__ChildProcessPipeKind pkind, string s) {
	#if defined(_WIN32)
	{
		os__Process_win_write_string(p, ((int)(pkind)), s);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL bool os__Process__is_pending(os__Process* p, os__ChildProcessPipeKind pkind) {
	#if defined(_WIN32)
	{
	}
	#else
	{
	}
	#endif
	bool _t2 = false;
	return _t2;
}

VV_LOCAL_SYMBOL void os__Process__check_redirection_call(os__Process* p, string fn_name) {
	if (!p->use_stdio_ctl) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Call p.set_redirect_stdio() before calling p."), /*115 &string*/0xfe10, {.d_s = fn_name}}, {_SLIT0, 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
	if (p->status == os__ProcessState__not_started) {
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Call p."), /*115 &string*/0xfe10, {.d_s = fn_name}}, {_SLIT("() after you have called p.run()"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	}
}

VV_LOCAL_SYMBOL void os__Process__signal_stop(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_stop_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_continue(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_resume_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_kill(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_kill_process(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__signal_pgkill(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_kill_pgroup(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL void os__Process__wait(os__Process* p) {
	#if defined(_WIN32)
	{
		os__Process_win_wait(p);
	}
	#else
	{
	}
	#endif
}

VV_LOCAL_SYMBOL bool os__Process__is_alive(os__Process* p) {
	#if defined(_WIN32)
	{
		bool _t2 = os__Process_win_is_alive(p);
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

void os__Process_run(os__Process* p) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	os__Process__spawn(p);
	return;
}

os__Process* os__new_process(string filename) {
	os__Process* _t1 = ((os__Process*)memdup(&(os__Process){.filename = filename,.pid = 0,.code = -1,.status = os__ProcessState__not_started,.err = (string){.str=(byteptr)"", .is_lit=1},.args = __new_array(0, 0, sizeof(string)),.work_folder = (string){.str=(byteptr)"", .is_lit=1},.env_is_custom = 0,.env = __new_array(0, 0, sizeof(string)),.use_stdio_ctl = 0,.use_pgroup = 0,.stdio_fd = {-1, -1, -1},.wdata = 0,.create_no_window = 0,}, sizeof(os__Process)));
	return _t1;
}

void os__Process_set_args(os__Process* p, Array_string pargs) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->args = pargs;
	return;
}

void os__Process_set_work_folder(os__Process* p, string path) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->work_folder = os__real_path(path);
	return;
}

void os__Process_set_environment(os__Process* p, Map_string_string envs) {
	if (p->status != os__ProcessState__not_started) {
		return;
	}
	p->env_is_custom = true;
	p->env = __new_array_with_default(0, 0, sizeof(string), 0);
	int _t2 = envs.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = envs.key_values.len - _t2;
		_t2 = envs.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&envs.key_values, _t1)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&envs.key_values, _t1);
		k = string_clone(k);
		string v = (*(string*)DenseArray_value(&envs.key_values, _t1));
		array_push((array*)&p->env, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = k}}, {_SLIT("="), /*115 &string*/0xfe10, {.d_s = v}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	}
	return;
}

// TypeDecl
VV_LOCAL_SYMBOL os__FN_NTSuspendResume os__ntdll_fn(char* name) {
	os__HMODULE ntdll = GetModuleHandleA("NTDLL");
	if (ntdll == 0) {
		os__FN_NTSuspendResume _t1 = (voidptr)((os__FN_NTSuspendResume)(0));
		return _t1;
	}
	u64 (*the_fn) (voidptr ) = ((os__FN_NTSuspendResume)(GetProcAddress(ntdll, ((voidptr)(name)))));
	return (voidptr)the_fn;
}

VV_LOCAL_SYMBOL void os__failed_cfn_report_error(bool ok, string label) {
	if (ok) {
		return;
	}
	int error_num = ((int)(GetLastError()));
	string error_msg = os__get_error_msg(error_num);
	eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("failed "), /*115 &string*/0xfe10, {.d_s = label}}, {_SLIT(": "), /*115 &string*/0xfe10, {.d_s = error_msg}}, {_SLIT0, 0, { .d_c = 0 }}})));
	_v_exit(1);
	VUNREACHABLE();
}

// TypeDecl
VV_LOCAL_SYMBOL void os__close_valid_handle(voidptr p) {
	os__PU32* h = ((os__PU32*)(p));
	if (*h != ((u32*)(0))) {
		CloseHandle(*h);
		{ // Unsafe block
			*h = ((u32*)(0));
		}
	}
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL int os__Process_win_spawn_process(os__Process* p) {
	bool os__Process_win_spawn_process_defer_0 = false;
	Array_voidptr to_be_freed;
	int idx;
	to_be_freed = __new_array_with_default(0, 5, sizeof(voidptr), 0);
	os__Process_win_spawn_process_defer_0 = true;
	p->filename = os__abs_path(p->filename);
	os__WProcess* wdata = ((os__WProcess*)memdup(&(os__WProcess){.proc_info = (os__ProcessInformation){.h_process = 0,.h_thread = 0,.dw_process_id = 0,.dw_thread_id = 0,},.command_line = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.child_stdin = ((void*)0),.child_stdout_read = ((void*)0),.child_stdout_write = ((void*)0),.child_stderr_read = ((void*)0),.child_stderr_write = ((void*)0),}, sizeof(os__WProcess)));
	p->wdata = ((voidptr)(wdata));
	os__StartupInfo start_info = ((os__StartupInfo){.cb = sizeof(PROCESS_INFORMATION),.lp_reserved = ((void*)0),.lp_desktop = ((void*)0),.lp_title = ((void*)0),.dw_x = 0,.dw_y = 0,.dw_x_size = 0,.dw_y_size = 0,.dw_x_count_chars = 0,.dw_y_count_chars = 0,.dw_fill_attributes = 0,.dw_flags = 0,.w_show_window = 0,.cb_reserved2 = 0,.lp_reserved2 = ((void*)0),.h_std_input = 0,.h_std_output = 0,.h_std_error = 0,});
	if (p->use_stdio_ctl) {
		os__SecurityAttributes sa = ((os__SecurityAttributes){.n_length = 0,.lp_security_descriptor = 0,.b_inherit_handle = 0,});
		sa.n_length = sizeof(SECURITY_ATTRIBUTES);
		sa.b_inherit_handle = true;
		bool create_pipe_ok1 = CreatePipe(((voidptr)(&wdata->child_stdout_read)), ((voidptr)(&wdata->child_stdout_write)), ((voidptr)(&sa)), 0U);
		os__failed_cfn_report_error(create_pipe_ok1, _SLIT("CreatePipe stdout"));
		bool set_handle_info_ok1 = SetHandleInformation(wdata->child_stdout_read, HANDLE_FLAG_INHERIT, 0U);
		os__failed_cfn_report_error(set_handle_info_ok1, _SLIT("SetHandleInformation"));
		bool create_pipe_ok2 = CreatePipe(((voidptr)(&wdata->child_stderr_read)), ((voidptr)(&wdata->child_stderr_write)), ((voidptr)(&sa)), 0U);
		os__failed_cfn_report_error(create_pipe_ok2, _SLIT("CreatePipe stderr"));
		bool set_handle_info_ok2 = SetHandleInformation(wdata->child_stderr_read, HANDLE_FLAG_INHERIT, 0U);
		os__failed_cfn_report_error(set_handle_info_ok2, _SLIT("SetHandleInformation stderr"));
		start_info.h_std_input = wdata->child_stdin;
		start_info.h_std_output = wdata->child_stdout_write;
		start_info.h_std_error = wdata->child_stderr_write;
		start_info.dw_flags = ((u32)(STARTF_USESTDHANDLES));
	}
	string cmd = string__plus( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = p->filename}}, {_SLIT(" "), 0, { .d_c = 0 }}})), Array_string_join(p->args, _SLIT(" ")));
	u16* cmd_wide_ptr = string_to_wide(cmd);
	array_push((array*)&to_be_freed, _MOV((voidptr[]){ cmd_wide_ptr }));
	ExpandEnvironmentStringsW(cmd_wide_ptr, ((voidptr)(&wdata->command_line[0])), 32768U);
	int creation_flags = (p->create_no_window ? (((int)(CREATE_NO_WINDOW))) : (((int)(NORMAL_PRIORITY_CLASS))));
	if (p->use_pgroup) {
		creation_flags |= CREATE_NEW_PROCESS_GROUP;
	}
	voidptr work_folder_ptr = ((voidptr)(((void*)0)));
	if ((p->work_folder).len != 0) {
		work_folder_ptr = string_to_wide(p->work_folder);
		array_push((array*)&to_be_freed, _MOV((voidptr[]){ work_folder_ptr }));
	}
	bool create_process_ok = CreateProcessW(0, ((voidptr)(&wdata->command_line[0])), 0, 0, TRUE, creation_flags, 0, work_folder_ptr, ((voidptr)(&start_info)), ((voidptr)(&wdata->proc_info)));
	os__failed_cfn_report_error(create_process_ok, _SLIT("CreateProcess"));
	if (p->use_stdio_ctl) {
		os__close_valid_handle(&wdata->child_stdout_write);
		os__close_valid_handle(&wdata->child_stderr_write);
	}
	p->pid = ((int)(wdata->proc_info.dw_process_id));
	int _t3 = p->pid;
		// Defer begin
		if (os__Process_win_spawn_process_defer_0) {
			for (idx = (int)(to_be_freed.len - 1); idx >= 0; idx--) {
				_v_free((*(voidptr*)array_get(to_be_freed, idx)));
			}
			array_free(&to_be_freed);
		}
		// Defer end
	return _t3;
}

VV_LOCAL_SYMBOL void os__Process_win_stop_process(os__Process* p) {
	u64 (*the_fn) (voidptr ) = os__ntdll_fn("NtSuspendProcess");
	if (((voidptr)(the_fn)) == 0) {
		return;
	}
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	the_fn(wdata->proc_info.h_process);
}

VV_LOCAL_SYMBOL void os__Process_win_resume_process(os__Process* p) {
	u64 (*the_fn) (voidptr ) = os__ntdll_fn("NtResumeProcess");
	if (((voidptr)(the_fn)) == 0) {
		return;
	}
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	the_fn(wdata->proc_info.h_process);
}

VV_LOCAL_SYMBOL void os__Process_win_kill_process(os__Process* p) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	TerminateProcess(wdata->proc_info.h_process, 3U);
}

VV_LOCAL_SYMBOL void os__Process_win_kill_pgroup(os__Process* p) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, wdata->proc_info.dw_process_id);
	Sleep(20U);
	TerminateProcess(wdata->proc_info.h_process, 3U);
}

VV_LOCAL_SYMBOL void os__Process_win_wait(os__Process* p) {
	u32 exit_code = ((u32)(1U));
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	if (p->wdata != 0) {
		WaitForSingleObject(wdata->proc_info.h_process, INFINITE);
		GetExitCodeProcess(wdata->proc_info.h_process, ((voidptr)(&exit_code)));
		os__close_valid_handle(&wdata->child_stdin);
		os__close_valid_handle(&wdata->child_stdout_write);
		os__close_valid_handle(&wdata->child_stderr_write);
		os__close_valid_handle(&wdata->proc_info.h_process);
		os__close_valid_handle(&wdata->proc_info.h_thread);
	}
	p->status = os__ProcessState__exited;
	p->code = ((int)(exit_code));
}

VV_LOCAL_SYMBOL bool os__Process_win_is_alive(os__Process* p) {
	u32 exit_code = ((u32)(0U));
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	GetExitCodeProcess(wdata->proc_info.h_process, ((voidptr)(&exit_code)));
	if (_us32_eq(exit_code,STILL_ACTIVE)) {
		bool _t1 = true;
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

VV_LOCAL_SYMBOL void os__Process_win_write_string(os__Process* p, int idx, string s) {
	_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Process.write_string "), /*100 &int*/0xfe07, {.d_i32 = idx}}, {_SLIT(" is not implemented yet"), 0, { .d_c = 0 }}})));
	VUNREACHABLE();
}

VV_LOCAL_SYMBOL multi_return_string_int os__Process_win_read_string(os__Process* p, int idx, int maxbytes) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	if (wdata == 0) {
		return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
	}
	u32* rhandle = ((u32*)(0));
	if (idx == 1) {
		rhandle = wdata->child_stdout_read;
	}
	if (idx == 2) {
		rhandle = wdata->child_stderr_read;
	}
	if (rhandle == 0) {
		return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
	}
	int bytes_avail = ((int)(0));
	if (!PeekNamedPipe(rhandle, ((void*)0), ((int)(0)), ((void*)0), ((voidptr)(&bytes_avail)), ((void*)0))) {
		return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
	}
	if (bytes_avail == 0) {
		return (multi_return_string_int){.arg0=_SLIT(""), .arg1=0};
	}
	int bytes_read = ((int)(0));
	Array_u8 buf = __new_array_with_default_noscan((int)(bytes_avail + 300), 0, sizeof(u8), 0);
	ReadFile(rhandle, &(*(u8*)array_get(buf, 0)), buf.cap, ((voidptr)(&bytes_read)), 0);
	return (multi_return_string_int){.arg0=Array_u8_bytestr(array_slice(buf, 0, bytes_read)), .arg1=bytes_read};
}

VV_LOCAL_SYMBOL string os__Process_win_slurp(os__Process* p, int idx) {
	os__WProcess* wdata = ((os__WProcess*)(p->wdata));
	if (wdata == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	u32* rhandle = ((u32*)(0));
	if (idx == 1) {
		rhandle = wdata->child_stdout_read;
	}
	if (idx == 2) {
		rhandle = wdata->child_stderr_read;
	}
	if (rhandle == 0) {
		string _t2 = _SLIT("");
		return _t2;
	}
	u32 bytes_read = ((u32)(0U));
	Array_fixed_u8_4096 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	strings__Builder read_data = strings__new_builder(1024);
	for (;;) {
		bool result = false;
		{ // Unsafe block
			result = ReadFile(rhandle, &buf[0], 1000U, ((voidptr)(&bytes_read)), 0);
			strings__Builder_write_ptr(&read_data, &buf[0], ((int)(bytes_read)));
		}
		if (result == false || ((int)(bytes_read)) == 0) {
			break;
		}
	}
	string soutput = strings__Builder_str(&read_data);
	strings__Builder_free(&read_data);
	return soutput;
}

VV_LOCAL_SYMBOL int os__Process_unix_spawn_process(os__Process* p) {
	int _t1 = 0;
	return _t1;
}

VV_LOCAL_SYMBOL void os__Process_unix_stop_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_resume_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_kill_process(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_kill_pgroup(os__Process* p) {
}

VV_LOCAL_SYMBOL void os__Process_unix_wait(os__Process* p) {
}

VV_LOCAL_SYMBOL bool os__Process_unix_is_alive(os__Process* p) {
	bool _t1 = false;
	return _t1;
}

_result_anon_fn_os__signal os__signal_opt(os__Signal signum, void (*handler)(os__Signal )) {
	errno = 0;
	voidptr prev_handler = signal(((int)(signum)), (voidptr)handler);
	if (prev_handler == SIG_ERR) {
		return (_result_anon_fn_os__signal){ .is_error=true, .err=error_with_code(os__posix_get_error_msg(EINVAL), EINVAL), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_anon_fn_os__signal _t2;
	_result_ok(&(os__SignalHandler[]) { (voidptr)((os__SignalHandler)(prev_handler)) }, (_result*)(&_t2), sizeof(os__SignalHandler));
	return _t2;
}

VV_LOCAL_SYMBOL void os__ignore_signal_handler(os__Signal signal) {
}

void os__signal_ignore(Array_os__Signal args) {
	if (os__is_main_thread()) {
	} else {
		os__signal_ignore_internal(args);
	}
}

// TypeDecl
bool os__is_main_thread(void) {
	bool _t1 = g_main_thread_id == ((u64)(GetCurrentThreadId()));
	return _t1;
}

VV_LOCAL_SYMBOL void os__signal_ignore_internal(Array_os__Signal args) {
}

// TypeDecl
VV_LOCAL_SYMBOL string x__json2__format_message(string msg, int line, int column) {
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("[x.json2] "), /*115 &string*/0xfe10, {.d_s = msg}}, {_SLIT(" ("), /*100 &int*/0xfe07, {.d_i32 = line}}, {_SLIT(":"), /*100 &int*/0xfe07, {.d_i32 = column}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	return _t1;
}

int x__json2__DecodeError_code(x__json2__DecodeError err) {
	int _t1 = 3;
	return _t1;
}

string x__json2__DecodeError_msg(x__json2__DecodeError err) {
	string _t1 = x__json2__format_message(err.message, err.line, err.column);
	return _t1;
}

int x__json2__InvalidTokenError_code(x__json2__InvalidTokenError err) {
	int _t1 = 2;
	return _t1;
}

string x__json2__InvalidTokenError_msg(x__json2__InvalidTokenError err) {
	string footer_text = (err.expected != x__json2__TokenKind__none_ ? ( str_intp(2, _MOV((StrIntpData[]){{_SLIT(", expecting `"), /*115 &x.json2.TokenKind*/0xfe10, {.d_s = x__json2__TokenKind_str(err.expected)}}, {_SLIT("`"), 0, { .d_c = 0 }}}))) : (_SLIT("")));
	string _t1 = x__json2__format_message( str_intp(3, _MOV((StrIntpData[]){{_SLIT("invalid token `"), /*115 &x.json2.TokenKind*/0xfe10, {.d_s = x__json2__TokenKind_str(err.token.kind)}}, {_SLIT("`"), /*115 &string*/0xfe10, {.d_s = footer_text}}, {_SLIT0, 0, { .d_c = 0 }}})), err.token.line, x__json2__Token_full_col(err.token));
	return _t1;
}

int x__json2__UnknownTokenError_code(x__json2__UnknownTokenError err) {
	int _t1 = 1;
	return _t1;
}

string x__json2__UnknownTokenError_msg(x__json2__UnknownTokenError err) {
	string _t1 = x__json2__format_message( str_intp(3, _MOV((StrIntpData[]){{_SLIT("unknown token '"), /*115 &[]u8*/0xfe10, {.d_s = Array_u8_str(err.token.lit)}}, {_SLIT("' when decoding "), /*115 &x.json2.ValueKind*/0xfe10, {.d_s = x__json2__ValueKind_str(err.kind)}}, {_SLIT("."), 0, { .d_c = 0 }}})), err.token.line, x__json2__Token_full_col(err.token));
	return _t1;
}

VV_LOCAL_SYMBOL void x__json2__Parser_next(x__json2__Parser* p) {
	p->prev_tok = p->tok;
	p->tok = p->next_tok;
	p->next_tok = x__json2__Scanner_scan(p->scanner);
}

VV_LOCAL_SYMBOL _result_void x__json2__Parser_next_with_err(x__json2__Parser* p) {
	x__json2__Parser_next(p);
	if (p->tok.kind == x__json2__TokenKind__error) {
		return (_result_void){ .is_error=true, .err=I_x__json2__DecodeError_to_Interface_IError(((x__json2__DecodeError*)memdup(&(x__json2__DecodeError){.line = p->tok.line,.column = x__json2__Token_full_col(p->tok),.message = Array_u8_bytestr(p->tok.lit),}, sizeof(x__json2__DecodeError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL string x__json2__skip_bom(string file_content) {
	string raw_text = file_content;
	if (raw_text.len >= 3) {
		{ // Unsafe block
			u8* c_text = raw_text.str;
			if (c_text[0] == 0xEF && c_text[1] == 0xBB && c_text[2] == 0xBF) {
				int offset_from_begin = 3;
				raw_text = tos((voidptr)&/*qq*/c_text[offset_from_begin], (int)(vstrlen(c_text) - offset_from_begin));
			}
		}
	}
	return raw_text;
}

VV_LOCAL_SYMBOL x__json2__Parser x__json2__new_parser(string srce, bool convert_type) {
	string src = x__json2__skip_bom(srce);
	x__json2__Parser _t1 = ((x__json2__Parser){.scanner = ((x__json2__Scanner*)memdup(&(x__json2__Scanner){.text = string_bytes(src),.pos = 0,.line = 0,.col = 0,}, sizeof(x__json2__Scanner))),.prev_tok = (x__json2__Token){.lit = __new_array_noscan(0, 0, sizeof(u8)),.line = 0,.col = 0,},.tok = (x__json2__Token){.lit = __new_array_noscan(0, 0, sizeof(u8)),.line = 0,.col = 0,},.next_tok = (x__json2__Token){.lit = __new_array_noscan(0, 0, sizeof(u8)),.line = 0,.col = 0,},.n_level = 0,.convert_type = convert_type,});
	return _t1;
}

_result_x__json2__Any x__json2__Parser_decode(x__json2__Parser* p) {
	x__json2__Parser_next(p);
	_result_void _t1 = x__json2__Parser_next_with_err(p);
	if (_t1.is_error) {
		_result_x__json2__Any _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_x__json2__Any _t3 = x__json2__Parser_decode_value(p);
	if (_t3.is_error) {
		_result_x__json2__Any _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	x__json2__Any fi =  (*(x__json2__Any*)_t3.data);
	if (p->tok.kind != x__json2__TokenKind__eof) {
		return (_result_x__json2__Any){ .is_error=true, .err=I_x__json2__InvalidTokenError_to_Interface_IError(((x__json2__InvalidTokenError*)memdup(&(x__json2__InvalidTokenError){.DecodeError = ((x__json2__DecodeError){.line = 0,.column = 0,.message = (string){.str=(byteptr)"", .is_lit=1},}),.token = p->tok,.expected = 0,}, sizeof(x__json2__InvalidTokenError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_x__json2__Any _t6;
	_result_ok(&(x__json2__Any[]) { fi }, (_result*)(&_t6), sizeof(x__json2__Any));
	return _t6;
}

VV_LOCAL_SYMBOL _result_x__json2__Any x__json2__Parser_decode_value(x__json2__Parser* p) {
	if ((int)(p->n_level + 1) == 500) {
		return (_result_x__json2__Any){ .is_error=true, .err=I_x__json2__DecodeError_to_Interface_IError(((x__json2__DecodeError*)memdup(&(x__json2__DecodeError){.line = 0,.column = 0,.message = _SLIT("reached maximum nesting level of 500"),}, sizeof(x__json2__DecodeError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	switch (p->tok.kind) {
		case x__json2__TokenKind__lsbr: {
				_result_x__json2__Any _t2 = x__json2__Parser_decode_array(p);
				return _t2;
		}
		case x__json2__TokenKind__lcbr: {
				_result_x__json2__Any _t3 = x__json2__Parser_decode_object(p);
				return _t3;
		}
		case x__json2__TokenKind__int_: case x__json2__TokenKind__float: {
				string tl = Array_u8_bytestr(p->tok.lit);
				x__json2__TokenKind kind = p->tok.kind;
				_result_void _t4 = x__json2__Parser_next_with_err(p);
				if (_t4.is_error) {
					_result_x__json2__Any _t5;
					memcpy(&_t5, &_t4, sizeof(_result));
					return _t5;
				}
				
 ;
				if (p->convert_type) {
					#if !defined(CUSTOM_DEFINE_nofloat)
					{
						if (kind == x__json2__TokenKind__float) {
							_result_x__json2__Any _t7;
							_result_ok(&(x__json2__Any[]) { f64_to_sumtype_x__json2__Any/*KEK*/(ADDR(f64, (string_f64(tl)))) }, (_result*)(&_t7), sizeof(x__json2__Any));
							return _t7;
						}
					}
					#endif
					_result_x__json2__Any _t8;
					_result_ok(&(x__json2__Any[]) { i64_to_sumtype_x__json2__Any/*KEK*/(ADDR(i64, (string_i64(tl)))) }, (_result*)(&_t8), sizeof(x__json2__Any));
					return _t8;
				}
				_result_x__json2__Any _t9;
				_result_ok(&(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&tl) }, (_result*)(&_t9), sizeof(x__json2__Any));
				return _t9;
		}
		case x__json2__TokenKind__bool_: {
				string lit = Array_u8_bytestr(p->tok.lit);
				_result_void _t10 = x__json2__Parser_next_with_err(p);
				if (_t10.is_error) {
					_result_x__json2__Any _t11;
					memcpy(&_t11, &_t10, sizeof(_result));
					return _t11;
				}
				
 ;
				if (p->convert_type) {
					_result_x__json2__Any _t12;
					_result_ok(&(x__json2__Any[]) { bool_to_sumtype_x__json2__Any/*KEK*/(ADDR(bool, (string_bool(lit)))) }, (_result*)(&_t12), sizeof(x__json2__Any));
					return _t12;
				}
				_result_x__json2__Any _t13;
				_result_ok(&(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&lit) }, (_result*)(&_t13), sizeof(x__json2__Any));
				return _t13;
		}
		case x__json2__TokenKind__null: {
				_result_void _t14 = x__json2__Parser_next_with_err(p);
				if (_t14.is_error) {
					_result_x__json2__Any _t15;
					memcpy(&_t15, &_t14, sizeof(_result));
					return _t15;
				}
				
 ;
				if (p->convert_type) {
					_result_x__json2__Any _t16;
					_result_ok(&(x__json2__Any[]) { x__json2__Null_to_sumtype_x__json2__Any/*KEK*/(&_const_x__json2__null) }, (_result*)(&_t16), sizeof(x__json2__Any));
					return _t16;
				}
				_result_x__json2__Any _t17;
				_result_ok(&(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("null")))) }, (_result*)(&_t17), sizeof(x__json2__Any));
				return _t17;
		}
		case x__json2__TokenKind__str_: {
				string str = Array_u8_bytestr(p->tok.lit);
				_result_void _t18 = x__json2__Parser_next_with_err(p);
				if (_t18.is_error) {
					_result_x__json2__Any _t19;
					memcpy(&_t19, &_t18, sizeof(_result));
					return _t19;
				}
				
 ;
				_result_x__json2__Any _t20;
				_result_ok(&(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&str) }, (_result*)(&_t20), sizeof(x__json2__Any));
				return _t20;
		}
		case x__json2__TokenKind__none_:
		case x__json2__TokenKind__error:
		case x__json2__TokenKind__eof:
		case x__json2__TokenKind__comma:
		case x__json2__TokenKind__colon:
		case x__json2__TokenKind__rsbr:
		case x__json2__TokenKind__rcbr:
		default: {
				return (_result_x__json2__Any){ .is_error=true, .err=I_x__json2__InvalidTokenError_to_Interface_IError(((x__json2__InvalidTokenError*)memdup(&(x__json2__InvalidTokenError){.DecodeError = ((x__json2__DecodeError){.line = 0,.column = 0,.message = (string){.str=(byteptr)"", .is_lit=1},}),.token = p->tok,.expected = 0,}, sizeof(x__json2__InvalidTokenError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	
	_result_x__json2__Any _t22;
	_result_ok(&(x__json2__Any[]) { x__json2__Null_to_sumtype_x__json2__Any/*KEK*/(&_const_x__json2__null) }, (_result*)(&_t22), sizeof(x__json2__Any));
	return _t22;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL _result_x__json2__Any x__json2__Parser_decode_array(x__json2__Parser* p) {
	Array_x__json2__Any items = __new_array_with_default(0, 0, sizeof(x__json2__Any), 0);
	_result_void _t1 = x__json2__Parser_next_with_err(p);
	if (_t1.is_error) {
		_result_x__json2__Any _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	p->n_level++;
	for (;;) {
		if (!(p->tok.kind != x__json2__TokenKind__rsbr)) break;
		_result_x__json2__Any _t3 = x__json2__Parser_decode_value(p);
		if (_t3.is_error) {
			_result_x__json2__Any _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 		x__json2__Any item =  (*(x__json2__Any*)_t3.data);
		array_push((array*)&items, _MOV((x__json2__Any[]){ item }));
		if (p->tok.kind == x__json2__TokenKind__comma) {
			_result_void _t6 = x__json2__Parser_next_with_err(p);
			if (_t6.is_error) {
				_result_x__json2__Any _t7;
				memcpy(&_t7, &_t6, sizeof(_result));
				return _t7;
			}
			
 ;
			if (p->tok.kind == x__json2__TokenKind__rsbr) {
				return (_result_x__json2__Any){ .is_error=true, .err=I_x__json2__InvalidTokenError_to_Interface_IError(((x__json2__InvalidTokenError*)memdup(&(x__json2__InvalidTokenError){.DecodeError = ((x__json2__DecodeError){.line = 0,.column = 0,.message = (string){.str=(byteptr)"", .is_lit=1},}),.token = p->tok,.expected = 0,}, sizeof(x__json2__InvalidTokenError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		} else if (p->tok.kind != x__json2__TokenKind__rsbr) {
			return (_result_x__json2__Any){ .is_error=true, .err=I_x__json2__UnknownTokenError_to_Interface_IError(((x__json2__UnknownTokenError*)memdup(&(x__json2__UnknownTokenError){.DecodeError = ((x__json2__DecodeError){.line = 0,.column = 0,.message = (string){.str=(byteptr)"", .is_lit=1},}),.token = p->tok,.kind = x__json2__ValueKind__array,}, sizeof(x__json2__UnknownTokenError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_void _t10 = x__json2__Parser_next_with_err(p);
	if (_t10.is_error) {
		_result_x__json2__Any _t11;
		memcpy(&_t11, &_t10, sizeof(_result));
		return _t11;
	}
	
 ;
	p->n_level--;
	_result_x__json2__Any _t12;
	_result_ok(&(x__json2__Any[]) { Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&items) }, (_result*)(&_t12), sizeof(x__json2__Any));
	return _t12;
}

VV_LOCAL_SYMBOL _result_x__json2__Any x__json2__Parser_decode_object(x__json2__Parser* p) {
	Map_string_x__json2__Any fields = new_map(sizeof(string), sizeof(x__json2__Any), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	_result_void _t1 = x__json2__Parser_next_with_err(p);
	if (_t1.is_error) {
		_result_x__json2__Any _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	p->n_level++;
	for (;;) {
		if (!(p->tok.kind != x__json2__TokenKind__rcbr)) break;
		if (p->tok.kind != x__json2__TokenKind__str_) {
			return (_result_x__json2__Any){ .is_error=true, .err=I_x__json2__InvalidTokenError_to_Interface_IError(((x__json2__InvalidTokenError*)memdup(&(x__json2__InvalidTokenError){.DecodeError = ((x__json2__DecodeError){.line = 0,.column = 0,.message = (string){.str=(byteptr)"", .is_lit=1},}),.token = p->tok,.expected = x__json2__TokenKind__str_,}, sizeof(x__json2__InvalidTokenError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		string cur_key = Array_u8_bytestr(p->tok.lit);
		_result_void _t4 = x__json2__Parser_next_with_err(p);
		if (_t4.is_error) {
			_result_x__json2__Any _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 ;
		if (p->tok.kind != x__json2__TokenKind__colon) {
			return (_result_x__json2__Any){ .is_error=true, .err=I_x__json2__InvalidTokenError_to_Interface_IError(((x__json2__InvalidTokenError*)memdup(&(x__json2__InvalidTokenError){.DecodeError = ((x__json2__DecodeError){.line = 0,.column = 0,.message = (string){.str=(byteptr)"", .is_lit=1},}),.token = p->tok,.expected = x__json2__TokenKind__colon,}, sizeof(x__json2__InvalidTokenError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_result_void _t7 = x__json2__Parser_next_with_err(p);
		if (_t7.is_error) {
			_result_x__json2__Any _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 ;
		_result_x__json2__Any _t9 = x__json2__Parser_decode_value(p);
		if (_t9.is_error) {
			_result_x__json2__Any _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 		map_set(&fields, &(string[]){cur_key}, &(x__json2__Any[]) {  (*(x__json2__Any*)_t9.data) });
		if (p->tok.kind != x__json2__TokenKind__comma && p->tok.kind != x__json2__TokenKind__rcbr) {
			return (_result_x__json2__Any){ .is_error=true, .err=I_x__json2__UnknownTokenError_to_Interface_IError(((x__json2__UnknownTokenError*)memdup(&(x__json2__UnknownTokenError){.DecodeError = ((x__json2__DecodeError){.line = 0,.column = 0,.message = (string){.str=(byteptr)"", .is_lit=1},}),.token = p->tok,.kind = x__json2__ValueKind__object,}, sizeof(x__json2__UnknownTokenError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else if (p->tok.kind == x__json2__TokenKind__comma) {
			_result_void _t12 = x__json2__Parser_next_with_err(p);
			if (_t12.is_error) {
				_result_x__json2__Any _t13;
				memcpy(&_t13, &_t12, sizeof(_result));
				return _t13;
			}
			
 ;
		}
	}
	_result_void _t14 = x__json2__Parser_next_with_err(p);
	if (_t14.is_error) {
		_result_x__json2__Any _t15;
		memcpy(&_t15, &_t14, sizeof(_result));
		return _t15;
	}
	
 ;
	p->n_level--;
	_result_x__json2__Any _t16;
	_result_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&fields) }, (_result*)(&_t16), sizeof(x__json2__Any));
	return _t16;
}

_result_void x__json2__Encoder_encode_value_T_x__json2__Any(x__json2__Encoder* e, x__json2__Any val, io__Writer* wr) {
	_result_void _t1 = x__json2__Encoder_encode_value_with_level_T_x__json2__Any(e, val, 1, wr);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}
_result_void x__json2__Encoder_encode_value_T_x__json2__Null(x__json2__Encoder* e, x__json2__Null val, io__Writer* wr) {
	_result_void _t1 = x__json2__Encoder_encode_value_with_level_T_x__json2__Null(e, val, 1, wr);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_newline(x__json2__Encoder* e, int level, io__Writer* wr) {
	if (e->newline != 0) {
		_result_int _t1 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){e->newline})));
		if (_t1.is_error) {
			_result_void _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
  (*(int*)_t1.data);
		for (int j = 0; j < (int)(level * e->newline_spaces_count); j++) {
			_result_int _t3 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__space_bytes);
			if (_t3.is_error) {
				_result_void _t4;
				memcpy(&_t4, &_t3, sizeof(_result));
				return _t4;
			}
			
  (*(int*)_t3.data);
		}
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_any(x__json2__Encoder* e, x__json2__Any val, int level, io__Writer* wr) {
	if (val._typ == 21 /* string */) {
		_result_void _t1 = x__json2__Encoder_encode_string(e, (*val._string), wr);
		if (_t1.is_error) {
			_result_void _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
	}
	else if (val._typ == 19 /* bool */) {
		if ((*val._bool) == true) {
			_result_int _t3 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__true_in_bytes);
			if (_t3.is_error) {
				_result_void _t4;
				memcpy(&_t4, &_t3, sizeof(_result));
				return _t4;
			}
			
  (*(int*)_t3.data);
		} else {
			_result_int _t5 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__false_in_bytes);
			if (_t5.is_error) {
				_result_void _t6;
				memcpy(&_t6, &_t5, sizeof(_result));
				return _t6;
			}
			
  (*(int*)_t5.data);
		}
	}
	else if (val._typ == 5 /* i8 */) {
		_result_int _t7 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(i8_str((*val._i8))));
		if (_t7.is_error) {
			_result_void _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
  (*(int*)_t7.data);
	}
	else if (val._typ == 6 /* i16 */) {
		_result_int _t9 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(i16_str((*val._i16))));
		if (_t9.is_error) {
			_result_void _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
  (*(int*)_t9.data);
	}
	else if (val._typ == 8 /* int */) {
		_result_int _t11 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(int_str((*val._int))));
		if (_t11.is_error) {
			_result_void _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
  (*(int*)_t11.data);
	}
	else if (val._typ == 9 /* i64 */) {
		_result_int _t13 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(i64_str((*val._i64))));
		if (_t13.is_error) {
			_result_void _t14;
			memcpy(&_t14, &_t13, sizeof(_result));
			return _t14;
		}
		
  (*(int*)_t13.data);
	}
	else if (val._typ == 11 /* u8 */) {
		_result_int _t15 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(u8_str((*val._u8))));
		if (_t15.is_error) {
			_result_void _t16;
			memcpy(&_t16, &_t15, sizeof(_result));
			return _t16;
		}
		
  (*(int*)_t15.data);
	}
	else if (val._typ == 12 /* u16 */) {
		_result_int _t17 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(u16_str((*val._u16))));
		if (_t17.is_error) {
			_result_void _t18;
			memcpy(&_t18, &_t17, sizeof(_result));
			return _t18;
		}
		
  (*(int*)_t17.data);
	}
	else if (val._typ == 13 /* u32 */) {
		_result_int _t19 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(u32_str((*val._u32))));
		if (_t19.is_error) {
			_result_void _t20;
			memcpy(&_t20, &_t19, sizeof(_result));
			return _t20;
		}
		
  (*(int*)_t19.data);
	}
	else if (val._typ == 14 /* u64 */) {
		_result_int _t21 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(u64_str((*val._u64))));
		if (_t21.is_error) {
			_result_void _t22;
			memcpy(&_t22, &_t21, sizeof(_result));
			return _t22;
		}
		
  (*(int*)_t21.data);
	}
	else if (val._typ == 16 /* f32 */) {
		#if !defined(CUSTOM_DEFINE_nofloat)
		{
			Array_u8 str_float = string_bytes(f32_str((*val._f32)));
			_result_int _t24 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, str_float);
			if (_t24.is_error) {
				_result_void _t25;
				memcpy(&_t25, &_t24, sizeof(_result));
				return _t25;
			}
			
  (*(int*)_t24.data);
			if ((*(u8*)array_get(str_float, (int)(str_float.len - 1))) == '.') {
				_result_int _t26 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__zero_in_bytes);
				if (_t26.is_error) {
					_result_void _t27;
					memcpy(&_t27, &_t26, sizeof(_result));
					return _t27;
				}
				
  (*(int*)_t26.data);
			}
			return (_result_void){0};
		}
		#endif
		_result_int _t28 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__zero_in_bytes);
		if (_t28.is_error) {
			_result_void _t29;
			memcpy(&_t29, &_t28, sizeof(_result));
			return _t29;
		}
		
  (*(int*)_t28.data);
	}
	else if (val._typ == 17 /* f64 */) {
		#if !defined(CUSTOM_DEFINE_nofloat)
		{
			Array_u8 str_float = string_bytes(f64_str((*val._f64)));
			_result_int _t31 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, str_float);
			if (_t31.is_error) {
				_result_void _t32;
				memcpy(&_t32, &_t31, sizeof(_result));
				return _t32;
			}
			
  (*(int*)_t31.data);
			if ((*(u8*)array_get(str_float, (int)(str_float.len - 1))) == '.') {
				_result_int _t33 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__zero_in_bytes);
				if (_t33.is_error) {
					_result_void _t34;
					memcpy(&_t34, &_t33, sizeof(_result));
					return _t34;
				}
				
  (*(int*)_t33.data);
			}
			return (_result_void){0};
		}
		#endif
		_result_int _t35 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__zero_in_bytes);
		if (_t35.is_error) {
			_result_void _t36;
			memcpy(&_t36, &_t35, sizeof(_result));
			return _t36;
		}
		
  (*(int*)_t35.data);
	}
	else if (val._typ == 173 /* map[string]x.json2.Any */) {
		_result_int _t37 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__curly_open);
		if (_t37.is_error) {
			_result_void _t38;
			memcpy(&_t38, &_t37, sizeof(_result));
			return _t38;
		}
		
  (*(int*)_t37.data);
		int i = 0;
		int _t40 = (*val._Map_string_x__json2__Any).key_values.len;
		for (int _t39 = 0; _t39 < _t40; ++_t39 ) {
			int _t41 = (*val._Map_string_x__json2__Any).key_values.len - _t40;
			_t40 = (*val._Map_string_x__json2__Any).key_values.len;
			if (_t41 < 0) {
				_t39 = -1;
				continue;
			}
			if (!DenseArray_has_index(&(*val._Map_string_x__json2__Any).key_values, _t39)) {continue;}
			string k = /*key*/ *(string*)DenseArray_key(&(*val._Map_string_x__json2__Any).key_values, _t39);
			k = string_clone(k);
			x__json2__Any v = (*(x__json2__Any*)DenseArray_value(&(*val._Map_string_x__json2__Any).key_values, _t39));
			_result_void _t42 = x__json2__Encoder_encode_newline(e, level, wr);
			if (_t42.is_error) {
				_result_void _t43;
				memcpy(&_t43, &_t42, sizeof(_result));
				return _t43;
			}
			
 ;
			_result_void _t44 = x__json2__Encoder_encode_string(e, k, wr);
			if (_t44.is_error) {
				_result_void _t45;
				memcpy(&_t45, &_t44, sizeof(_result));
				return _t45;
			}
			
 ;
			_result_int _t46 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__colon_bytes);
			if (_t46.is_error) {
				_result_void _t47;
				memcpy(&_t47, &_t46, sizeof(_result));
				return _t47;
			}
			
  (*(int*)_t46.data);
			if (e->newline != 0) {
				_result_int _t48 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__space_bytes);
				if (_t48.is_error) {
					_result_void _t49;
					memcpy(&_t49, &_t48, sizeof(_result));
					return _t49;
				}
				
  (*(int*)_t48.data);
			}
			_result_void _t50 = x__json2__Encoder_encode_value_with_level_T_x__json2__Any(e, v, (int)(level + 1), wr);
			if (_t50.is_error) {
				_result_void _t51;
				memcpy(&_t51, &_t50, sizeof(_result));
				return _t51;
			}
			
 ;
			if (i < (int)((*val._Map_string_x__json2__Any).len - 1)) {
				_result_int _t52 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__comma_bytes);
				if (_t52.is_error) {
					_result_void _t53;
					memcpy(&_t53, &_t52, sizeof(_result));
					return _t53;
				}
				
  (*(int*)_t52.data);
			}
			i++;
		}
		_result_void _t54 = x__json2__Encoder_encode_newline(e, (int)(level - 1), wr);
		if (_t54.is_error) {
			_result_void _t55;
			memcpy(&_t55, &_t54, sizeof(_result));
			return _t55;
		}
		
 ;
		_result_int _t56 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__curly_close);
		if (_t56.is_error) {
			_result_void _t57;
			memcpy(&_t57, &_t56, sizeof(_result));
			return _t57;
		}
		
  (*(int*)_t56.data);
	}
	else if (val._typ == 174 /* []x.json2.Any */) {
		_result_int _t58 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)('['))})));
		if (_t58.is_error) {
			_result_void _t59;
			memcpy(&_t59, &_t58, sizeof(_result));
			return _t59;
		}
		
  (*(int*)_t58.data);
		for (int i = 0; i < (*val._Array_x__json2__Any).len; ++i) {
			_result_void _t60 = x__json2__Encoder_encode_newline(e, level, wr);
			if (_t60.is_error) {
				_result_void _t61;
				memcpy(&_t61, &_t60, sizeof(_result));
				return _t61;
			}
			
 ;
			_result_void _t62 = x__json2__Encoder_encode_value_with_level_T_x__json2__Any(e, (*(x__json2__Any*)array_get((*val._Array_x__json2__Any), i)), (int)(level + 1), wr);
			if (_t62.is_error) {
				_result_void _t63;
				memcpy(&_t63, &_t62, sizeof(_result));
				return _t63;
			}
			
 ;
			if (i < (int)((*val._Array_x__json2__Any).len - 1)) {
				_result_int _t64 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__comma_bytes);
				if (_t64.is_error) {
					_result_void _t65;
					memcpy(&_t65, &_t64, sizeof(_result));
					return _t65;
				}
				
  (*(int*)_t64.data);
			}
		}
		_result_void _t66 = x__json2__Encoder_encode_newline(e, (int)(level - 1), wr);
		if (_t66.is_error) {
			_result_void _t67;
			memcpy(&_t67, &_t66, sizeof(_result));
			return _t67;
		}
		
 ;
		_result_int _t68 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)(']'))})));
		if (_t68.is_error) {
			_result_void _t69;
			memcpy(&_t69, &_t68, sizeof(_result));
			return _t69;
		}
		
  (*(int*)_t68.data);
	}
	else if (val._typ == 176 /* time.Time */) {
	}
	else if (val._typ == 170 /* x.json2.Null */) {
		_result_int _t70 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__null_in_bytes);
		if (_t70.is_error) {
			_result_void _t71;
			memcpy(&_t71, &_t70, sizeof(_result));
			return _t71;
		}
		
  (*(int*)_t70.data);
	}
	
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_value_with_level_T_x__json2__Any(x__json2__Encoder* e, x__json2__Any val, int level, io__Writer* wr) {
	#if 117 == 21 && false == false
	{
	}
	#elif 117 == 117 && false == false
	{
		_result_void _t2 = x__json2__Encoder_encode_any(e, val, level, wr);
		if (_t2.is_error) {
			_result_void _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
	}
	#endif
	return (_result_void){0};
}
VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_value_with_level_T_x__json2__Null(x__json2__Encoder* e, x__json2__Null val, int level, io__Writer* wr) {
	#if 170 == 21 && false == false
	{
	}
	#elif 170 == 117 && false == false
	{
	}
	#elif 170 == 173 && false == false
	{
	}
	#elif 0
	{
	}
	#elif 170 == 174 && false == false
	{
	}
	#elif 0
	{
	}
	#elif 1
	{
		_result_void _t2 = x__json2__Encoder_encode_struct_T_x__json2__Null(e, val, level, wr);
		if (_t2.is_error) {
			_result_void _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
	}
	#endif
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_struct_T_x__json2__Null(x__json2__Encoder* e, x__json2__Null val, int level, io__Writer* wr) {
	_result_int _t1 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__curly_open);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(int*)_t1.data);
	int i = 0;
	int fields_len = 0;
	/* $for field in x.json2.Null.fields */ {
			FieldData field = {0};
		/* field 0 */ {
			field.name = _SLIT("is_null");
			field.attrs = __new_array_with_default(0, 0, sizeof(string), 0);
			field.typ = 19;
			field.unaliased_typ = 19;
			field.is_pub = false;
			field.is_mut = false;
			field.is_shared = false;
			field.is_atomic = false;
			field.is_option = false;
			field.is_array = false;
			field.is_map = false;
			field.is_chan = false;
			field.is_struct = false;
			field.is_alias = false;
			field.is_enum = false;
			field.indirections = 0;
			if (!string__eq(val.is_null ? _SLIT("true") : _SLIT("false"), _SLIT("Option(none)"))) {
				fields_len++;
			}
		}
	}// $for
	/* $for field in x.json2.Null.fields */ {
			FieldData field = {0};
		/* field 0 */ {
			field.name = _SLIT("is_null");
			field.attrs = __new_array_with_default(0, 0, sizeof(string), 0);
			field.typ = 19;
			field.unaliased_typ = 19;
			field.is_pub = false;
			field.is_mut = false;
			field.is_shared = false;
			field.is_atomic = false;
			field.is_option = false;
			field.is_array = false;
			field.is_map = false;
			field.is_chan = false;
			field.is_struct = false;
			field.is_alias = false;
			field.is_enum = false;
			field.indirections = 0;
			bool ignore_field = false;
			bool value = val.is_null;
			bool is_nil = string__eq(val.is_null ? _SLIT("true") : _SLIT("false"), _SLIT("&nil"));
			string json_name = _SLIT("");
			for (int _t3 = 0; _t3 < field.attrs.len; ++_t3) {
				string attr = ((string*)field.attrs.data)[_t3];
				if (string_contains(attr, _SLIT("json: "))) {
					json_name = string_replace(attr, _SLIT("json: "), _SLIT(""));
					break;
				}
			}
			#if false
			{
			}
			#else
			{
				bool is_none = string__eq(val.is_null ? _SLIT("true") : _SLIT("false"), _SLIT("unknown sum type value"));
				if (!is_none && !is_nil) {
					_result_void _t5 = x__json2__Encoder_encode_newline(e, level, wr);
					if (_t5.is_error) {
						_result_void _t6;
						memcpy(&_t6, &_t5, sizeof(_result));
						return _t6;
					}
					
 ;
					if ((json_name).len != 0) {
						_result_void _t7 = x__json2__Encoder_encode_string(e, json_name, wr);
						if (_t7.is_error) {
							_result_void _t8;
							memcpy(&_t8, &_t7, sizeof(_result));
							return _t8;
						}
						
 ;
					} else {
						_result_void _t9 = x__json2__Encoder_encode_string(e, field.name, wr);
						if (_t9.is_error) {
							_result_void _t10;
							memcpy(&_t10, &_t9, sizeof(_result));
							return _t10;
						}
						
 ;
					}
					_result_int _t11 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__colon_bytes);
					if (_t11.is_error) {
						_result_void _t12;
						memcpy(&_t12, &_t11, sizeof(_result));
						return _t12;
					}
					
  (*(int*)_t11.data);
					if (e->newline != 0) {
						_result_int _t13 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__space_bytes);
						if (_t13.is_error) {
							_result_void _t14;
							memcpy(&_t14, &_t13, sizeof(_result));
							return _t14;
						}
						
  (*(int*)_t13.data);
					}
				}
				#if 0
				{
				}
				#elif 19 == 21 && false == false
				{
				}
				#elif 19 == 176 && false == false
				{
				}
				#elif 1
				{
					_result_int _t16 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(val.is_null ? _SLIT("true") : _SLIT("false")));
					if (_t16.is_error) {
						_result_void _t17;
						memcpy(&_t17, &_t16, sizeof(_result));
						return _t17;
					}
					
  (*(int*)_t16.data);
				}
				#endif
			}
			#endif
			if (i < (int)(fields_len - 1) && !ignore_field) {
				if (!is_nil) {
					_result_int _t18 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__comma_bytes);
					if (_t18.is_error) {
						_result_void _t19;
						memcpy(&_t19, &_t18, sizeof(_result));
						return _t19;
					}
					
  (*(int*)_t18.data);
				}
			}
			if (!ignore_field) {
				i++;
			}
		}
	}// $for
	_result_void _t20 = x__json2__Encoder_encode_newline(e, (int)(level - 1), wr);
	if (_t20.is_error) {
		_result_void _t21;
		memcpy(&_t21, &_t20, sizeof(_result));
		return _t21;
	}
	
 ;
	_result_int _t22 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__curly_close);
	if (_t22.is_error) {
		_result_void _t23;
		memcpy(&_t23, &_t22, sizeof(_result));
		return _t23;
	}
	
  (*(int*)_t22.data);
	return (_result_void){0};
}

string Map_string_x__json2__Any_str(Map_string_x__json2__Any f) {
	string _t1 = x__json2__Any_json_str(Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&f));
	return _t1;
}

string Array_x__json2__Any_str(Array_x__json2__Any f) {
	string _t1 = x__json2__Any_json_str(Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&f));
	return _t1;
}

string x__json2__Any_str(x__json2__Any f) {
	if ((f)._typ == 21 /* string */) {
		return (*f._string);
	} else {
		string _t2 = x__json2__Any_json_str(f);
		return _t2;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

// Attr: [manualfree]
string x__json2__Any_json_str(x__json2__Any f) {
	string _t1 = x__json2__encode_T_x__json2__Any(f);
	return _t1;
}

// Attr: [manualfree]
string x__json2__Any_prettify_json_str(x__json2__Any f) {
	bool x__json2__Any_prettify_json_str_defer_0 = false;
	strings__Builder* sb;
	sb = HEAP(strings__Builder, (strings__new_builder(4096)));
	x__json2__Any_prettify_json_str_defer_0 = true;
	x__json2__Encoder enc = ((x__json2__Encoder){.newline = '\n',.newline_spaces_count = 2,.escape_unicode = true,});
	_result_void _t1 = x__json2__Encoder_encode_value_T_x__json2__Any(&enc, f, HEAP(io__Writer, /*&io.Writer*/I_strings__Builder_to_Interface_io__Writer(&(*(sb)))));
	if (_t1.is_error) {
		IError err = _t1.err;
	}
	
 ;
	string _t2 = strings__Builder_str(&(*(sb)));
		// Defer begin
		if (x__json2__Any_prettify_json_str_defer_0) {
			strings__Builder_free(&(*(sb)));
		}
		// Defer end
	return _t2;
}

VV_LOCAL_SYMBOL _option_int x__json2__CharLengthIterator_next(x__json2__CharLengthIterator* iter) {
	bool x__json2__CharLengthIterator_next_defer_0 = false;
	if (iter->idx >= iter->text.len) {
		return (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	x__json2__CharLengthIterator_next_defer_0 = true;
	int len = 1;
	u8 c = string_at(iter->text, iter->idx);
	if (((c & ((1 << 7)))) != 0) {
		for (u8 t = ((u8)((1 << 6))); ((c & t)) != 0; t >>= 1) {
			len++;
			iter->idx++;
		}
	}
	_option_int _t2;
	_option_ok(&(int[]) { len }, (_option*)(&_t2), sizeof(int));
		// Defer begin
		if (x__json2__CharLengthIterator_next_defer_0) {
			iter->idx++;
		}
		// Defer end
	return _t2;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL _result_void x__json2__Encoder_encode_string(x__json2__Encoder* e, string s, io__Writer* wr) {
	x__json2__CharLengthIterator char_lens = ((x__json2__CharLengthIterator){.text = s,.idx = 0,});
	int i = 0;
	_result_int _t1 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__quote_bytes);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(int*)_t1.data);
	x__json2__CharLengthIterator _t3 = char_lens;
	while (1) {
		_option_int _t4 = x__json2__CharLengthIterator_next(&_t3);
		if (_t4.state != 0) break;
		int char_len = *(int*)_t4.data;
		if (char_len == 1) {
			u8 chr = string_at(s, i);
			if (Array_rune_contains(_const_x__json2__important_escapable_chars, chr)) {
				for (int j = 0; j < _const_x__json2__important_escapable_chars.len; j++) {
					if (chr == (*(rune*)array_get(_const_x__json2__important_escapable_chars, j))) {
						_result_int _t5 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, (*(Array_u8*)array_get(_const_x__json2__escaped_chars, j)));
						if (_t5.is_error) {
							_result_void _t6;
							memcpy(&_t6, &_t5, sizeof(_result));
							return _t6;
						}
						
  (*(int*)_t5.data);
						break;
					}
				}
			} else if (chr == '"' || chr == '/' || chr == '\\') {
				_result_int _t7 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, new_array_from_c_array_noscan(2, 2, sizeof(u8), _MOV((u8[2]){((u8)('\\')), chr})));
				if (_t7.is_error) {
					_result_void _t8;
					memcpy(&_t8, &_t7, sizeof(_result));
					return _t8;
				}
				
  (*(int*)_t7.data);
			} else if (((int)(chr)) < 0x20) {
				Array_u8 hex_code = string_bytes(u8_hex(chr));
				_result_int _t9 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__unicode_escape_chars);
				if (_t9.is_error) {
					_result_void _t10;
					memcpy(&_t10, &_t9, sizeof(_result));
					return _t10;
				}
				
  (*(int*)_t9.data);
				_result_int _t11 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__zero_in_bytes);
				if (_t11.is_error) {
					_result_void _t12;
					memcpy(&_t12, &_t11, sizeof(_result));
					return _t12;
				}
				
  (*(int*)_t11.data);
				_result_int _t13 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__zero_in_bytes);
				if (_t13.is_error) {
					_result_void _t14;
					memcpy(&_t14, &_t13, sizeof(_result));
					return _t14;
				}
				
  (*(int*)_t13.data);
				_result_int _t15 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, hex_code);
				if (_t15.is_error) {
					_result_void _t16;
					memcpy(&_t16, &_t15, sizeof(_result));
					return _t16;
				}
				
  (*(int*)_t15.data);
			} else {
				_result_int _t17 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)(chr))})));
				if (_t17.is_error) {
					_result_void _t18;
					memcpy(&_t18, &_t17, sizeof(_result));
					return _t18;
				}
				
  (*(int*)_t17.data);
			}
		} else {
			string slice = string_substr(s, i, (int)(i + char_len));
			Array_u8 hex_code = string_bytes(int_hex(string_utf32_code(slice)));
			if (!e->escape_unicode || hex_code.len < 4) {
				_result_int _t19 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, string_bytes(slice));
				if (_t19.is_error) {
					_result_void _t20;
					memcpy(&_t20, &_t19, sizeof(_result));
					return _t20;
				}
				
  (*(int*)_t19.data);
			} else if (hex_code.len == 4) {
				_result_int _t21 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__unicode_escape_chars);
				if (_t21.is_error) {
					_result_void _t22;
					memcpy(&_t22, &_t21, sizeof(_result));
					return _t22;
				}
				
  (*(int*)_t21.data);
				_result_int _t23 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, hex_code);
				if (_t23.is_error) {
					_result_void _t24;
					memcpy(&_t24, &_t23, sizeof(_result));
					return _t24;
				}
				
  (*(int*)_t23.data);
			} else {
				_result_int _t25 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__space_bytes);
				if (_t25.is_error) {
					_result_void _t26;
					memcpy(&_t26, &_t25, sizeof(_result));
					return _t26;
				}
				
  (*(int*)_t25.data);
			}
			{ // Unsafe block
				string_free(&slice);
				array_free(&hex_code);
			}
		}
		i += char_len;
	}
	_result_int _t27 = io__Writer_name_table[wr->_typ]._method_write(wr->_object, _const_x__json2__quote_bytes);
	if (_t27.is_error) {
		_result_void _t28;
		memcpy(&_t28, &_t27, sizeof(_result));
		return _t28;
	}
	
  (*(int*)_t27.data);
	return (_result_void){0};
}

_result_x__json2__Any x__json2__raw_decode(string src) {
	x__json2__Parser p = x__json2__new_parser(src, true);
	_result_x__json2__Any _t1 = x__json2__Parser_decode(&p);
	return _t1;
}

_result_x__json2__Any x__json2__fast_raw_decode(string src) {
	x__json2__Parser p = x__json2__new_parser(src, false);
	_result_x__json2__Any _t1 = x__json2__Parser_decode(&p);
	return _t1;
}

string x__json2__encode_T_x__json2__Any(x__json2__Any val) {
	bool x__json2__encode_T_x__json2__Any_defer_0 = false;
	strings__Builder* sb;
	#if 0
	{
	}
	#else
	{
		sb = HEAP(strings__Builder, (strings__new_builder(64)));
		x__json2__encode_T_x__json2__Any_defer_0 = true;
		_result_void _t2 = x__json2__Encoder_encode_value_T_x__json2__Any(&_const_x__json2__default_encoder, val, HEAP(io__Writer, /*&io.Writer*/I_strings__Builder_to_Interface_io__Writer(&(*(sb)))));
		if (_t2.is_error) {
			IError err = _t2.err;
			println(IError_str(err));
			_result_void _t3 = x__json2__Encoder_encode_value_T_x__json2__Null(&_const_x__json2__default_encoder, _const_x__json2__null, HEAP(io__Writer, /*&io.Writer*/I_strings__Builder_to_Interface_io__Writer(&(*(sb)))));
			if (_t3.is_error) {
				IError err = _t3.err;
			}
			
 ;
		;
		}
		
 ;
		string _t4 = strings__Builder_str(&(*(sb)));
			// Defer begin
			if (x__json2__encode_T_x__json2__Any_defer_0) {
				#if 0
		#else
					strings__Builder_free(&(*(sb)));
				
				#endif
			}
			// Defer end
		return _t4;
	}
	#endif
	return (string){.str=(byteptr)"", .is_lit=1};
}

i8 x__json2__Any_i8(x__json2__Any f) {
	if (f._typ == 5 /* i8 */) {
		return (*f._i8);
	}
	else if (f._typ == 6 /* i16 */) {
		i8 _t2 = ((i8)((*f._i16)));
		return _t2;
	}
	else if (f._typ == 8 /* int */) {
		i8 _t3 = ((i8)((*f._int)));
		return _t3;
	}
	else if (f._typ == 9 /* i64 */) {
		i8 _t4 = ((i8)((*f._i64)));
		return _t4;
	}
	else if (f._typ == 11 /* u8 */) {
		i8 _t5 = ((i8)((*f._u8)));
		return _t5;
	}
	else if (f._typ == 12 /* u16 */) {
		i8 _t6 = ((i8)((*f._u16)));
		return _t6;
	}
	else if (f._typ == 13 /* u32 */) {
		i8 _t7 = ((i8)((*f._u32)));
		return _t7;
	}
	else if (f._typ == 14 /* u64 */) {
		i8 _t8 = ((i8)((*f._u64)));
		return _t8;
	}
	else if (f._typ == 16 /* f32 */) {
		i8 _t9 = ((i8)((*f._f32)));
		return _t9;
	}
	else if (f._typ == 17 /* f64 */) {
		i8 _t10 = ((i8)((*f._f64)));
		return _t10;
	}
	else if (f._typ == 19 /* bool */) {
		i8 _t11 = ((i8)((*f._bool)));
		return _t11;
	}
	else if (f._typ == 21 /* string */) {
		i8 _t12 = string_i8((*f._string));
		return _t12;
	}
	
	else {
		i8 _t13 = 0;
		return _t13;
	}
	
	return 0;
}

i16 x__json2__Any_i16(x__json2__Any f) {
	if (f._typ == 6 /* i16 */) {
		return (*f._i16);
	}
	else if (f._typ == 5 /* i8 */) {
		i16 _t2 = ((i16)((*f._i8)));
		return _t2;
	}
	else if (f._typ == 8 /* int */) {
		i16 _t3 = ((i16)((*f._int)));
		return _t3;
	}
	else if (f._typ == 9 /* i64 */) {
		i16 _t4 = ((i16)((*f._i64)));
		return _t4;
	}
	else if (f._typ == 11 /* u8 */) {
		i16 _t5 = ((i16)((*f._u8)));
		return _t5;
	}
	else if (f._typ == 12 /* u16 */) {
		i16 _t6 = ((i16)((*f._u16)));
		return _t6;
	}
	else if (f._typ == 13 /* u32 */) {
		i16 _t7 = ((i16)((*f._u32)));
		return _t7;
	}
	else if (f._typ == 14 /* u64 */) {
		i16 _t8 = ((i16)((*f._u64)));
		return _t8;
	}
	else if (f._typ == 16 /* f32 */) {
		i16 _t9 = ((i16)((*f._f32)));
		return _t9;
	}
	else if (f._typ == 17 /* f64 */) {
		i16 _t10 = ((i16)((*f._f64)));
		return _t10;
	}
	else if (f._typ == 19 /* bool */) {
		i16 _t11 = ((i16)((*f._bool)));
		return _t11;
	}
	else if (f._typ == 21 /* string */) {
		i16 _t12 = string_i16((*f._string));
		return _t12;
	}
	
	else {
		i16 _t13 = 0;
		return _t13;
	}
	
	return 0;
}

int x__json2__Any_int(x__json2__Any f) {
	if (f._typ == 8 /* int */) {
		return (*f._int);
	}
	else if (f._typ == 5 /* i8 */) {
		int _t2 = ((int)((*f._i8)));
		return _t2;
	}
	else if (f._typ == 6 /* i16 */) {
		int _t3 = ((int)((*f._i16)));
		return _t3;
	}
	else if (f._typ == 9 /* i64 */) {
		int _t4 = ((int)((*f._i64)));
		return _t4;
	}
	else if (f._typ == 11 /* u8 */) {
		int _t5 = ((int)((*f._u8)));
		return _t5;
	}
	else if (f._typ == 12 /* u16 */) {
		int _t6 = ((int)((*f._u16)));
		return _t6;
	}
	else if (f._typ == 13 /* u32 */) {
		int _t7 = ((int)((*f._u32)));
		return _t7;
	}
	else if (f._typ == 14 /* u64 */) {
		int _t8 = ((int)((*f._u64)));
		return _t8;
	}
	else if (f._typ == 16 /* f32 */) {
		int _t9 = ((int)((*f._f32)));
		return _t9;
	}
	else if (f._typ == 17 /* f64 */) {
		int _t10 = ((int)((*f._f64)));
		return _t10;
	}
	else if (f._typ == 19 /* bool */) {
		int _t11 = ((int)((*f._bool)));
		return _t11;
	}
	else if (f._typ == 21 /* string */) {
		int _t12 = string_int((*f._string));
		return _t12;
	}
	
	else {
		int _t13 = 0;
		return _t13;
	}
	
	return 0;
}

i64 x__json2__Any_i64(x__json2__Any f) {
	if (f._typ == 9 /* i64 */) {
		return (*f._i64);
	}
	else if (f._typ == 5 /* i8 */) {
		i64 _t2 = ((i64)((*f._i8)));
		return _t2;
	}
	else if (f._typ == 6 /* i16 */) {
		i64 _t3 = ((i64)((*f._i16)));
		return _t3;
	}
	else if (f._typ == 8 /* int */) {
		i64 _t4 = ((i64)((*f._int)));
		return _t4;
	}
	else if (f._typ == 11 /* u8 */) {
		i64 _t5 = ((i64)((*f._u8)));
		return _t5;
	}
	else if (f._typ == 12 /* u16 */) {
		i64 _t6 = ((i64)((*f._u16)));
		return _t6;
	}
	else if (f._typ == 13 /* u32 */) {
		i64 _t7 = ((i64)((*f._u32)));
		return _t7;
	}
	else if (f._typ == 14 /* u64 */) {
		i64 _t8 = ((i64)((*f._u64)));
		return _t8;
	}
	else if (f._typ == 16 /* f32 */) {
		i64 _t9 = ((i64)((*f._f32)));
		return _t9;
	}
	else if (f._typ == 17 /* f64 */) {
		i64 _t10 = ((i64)((*f._f64)));
		return _t10;
	}
	else if (f._typ == 19 /* bool */) {
		i64 _t11 = ((i64)((*f._bool)));
		return _t11;
	}
	else if (f._typ == 21 /* string */) {
		i64 _t12 = string_i64((*f._string));
		return _t12;
	}
	
	else {
		i64 _t13 = 0;
		return _t13;
	}
	
	return 0;
}

u64 x__json2__Any_u64(x__json2__Any f) {
	if (f._typ == 14 /* u64 */) {
		return (*f._u64);
	}
	else if (f._typ == 11 /* u8 */) {
		u64 _t2 = ((u64)((*f._u8)));
		return _t2;
	}
	else if (f._typ == 12 /* u16 */) {
		u64 _t3 = ((u64)((*f._u16)));
		return _t3;
	}
	else if (f._typ == 13 /* u32 */) {
		u64 _t4 = ((u64)((*f._u32)));
		return _t4;
	}
	else if (f._typ == 5 /* i8 */) {
		u64 _t5 = ((u64)((*f._i8)));
		return _t5;
	}
	else if (f._typ == 6 /* i16 */) {
		u64 _t6 = ((u64)((*f._i16)));
		return _t6;
	}
	else if (f._typ == 8 /* int */) {
		u64 _t7 = ((u64)((*f._int)));
		return _t7;
	}
	else if (f._typ == 9 /* i64 */) {
		u64 _t8 = ((u64)((*f._i64)));
		return _t8;
	}
	else if (f._typ == 16 /* f32 */) {
		u64 _t9 = ((u64)((*f._f32)));
		return _t9;
	}
	else if (f._typ == 17 /* f64 */) {
		u64 _t10 = ((u64)((*f._f64)));
		return _t10;
	}
	else if (f._typ == 19 /* bool */) {
		u64 _t11 = ((u64)((*f._bool)));
		return _t11;
	}
	else if (f._typ == 21 /* string */) {
		u64 _t12 = string_u64((*f._string));
		return _t12;
	}
	
	else {
		u64 _t13 = 0U;
		return _t13;
	}
	
	return 0;
}

f32 x__json2__Any_f32(x__json2__Any f) {
	if (f._typ == 16 /* f32 */) {
		return (*f._f32);
	}
	else if (f._typ == 19 /* bool */) {
		f32 _t2 = ((f32)((*f._bool)));
		return _t2;
	}
	else if (f._typ == 5 /* i8 */) {
		f32 _t3 = ((f32)((*f._i8)));
		return _t3;
	}
	else if (f._typ == 6 /* i16 */) {
		f32 _t4 = ((f32)((*f._i16)));
		return _t4;
	}
	else if (f._typ == 8 /* int */) {
		f32 _t5 = ((f32)((*f._int)));
		return _t5;
	}
	else if (f._typ == 9 /* i64 */) {
		f32 _t6 = ((f32)((*f._i64)));
		return _t6;
	}
	else if (f._typ == 11 /* u8 */) {
		f32 _t7 = ((f32)((*f._u8)));
		return _t7;
	}
	else if (f._typ == 12 /* u16 */) {
		f32 _t8 = ((f32)((*f._u16)));
		return _t8;
	}
	else if (f._typ == 13 /* u32 */) {
		f32 _t9 = ((f32)((*f._u32)));
		return _t9;
	}
	else if (f._typ == 14 /* u64 */) {
		f32 _t10 = ((f32)((*f._u64)));
		return _t10;
	}
	else if (f._typ == 17 /* f64 */) {
		f32 _t11 = ((f32)((*f._f64)));
		return _t11;
	}
	else if (f._typ == 21 /* string */) {
		f32 _t12 = string_f32((*f._string));
		return _t12;
	}
	
	else {
		f32 _t13 = 0.0;
		return _t13;
	}
	
	return 0;
}

f64 x__json2__Any_f64(x__json2__Any f) {
	if (f._typ == 17 /* f64 */) {
		return (*f._f64);
	}
	else if (f._typ == 5 /* i8 */) {
		f64 _t2 = ((f64)((*f._i8)));
		return _t2;
	}
	else if (f._typ == 6 /* i16 */) {
		f64 _t3 = ((f64)((*f._i16)));
		return _t3;
	}
	else if (f._typ == 8 /* int */) {
		f64 _t4 = ((f64)((*f._int)));
		return _t4;
	}
	else if (f._typ == 9 /* i64 */) {
		f64 _t5 = ((f64)((*f._i64)));
		return _t5;
	}
	else if (f._typ == 11 /* u8 */) {
		f64 _t6 = ((f64)((*f._u8)));
		return _t6;
	}
	else if (f._typ == 12 /* u16 */) {
		f64 _t7 = ((f64)((*f._u16)));
		return _t7;
	}
	else if (f._typ == 13 /* u32 */) {
		f64 _t8 = ((f64)((*f._u32)));
		return _t8;
	}
	else if (f._typ == 14 /* u64 */) {
		f64 _t9 = ((f64)((*f._u64)));
		return _t9;
	}
	else if (f._typ == 16 /* f32 */) {
		f64 _t10 = ((f64)((*f._f32)));
		return _t10;
	}
	else if (f._typ == 21 /* string */) {
		f64 _t11 = string_f64((*f._string));
		return _t11;
	}
	
	else {
		f64 _t12 = 0.0;
		return _t12;
	}
	
	return 0;
}

bool x__json2__Any_bool(x__json2__Any f) {
	if (f._typ == 19 /* bool */) {
		return (*f._bool);
	}
	else if (f._typ == 21 /* string */) {
		if (string__eq((*f._string), _SLIT("false"))) {
			bool _t2 = false;
			return _t2;
		}
		if (string__eq((*f._string), _SLIT("true"))) {
			bool _t3 = true;
			return _t3;
		}
		if ((*f._string).len > 0) {
			bool _t4 = !string__eq((*f._string), _SLIT("0")) && !string__eq((*f._string), _SLIT("0.0"));
			return _t4;
		} else {
			bool _t5 = false;
			return _t5;
		}
	}
	else if (f._typ == 5 /* i8 */) {
		bool _t6 = ((i64)((*f._i8))) != 0;
		return _t6;
	}
	else if (f._typ == 6 /* i16 */) {
		bool _t7 = ((i64)((*f._i16))) != 0;
		return _t7;
	}
	else if (f._typ == 8 /* int */) {
		bool _t8 = ((i64)((*f._int))) != 0;
		return _t8;
	}
	else if (f._typ == 9 /* i64 */) {
		bool _t9 = ((i64)((*f._i64))) != 0;
		return _t9;
	}
	else if (f._typ == 11 /* u8 */) {
		bool _t10 = ((u64)((*f._u8))) != 0U;
		return _t10;
	}
	else if (f._typ == 12 /* u16 */) {
		bool _t11 = ((u64)((*f._u16))) != 0U;
		return _t11;
	}
	else if (f._typ == 13 /* u32 */) {
		bool _t12 = ((u64)((*f._u32))) != 0U;
		return _t12;
	}
	else if (f._typ == 14 /* u64 */) {
		bool _t13 = ((u64)((*f._u64))) != 0U;
		return _t13;
	}
	else if (f._typ == 16 /* f32 */) {
		bool _t14 = ((f64)((*f._f32))) != ((f64)(0.0));
		return _t14;
	}
	else if (f._typ == 17 /* f64 */) {
		bool _t15 = ((f64)((*f._f64))) != ((f64)(0.0));
		return _t15;
	}
	
	else {
		bool _t16 = false;
		return _t16;
	}
	
	return 0;
}

Array_x__json2__Any x__json2__Any_arr(x__json2__Any f) {
	if ((f)._typ == 174 /* []x.json2.Any */) {
		return (*f._Array_x__json2__Any);
	} else if ((f)._typ == 173 /* map[string]x.json2.Any */) {
		Array_x__json2__Any arr = __new_array_with_default(0, 0, sizeof(x__json2__Any), 0);
		int _t3 = (*f._Map_string_x__json2__Any).key_values.len;
		for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
			int _t4 = (*f._Map_string_x__json2__Any).key_values.len - _t3;
			_t3 = (*f._Map_string_x__json2__Any).key_values.len;
			if (_t4 < 0) {
				_t2 = -1;
				continue;
			}
			if (!DenseArray_has_index(&(*f._Map_string_x__json2__Any).key_values, _t2)) {continue;}
			x__json2__Any v = (*(x__json2__Any*)DenseArray_value(&(*f._Map_string_x__json2__Any).key_values, _t2));
			array_push((array*)&arr, _MOV((x__json2__Any[]){ v }));
		}
		return arr;
	}
	Array_x__json2__Any _t7 = new_array_from_c_array(1, 1, sizeof(x__json2__Any), _MOV((x__json2__Any[1]){f}));
	return _t7;
}

Map_string_x__json2__Any x__json2__Any_as_map(x__json2__Any f) {
	if ((f)._typ == 173 /* map[string]x.json2.Any */) {
		return (*f._Map_string_x__json2__Any);
	} else if ((f)._typ == 174 /* []x.json2.Any */) {
		Map_string_x__json2__Any mp = new_map(sizeof(string), sizeof(x__json2__Any), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
		;
		for (int i = 0; i < (*f._Array_x__json2__Any).len; ++i) {
			x__json2__Any fi = ((x__json2__Any*)(*f._Array_x__json2__Any).data)[i];
			map_set(&mp, &(string[]){ str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = i}}, {_SLIT0, 0, { .d_c = 0 }}}))}, &(x__json2__Any[]) { fi });
		}
		return mp;
	}
	Map_string_x__json2__Any _t3 = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[1]){
				_SLIT("0"), 
			}),
			_MOV((x__json2__Any[1]){
				f, 
			})
		)
	
	;
	return _t3;
}

_result_time__Time x__json2__Any_to_time(x__json2__Any f) {
	if (f._typ == 176 /* time.Time */) {
		_result_time__Time _t1;
		_result_ok(&(time__Time[]) { (*f._time__Time) }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	else if (f._typ == 9 /* i64 */) {
		_result_time__Time _t2;
		_result_ok(&(time__Time[]) { time__unix((*f._i64)) }, (_result*)(&_t2), sizeof(time__Time));
		return _t2;
	}
	else if (f._typ == 21 /* string */) {
		bool is_iso8601 = string_at((*f._string), 4) == '-' && string_at((*f._string), 7) == '-';
		if (is_iso8601) {
			_result_time__Time _t4 = time__parse_iso8601((*f._string));
			if (_t4.is_error) {
				_result_time__Time _t5;
				memcpy(&_t5, &_t4, sizeof(_result));
				return _t5;
			}
			
 			_result_time__Time _t3;
			_result_ok(&(time__Time[]) {  (*(time__Time*)_t4.data) }, (_result*)(&_t3), sizeof(time__Time));
			return _t3;
		}
		bool is_rfc3339 = (*f._string).len == 24 && string_at((*f._string), 23) == 'Z' && string_at((*f._string), 10) == 'T';
		if (is_rfc3339) {
			_result_time__Time _t7 = time__parse_rfc3339((*f._string));
			if (_t7.is_error) {
				_result_time__Time _t8;
				memcpy(&_t8, &_t7, sizeof(_result));
				return _t8;
			}
			
 			_result_time__Time _t6;
			_result_ok(&(time__Time[]) {  (*(time__Time*)_t7.data) }, (_result*)(&_t6), sizeof(time__Time));
			return _t6;
		}
		bool is_unix_timestamp = true;
		for (int _t9 = 0; _t9 < (*f._string).len; ++_t9) {
			u8 c = (*f._string).str[_t9];
			if (c == '-' || (c >= '0' && c <= '9')) {
				continue;
			}
			is_unix_timestamp = false;
			break;
		}
		if (is_unix_timestamp) {
			_result_time__Time _t10;
			_result_ok(&(time__Time[]) { time__unix(string_i64((*f._string))) }, (_result*)(&_t10), sizeof(time__Time));
			return _t10;
		}
		_result_time__Time _t12 = time__parse((*f._string));
		if (_t12.is_error) {
			_result_time__Time _t13;
			memcpy(&_t13, &_t12, sizeof(_result));
			return _t13;
		}
		
 		_result_time__Time _t11;
		_result_ok(&(time__Time[]) {  (*(time__Time*)_t12.data) }, (_result*)(&_t11), sizeof(time__Time));
		return _t11;
	}
	
	else {
		return (_result_time__Time){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT("not a time value: "), /*115 &x.json2.Any*/0xfe10, {.d_s = x__json2__Any_str(f)}}, {_SLIT(" of type: "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (f)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_time__Time){0};
}

int x__json2__Token_full_col(x__json2__Token t) {
	int _t1 = (int)(t.col + t.lit.len);
	return _t1;
}

VV_LOCAL_SYMBOL void x__json2__Scanner_move(x__json2__Scanner* s) {
	x__json2__Scanner_move_pos(s, true, true);
}

VV_LOCAL_SYMBOL void x__json2__Scanner_move_pos_with_newlines(x__json2__Scanner* s) {
	x__json2__Scanner_move_pos(s, false, true);
}

VV_LOCAL_SYMBOL void x__json2__Scanner_move_pos(x__json2__Scanner* s, bool include_space, bool include_newlines) {
	s->pos++;
	if (s->pos < s->text.len) {
		if (include_newlines && Array_rune_contains(_const_x__json2__newlines, (*(u8*)array_get(s->text, s->pos)))) {
			s->line++;
			s->col = 0;
			if ((*(u8*)array_get(s->text, s->pos)) == '\r' && (int)(s->pos + 1) < s->text.len && (*(u8*)array_get(s->text, (int)(s->pos + 1))) == '\n') {
				s->pos++;
			}
			for (;;) {
				if (!(s->pos < s->text.len && Array_rune_contains(_const_x__json2__newlines, (*(u8*)array_get(s->text, s->pos))))) break;
				x__json2__Scanner_move(s);
			}
		} else if (include_space && (*(u8*)array_get(s->text, s->pos)) == ' ') {
			s->pos++;
			s->col++;
			for (;;) {
				if (!(s->pos < s->text.len && (*(u8*)array_get(s->text, s->pos)) == ' ')) break;
				x__json2__Scanner_move(s);
			}
		}
	} else {
		s->col++;
	}
}

VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_error(x__json2__Scanner s, string description) {
	x__json2__Token _t1 = x__json2__Scanner_tokenize(s, string_bytes(description), x__json2__TokenKind__error);
	return _t1;
}

VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_tokenize(x__json2__Scanner s, Array_u8 lit, x__json2__TokenKind kind) {
	x__json2__Token _t1 = ((x__json2__Token){.lit = lit,.kind = kind,.line = s.line,.col = s.col,});
	return _t1;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_text_scan(x__json2__Scanner* s) {
	bool has_closed = false;
	Array_u8 chrs = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	for (;;) {
		s->pos++;
		s->col++;
		if (s->pos >= s->text.len) {
			break;
		}
		u8 ch = (*(u8*)array_get(s->text, s->pos));
		if (((int)(s->pos - 1) >= 0 && (*(u8*)array_get(s->text, (int)(s->pos - 1))) != '\\') && ch == '"') {
			has_closed = true;
			break;
		} else if (((int)(s->pos - 1) >= 0 && (*(u8*)array_get(s->text, (int)(s->pos - 1))) != '\\') && Array_rune_contains(_const_x__json2__important_escapable_chars, ch)) {
			x__json2__Token _t1 = x__json2__Scanner_error(/*rec*/*s, _SLIT("character must be escaped with a backslash"));
			return _t1;
		} else if ((s->pos == (int)(s->text.len - 1) && ch == '\\') || ch == ((u8)(0))) {
			x__json2__Token _t2 = x__json2__Scanner_error(/*rec*/*s, _SLIT("invalid backslash escape"));
			return _t2;
		} else if ((int)(s->pos + 1) < s->text.len && ch == '\\') {
			u8 peek = (*(u8*)array_get(s->text, (int)(s->pos + 1)));
			if (Array_rune_contains(_const_x__json2__valid_unicode_escapes, peek)) {
				array_push_noscan((array*)&chrs, _MOV((u8[]){ (*(rune*)map_get((map*)&_const_x__json2__unicode_transform_escapes, &(int[]){((int)(peek))}, &(rune[]){ 0 })) }));
				s->pos++;
				s->col++;
				continue;
			} else if (peek == 'u') {
				if ((int)(s->pos + 5) < s->text.len) {
					s->pos++;
					s->col++;
					Array_u8 codepoint = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
					int codepoint_start = s->pos;
					for (;;) {
						if (!(s->pos < s->text.len && s->pos < (int)(codepoint_start + 4))) break;
						s->pos++;
						s->col++;
						if ((*(u8*)array_get(s->text, s->pos)) == '"') {
							break;
						} else if (!u8_is_hex_digit((*(u8*)array_get(s->text, s->pos)))) {
							string x = u8_ascii_str((*(u8*)array_get(s->text, s->pos)));
							x__json2__Token _t4 = x__json2__Scanner_error(/*rec*/*s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("`"), /*115 &string*/0xfe10, {.d_s = x}}, {_SLIT("` is not a hex digit"), 0, { .d_c = 0 }}})));
							return _t4;
						}
						array_push_noscan((array*)&codepoint, _MOV((u8[]){ (*(u8*)array_get(s->text, s->pos)) }));
					}
					if (codepoint.len != 4) {
						x__json2__Token _t6 = x__json2__Scanner_error(/*rec*/*s, _SLIT("unicode escape must have 4 hex digits"));
						return _t6;
					}
					_result_u64 _t7 = strconv__parse_uint(Array_u8_bytestr(codepoint), 16, 32);
					if (_t7.is_error) {
						IError err = _t7.err;
						*(u64*) _t7.data = 0U;
					}
					
 					u32 val = ((u32)( (*(u64*)_t7.data)));
					string converted = utf32_to_str(val);
					Array_u8 converted_bytes = string_bytes(converted);
					_PUSH_MANY_noscan(&chrs, (converted_bytes), _t8, Array_u8);
					{ // Unsafe block
						string_free(&converted);
						array_free(&converted_bytes);
						array_free(&codepoint);
					}
					continue;
				} else {
					x__json2__Token _t9 = x__json2__Scanner_error(/*rec*/*s, _SLIT("incomplete unicode escape"));
					return _t9;
				}
			} else if (peek == 'U') {
				x__json2__Token _t10 = x__json2__Scanner_error(/*rec*/*s, _SLIT("unicode endpoints must be in lowercase `u`"));
				return _t10;
			} else if (peek == ((u8)(229))) {
				x__json2__Token _t11 = x__json2__Scanner_error(/*rec*/*s, _SLIT("unicode endpoint not allowed"));
				return _t11;
			} else {
				x__json2__Token _t12 = x__json2__Scanner_error(/*rec*/*s, _SLIT("invalid backslash escape"));
				return _t12;
			}
		}
		array_push_noscan((array*)&chrs, _MOV((u8[]){ ch }));
	}
	x__json2__Token tok = x__json2__Scanner_tokenize(/*rec*/*s, chrs, x__json2__TokenKind__str_);
	x__json2__Scanner_move(s);
	if (!has_closed) {
		x__json2__Token _t14 = x__json2__Scanner_error(/*rec*/*s, _SLIT("missing double quotes in string closing"));
		return _t14;
	}
	return tok;
}

VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_num_scan(x__json2__Scanner* s) {
	bool is_fl = false;
	int dot_index = -1;
	Array_u8 digits = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	if ((*(u8*)array_get(s->text, s->pos)) == '-') {
		array_push_noscan((array*)&digits, _MOV((u8[]){ '-' }));
		if (!u8_is_digit((*(u8*)array_get(s->text, (int)(s->pos + 1))))) {
			x__json2__Token _t2 = x__json2__Scanner_invalid_token(/*rec*/*s);
			return _t2;
		}
		x__json2__Scanner_move_pos_with_newlines(s);
	}
	if ((*(u8*)array_get(s->text, s->pos)) == '0' && ((int)(s->pos + 1) < s->text.len && u8_is_digit((*(u8*)array_get(s->text, (int)(s->pos + 1)))))) {
		x__json2__Token _t3 = x__json2__Scanner_error(/*rec*/*s, _SLIT("leading zeroes in a number are not allowed"));
		return _t3;
	}
	for (;;) {
		if (!(s->pos < s->text.len && (u8_is_digit((*(u8*)array_get(s->text, s->pos))) || (!is_fl && (*(u8*)array_get(s->text, s->pos)) == '.')))) break;
		array_push_noscan((array*)&digits, _MOV((u8[]){ (*(u8*)array_get(s->text, s->pos)) }));
		if ((*(u8*)array_get(s->text, s->pos)) == '.') {
			is_fl = true;
			dot_index = (int)(digits.len - 1);
		}
		x__json2__Scanner_move_pos_with_newlines(s);
	}
	if ((int)(dot_index + 1) < s->text.len && array_slice(digits, (int)(dot_index + 1), 2147483647).len == 0) {
		x__json2__Token _t5 = x__json2__Scanner_error(/*rec*/*s, _SLIT("invalid float"));
		return _t5;
	}
	if (s->pos < s->text.len && ((*(u8*)array_get(s->text, s->pos)) == 'e' || (*(u8*)array_get(s->text, s->pos)) == 'E')) {
		array_push_noscan((array*)&digits, _MOV((u8[]){ (*(u8*)array_get(s->text, s->pos)) }));
		x__json2__Scanner_move_pos_with_newlines(s);
		if (s->pos < s->text.len && Array_u8_contains(_const_x__json2__exp_signs, (*(u8*)array_get(s->text, s->pos)))) {
			array_push_noscan((array*)&digits, _MOV((u8[]){ (*(u8*)array_get(s->text, s->pos)) }));
			x__json2__Scanner_move_pos_with_newlines(s);
		}
		int exp_digits_count = 0;
		for (;;) {
			if (!(s->pos < s->text.len && u8_is_digit((*(u8*)array_get(s->text, s->pos))))) break;
			array_push_noscan((array*)&digits, _MOV((u8[]){ (*(u8*)array_get(s->text, s->pos)) }));
			exp_digits_count++;
			x__json2__Scanner_move_pos_with_newlines(s);
		}
		if (exp_digits_count == 0) {
			x__json2__Token _t9 = x__json2__Scanner_error(/*rec*/*s, _SLIT("invalid exponent"));
			return _t9;
		}
	}
	x__json2__TokenKind kind = (is_fl ? (x__json2__TokenKind__float) : (x__json2__TokenKind__int_));
	x__json2__Token _t10 = x__json2__Scanner_tokenize(/*rec*/*s, digits, kind);
	return _t10;
}

VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_invalid_token(x__json2__Scanner s) {
	if ((*(u8*)array_get(s.text, s.pos)) >= 32 && (*(u8*)array_get(s.text, s.pos)) <= 126) {
		string x = u8_ascii_str((*(u8*)array_get(s.text, s.pos)));
		x__json2__Token _t1 = x__json2__Scanner_error(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid token `"), /*115 &string*/0xfe10, {.d_s = x}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		return _t1;
	} else {
		string x = u8_str_escaped((*(u8*)array_get(s.text, s.pos)));
		x__json2__Token _t2 = x__json2__Scanner_error(s,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid token `"), /*115 &string*/0xfe10, {.d_s = x}}, {_SLIT("`"), 0, { .d_c = 0 }}})));
		return _t2;
	}
	return (x__json2__Token){.lit = __new_array_noscan(0, 0, sizeof(u8)),.line = 0,.col = 0,};
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL x__json2__Token x__json2__Scanner_scan(x__json2__Scanner* s) {
	if (s->pos < s->text.len && ((*(u8*)array_get(s->text, s->pos)) == ' ' || Array_rune_contains(_const_x__json2__newlines, (*(u8*)array_get(s->text, s->pos))))) {
		x__json2__Scanner_move(s);
	}
	if (s->pos >= s->text.len) {
		x__json2__Token _t1 = x__json2__Scanner_tokenize(/*rec*/*s, __new_array_with_default_noscan(0, 0, sizeof(u8), 0), x__json2__TokenKind__eof);
		return _t1;
	} else if ((int)(s->pos + 3) < s->text.len && ((*(u8*)array_get(s->text, s->pos)) == 't' || (*(u8*)array_get(s->text, s->pos)) == 'n')) {
		string ident = Array_u8_bytestr(array_slice(s->text, s->pos, (int)(s->pos + 4)));
		if (string__eq(ident, _SLIT("true")) || string__eq(ident, _SLIT("null"))) {
			x__json2__TokenKind kind = x__json2__TokenKind__null;
			if (string__eq(ident, _SLIT("true"))) {
				kind = x__json2__TokenKind__bool_;
			}
			string_free(&ident);
			Array_u8 val = array_slice(s->text, s->pos, (int)(s->pos + 4));
			x__json2__Token tok = x__json2__Scanner_tokenize(/*rec*/*s, val, kind);
			x__json2__Scanner_move(s);
			x__json2__Scanner_move(s);
			x__json2__Scanner_move(s);
			x__json2__Scanner_move(s);
			return tok;
		}
		string_free(&ident);
		x__json2__Token _t3 = x__json2__Scanner_invalid_token(/*rec*/*s);
		return _t3;
	} else if ((int)(s->pos + 4) < s->text.len && (*(u8*)array_get(s->text, s->pos)) == 'f') {
		string ident = Array_u8_bytestr(array_slice(s->text, s->pos, (int)(s->pos + 5)));
		if (string__eq(ident, _SLIT("false"))) {
			string_free(&ident);
			Array_u8 val = array_slice(s->text, s->pos, (int)(s->pos + 5));
			x__json2__Token tok = x__json2__Scanner_tokenize(/*rec*/*s, val, x__json2__TokenKind__bool_);
			x__json2__Scanner_move(s);
			x__json2__Scanner_move(s);
			x__json2__Scanner_move(s);
			x__json2__Scanner_move(s);
			x__json2__Scanner_move(s);
			return tok;
		}
		string_free(&ident);
		x__json2__Token _t5 = x__json2__Scanner_invalid_token(/*rec*/*s);
		return _t5;
	} else if (Array_rune_contains(_const_x__json2__char_list, (*(u8*)array_get(s->text, s->pos)))) {
		u8 chr = (*(u8*)array_get(s->text, s->pos));
		x__json2__Token tok = x__json2__Scanner_tokenize(/*rec*/*s, __new_array_with_default_noscan(0, 0, sizeof(u8), 0), ((x__json2__TokenKind)(((int)(chr)))));
		x__json2__Scanner_move(s);
		return tok;
	} else if ((*(u8*)array_get(s->text, s->pos)) == '"') {
		x__json2__Token _t7 = x__json2__Scanner_text_scan(s);
		return _t7;
	} else if (u8_is_digit((*(u8*)array_get(s->text, s->pos))) || (*(u8*)array_get(s->text, s->pos)) == '-') {
		x__json2__Token _t8 = x__json2__Scanner_num_scan(s);
		return _t8;
	} else {
		x__json2__Token _t9 = x__json2__Scanner_invalid_token(/*rec*/*s);
		return _t9;
	}
	return (x__json2__Token){.lit = __new_array_noscan(0, 0, sizeof(u8)),.line = 0,.col = 0,};
}

// TypeDecl
string x__json2__ValueKind_str(x__json2__ValueKind k) {
	string _t1 = ((k == (x__json2__ValueKind__unknown))? (_SLIT("unknown")) : (k == (x__json2__ValueKind__array))? (_SLIT("array")) : (k == (x__json2__ValueKind__object))? (_SLIT("object")) : (k == (x__json2__ValueKind__string_))? (_SLIT("string")) : (_SLIT("number")));
	return _t1;
}

// Attr: [unsafe]
void crypto__sha1__Digest_free(crypto__sha1__Digest* d) {
	{ // Unsafe block
		array_free(&d->x);
		array_free(&d->h);
	}
}

VV_LOCAL_SYMBOL void crypto__sha1__Digest_init(crypto__sha1__Digest* d) {
	d->x = __new_array_with_default_noscan(_const_crypto__sha1__chunk, 0, sizeof(u8), 0);
	d->h = __new_array_with_default_noscan((5), 0, sizeof(u32), 0);
	crypto__sha1__Digest_reset(d);
}

void crypto__sha1__Digest_reset(crypto__sha1__Digest* d) {
	array_set(&d->h, 0, &(u32[]) { ((u32)(_const_crypto__sha1__init0)) });
	array_set(&d->h, 1, &(u32[]) { ((u32)(_const_crypto__sha1__init1)) });
	array_set(&d->h, 2, &(u32[]) { ((u32)(_const_crypto__sha1__init2)) });
	array_set(&d->h, 3, &(u32[]) { ((u32)(_const_crypto__sha1__init3)) });
	array_set(&d->h, 4, &(u32[]) { ((u32)(_const_crypto__sha1__init4)) });
	d->nx = 0;
	d->len = 0U;
}

VV_LOCAL_SYMBOL crypto__sha1__Digest* crypto__sha1__Digest_clone(crypto__sha1__Digest* d) {
	crypto__sha1__Digest* _t1 = ((crypto__sha1__Digest*)memdup(&(crypto__sha1__Digest){.h = array_clone_to_depth_noscan(&d->h, 0),.x = array_clone_to_depth_noscan(&d->x, 0),.nx = (d)->nx,.len = (d)->len,}, sizeof(crypto__sha1__Digest)));
	return _t1;
}

crypto__sha1__Digest* crypto__sha1__new(void) {
	crypto__sha1__Digest* d = ((crypto__sha1__Digest*)memdup(&(crypto__sha1__Digest){.h = __new_array_noscan(0, 0, sizeof(u32)),.x = __new_array_noscan(0, 0, sizeof(u8)),.nx = 0,.len = 0,}, sizeof(crypto__sha1__Digest)));
	crypto__sha1__Digest_init(d);
	return d;
}

// Attr: [manualfree]
_result_int crypto__sha1__Digest_write(crypto__sha1__Digest* d, Array_u8 p_) {
	int nn = p_.len;
	{ // Unsafe block
		Array_u8 p = p_;
		d->len += ((u64)(nn));
		if (d->nx > 0) {
			int n = copy(&/*111*/(array[]){array_slice(d->x, d->nx, 2147483647)}[0], p);
			d->nx += n;
			if (d->nx == _const_crypto__sha1__chunk) {
				crypto__sha1__block(d, d->x);
				d->nx = 0;
			}
			if (n >= p.len) {
				p = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
			} else {
				p = array_slice(p, n, 2147483647);
			}
		}
		if (p.len >= _const_crypto__sha1__chunk) {
			int n = (p.len & ~((int_literal)(_const_crypto__sha1__chunk - 1)));
			crypto__sha1__block(d, array_slice(p, 0, n));
			if (n >= p.len) {
				p = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
			} else {
				p = array_slice(p, n, 2147483647);
			}
		}
		if (p.len > 0) {
			d->nx = copy(&/*arr*/d->x, p);
		}
	}
	_result_int _t1;
	_result_ok(&(int[]) { nn }, (_result*)(&_t1), sizeof(int));
	return _t1;
}

Array_u8 crypto__sha1__Digest_sum(crypto__sha1__Digest* d, Array_u8 b_in) {
	crypto__sha1__Digest* d0 = crypto__sha1__Digest_clone(d);
	Array_u8 hash = crypto__sha1__Digest_checksum_internal(d0);
	Array_u8 b_out = array_clone_to_depth_noscan(&b_in, 0);
	for (int _t1 = 0; _t1 < hash.len; ++_t1) {
		u8 b = ((u8*)hash.data)[_t1];
		array_push_noscan((array*)&b_out, _MOV((u8[]){ b }));
	}
	return b_out;
}

VV_LOCAL_SYMBOL Array_u8 crypto__sha1__Digest_checksum_internal(crypto__sha1__Digest* d) {
	u64 len = d->len;
	Array_u8 tmp = __new_array_with_default_noscan((64), 0, sizeof(u8), 0);
	array_set(&tmp, 0, &(u8[]) { 0x80 });
	if ((int)(((int)(len)) % 64) < 56) {
		_result_int _t1 = crypto__sha1__Digest_write(d, array_slice(tmp, 0, (int)(56 - (int)(((int)(len)) % 64))));
		if (_t1.is_error) {
			IError err = _t1.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
  (*(int*)_t1.data);
	} else {
		_result_int _t2 = crypto__sha1__Digest_write(d, array_slice(tmp, 0, (int)((int_literal)(64 + 56) - (int)(((int)(len)) % 64))));
		if (_t2.is_error) {
			IError err = _t2.err;
			_v_panic(IError_str(err));
			VUNREACHABLE();
		;
		}
		
  (*(int*)_t2.data);
	}
	len <<= 3U;
	encoding__binary__big_endian_put_u64(&/*arr*/tmp, len);
	_result_int _t3 = crypto__sha1__Digest_write(d, array_slice(tmp, 0, 8));
	if (_t3.is_error) {
		IError err = _t3.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
  (*(int*)_t3.data);
	Array_u8 digest = __new_array_with_default_noscan(_const_crypto__sha1__size, 0, sizeof(u8), 0);
	encoding__binary__big_endian_put_u32(&/*arr*/digest, (*(u32*)array_get(d->h, 0)));
	encoding__binary__big_endian_put_u32(&/*111*/(array[]){array_slice(digest, 4, 2147483647)}[0], (*(u32*)array_get(d->h, 1)));
	encoding__binary__big_endian_put_u32(&/*111*/(array[]){array_slice(digest, 8, 2147483647)}[0], (*(u32*)array_get(d->h, 2)));
	encoding__binary__big_endian_put_u32(&/*111*/(array[]){array_slice(digest, 12, 2147483647)}[0], (*(u32*)array_get(d->h, 3)));
	encoding__binary__big_endian_put_u32(&/*111*/(array[]){array_slice(digest, 16, 2147483647)}[0], (*(u32*)array_get(d->h, 4)));
	return digest;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
Array_u8 crypto__sha1__Digest_checksum(crypto__sha1__Digest* d) {
	Array_u8 _t1 = crypto__sha1__Digest_checksum_internal(d);
	return _t1;
}

Array_u8 crypto__sha1__sum(Array_u8 data) {
	crypto__sha1__Digest* d = crypto__sha1__new();
	_result_int _t1 = crypto__sha1__Digest_write(d, data);
	if (_t1.is_error) {
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
  (*(int*)_t1.data);
	Array_u8 _t2 = crypto__sha1__Digest_checksum_internal(d);
	return _t2;
}

VV_LOCAL_SYMBOL void crypto__sha1__block(crypto__sha1__Digest* dig, Array_u8 p) {
	crypto__sha1__block_generic(dig, p);
}

int crypto__sha1__Digest_size(crypto__sha1__Digest* d) {
	return _const_crypto__sha1__size;
}

int crypto__sha1__Digest_block_size(crypto__sha1__Digest* d) {
	return _const_crypto__sha1__block_size;
}

string crypto__sha1__hexhash(string s) {
	string _t1 = Array_u8_hex(crypto__sha1__sum(string_bytes(s)));
	return _t1;
}

VV_LOCAL_SYMBOL void crypto__sha1__block_generic(crypto__sha1__Digest* dig, Array_u8 p_) {
	{ // Unsafe block
		Array_u8 p = p_;
		Array_u32 w = __new_array_with_default_noscan((16), 0, sizeof(u32), 0);
		u32 h0 = (*(u32*)array_get(dig->h, 0));
		u32 h1 = (*(u32*)array_get(dig->h, 1));
		u32 h2 = (*(u32*)array_get(dig->h, 2));
		u32 h3 = (*(u32*)array_get(dig->h, 3));
		u32 h4 = (*(u32*)array_get(dig->h, 4));
		for (;;) {
			if (!(p.len >= _const_crypto__sha1__chunk)) break;
			for (int i = 0; i < 16; ++i) {
				int j = (int_literal)(i * 4);
				array_set(&w, i, &(u32[]) { ((((((u32)((*(u8*)array_get(p, j)))) << 24U) | (((u32)((*(u8*)array_get(p, (int)(j + 1))))) << 16U)) | (((u32)((*(u8*)array_get(p, (int)(j + 2))))) << 8U)) | ((u32)((*(u8*)array_get(p, (int)(j + 3)))))) });
			}
			u32 a = h0;
			u32 b = h1;
			u32 c = h2;
			u32 d = h3;
			u32 e = h4;
			int i = 0;
			for (;;) {
				if (!(i < 16)) break;
				u32 f = ((b & c) | ((~b) & d));
				u32 t = (u32)((u32)((u32)((u32)(math__bits__rotate_left_32(a, 5) + f) + e) + (*(u32*)array_get(w, (i & 0xf)))) + ((u32)(_const_crypto__sha1___k0)));
				e = d;
				d = c;
				c = math__bits__rotate_left_32(b, 30);
				b = a;
				a = t;
				i++;
			}
			for (;;) {
				if (!(i < 20)) break;
				u32 tmp = ((((*(u32*)array_get(w, (((int)(i - 3)) & 0xf))) ^ (*(u32*)array_get(w, (((int)(i - 8)) & 0xf)))) ^ (*(u32*)array_get(w, (((int)(i - 14)) & 0xf)))) ^ (*(u32*)array_get(w, (i & 0xf))));
				array_set(&w, (i & 0xf), &(u32[]) { (((tmp << 1U)) | ((tmp >> ((int_literal)(32 - 1))))) });
				u32 f = ((b & c) | ((~b) & d));
				u32 t = (u32)((u32)((u32)((u32)(math__bits__rotate_left_32(a, 5) + f) + e) + (*(u32*)array_get(w, (i & 0xf)))) + ((u32)(_const_crypto__sha1___k0)));
				e = d;
				d = c;
				c = math__bits__rotate_left_32(b, 30);
				b = a;
				a = t;
				i++;
			}
			for (;;) {
				if (!(i < 40)) break;
				u32 tmp = ((((*(u32*)array_get(w, (((int)(i - 3)) & 0xf))) ^ (*(u32*)array_get(w, (((int)(i - 8)) & 0xf)))) ^ (*(u32*)array_get(w, (((int)(i - 14)) & 0xf)))) ^ (*(u32*)array_get(w, (i & 0xf))));
				array_set(&w, (i & 0xf), &(u32[]) { (((tmp << 1U)) | ((tmp >> ((int_literal)(32 - 1))))) });
				u32 f = ((b ^ c) ^ d);
				u32 t = (u32)((u32)((u32)((u32)(math__bits__rotate_left_32(a, 5) + f) + e) + (*(u32*)array_get(w, (i & 0xf)))) + ((u32)(_const_crypto__sha1___k1)));
				e = d;
				d = c;
				c = math__bits__rotate_left_32(b, 30);
				b = a;
				a = t;
				i++;
			}
			for (;;) {
				if (!(i < 60)) break;
				u32 tmp = ((((*(u32*)array_get(w, (((int)(i - 3)) & 0xf))) ^ (*(u32*)array_get(w, (((int)(i - 8)) & 0xf)))) ^ (*(u32*)array_get(w, (((int)(i - 14)) & 0xf)))) ^ (*(u32*)array_get(w, (i & 0xf))));
				array_set(&w, (i & 0xf), &(u32[]) { (((tmp << 1U)) | ((tmp >> ((int_literal)(32 - 1))))) });
				u32 f = (((((b | c)) & d)) | ((b & c)));
				u32 t = (u32)((u32)((u32)((u32)(math__bits__rotate_left_32(a, 5) + f) + e) + (*(u32*)array_get(w, (i & 0xf)))) + ((u32)(_const_crypto__sha1___k2)));
				e = d;
				d = c;
				c = math__bits__rotate_left_32(b, 30);
				b = a;
				a = t;
				i++;
			}
			for (;;) {
				if (!(i < 80)) break;
				u32 tmp = ((((*(u32*)array_get(w, (((int)(i - 3)) & 0xf))) ^ (*(u32*)array_get(w, (((int)(i - 8)) & 0xf)))) ^ (*(u32*)array_get(w, (((int)(i - 14)) & 0xf)))) ^ (*(u32*)array_get(w, (i & 0xf))));
				array_set(&w, (i & 0xf), &(u32[]) { (((tmp << 1U)) | ((tmp >> ((int_literal)(32 - 1))))) });
				u32 f = ((b ^ c) ^ d);
				u32 t = (u32)((u32)((u32)((u32)(math__bits__rotate_left_32(a, 5) + f) + e) + (*(u32*)array_get(w, (i & 0xf)))) + ((u32)(_const_crypto__sha1___k3)));
				e = d;
				d = c;
				c = math__bits__rotate_left_32(b, 30);
				b = a;
				a = t;
				i++;
			}
			h0 += a;
			h1 += b;
			h2 += c;
			h3 += d;
			h4 += e;
			if (_const_crypto__sha1__chunk >= p.len) {
				p = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
			} else {
				p = array_slice(p, _const_crypto__sha1__chunk, 2147483647);
			}
		}
		array_set(&dig->h, 0, &(u32[]) { h0 });
		array_set(&dig->h, 1, &(u32[]) { h1 });
		array_set(&dig->h, 2, &(u32[]) { h2 });
		array_set(&dig->h, 3, &(u32[]) { h3 });
		array_set(&dig->h, 4, &(u32[]) { h4 });
	}
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u32 rand__seed__nr_next(u32 prev) {
	u32 _t1 = (u32)((u32)(prev * 1664525U) + 1013904223U);
	return _t1;
}

Array_u32 rand__seed__time_seed_array(int count) {
	u64 ctime = time__sys_mono_now();
	u32 seed = ((u32)(((ctime >> 32U) ^ ((ctime & 0x00000000FFFFFFFFU)))));
	Array_u32 seed_data = __new_array_with_default_noscan(0, count, sizeof(u32), 0);
	for (int _t1 = 0; _t1 < count; ++_t1) {
		seed = rand__seed__nr_next(seed);
		array_push_noscan((array*)&seed_data, _MOV((u32[]){ rand__seed__nr_next(seed) }));
	}
	return seed_data;
}

// Attr: [manualfree]
u32 rand__seed__time_seed_32(void) {
	Array_u32 sa = rand__seed__time_seed_array(1);
	u32 res = (*(u32*)array_get(sa, 0));
	array_free(&sa);
	return res;
}

// Attr: [manualfree]
u64 rand__seed__time_seed_64(void) {
	Array_u32 seed_data = rand__seed__time_seed_array(2);
	u64 lower = ((u64)((*(u32*)array_get(seed_data, 0))));
	u64 upper = ((u64)((*(u32*)array_get(seed_data, 1))));
	array_free(&seed_data);
	u64 res = (lower | ((upper << 32U)));
	return res;
}

string term__format_esc(string code) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("["), /*115 &string*/0xfe10, {.d_s = code}}, {_SLIT("m"), 0, { .d_c = 0 }}}));
	return _t1;
}

string term__format(string msg, string open, string close) {
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("["), /*115 &string*/0xfe10, {.d_s = open}}, {_SLIT("m"), /*115 &string*/0xfe10, {.d_s = msg}}, {_SLIT("["), /*115 &string*/0xfe10, {.d_s = close}}, {_SLIT("m"), 0, { .d_c = 0 }}}));
	return _t1;
}

string term__format_rgb(int r, int g, int b, string msg, string open, string close) {
	string _t1 =  str_intp(7, _MOV((StrIntpData[]){{_SLIT("["), /*115 &string*/0xfe10, {.d_s = open}}, {_SLIT(";2;"), /*100 &int*/0xfe07, {.d_i32 = r}}, {_SLIT(";"), /*100 &int*/0xfe07, {.d_i32 = g}}, {_SLIT(";"), /*100 &int*/0xfe07, {.d_i32 = b}}, {_SLIT("m"), /*115 &string*/0xfe10, {.d_s = msg}}, {_SLIT("["), /*115 &string*/0xfe10, {.d_s = close}}, {_SLIT("m"), 0, { .d_c = 0 }}}));
	return _t1;
}

string term__rgb(int r, int g, int b, string msg) {
	string _t1 = term__format_rgb(r, g, b, msg, _SLIT("38"), _SLIT("39"));
	return _t1;
}

string term__bg_rgb(int r, int g, int b, string msg) {
	string _t1 = term__format_rgb(r, g, b, msg, _SLIT("48"), _SLIT("49"));
	return _t1;
}

string term__hex(int hex, string msg) {
	string _t1 = term__format_rgb((hex >> 16), ((hex >> 8) & 0xFF), (hex & 0xFF), msg, _SLIT("38"), _SLIT("39"));
	return _t1;
}

string term__bg_hex(int hex, string msg) {
	string _t1 = term__format_rgb((hex >> 16), ((hex >> 8) & 0xFF), (hex & 0xFF), msg, _SLIT("48"), _SLIT("49"));
	return _t1;
}

string term__reset(string msg) {
	string _t1 = term__format(msg, _SLIT("0"), _SLIT("0"));
	return _t1;
}

string term__bold(string msg) {
	string _t1 = term__format(msg, _SLIT("1"), _SLIT("22"));
	return _t1;
}

string term__dim(string msg) {
	string _t1 = term__format(msg, _SLIT("2"), _SLIT("22"));
	return _t1;
}

string term__italic(string msg) {
	string _t1 = term__format(msg, _SLIT("3"), _SLIT("23"));
	return _t1;
}

string term__underline(string msg) {
	string _t1 = term__format(msg, _SLIT("4"), _SLIT("24"));
	return _t1;
}

string term__slow_blink(string msg) {
	string _t1 = term__format(msg, _SLIT("5"), _SLIT("25"));
	return _t1;
}

string term__rapid_blink(string msg) {
	string _t1 = term__format(msg, _SLIT("6"), _SLIT("26"));
	return _t1;
}

string term__inverse(string msg) {
	string _t1 = term__format(msg, _SLIT("7"), _SLIT("27"));
	return _t1;
}

string term__hidden(string msg) {
	string _t1 = term__format(msg, _SLIT("8"), _SLIT("28"));
	return _t1;
}

string term__strikethrough(string msg) {
	string _t1 = term__format(msg, _SLIT("9"), _SLIT("29"));
	return _t1;
}

string term__black(string msg) {
	string _t1 = term__format(msg, _SLIT("30"), _SLIT("39"));
	return _t1;
}

string term__red(string msg) {
	string _t1 = term__format(msg, _SLIT("31"), _SLIT("39"));
	return _t1;
}

string term__green(string msg) {
	string _t1 = term__format(msg, _SLIT("32"), _SLIT("39"));
	return _t1;
}

string term__yellow(string msg) {
	string _t1 = term__format(msg, _SLIT("33"), _SLIT("39"));
	return _t1;
}

string term__blue(string msg) {
	string _t1 = term__format(msg, _SLIT("34"), _SLIT("39"));
	return _t1;
}

string term__magenta(string msg) {
	string _t1 = term__format(msg, _SLIT("35"), _SLIT("39"));
	return _t1;
}

string term__cyan(string msg) {
	string _t1 = term__format(msg, _SLIT("36"), _SLIT("39"));
	return _t1;
}

string term__white(string msg) {
	string _t1 = term__format(msg, _SLIT("37"), _SLIT("39"));
	return _t1;
}

string term__bg_black(string msg) {
	string _t1 = term__format(msg, _SLIT("40"), _SLIT("49"));
	return _t1;
}

string term__bg_red(string msg) {
	string _t1 = term__format(msg, _SLIT("41"), _SLIT("49"));
	return _t1;
}

string term__bg_green(string msg) {
	string _t1 = term__format(msg, _SLIT("42"), _SLIT("49"));
	return _t1;
}

string term__bg_yellow(string msg) {
	string _t1 = term__format(msg, _SLIT("43"), _SLIT("49"));
	return _t1;
}

string term__bg_blue(string msg) {
	string _t1 = term__format(msg, _SLIT("44"), _SLIT("49"));
	return _t1;
}

string term__bg_magenta(string msg) {
	string _t1 = term__format(msg, _SLIT("45"), _SLIT("49"));
	return _t1;
}

string term__bg_cyan(string msg) {
	string _t1 = term__format(msg, _SLIT("46"), _SLIT("49"));
	return _t1;
}

string term__bg_white(string msg) {
	string _t1 = term__format(msg, _SLIT("47"), _SLIT("49"));
	return _t1;
}

string term__gray(string msg) {
	string _t1 = term__bright_black(msg);
	return _t1;
}

string term__bright_black(string msg) {
	string _t1 = term__format(msg, _SLIT("90"), _SLIT("39"));
	return _t1;
}

string term__bright_red(string msg) {
	string _t1 = term__format(msg, _SLIT("91"), _SLIT("39"));
	return _t1;
}

string term__bright_green(string msg) {
	string _t1 = term__format(msg, _SLIT("92"), _SLIT("39"));
	return _t1;
}

string term__bright_yellow(string msg) {
	string _t1 = term__format(msg, _SLIT("93"), _SLIT("39"));
	return _t1;
}

string term__bright_blue(string msg) {
	string _t1 = term__format(msg, _SLIT("94"), _SLIT("39"));
	return _t1;
}

string term__bright_magenta(string msg) {
	string _t1 = term__format(msg, _SLIT("95"), _SLIT("39"));
	return _t1;
}

string term__bright_cyan(string msg) {
	string _t1 = term__format(msg, _SLIT("96"), _SLIT("39"));
	return _t1;
}

string term__bright_white(string msg) {
	string _t1 = term__format(msg, _SLIT("97"), _SLIT("39"));
	return _t1;
}

string term__bright_bg_black(string msg) {
	string _t1 = term__format(msg, _SLIT("100"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_red(string msg) {
	string _t1 = term__format(msg, _SLIT("101"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_green(string msg) {
	string _t1 = term__format(msg, _SLIT("102"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_yellow(string msg) {
	string _t1 = term__format(msg, _SLIT("103"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_blue(string msg) {
	string _t1 = term__format(msg, _SLIT("104"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_magenta(string msg) {
	string _t1 = term__format(msg, _SLIT("105"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_cyan(string msg) {
	string _t1 = term__format(msg, _SLIT("106"), _SLIT("49"));
	return _t1;
}

string term__bright_bg_white(string msg) {
	string _t1 = term__format(msg, _SLIT("107"), _SLIT("49"));
	return _t1;
}

string term__highlight_command(string command) {
	string _t1 = term__bright_white(term__bg_cyan( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), /*115 &string*/0xfe10, {.d_s = command}}, {_SLIT(" "), 0, { .d_c = 0 }}}))));
	return _t1;
}

void term__set_cursor_position(term__Coord c) {
	print(string__plus( str_intp(3, _MOV((StrIntpData[]){{_SLIT("["), /*100 &int*/0xfe07, {.d_i32 = c.y}}, {_SLIT(";"), /*100 &int*/0xfe07, {.d_i32 = c.x}}, {_SLIT0, 0, { .d_c = 0 }}})), _SLIT("H")));
	flush_stdout();
}

void term__move(int n, string direction) {
	print( str_intp(3, _MOV((StrIntpData[]){{_SLIT("["), /*100 &int*/0xfe07, {.d_i32 = n}}, {_SLIT0, /*115 &string*/0xfe10, {.d_s = direction}}, {_SLIT0, 0, { .d_c = 0 }}})));
	flush_stdout();
}

void term__cursor_up(int n) {
	term__move(n, _SLIT("A"));
}

void term__cursor_down(int n) {
	term__move(n, _SLIT("B"));
}

void term__cursor_forward(int n) {
	term__move(n, _SLIT("C"));
}

void term__cursor_back(int n) {
	term__move(n, _SLIT("D"));
}

void term__erase_display(string t) {
	print(string__plus(string__plus(_SLIT("\033["), t), _SLIT("J")));
	flush_stdout();
}

void term__erase_toend(void) {
	term__erase_display(_SLIT("0"));
}

void term__erase_tobeg(void) {
	term__erase_display(_SLIT("1"));
}

void term__erase_clear(void) {
	print(_SLIT("\033[H\033[J"));
	flush_stdout();
}

void term__erase_del_clear(void) {
	term__erase_display(_SLIT("3"));
}

void term__erase_line(string t) {
	print(string__plus(string__plus(_SLIT("\033["), t), _SLIT("K")));
	flush_stdout();
}

void term__erase_line_toend(void) {
	term__erase_line(_SLIT("0"));
}

void term__erase_line_tobeg(void) {
	term__erase_line(_SLIT("1"));
}

void term__erase_line_clear(void) {
	term__erase_line(_SLIT("2"));
}

void term__show_cursor(void) {
	print(_SLIT("\033[?25h"));
	flush_stdout();
}

void term__hide_cursor(void) {
	print(_SLIT("\033[?25l"));
	flush_stdout();
}

void term__clear_previous_line(void) {
	print(_SLIT("\r\033[1A\033[2K"));
	flush_stdout();
}

bool term__can_show_color_on_stdout(void) {
	bool _t1 = term__supports_escape_sequences(1);
	return _t1;
}

bool term__can_show_color_on_stderr(void) {
	bool _t1 = term__supports_escape_sequences(2);
	return _t1;
}

string term__failed(string s) {
	if (term__can_show_color_on_stdout()) {
		string _t1 = term__bg_red(term__bold(term__white(s)));
		return _t1;
	}
	return s;
}

string term__ok_message(string s) {
	if (term__can_show_color_on_stdout()) {
		string _t1 = term__green( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		return _t1;
	}
	return s;
}

string term__fail_message(string s) {
	string _t1 = term__failed( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
	return _t1;
}

string term__warn_message(string s) {
	if (term__can_show_color_on_stdout()) {
		string _t1 = term__bright_yellow( str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT(" "), 0, { .d_c = 0 }}})));
		return _t1;
	}
	return s;
}

string term__colorize(string (*cfn)(string ), string s) {
	if (term__can_show_color_on_stdout()) {
		string _t1 = cfn(s);
		return _t1;
	}
	return s;
}

string term__ecolorize(string (*cfn)(string ), string s) {
	if (term__can_show_color_on_stderr()) {
		string _t1 = cfn(s);
		return _t1;
	}
	return s;
}

string term__strip_ansi(string text) {
	strings__textscanner__TextScanner input = strings__textscanner__new(text);
	Array_u8 output = __new_array_with_default_noscan(0, text.len, sizeof(u8), 0);
	int ch = 0;
	for (;;) {
		if (!(ch != -1)) break;
		ch = strings__textscanner__TextScanner_next(&input);
		if (ch == 27) {
			ch = strings__textscanner__TextScanner_next(&input);
			if (ch == '[') {
				for (;;) {
					ch = strings__textscanner__TextScanner_next(&input);
					if ((ch == ';' || ch == '?') || (ch >= '0' && ch <= '9')) {
						continue;
					}
					break;
				}
			} else if (ch == ']') {
				ch = strings__textscanner__TextScanner_next(&input);
				if (ch >= '0' && ch <= '9') {
					for (;;) {
						ch = strings__textscanner__TextScanner_next(&input);
						if (ch == -1 || ch == 7) {
							break;
						}
						if (ch == 27) {
							ch = strings__textscanner__TextScanner_next(&input);
							break;
						}
					}
				}
			} else if (ch == '%') {
				ch = strings__textscanner__TextScanner_next(&input);
			}
		} else if (ch != -1) {
			array_push_noscan((array*)&output, _MOV((u8[]){ ((u8)(ch)) }));
		}
	}
	string _t2 = Array_u8_bytestr(output);
	return _t2;
}

string term__h_divider(string divider) {
	multi_return_int_int mr_3271 = term__get_terminal_size();
	int cols = mr_3271.arg0;
	string result = _SLIT("");
	if (divider.len > 0) {
		result = string_repeat(divider, (int)(1 + ((int)(cols / divider.len))));
	} else {
		result = string_repeat(_SLIT(" "), (int)(1 + cols));
	}
	string _t1 = string_substr(result, 0, cols);
	return _t1;
}

string term__header_left(string text, string divider) {
	string plain_text = term__strip_ansi(text);
	multi_return_int_int mr_3716 = term__get_terminal_size();
	int xcols = mr_3716.arg0;
	int cols = term__imax(1, xcols);
	string relement = (divider.len > 0 ? (divider) : (_SLIT(" ")));
	string hstart = string_substr(string_repeat(relement, 4), 0, 4);
	int remaining_cols = term__imax(0, ((int)(cols - ((int)((int)((int)(hstart.len + 1) + plain_text.len) + 1)))));
	string hend = string_substr(string_repeat(relement, (int)(((int)(remaining_cols + 1)) / relement.len)), 0, remaining_cols);
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = hstart}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = text}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = hend}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string term__header(string text, string divider) {
	if (text.len == 0) {
		string _t1 = term__h_divider(divider);
		return _t1;
	}
	multi_return_int_int mr_4342 = term__get_terminal_size();
	int xcols = mr_4342.arg0;
	int cols = term__imax(1, xcols);
	int tlimit = term__imax(1, (cols > (int)((int)(text.len + 2) + (int)(2 * divider.len)) ? (text.len) : ((int)((int)(cols - 3) - (int)(2 * divider.len)))));
	int tlimit_aligned = (((int)(tlimit % 2)) != ((int)(cols % 2)) ? ((int)(tlimit + 1)) : (tlimit));
	int tstart = term__imax(0, (int)(((int)(cols - tlimit_aligned)) / 2));
	string ln = _SLIT("");
	if (divider.len > 0) {
		ln = string_substr(string_repeat(divider, (int)(1 + (int)(cols / divider.len))), 0, cols);
	} else {
		ln = string_repeat(_SLIT(" "), (int)(1 + cols));
	}
	if (ln.len == 1) {
		string _t2 = string__plus(string__plus(string__plus(string__plus(ln, _SLIT(" ")), string_substr(text, 0, tlimit)), _SLIT(" ")), ln);
		return _t2;
	}
	string _t3 = string__plus(string__plus(string__plus(string__plus(string_substr(ln, 0, tstart), _SLIT(" ")), string_substr(text, 0, tlimit)), _SLIT(" ")), string_substr(ln, (int)((int)(tstart + tlimit) + 2), cols));
	return _t3;
}

VV_LOCAL_SYMBOL int term__imax(int x, int y) {
	int _t1 = (x > y ? (x) : (y));
	return _t1;
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL bool term__supports_escape_sequences(int fd) {
	bool term__supports_escape_sequences_defer_0 = false;
	string vcolors_override;
	bool term__supports_escape_sequences_defer_1 = false;
	string env_term;
	bool term__supports_escape_sequences_defer_2 = false;
	string env_conemu;
	vcolors_override = os__getenv(_SLIT("VCOLORS"));
	term__supports_escape_sequences_defer_0 = true;
	if (string__eq(vcolors_override, _SLIT("always"))) {
		bool _t1 = true;
			// Defer begin
			if (term__supports_escape_sequences_defer_0) {
				string_free(&vcolors_override);
			}
			// Defer end
		return _t1;
	}
	if (string__eq(vcolors_override, _SLIT("never"))) {
		bool _t2 = false;
			// Defer begin
			if (term__supports_escape_sequences_defer_0) {
				string_free(&vcolors_override);
			}
			// Defer end
		return _t2;
	}
	env_term = os__getenv(_SLIT("TERM"));
	term__supports_escape_sequences_defer_1 = true;
	if (string__eq(env_term, _SLIT("dumb"))) {
		bool _t3 = false;
			// Defer begin
			if (term__supports_escape_sequences_defer_1) {
				string_free(&env_term);
			}
			// Defer end
			// Defer begin
			if (term__supports_escape_sequences_defer_0) {
				string_free(&vcolors_override);
			}
			// Defer end
		return _t3;
	}
	#if defined(_WIN32)
	{
		env_conemu = os__getenv(_SLIT("ConEmuANSI"));
		term__supports_escape_sequences_defer_2 = true;
		if (string__eq(env_conemu, _SLIT("ON"))) {
			bool _t5 = true;
				// Defer begin
				if (term__supports_escape_sequences_defer_2) {
					#if defined(_WIN32)
						string_free(&env_conemu);
					
					#endif
				}
				// Defer end
				// Defer begin
				if (term__supports_escape_sequences_defer_1) {
					string_free(&env_term);
				}
				// Defer end
				// Defer begin
				if (term__supports_escape_sequences_defer_0) {
					string_free(&vcolors_override);
				}
				// Defer end
			return _t5;
		}
		bool _t6 = ((os__is_atty(fd) & 0x0004)) > 0;
			// Defer begin
			if (term__supports_escape_sequences_defer_2) {
				#if defined(_WIN32)
					string_free(&env_conemu);
				
				#endif
			}
			// Defer end
			// Defer begin
			if (term__supports_escape_sequences_defer_1) {
				string_free(&env_term);
			}
			// Defer end
			// Defer begin
			if (term__supports_escape_sequences_defer_0) {
				string_free(&vcolors_override);
			}
			// Defer end
		return _t6;
	}
	#else
	{
	}
	#endif
	return 0;
}

multi_return_int_int term__get_terminal_size(void) {
	if (os__is_atty(1) > 0 && !string__eq(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		CONSOLE_SCREEN_BUFFER_INFO info = ((CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},});
		if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
			int columns = ((int)((u16)((u16)(info.srWindow.Right - info.srWindow.Left) + 1U)));
			int rows = ((int)((u16)((u16)(info.srWindow.Bottom - info.srWindow.Top) + 1U)));
			return (multi_return_int_int){.arg0=columns, .arg1=rows};
		}
	}
	return (multi_return_int_int){.arg0=_const_term__default_columns_size, .arg1=_const_term__default_rows_size};
}

_result_term__Coord term__get_cursor_position(void) {
	term__Coord res = ((term__Coord){.x = 0,.y = 0,});
	if (os__is_atty(1) > 0 && !string__eq(os__getenv(_SLIT("TERM")), _SLIT("dumb"))) {
		CONSOLE_SCREEN_BUFFER_INFO info = ((CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},});
		if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &info)) {
			res.x = info.dwCursorPosition.X;
			res.y = info.dwCursorPosition.Y;
		} else {
			return (_result_term__Coord){ .is_error=true, .err=os__last_error(), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_term__Coord _t2;
	_result_ok(&(term__Coord[]) { res }, (_result*)(&_t2), sizeof(term__Coord));
	return _t2;
}

bool term__set_terminal_title(string title) {
	u16* wide_title = string_to_wide(title);
	bool _t1 = SetConsoleTitle(wide_title);
	return _t1;
}

bool term__set_tab_title(string title) {
	bool _t1 = term__set_terminal_title(title);
	return _t1;
}

bool term__clear(void) {
	voidptr hconsole = GetStdHandle(STD_OUTPUT_HANDLE);
	CONSOLE_SCREEN_BUFFER_INFO csbi = ((CONSOLE_SCREEN_BUFFER_INFO){.dwSize = {0},.dwCursorPosition = {0},.wAttributes = 0,.srWindow = {0},.dwMaximumWindowSize = {0},});
	SMALL_RECT scrollrect = ((SMALL_RECT){.Left = 0,.Top = 0,.Right = 0,.Bottom = 0,});
	COORD scrolltarget = ((COORD){.X = 0,.Y = 0,});
	CHAR_INFO fill = ((CHAR_INFO){.Char = {0},.Attributes = 0,});
	if (!GetConsoleScreenBufferInfo(hconsole, &csbi)) {
		bool _t1 = false;
		return _t1;
	}
	scrollrect.Left = 0U;
	scrollrect.Top = 0U;
	scrollrect.Right = ((u16)(csbi.dwSize.X));
	scrollrect.Bottom = ((u16)(csbi.dwSize.Y));
	scrolltarget.X = 0;
	scrolltarget.Y = ((i16)(0 - csbi.dwSize.Y));
	fill.Char.UnicodeChar = ((rune)(' '));
	fill.Attributes = csbi.wAttributes;
	ScrollConsoleScreenBuffer(hconsole, &scrollrect, NULL, scrolltarget, &fill);
	csbi.dwCursorPosition.X = 0;
	csbi.dwCursorPosition.Y = 0;
	SetConsoleCursorPosition(hconsole, csbi.dwCursorPosition);
	bool _t2 = true;
	return _t2;
}

_option_rune term__utf8_getchar(void) {
	int c = input_character();
	if (c == -1) {
		return (_option_rune){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int len = term__utf8_len(((u8)(~c)));
	if (c < 0) {
		_option_rune _t2;
		_option_ok(&(rune[]) { 0 }, (_option*)(&_t2), sizeof(rune));
		return _t2;
	} else if (len == 0) {
		_option_rune _t3;
		_option_ok(&(rune[]) { c }, (_option*)(&_t3), sizeof(rune));
		return _t3;
	} else if (len == 1) {
		_option_rune _t4;
		_option_ok(&(rune[]) { -1 }, (_option*)(&_t4), sizeof(rune));
		return _t4;
	} else {
		int uc = (c & ((int_literal)(((1 << ((int)(7 - len)))) - 1)));
		for (int i = 0; (int)(i + 1) < len; i++) {
			int c2 = input_character();
			if (c2 != -1 && ((c2 >> 6)) == 2) {
				uc <<= 6;
				uc |= ((c2 & 63));
			} else if (c2 == -1) {
				_option_rune _t5;
				_option_ok(&(rune[]) { 0 }, (_option*)(&_t5), sizeof(rune));
				return _t5;
			} else {
				_option_rune _t6;
				_option_ok(&(rune[]) { -1 }, (_option*)(&_t6), sizeof(rune));
				return _t6;
			}
		}
		_option_rune _t7;
		_option_ok(&(rune[]) { uc }, (_option*)(&_t7), sizeof(rune));
		return _t7;
	}
	return (_option_rune){0};
}

int term__utf8_len(u8 c) {
	int b = 0;
	u8 x = c;
	if (((x & 240)) != 0) {
		x >>= 4;
	} else {
		b += 4;
	}
	if (((x & 12)) != 0) {
		x >>= 2;
	} else {
		b += 2;
	}
	if (((x & 2)) == 0) {
		b++;
	}
	return b;
}

int runtime__nr_jobs(void) {
	int cpus = (int)(runtime__nr_cpus() - 1);
	int vjobs = string_int(os__getenv(_SLIT("VJOBS")));
	if (vjobs > 0) {
		cpus = vjobs;
	}
	if (cpus == 0) {
		int _t1 = 1;
		return _t1;
	}
	return cpus;
}

bool runtime__is_32bit(void) {
	#if defined(TARGET_IS_32BIT)
	{
		bool _t2 = true;
		return _t2;
	}
	#endif
	bool _t3 = false;
	return _t3;
}

bool runtime__is_64bit(void) {
	#if defined(TARGET_IS_64BIT)
	{
		bool _t2 = true;
		return _t2;
	}
	#endif
	bool _t3 = false;
	return _t3;
}

bool runtime__is_little_endian(void) {
	#if defined(TARGET_ORDER_IS_LITTLE)
	{
		bool _t2 = true;
		return _t2;
	}
	#endif
	bool _t3 = false;
	return _t3;
}

bool runtime__is_big_endian(void) {
	#if defined(TARGET_ORDER_IS_BIG)
	{
		bool _t2 = true;
		return _t2;
	}
	#endif
	bool _t3 = false;
	return _t3;
}

int runtime__nr_cpus(void) {
	SYSTEM_INFO sinfo = ((SYSTEM_INFO){.dwNumberOfProcessors = 0,.dwPageSize = 0,});
	GetSystemInfo(&sinfo);
	int nr = ((int)(sinfo.dwNumberOfProcessors));
	if (nr == 0) {
		nr = string_int(os__getenv(_SLIT("NUMBER_OF_PROCESSORS")));
	}
	return nr;
}

usize runtime__total_memory(void) {
	MEMORYSTATUS memory_status = ((MEMORYSTATUS){.dwTotalPhys = 0,.dwAvailPhys = 0,});
	GlobalMemoryStatus(&memory_status);
	usize _t1 = memory_status.dwTotalPhys;
	return _t1;
}

usize runtime__free_memory(void) {
	MEMORYSTATUS memory_status = ((MEMORYSTATUS){.dwTotalPhys = 0,.dwAvailPhys = 0,});
	GlobalMemoryStatus(&memory_status);
	usize _t1 = memory_status.dwAvailPhys;
	return _t1;
}

VV_LOCAL_SYMBOL usize runtime__free_memory_impl(void) {
	usize _t1 = 1;
	return _t1;
}

void rand__wyrand__WyRandRNG_seed(rand__wyrand__WyRandRNG* rng, Array_u32 seed_data) {
	if (seed_data.len != 2) {
		eprintln(_SLIT("WyRandRNG needs 2 32-bit unsigned integers as the seed."));
		_v_exit(1);
		VUNREACHABLE();
	}
	rng->state = ((*(u32*)array_get(seed_data, 0)) | ((((u64)((*(u32*)array_get(seed_data, 1)))) << 32U)));
	rng->bytes_left = 0;
	rng->buffer = 0U;
}

// Attr: [inline]
inline u8 rand__wyrand__WyRandRNG_u8(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 1) {
		rng->bytes_left -= 1;
		u8 value = ((u8)(rng->buffer));
		rng->buffer >>= 8U;
		return value;
	}
	rng->buffer = rand__wyrand__WyRandRNG_u64(rng);
	rng->bytes_left = 7;
	u8 value = ((u8)(rng->buffer));
	rng->buffer >>= 8U;
	return value;
}

// Attr: [inline]
inline u16 rand__wyrand__WyRandRNG_u16(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 2) {
		rng->bytes_left -= 2;
		u16 value = ((u16)(rng->buffer));
		rng->buffer >>= 16U;
		return value;
	}
	u64 ans = rand__wyrand__WyRandRNG_u64(rng);
	rng->buffer = (ans >> 16U);
	rng->bytes_left = 6;
	u16 _t2 = ((u16)(ans));
	return _t2;
}

// Attr: [inline]
inline u32 rand__wyrand__WyRandRNG_u32(rand__wyrand__WyRandRNG* rng) {
	if (rng->bytes_left >= 4) {
		rng->bytes_left -= 4;
		u32 value = ((u32)(rng->buffer));
		rng->buffer >>= 32U;
		return value;
	}
	u64 ans = rand__wyrand__WyRandRNG_u64(rng);
	rng->buffer = (ans >> 32U);
	rng->bytes_left = 4;
	u32 _t2 = ((u32)(ans));
	return _t2;
}

// Attr: [inline]
inline u64 rand__wyrand__WyRandRNG_u64(rand__wyrand__WyRandRNG* rng) {
	{ // Unsafe block
		u64 seed1 = rng->state;
		seed1 += _const_rand__wyrand__wyp0;
		rng->state = seed1;
		u64 _t1 = hash__wymum((seed1 ^ _const_rand__wyrand__wyp1), seed1);
		return _t1;
	}
	u64 _t2 = 0U;
	return _t2;
}

// Attr: [inline]
inline int rand__wyrand__WyRandRNG_block_size(rand__wyrand__WyRandRNG* rng) {
	int _t1 = 64;
	return _t1;
}

// Attr: [unsafe]
void rand__wyrand__WyRandRNG_free(rand__wyrand__WyRandRNG* rng) {
	_v_free(rng);
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 rand__msqrt(f64 a) {
	if (a == 0) {
		return a;
	}
	f64 x = a;
	multi_return_f64_int mr_867 = rand__frexp(x);
	f64 z = mr_867.arg0;
	int ex = mr_867.arg1;
	f64 w = x;
	x = (f64)(((f64)(4.173075996388649989089e-1)) + (f64)(((f64)(5.9016206709064458299663e-1)) * z));
	if (((ex & 1)) != 0) {
		x *= _const_rand__sqrt2;
	}
	x = rand__scalbn(x, (ex >> 1));
	x = (f64)(((f64)(0.5)) * ((f64)(x + (f64)(w / x))));
	x = (f64)(((f64)(0.5)) * ((f64)(x + (f64)(w / x))));
	x = (f64)(((f64)(0.5)) * ((f64)(x + (f64)(w / x))));
	return x;
}

VV_LOCAL_SYMBOL f64 rand__mlog(f64 a) {
	f64 ln2_lo = 1.90821492927058770002e-10;
	f64 ln2_hi = 0.693147180369123816490;
	f64 l1 = 0.6666666666666735130;
	f64 l2 = 0.3999999999940941908;
	f64 l3 = 0.2857142874366239149;
	f64 l4 = 0.2222219843214978396;
	f64 l5 = 0.1818357216161805012;
	f64 l6 = 0.1531383769920937332;
	f64 l7 = 0.1479819860511658591;
	f64 x = a;
	multi_return_f64_int mr_1644 = rand__frexp(x);
	f64 f1 = mr_1644.arg0;
	int ki = mr_1644.arg1;
	if (f1 < ((f64)((float_literal)(_const_rand__sqrt2 / 2)))) {
		f1 *= 2;
		ki--;
	}
	f64 f = (f64)(f1 - 1);
	f64 k = ((f64)(ki));
	f64 s = (f64)(f / ((f64)(2 + f)));
	f64 s2 = (f64)(s * s);
	f64 s4 = (f64)(s2 * s2);
	f64 t1 = (f64)(s2 * ((f64)(l1 + (f64)(s4 * ((f64)(l3 + (f64)(s4 * ((f64)(l5 + (f64)(s4 * l7))))))))));
	f64 t2 = (f64)(s4 * ((f64)(l2 + (f64)(s4 * ((f64)(l4 + (f64)(s4 * l6)))))));
	f64 r = (f64)(t1 + t2);
	f64 hfsq = (f64)((f64)(((f64)(0.5)) * f) * f);
	f64 _t1 = (f64)((f64)(k * ln2_hi) - ((f64)(((f64)(hfsq - ((f64)((f64)(s * ((f64)(hfsq + r))) + (f64)(k * ln2_lo))))) - f)));
	return _t1;
}

VV_LOCAL_SYMBOL multi_return_f64_int rand__frexp(f64 x) {
	u64 y = rand__f64_bits(x);
	int ee = ((int)((((y >> 52U)) & 0x7ffU)));
	if (ee == 0) {
		if (x != ((f64)(0.0))) {
			f64 x1p64 = rand__f64_from_bits(((u64)(0x43f0000000000000U)));
			multi_return_f64_int mr_2140 = rand__frexp((f64)(x * x1p64));
			f64 z = mr_2140.arg0;
			int e_ = mr_2140.arg1;
			return (multi_return_f64_int){.arg0=z, .arg1=(int)(e_ - 64)};
		}
		return (multi_return_f64_int){.arg0=x, .arg1=0};
	} else if (ee == 0x7ff) {
		return (multi_return_f64_int){.arg0=x, .arg1=0};
	}
	int e_ = (int)(ee - 0x3fe);
	y &= ((u64)(0x800fffffffffffffU));
	y |= ((u64)(0x3fe0000000000000U));
	return (multi_return_f64_int){.arg0=rand__f64_from_bits(y), .arg1=e_};
}

VV_LOCAL_SYMBOL f64 rand__scalbn(f64 x, int n_) {
	int n = n_;
	f64 x1p1023 = rand__f64_from_bits(((u64)(0x7fe0000000000000U)));
	f64 x1p53 = rand__f64_from_bits(((u64)(0x4340000000000000U)));
	f64 x1p_1022 = rand__f64_from_bits(((u64)(0x0010000000000000U)));
	f64 y = x;
	if (n > 1023) {
		y *= x1p1023;
		n -= 1023;
		if (n > 1023) {
			y *= x1p1023;
			n -= 1023;
			if (n > 1023) {
				n = 1023;
			}
		}
	} else if (n < -1022) {
		y *= (f64)(x1p_1022 * x1p53);
		n += (int_literal)(1022 - 53);
		if (n < -1022) {
			y *= (f64)(x1p_1022 * x1p53);
			n += (int_literal)(1022 - 53);
			if (n < -1022) {
				n = -1022;
			}
		}
	}
	f64 _t1 = (f64)(y * rand__f64_from_bits((((u64)(((int)(0x3ff + n)))) << 52U)));
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL f64 rand__f64_from_bits(u64 b) {
	f64 _t1 = *((f64*)(&b));
	return _t1;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL u64 rand__f64_bits(f64 f) {
	u64 _t1 = *((u64*)(&f));
	return _t1;
}

string rand__uuid_v4(void) {
	string _t1 = rand__internal_uuid_v4(default_rng);
	return _t1;
}

VV_LOCAL_SYMBOL string rand__internal_uuid_v4(rand__PRNG* rng) {
	int buflen = 36;
	u8* buf = malloc_noscan(37);
	int i_buf = 0;
	u64 x = ((u64)(0U));
	u8 d = ((u8)(0));
	for (;;) {
		if (!(i_buf < buflen)) break;
		int c = 0;
		x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
		x &= 0x0F0F0F0F0F0F0F0FU;
		x += 0x3030303030303030U;
		for (;;) {
			if (!(c < 8 && i_buf < buflen)) break;
			d = ((u8)(x));
			{ // Unsafe block
				buf[i_buf] = (d > 0x39 ? ((u8)(d + 0x27)) : (d));
			}
			i_buf++;
			c++;
			x = (x >> 8U);
		}
	}
	x = (x >> 8U);
	d = ((u8)(x));
	{ // Unsafe block
		buf[19] = (*(rune*)array_get(_const_rand__clock_seq_hi_and_reserved_valid_values, (d & 0x03)));
		buf[14] = '4';
		buf[8] = '-';
		buf[13] = '-';
		buf[18] = '-';
		buf[23] = '-';
		buf[buflen] = 0;
		string _t1 = u8_vstring_with_len(buf, buflen);
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string rand__internal_ulid_at_millisecond(rand__PRNG* rng, u64 unix_time_milli) {
	int buflen = 26;
	u8* buf = malloc_noscan(27);
	u64 t = unix_time_milli;
	int i = 9;
	for (;;) {
		if (!(i >= 0)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (t & 0x1FU));
		}
		t = (t >> 5U);
		i--;
	}
	u64 x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
	i = 10;
	for (;;) {
		if (!(i < 19)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (x & 0x1FU));
		}
		x = (x >> 5U);
		i++;
	}
	x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
	for (;;) {
		if (!(i < 26)) break;
		{ // Unsafe block
			buf[i] = string_at(_const_rand__ulid_encoding, (x & 0x1FU));
		}
		x = (x >> 5U);
		i++;
	}
	{ // Unsafe block
		buf[26] = 0;
		string _t1 = u8_vstring_with_len(buf, buflen);
		return _t1;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL string rand__internal_string_from_set(rand__PRNG* rng, string charset, int len) {
	if (len == 0) {
		string _t1 = _SLIT("");
		return _t1;
	}
	u8* buf = malloc_noscan((int)(len + 1));
	for (int i = 0; i < len; ++i) {
		{ // Unsafe block
			_result_int _t2 = rand__intn(charset.len);
			if (_t2.is_error) {
				IError err = _t2.err;
				*(int*) _t2.data = 0;
			}
			
 			buf[i] = string_at(charset,  (*(int*)_t2.data));
		}
	}
	{ // Unsafe block
		buf[len] = 0;
	}
	string _t3 = u8_vstring_with_len(buf, len);
	return _t3;
}

VV_LOCAL_SYMBOL void rand__deinit(void) {
	{ // Unsafe block
		rand__PRNG_name_table[default_rng->_typ]._method__v_free(default_rng->_object);
		_v_free(default_rng);
	}
}

VV_LOCAL_SYMBOL void rand__init(void) {
	default_rng = rand__new_default(((rand__config__PRNGConfigStruct){.seed_ = rand__seed__time_seed_array(2),}));
	atexit((voidptr)rand__deinit);
}

VV_LOCAL_SYMBOL void rand__read_32(rand__PRNG* rng, Array_u8* buf) {
	u32* p32 = ((u32*)(buf->data));
	int u32s = (int)(buf->len / 4);
	for (int i = 0; i < u32s; ++i) {
		{ // Unsafe block
			*(p32 + i) = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
		}
	}
	for (int i = (int)(u32s * 4); i < buf->len; ++i) {
		array_set(buf, i, &(u8[]) { rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object) });
	}
}

VV_LOCAL_SYMBOL void rand__read_64(rand__PRNG* rng, Array_u8* buf) {
	u64* p64 = ((u64*)(buf->data));
	int u64s = (int)(buf->len / 8);
	for (int i = 0; i < u64s; ++i) {
		{ // Unsafe block
			*(p64 + i) = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
		}
	}
	for (int i = (int)(u64s * 8); i < buf->len; ++i) {
		array_set(buf, i, &(u8[]) { rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object) });
	}
}

VV_LOCAL_SYMBOL void rand__read_internal(rand__PRNG* rng, Array_u8* buf) {
	int /*A*/ _t1 = rand__PRNG_name_table[rng->_typ]._method_block_size(rng->_object);
		switch (_t1) {
		case 32: {
				rand__read_32(rng, buf);
				break;
		}
		case 64: {
				rand__read_64(rng, buf);
				break;
		}
		default: {
				for (int i = 0; i < buf->len; ++i) {
					array_set(buf, i, &(u8[]) { rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object) });
				}
				break;
		}
	}
	
}

// Attr: [inline]
inline _result_Array_u8 rand__PRNG_bytes(rand__PRNG* rng, int bytes_needed) {
	if (bytes_needed < 0) {
		return (_result_Array_u8){ .is_error=true, .err=_v_error(_SLIT("can not read < 0 random bytes")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_u8 buffer = __new_array_with_default_noscan(bytes_needed, 0, sizeof(u8), 0);
	rand__read_internal(rng, &/*arr*/buffer);
	_result_Array_u8 _t2;
	_result_ok(&(Array_u8[]) { buffer }, (_result*)(&_t2), sizeof(Array_u8));
	return _t2;
}

void rand__PRNG_read(rand__PRNG* rng, Array_u8* buf) {
	rand__read_internal(rng, buf);
}

// Attr: [inline]
inline _result_u32 rand__PRNG_u32n(rand__PRNG* rng, u32 max) {
	if (max == 0U) {
		return (_result_u32){ .is_error=true, .err=_v_error(_SLIT("max must be positive integer")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int bit_len = math__bits__len_32(max);
	if (_unlikely_(bit_len == 32)) {
		for (;;) {
			u32 value = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
			if (value < max) {
				_result_u32 _t2;
				_result_ok(&(u32[]) { value }, (_result*)(&_t2), sizeof(u32));
				return _t2;
			}
		}
	} else {
		u32 mask = (_unlikely_(bit_len == 31) ? (((u32)(0x7FFFFFFFU))) : ((u32)(((((u32)(1U)) << ((int)(bit_len + 1)))) - 1U)));
		for (;;) {
			u32 value = (rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) & mask);
			if (value < max) {
				_result_u32 _t3;
				_result_ok(&(u32[]) { value }, (_result*)(&_t3), sizeof(u32));
				return _t3;
			}
		}
	}
	_result_u32 _t4;
	_result_ok(&(u32[]) { ((u32)(0U)) }, (_result*)(&_t4), sizeof(u32));
	return _t4;
}

// Attr: [inline]
inline _result_u64 rand__PRNG_u64n(rand__PRNG* rng, u64 max) {
	if (max == 0U) {
		return (_result_u64){ .is_error=true, .err=_v_error(_SLIT("max must be positive integer")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int bit_len = math__bits__len_64(max);
	if (_unlikely_(bit_len == 64)) {
		for (;;) {
			u64 value = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
			if (value < max) {
				_result_u64 _t2;
				_result_ok(&(u64[]) { value }, (_result*)(&_t2), sizeof(u64));
				return _t2;
			}
		}
	} else {
		u64 mask = (_unlikely_(bit_len == 63) ? (((u64)(0x7FFFFFFFFFFFFFFFU))) : ((u64)(((((u64)(1U)) << ((int)(bit_len + 1)))) - 1U)));
		for (;;) {
			u64 value = (rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object) & mask);
			if (value < max) {
				_result_u64 _t3;
				_result_ok(&(u64[]) { value }, (_result*)(&_t3), sizeof(u64));
				return _t3;
			}
		}
	}
	_result_u64 _t4;
	_result_ok(&(u64[]) { ((u64)(0U)) }, (_result*)(&_t4), sizeof(u64));
	return _t4;
}

// Attr: [inline]
inline _result_u32 rand__PRNG_u32_in_range(rand__PRNG* rng, u32 min, u32 max) {
	if (max <= min) {
		return (_result_u32){ .is_error=true, .err=_v_error(_SLIT("max must be greater than min")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_u32 _t3 = rand__PRNG_u32n(rng, (u32)(max - min));
	if (_t3.is_error) {
		_result_u32 _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_u32 _t2;
	_result_ok(&(u32[]) { (u32)(min +  (*(u32*)_t3.data)) }, (_result*)(&_t2), sizeof(u32));
	return _t2;
}

// Attr: [inline]
inline _result_u64 rand__PRNG_u64_in_range(rand__PRNG* rng, u64 min, u64 max) {
	if (max <= min) {
		return (_result_u64){ .is_error=true, .err=_v_error(_SLIT("max must be greater than min")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_u64 _t3 = rand__PRNG_u64n(rng, (u64)(max - min));
	if (_t3.is_error) {
		_result_u64 _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_u64 _t2;
	_result_ok(&(u64[]) { (u64)(min +  (*(u64*)_t3.data)) }, (_result*)(&_t2), sizeof(u64));
	return _t2;
}

// Attr: [inline]
inline i8 rand__PRNG_i8(rand__PRNG* rng) {
	i8 _t1 = ((i8)(rand__PRNG_name_table[rng->_typ]._method_u8(rng->_object)));
	return _t1;
}

// Attr: [inline]
inline i16 rand__PRNG_i16(rand__PRNG* rng) {
	i16 _t1 = ((i16)(rand__PRNG_name_table[rng->_typ]._method_u16(rng->_object)));
	return _t1;
}

// Attr: [inline]
inline int rand__PRNG_int(rand__PRNG* rng) {
	int _t1 = ((int)(rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object)));
	return _t1;
}

// Attr: [inline]
inline i64 rand__PRNG_i64(rand__PRNG* rng) {
	i64 _t1 = ((i64)(rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object)));
	return _t1;
}

// Attr: [inline]
inline int rand__PRNG_int31(rand__PRNG* rng) {
	int _t1 = ((int)((rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) & _const_rand__constants__u31_mask)));
	return _t1;
}

// Attr: [inline]
inline i64 rand__PRNG_int63(rand__PRNG* rng) {
	i64 _t1 = ((i64)((rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object) & _const_rand__constants__u63_mask)));
	return _t1;
}

// Attr: [inline]
inline _result_int rand__PRNG_intn(rand__PRNG* rng, int max) {
	if (max <= 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("max has to be positive.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_u32 _t3 = rand__PRNG_u32n(rng, ((u32)(max)));
	if (_t3.is_error) {
		_result_int _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_int _t2;
	_result_ok(&(int[]) { ((int)( (*(u32*)_t3.data))) }, (_result*)(&_t2), sizeof(int));
	return _t2;
}

// Attr: [inline]
inline _result_i64 rand__PRNG_i64n(rand__PRNG* rng, i64 max) {
	if (max <= 0) {
		return (_result_i64){ .is_error=true, .err=_v_error(_SLIT("max has to be positive.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_u64 _t3 = rand__PRNG_u64n(rng, ((u64)(max)));
	if (_t3.is_error) {
		_result_i64 _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_i64 _t2;
	_result_ok(&(i64[]) { ((i64)( (*(u64*)_t3.data))) }, (_result*)(&_t2), sizeof(i64));
	return _t2;
}

// Attr: [inline]
inline _result_int rand__PRNG_int_in_range(rand__PRNG* rng, int min, int max) {
	if (max <= min) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("max must be greater than min")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t3 = rand__PRNG_intn(rng, (int)(max - min));
	if (_t3.is_error) {
		_result_int _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_int _t2;
	_result_ok(&(int[]) { (int)(min +  (*(int*)_t3.data)) }, (_result*)(&_t2), sizeof(int));
	return _t2;
}

// Attr: [inline]
inline _result_i64 rand__PRNG_i64_in_range(rand__PRNG* rng, i64 min, i64 max) {
	if (max <= min) {
		return (_result_i64){ .is_error=true, .err=_v_error(_SLIT("max must be greater than min")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_i64 _t3 = rand__PRNG_i64n(rng, (i64)(max - min));
	if (_t3.is_error) {
		_result_i64 _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_i64 _t2;
	_result_ok(&(i64[]) { (i64)(min +  (*(i64*)_t3.data)) }, (_result*)(&_t2), sizeof(i64));
	return _t2;
}

// Attr: [inline]
inline f32 rand__PRNG_f32(rand__PRNG* rng) {
	f32 _t1 = ((f32)((f64)(((rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object) >> 9U)) * _const_rand__constants__reciprocal_2_23rd)));
	return _t1;
}

// Attr: [inline]
inline f32 rand__PRNG_f32cp(rand__PRNG* rng) {
	u32 x = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
	u32 exp = ((u32)(126U));
	u32 mask = (((u32)(1U)) << 31U);
	if (_unlikely_(x == 0U)) {
		x = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
		exp -= 31U;
	}
	for (;;) {
		if ((x & mask) != 0U) {
			mask >>= 1U;
			exp -= 1U;
		} else {
			break;
		}
	}
	if (exp < ((int_literal)(126 - 8))) {
		x = rand__PRNG_name_table[rng->_typ]._method_u32(rng->_object);
	}
	x = (((exp << 23U)) | (((x >> 8U)) & _const_rand__constants__ieee754_mantissa_f32_mask));
	f32 _t1 = math__bits__f32_from_bits(x);
	return _t1;
}

// Attr: [inline]
inline f64 rand__PRNG_f64(rand__PRNG* rng) {
	f64 _t1 = ((f64)((f64)(((rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object) >> 12U)) * _const_rand__constants__reciprocal_2_52nd)));
	return _t1;
}

// Attr: [inline]
inline f64 rand__PRNG_f64cp(rand__PRNG* rng) {
	u64 x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
	u64 exp = ((u64)(1022U));
	u64 mask = (((u64)(1U)) << 63U);
	u32 bitcount = ((u32)(0U));
	if (_unlikely_(x == 0U)) {
		x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
		exp -= 31U;
	}
	for (;;) {
		if ((x & mask) != 0U) {
			mask >>= 1U;
			bitcount += 1U;
		} else {
			break;
		}
	}
	exp -= bitcount;
	if (bitcount > 11U) {
		x = rand__PRNG_name_table[rng->_typ]._method_u64(rng->_object);
	}
	x = (((exp << 52U)) | ((x & _const_rand__constants__ieee754_mantissa_f64_mask)));
	f64 _t1 = math__bits__f64_from_bits(x);
	return _t1;
}

// Attr: [inline]
inline _result_f32 rand__PRNG_f32n(rand__PRNG* rng, f32 max) {
	if (max < 0) {
		return (_result_f32){ .is_error=true, .err=_v_error(_SLIT("max has to be non-negative.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_f32 _t2;
	_result_ok(&(f32[]) { (f32)(rand__PRNG_f32(rng) * max) }, (_result*)(&_t2), sizeof(f32));
	return _t2;
}

// Attr: [inline]
inline _result_f64 rand__PRNG_f64n(rand__PRNG* rng, f64 max) {
	if (max < 0) {
		return (_result_f64){ .is_error=true, .err=_v_error(_SLIT("max has to be non-negative.")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_f64 _t2;
	_result_ok(&(f64[]) { (f64)(rand__PRNG_f64(rng) * max) }, (_result*)(&_t2), sizeof(f64));
	return _t2;
}

// Attr: [inline]
inline _result_f32 rand__PRNG_f32_in_range(rand__PRNG* rng, f32 min, f32 max) {
	if (max < min) {
		return (_result_f32){ .is_error=true, .err=_v_error(_SLIT("max must be greater than or equal to min")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_f32 _t3 = rand__PRNG_f32n(rng, (f32)(max - min));
	if (_t3.is_error) {
		_result_f32 _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_f32 _t2;
	_result_ok(&(f32[]) { (f32)(min +  (*(f32*)_t3.data)) }, (_result*)(&_t2), sizeof(f32));
	return _t2;
}

// Attr: [inline]
inline _result_f64 rand__PRNG_f64_in_range(rand__PRNG* rng, f64 min, f64 max) {
	if (max < min) {
		return (_result_f64){ .is_error=true, .err=_v_error(_SLIT("max must be greater than or equal to min")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_f64 _t3 = rand__PRNG_f64n(rng, (f64)(max - min));
	if (_t3.is_error) {
		_result_f64 _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_f64 _t2;
	_result_ok(&(f64[]) { (f64)(min +  (*(f64*)_t3.data)) }, (_result*)(&_t2), sizeof(f64));
	return _t2;
}

string rand__PRNG_ulid(rand__PRNG* rng) {
	string _t1 = rand__internal_ulid_at_millisecond(rng, ((u64)(time__Time_unix_time_milli(ADDR(time__Time, time__utc())))));
	return _t1;
}

string rand__PRNG_ulid_at_millisecond(rand__PRNG* rng, u64 unix_time_milli) {
	string _t1 = rand__internal_ulid_at_millisecond(rng, unix_time_milli);
	return _t1;
}

string rand__PRNG_string_from_set(rand__PRNG* rng, string charset, int len) {
	string _t1 = rand__internal_string_from_set(rng, charset, len);
	return _t1;
}

string rand__PRNG_string(rand__PRNG* rng, int len) {
	string _t1 = rand__internal_string_from_set(rng, _const_rand__english_letters, len);
	return _t1;
}

string rand__PRNG_hex(rand__PRNG* rng, int len) {
	string _t1 = rand__internal_string_from_set(rng, _const_rand__hex_chars, len);
	return _t1;
}

string rand__PRNG_ascii(rand__PRNG* rng, int len) {
	string _t1 = rand__internal_string_from_set(rng, _const_rand__ascii_chars, len);
	return _t1;
}

_result_bool rand__PRNG_bernoulli(rand__PRNG* rng, f64 p) {
	if (p < 0 || p > 1) {
		return (_result_bool){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*103 &f64*/0x1fe0f, {.d_f64 = p}}, {_SLIT(" is not a valid probability value."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_bool _t2;
	_result_ok(&(bool[]) { rand__PRNG_f64(rng) <= p }, (_result*)(&_t2), sizeof(bool));
	return _t2;
}

_result_f64 rand__PRNG_normal(rand__PRNG* rng, rand__config__NormalConfigStruct conf) {
	_result_multi_return_f64_f64 _t1 = rand__PRNG_normal_pair(rng, conf);
	if (_t1.is_error) {
		_result_f64 _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_f64_f64 mr_10060 =  (*(multi_return_f64_f64*)_t1.data);
	f64 x = mr_10060.arg0;
	_result_f64 _t3;
	_result_ok(&(f64[]) { x }, (_result*)(&_t3), sizeof(f64));
	return _t3;
}

_result_multi_return_f64_f64 rand__PRNG_normal_pair(rand__PRNG* rng, rand__config__NormalConfigStruct conf) {
	if (conf.sigma <= 0) {
		return (_result_multi_return_f64_f64){ .is_error=true, .err=_v_error(_SLIT("Standard deviation must be positive")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	for (;;) {
		_result_f64 _t2 = rand__PRNG_f64_in_range(rng, -1, 1);
		if (_t2.is_error) {
			IError err = _t2.err;
			*(f64*) _t2.data = 0.0;
		}
		
 		f64 u =  (*(f64*)_t2.data);
		_result_f64 _t3 = rand__PRNG_f64_in_range(rng, -1, 1);
		if (_t3.is_error) {
			IError err = _t3.err;
			*(f64*) _t3.data = 0.0;
		}
		
 		f64 v =  (*(f64*)_t3.data);
		f64 s = (f64)((f64)(u * u) + (f64)(v * v));
		if (s >= 1 || s == 0) {
			continue;
		}
		f64 t = rand__msqrt((f64)((f64)(-2 * rand__mlog(s)) / s));
		f64 x = (f64)(conf.mu + (f64)((f64)(conf.sigma * t) * u));
		f64 y = (f64)(conf.mu + (f64)((f64)(conf.sigma * t) * v));
		_result_multi_return_f64_f64 _t4;
		_result_ok(&(multi_return_f64_f64[]) { (multi_return_f64_f64){.arg0=x, .arg1=y} }, (_result*)(&_t4), sizeof(multi_return_f64_f64));
		return _t4;
	}
	return (_result_multi_return_f64_f64){ .is_error=true, .err=_v_error(_SLIT("Implementation error. Please file an issue.")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_int rand__PRNG_binomial(rand__PRNG* rng, int n, f64 p) {
	if (p < 0 || p > 1) {
		return (_result_int){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*103 &f64*/0x1fe0f, {.d_f64 = p}}, {_SLIT(" is not a valid probability value."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int count = 0;
	for (int _t2 = 0; _t2 < n; ++_t2) {
		_result_bool _t3 = rand__PRNG_bernoulli(rng, p);
		if (_t3.is_error) {
			_result_int _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 		if ( (*(bool*)_t3.data)) {
			count++;
		}
	}
	_result_int _t5;
	_result_ok(&(int[]) { count }, (_result*)(&_t5), sizeof(int));
	return _t5;
}

f64 rand__PRNG_exponential(rand__PRNG* rng, f64 lambda) {
	if (lambda <= 0) {
		_v_panic(_SLIT("The rate (lambda) must be positive."));
		VUNREACHABLE();
	}
	f64 _t1 = (f64)(-rand__mlog(rand__PRNG_f64(rng)) / lambda);
	return _t1;
}

// Attr: [manualfree]
rand__PRNG* rand__new_default(rand__config__PRNGConfigStruct config_) {
	rand__wyrand__WyRandRNG* rng = ((rand__wyrand__WyRandRNG*)memdup(&(rand__wyrand__WyRandRNG){.PRNGBuffer = ((rand__buffer__PRNGBuffer){.bytes_left = 0,.buffer = 0,}),.state = rand__seed__time_seed_64(),.bytes_left = 0,.buffer = 0,}, sizeof(rand__wyrand__WyRandRNG)));
	rand__wyrand__WyRandRNG_seed(rng, config_.seed_);
	array_free(&config_.seed_);
	rand__PRNG* _t1 = HEAP(rand__PRNG, /*&rand.PRNG*/I_rand__wyrand__WyRandRNG_to_Interface_rand__PRNG(rng));
	return _t1;
}

rand__PRNG* rand__get_current_rng(void) {
	return default_rng;
}

void rand__set_rng(rand__PRNG* rng) {
	default_rng = rng;
}

void rand__seed(Array_u32 seed) {
	rand__PRNG_name_table[default_rng->_typ]._method_seed(default_rng->_object, seed);
}

u8 rand__u8(void) {
	u8 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u8(default_rng->_object);
	return _t1;
}

u16 rand__u16(void) {
	u16 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u16(default_rng->_object);
	return _t1;
}

u32 rand__u32(void) {
	u32 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u32(default_rng->_object);
	return _t1;
}

u64 rand__u64(void) {
	u64 _t1 = rand__PRNG_name_table[default_rng->_typ]._method_u64(default_rng->_object);
	return _t1;
}

_result_u32 rand__u32n(u32 max) {
	_result_u32 _t1 = rand__PRNG_u32n(default_rng, max);
	return _t1;
}

_result_u64 rand__u64n(u64 max) {
	_result_u64 _t1 = rand__PRNG_u64n(default_rng, max);
	return _t1;
}

_result_u32 rand__u32_in_range(u32 min, u32 max) {
	_result_u32 _t1 = rand__PRNG_u32_in_range(default_rng, min, max);
	return _t1;
}

_result_u64 rand__u64_in_range(u64 min, u64 max) {
	_result_u64 _t1 = rand__PRNG_u64_in_range(default_rng, min, max);
	return _t1;
}

i16 rand__i16(void) {
	i16 _t1 = rand__PRNG_i16(default_rng);
	return _t1;
}

int rand__int(void) {
	int _t1 = rand__PRNG_int(default_rng);
	return _t1;
}

_result_int rand__intn(int max) {
	_result_int _t1 = rand__PRNG_intn(default_rng, max);
	return _t1;
}

_result_int rand__int_in_range(int min, int max) {
	_result_int _t1 = rand__PRNG_int_in_range(default_rng, min, max);
	return _t1;
}

int rand__int31(void) {
	int _t1 = rand__PRNG_int31(default_rng);
	return _t1;
}

i64 rand__i64(void) {
	i64 _t1 = rand__PRNG_i64(default_rng);
	return _t1;
}

_result_i64 rand__i64n(i64 max) {
	_result_i64 _t1 = rand__PRNG_i64n(default_rng, max);
	return _t1;
}

_result_i64 rand__i64_in_range(i64 min, i64 max) {
	_result_i64 _t1 = rand__PRNG_i64_in_range(default_rng, min, max);
	return _t1;
}

i64 rand__int63(void) {
	i64 _t1 = rand__PRNG_int63(default_rng);
	return _t1;
}

f32 rand__f32(void) {
	f32 _t1 = rand__PRNG_f32(default_rng);
	return _t1;
}

f32 rand__f32cp(void) {
	f32 _t1 = rand__PRNG_f32cp(default_rng);
	return _t1;
}

f64 rand__f64(void) {
	f64 _t1 = rand__PRNG_f64(default_rng);
	return _t1;
}

f64 rand__f64cp(void) {
	f64 _t1 = rand__PRNG_f64cp(default_rng);
	return _t1;
}

_result_f32 rand__f32n(f32 max) {
	_result_f32 _t1 = rand__PRNG_f32n(default_rng, max);
	return _t1;
}

_result_f64 rand__f64n(f64 max) {
	_result_f64 _t1 = rand__PRNG_f64n(default_rng, max);
	return _t1;
}

_result_f32 rand__f32_in_range(f32 min, f32 max) {
	_result_f32 _t1 = rand__PRNG_f32_in_range(default_rng, min, max);
	return _t1;
}

_result_f64 rand__f64_in_range(f64 min, f64 max) {
	_result_f64 _t1 = rand__PRNG_f64_in_range(default_rng, min, max);
	return _t1;
}

_result_Array_u8 rand__bytes(int bytes_needed) {
	_result_Array_u8 _t1 = rand__PRNG_bytes(default_rng, bytes_needed);
	return _t1;
}

void rand__read(Array_u8* buf) {
	rand__read_internal(default_rng, buf);
}

string rand__ulid(void) {
	string _t1 = rand__PRNG_ulid(default_rng);
	return _t1;
}

string rand__ulid_at_millisecond(u64 unix_time_milli) {
	string _t1 = rand__PRNG_ulid_at_millisecond(default_rng, unix_time_milli);
	return _t1;
}

string rand__string_from_set(string charset, int len) {
	string _t1 = rand__PRNG_string_from_set(default_rng, charset, len);
	return _t1;
}

string rand__string(int len) {
	string _t1 = rand__string_from_set(_const_rand__english_letters, len);
	return _t1;
}

string rand__hex(int len) {
	string _t1 = rand__string_from_set(_const_rand__hex_chars, len);
	return _t1;
}

string rand__ascii(int len) {
	string _t1 = rand__string_from_set(_const_rand__ascii_chars, len);
	return _t1;
}

_result_bool rand__bernoulli(f64 p) {
	_result_bool _t1 = rand__PRNG_bernoulli(default_rng, p);
	return _t1;
}

_result_f64 rand__normal(rand__config__NormalConfigStruct config_) {
	_result_f64 _t1 = rand__PRNG_normal(default_rng, config_);
	return _t1;
}

_result_multi_return_f64_f64 rand__normal_pair(rand__config__NormalConfigStruct config_) {
	_result_multi_return_f64_f64 _t1 = rand__PRNG_normal_pair(default_rng, config_);
	return _t1;
}

_result_int rand__binomial(int n, f64 p) {
	_result_int _t1 = rand__PRNG_binomial(default_rng, n, p);
	return _t1;
}

f64 rand__exponential(f64 lambda) {
	f64 _t1 = rand__PRNG_exponential(default_rng, lambda);
	return _t1;
}

VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st(u32 n, u32 st) {
	u32 wsem = (n > 0U ? (n) : (1));
	u32 rsem = (n > 0U ? (((u32)(0U))) : (1));
	u8* rbuf = (n > 0U ? (_v_malloc(((int)((u32)(n * st))))) : (((u8*)(0))));
	u8* sbuf = (n > 0U ? (vcalloc_noscan(((int)((u32)(n * 2U))))) : (((u8*)(0))));
	sync__Channel *ch = HEAP(sync__Channel, (((sync__Channel){
		.ringbuf = rbuf,
		.statusbuf = sbuf,
		.objsize = st,
		.writesem = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},
		.readsem = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},
		.writesem_im = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},
		.readsem_im = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},
		.write_free = n,
		.read_avail = 0U,
		.buf_elem_write_idx = 0,
		.buf_elem_read_idx = 0,
		.write_subscriber = ((void*)0),
		.read_subscriber = ((void*)0),
		.write_sub_mtx = 0,
		.read_sub_mtx = 0,
		.closed = 0,
		.cap = n,
	})));
	sync__Semaphore_init(&(*(ch)).writesem, wsem);
	sync__Semaphore_init(&(*(ch)).readsem, rsem);
	sync__Semaphore_init(&(*(ch)).writesem_im, 0U);
	sync__Semaphore_init(&(*(ch)).readsem_im, 0U);
	sync__Channel* _t1 = &(*(ch));
	return _t1;
}

VV_LOCAL_SYMBOL sync__Channel* sync__new_channel_st_noscan(u32 n, u32 st) {
	#if defined(CUSTOM_DEFINE_gcboehm_opt)
	{
		u32 wsem = (n > 0U ? (n) : (1));
		u32 rsem = (n > 0U ? (((u32)(0U))) : (1));
		u8* rbuf = (n > 0U ? (malloc_noscan(((int)((u32)(n * st))))) : (((u8*)(0))));
		u8* sbuf = (n > 0U ? (vcalloc_noscan(((int)((u32)(n * 2U))))) : (((u8*)(0))));
		sync__Channel *ch = HEAP(sync__Channel, (((sync__Channel){
			.ringbuf = rbuf,
			.statusbuf = sbuf,
			.objsize = st,
			.writesem = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},
			.readsem = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},
			.writesem_im = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},
			.readsem_im = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},
			.write_free = n,
			.read_avail = 0U,
			.buf_elem_write_idx = 0,
			.buf_elem_read_idx = 0,
			.write_subscriber = ((void*)0),
			.read_subscriber = ((void*)0),
			.write_sub_mtx = 0,
			.read_sub_mtx = 0,
			.closed = 0,
			.cap = n,
		})));
		sync__Semaphore_init(&(*(ch)).writesem, wsem);
		sync__Semaphore_init(&(*(ch)).readsem, rsem);
		sync__Semaphore_init(&(*(ch)).writesem_im, 0U);
		sync__Semaphore_init(&(*(ch)).readsem_im, 0U);
		sync__Channel* _t2 = &(*(ch));
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

string sync__Channel_auto_str(sync__Channel* ch, string __v_typename) {
	string _t1 =  str_intp(4, _MOV((StrIntpData[]){{_SLIT("chan "), /*115 &string*/0xfe10, {.d_s = __v_typename}}, {_SLIT("{cap: "), /*117 &u32*/0xfe06, {.d_u32 = ch->cap}}, {_SLIT(", closed: "), /*117 &u16*/0xfe04, {.d_u16 = ch->closed}}, {_SLIT("}"), 0, { .d_c = 0 }}}));
	return _t1;
}

void sync__Channel_close(sync__Channel* ch) {
	u16 open_val = ((u16)(0U));
	if (!atomic_compare_exchange_strong_u16(&ch->closed, &open_val, 1U)) {
		return;
	}
	voidptr nulladr = ((void*)0);
	for (;;) {
		if (!(!atomic_compare_exchange_weak_ptr(((voidptr*)(&ch->adr_written)), &nulladr, ((voidptr)(-1))))) break;
		nulladr = ((void*)0);
	}
	sync__Semaphore_post(&ch->readsem_im);
	sync__Semaphore_post(&ch->readsem);
	u16 null16 = ((u16)(0U));
	for (;;) {
		if (!(!atomic_compare_exchange_weak_u16(&ch->read_sub_mtx, &null16, ((u16)(1U))))) break;
		null16 = ((u16)(0U));
	}
	if (ch->read_subscriber != ((void*)0)) {
		sync__Semaphore_post(ch->read_subscriber->sem);
	}
	atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
	null16 = ((u16)(0U));
	for (;;) {
		if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
		null16 = ((u16)(0U));
	}
	if (ch->write_subscriber != ((void*)0)) {
		sync__Semaphore_post(ch->write_subscriber->sem);
	}
	atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
	sync__Semaphore_post(&ch->writesem);
	if (ch->cap == 0U) {
		atomic_store_ptr(((voidptr*)(&ch->read_adr)), ((void*)0));
	}
	sync__Semaphore_post(&ch->writesem_im);
}

// Attr: [inline]
inline int sync__Channel_len(sync__Channel* ch) {
	int _t1 = ((int)(atomic_load_u32(&ch->read_avail)));
	return _t1;
}

// Attr: [inline]
inline bool sync__Channel_closed(sync__Channel* ch) {
	bool _t1 = atomic_load_u16(&ch->closed) != 0U;
	return _t1;
}

// Attr: [inline]
inline void sync__Channel_push(sync__Channel* ch, voidptr src) {
	if (sync__Channel_try_push_priv(ch, src, false) == ChanState__closed) {
		_v_panic(_SLIT("push on closed channel"));
		VUNREACHABLE();
	}
}

// Attr: [inline]
inline ChanState sync__Channel_try_push(sync__Channel* ch, voidptr src) {
	ChanState _t1 = sync__Channel_try_push_priv(ch, src, true);
	return _t1;
}

VV_LOCAL_SYMBOL ChanState sync__Channel_try_push_priv(sync__Channel* ch, voidptr src, bool no_block) {
	if (atomic_load_u16(&ch->closed) != 0U) {
		ChanState _t1 = ChanState__closed;
		return _t1;
	}
	multi_return_int_int mr_4707 = (no_block ? ((multi_return_int_int){.arg0=1,.arg1=1}) : ((multi_return_int_int){.arg0=_const_sync__spinloops,.arg1=_const_sync__spinloops_sem}));
	int spinloops_sem_ = mr_4707.arg0;
	int spinloops_ = mr_4707.arg1;
	bool have_swapped = false;
	for (;;) {
		bool got_sem = false;
		voidptr wradr = atomic_load_ptr(((voidptr*)(&ch->write_adr)));
		for (;;) {
			if (!(wradr != NULL)) break;
			if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->write_adr)), &wradr, ((void*)0))) {
				memcpy(wradr, src, ch->objsize);
				voidptr nulladr = ((void*)0);
				for (;;) {
					if (!(!atomic_compare_exchange_weak_ptr(((voidptr*)(&ch->adr_written)), &nulladr, wradr))) break;
					nulladr = ((void*)0);
				}
				sync__Semaphore_post(&ch->readsem_im);
				ChanState _t2 = ChanState__success;
				return _t2;
			}
		}
		if (no_block && ch->cap == 0U) {
			ChanState _t3 = ChanState__not_ready;
			return _t3;
		}
		for (int _t4 = 0; _t4 < spinloops_sem_; ++_t4) {
			if (got_sem) {
				break;
			}
			got_sem = sync__Semaphore_try_wait(&ch->writesem);
		}
		if (!got_sem) {
			if (no_block) {
				ChanState _t5 = ChanState__not_ready;
				return _t5;
			}
			sync__Semaphore_wait(&ch->writesem);
		}
		if (atomic_load_u16(&ch->closed) != 0U) {
			sync__Semaphore_post(&ch->writesem);
			ChanState _t6 = ChanState__closed;
			return _t6;
		}
		if (ch->cap == 0U) {
			bool read_in_progress = false;
			atomic_store_ptr(((voidptr*)(&ch->read_adr)), src);
			wradr = atomic_load_ptr(((voidptr*)(&ch->write_adr)));
			if (wradr != NULL) {
				voidptr src2 = src;
				if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->read_adr)), &src2, ((void*)0))) {
					sync__Semaphore_post(&ch->writesem);
					continue;
				} else {
					read_in_progress = true;
				}
			}
			if (!read_in_progress) {
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(((voidptr)(&ch->read_sub_mtx)), &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->read_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->read_subscriber->sem);
				}
				atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
			}
			voidptr src2 = src;
			for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_) || read_in_progress; sp++) {
				if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_read)), &src2, ((void*)0))) {
					have_swapped = true;
					read_in_progress = true;
					break;
				}
				src2 = src;
			}
			bool got_im_sem = false;
			for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_sem_) || read_in_progress; sp++) {
				got_im_sem = sync__Semaphore_try_wait(&ch->writesem_im);
				if (got_im_sem) {
					break;
				}
			}
			for (;;) {
				if (got_im_sem) {
					got_im_sem = false;
				} else {
					sync__Semaphore_wait(&ch->writesem_im);
				}
				if (atomic_load_u16(&ch->closed) != 0U) {
					if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_read)), &src2, ((void*)0))) {
						sync__Semaphore_post(&ch->writesem);
						ChanState _t7 = ChanState__success;
						return _t7;
					} else {
						ChanState _t8 = ChanState__closed;
						return _t8;
					}
				}
				if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_read)), &src2, ((void*)0))) {
					sync__Semaphore_post(&ch->writesem);
					break;
				} else {
					sync__Semaphore_post(&ch->writesem_im);
					if (src2 == ((voidptr)(-1))) {
						sync__Semaphore_post(&ch->readsem);
						ChanState _t9 = ChanState__closed;
						return _t9;
					}
					src2 = src;
				}
			}
			ChanState _t10 = ChanState__success;
			return _t10;
		} else {
			bool space_in_queue = false;
			u32 wr_free = atomic_load_u32(&ch->write_free);
			for (;;) {
				if (!(wr_free > 0U)) break;
				space_in_queue = atomic_compare_exchange_weak_u32(&ch->write_free, &wr_free, (u32)(wr_free - 1U));
				if (space_in_queue) {
					break;
				}
			}
			if (space_in_queue) {
				u32 wr_idx = atomic_load_u32(&ch->buf_elem_write_idx);
				for (;;) {
					u32 new_wr_idx = (u32)(wr_idx + 1U);
					for (;;) {
						if (!(new_wr_idx >= ch->cap)) break;
						new_wr_idx -= ch->cap;
					}
					if (atomic_compare_exchange_strong_u32(&ch->buf_elem_write_idx, &wr_idx, new_wr_idx)) {
						break;
					}
				}
				u8* wr_ptr = ch->ringbuf;
				u8* status_adr = ch->statusbuf;
				{ // Unsafe block
					wr_ptr += ((u32)(wr_idx * ch->objsize));
					status_adr += (u32)(wr_idx * sizeof(u16));
				}
				u16 expected_status = ((u16)(sync__BufferElemStat__unused));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(status_adr, &expected_status, ((u16)(sync__BufferElemStat__writing))))) break;
					expected_status = ((u16)(sync__BufferElemStat__unused));
				}
				memcpy(wr_ptr, src, ch->objsize);
				atomic_store_u16(((u16*)(status_adr)), ((u16)(sync__BufferElemStat__written)));
				atomic_fetch_add_u32(&ch->read_avail, 1U);
				sync__Semaphore_post(&ch->readsem);
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(&ch->read_sub_mtx, &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->read_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->read_subscriber->sem);
				}
				atomic_store_u16(&ch->read_sub_mtx, ((u16)(0U)));
				ChanState _t11 = ChanState__success;
				return _t11;
			} else {
				if (no_block) {
					ChanState _t12 = ChanState__not_ready;
					return _t12;
				}
				sync__Semaphore_post(&ch->writesem);
			}
		}
	}
	_v_panic(_SLIT("unknown `try_push_priv` state"));
	VUNREACHABLE();
	return 0;
}

// Attr: [inline]
inline bool sync__Channel_pop(sync__Channel* ch, voidptr dest) {
	bool _t1 = sync__Channel_try_pop_priv(ch, dest, false) == ChanState__success;
	return _t1;
}

// Attr: [inline]
inline ChanState sync__Channel_try_pop(sync__Channel* ch, voidptr dest) {
	ChanState _t1 = sync__Channel_try_pop_priv(ch, dest, true);
	return _t1;
}

VV_LOCAL_SYMBOL ChanState sync__Channel_try_pop_priv(sync__Channel* ch, voidptr dest, bool no_block) {
	multi_return_int_int mr_9730 = (no_block ? ((multi_return_int_int){.arg0=1,.arg1=1}) : ((multi_return_int_int){.arg0=_const_sync__spinloops,.arg1=_const_sync__spinloops_sem}));
	int spinloops_sem_ = mr_9730.arg0;
	int spinloops_ = mr_9730.arg1;
	bool have_swapped = false;
	bool write_in_progress = false;
	for (;;) {
		bool got_sem = false;
		if (ch->cap == 0U) {
			voidptr rdadr = atomic_load_ptr(((voidptr*)(&ch->read_adr)));
			for (;;) {
				if (!(rdadr != NULL)) break;
				if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->read_adr)), &rdadr, ((void*)0))) {
					memcpy(dest, rdadr, ch->objsize);
					voidptr nulladr = ((void*)0);
					for (;;) {
						if (!(!atomic_compare_exchange_weak_ptr(((voidptr*)(&ch->adr_read)), &nulladr, rdadr))) break;
						nulladr = ((void*)0);
					}
					sync__Semaphore_post(&ch->writesem_im);
					ChanState _t1 = ChanState__success;
					return _t1;
				}
			}
			if (no_block) {
				if (atomic_load_u16(&ch->closed) == 0U) {
					ChanState _t2 = ChanState__not_ready;
					return _t2;
				} else {
					ChanState _t3 = ChanState__closed;
					return _t3;
				}
			}
		}
		for (int _t4 = 0; _t4 < spinloops_sem_; ++_t4) {
			if (got_sem) {
				break;
			}
			got_sem = sync__Semaphore_try_wait(&ch->readsem);
		}
		if (!got_sem) {
			if (no_block) {
				if (atomic_load_u16(&ch->closed) == 0U) {
					ChanState _t5 = ChanState__not_ready;
					return _t5;
				} else {
					ChanState _t6 = ChanState__closed;
					return _t6;
				}
			}
			sync__Semaphore_wait(&ch->readsem);
		}
		if (ch->cap > 0U) {
			bool obj_in_queue = false;
			u32 rd_avail = atomic_load_u32(&ch->read_avail);
			for (;;) {
				if (!(rd_avail > 0U)) break;
				obj_in_queue = atomic_compare_exchange_weak_u32(&ch->read_avail, &rd_avail, (u32)(rd_avail - 1U));
				if (obj_in_queue) {
					break;
				}
			}
			if (obj_in_queue) {
				u32 rd_idx = atomic_load_u32(&ch->buf_elem_read_idx);
				for (;;) {
					u32 new_rd_idx = (u32)(rd_idx + 1U);
					for (;;) {
						if (!(new_rd_idx >= ch->cap)) break;
						new_rd_idx -= ch->cap;
					}
					if (atomic_compare_exchange_weak_u32(&ch->buf_elem_read_idx, &rd_idx, new_rd_idx)) {
						break;
					}
				}
				u8* rd_ptr = ch->ringbuf;
				u8* status_adr = ch->statusbuf;
				{ // Unsafe block
					rd_ptr += (u32)(rd_idx * ch->objsize);
					status_adr += (u32)(rd_idx * sizeof(u16));
				}
				u16 expected_status = ((u16)(sync__BufferElemStat__written));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(status_adr, &expected_status, ((u16)(sync__BufferElemStat__reading))))) break;
					expected_status = ((u16)(sync__BufferElemStat__written));
				}
				memcpy(dest, rd_ptr, ch->objsize);
				atomic_store_u16(((u16*)(status_adr)), ((u16)(sync__BufferElemStat__unused)));
				atomic_fetch_add_u32(&ch->write_free, 1U);
				sync__Semaphore_post(&ch->writesem);
				u16 null16 = ((u16)(0U));
				for (;;) {
					if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
					null16 = ((u16)(0U));
				}
				if (ch->write_subscriber != ((void*)0)) {
					sync__Semaphore_post(ch->write_subscriber->sem);
				}
				atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
				ChanState _t7 = ChanState__success;
				return _t7;
			}
		}
		atomic_store_ptr(((voidptr*)(&ch->write_adr)), dest);
		if (ch->cap == 0U) {
			voidptr rdadr = atomic_load_ptr(((voidptr*)(&ch->read_adr)));
			if (rdadr != NULL) {
				voidptr dest2 = dest;
				if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->write_adr)), &dest2, ((void*)0))) {
					sync__Semaphore_post(&ch->readsem);
					continue;
				} else {
					write_in_progress = true;
				}
			}
		}
		if (ch->cap == 0U && !write_in_progress) {
			u16 null16 = ((u16)(0U));
			for (;;) {
				if (!(!atomic_compare_exchange_weak_u16(&ch->write_sub_mtx, &null16, ((u16)(1U))))) break;
				null16 = ((u16)(0U));
			}
			if (ch->write_subscriber != ((void*)0)) {
				sync__Semaphore_post(ch->write_subscriber->sem);
			}
			atomic_store_u16(&ch->write_sub_mtx, ((u16)(0U)));
		}
		voidptr dest2 = dest;
		for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_) || write_in_progress; sp++) {
			if (atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_written)), &dest2, ((void*)0))) {
				have_swapped = true;
				break;
			} else if (dest2 == ((voidptr)(-1))) {
				sync__Semaphore_post(&ch->readsem);
				ChanState _t8 = ChanState__closed;
				return _t8;
			}
			dest2 = dest;
		}
		bool got_im_sem = false;
		for (u32 sp = ((u32)(0U)); _us32_lt(sp,spinloops_sem_) || write_in_progress; sp++) {
			got_im_sem = sync__Semaphore_try_wait(&ch->readsem_im);
			if (got_im_sem) {
				break;
			}
		}
		for (;;) {
			if (got_im_sem) {
				got_im_sem = false;
			} else {
				sync__Semaphore_wait(&ch->readsem_im);
			}
			if (have_swapped || atomic_compare_exchange_strong_ptr(((voidptr*)(&ch->adr_written)), &dest2, ((void*)0))) {
				sync__Semaphore_post(&ch->readsem);
				break;
			} else {
				sync__Semaphore_post(&ch->readsem_im);
				if (dest2 == ((voidptr)(-1))) {
					sync__Semaphore_post(&ch->readsem);
					ChanState _t9 = ChanState__closed;
					return _t9;
				}
				dest2 = dest;
			}
		}
		break;
	}
	ChanState _t10 = ChanState__success;
	return _t10;
}

int sync__channel_select(Array_sync__Channel_ptr* channels, Array_sync__Direction dir, Array_voidptr* objrefs, time__Duration timeout) {
	Array_sync__Subscription subscr = __new_array_with_default(channels->len, 0, sizeof(sync__Subscription), (voidptr)&(sync__Subscription[]){(sync__Subscription){.sem = ((void*)0),.prev = ((void*)0),.nxt = ((void*)0),}}[0]);
	sync__Semaphore *sem = HEAP(sync__Semaphore, (((sync__Semaphore){.count = 0,})));
	sync__Semaphore_init(&(*(sem)), 0U);
	for (int i = 0; i < channels->len; ++i) {
		sync__Channel* ch = ((sync__Channel**)channels->data)[i];
		(*(sync__Subscription*)array_get(subscr, i)).sem = &(*(sem));
		multi_return_ref_u16_ref_sync__Subscription mr_15068 = ((*(sync__Direction*)array_get(dir, i)) == sync__Direction__push ? ((multi_return_ref_u16_ref_sync__Subscription){.arg0=&ch->write_sub_mtx,.arg1=&ch->write_subscriber}) : ((multi_return_ref_u16_ref_sync__Subscription){.arg0=&ch->read_sub_mtx,.arg1=&ch->read_subscriber}));
		u16* sub_mtx = mr_15068.arg0;
		sync__Subscription** subscriber = mr_15068.arg1;
		u16 null16 = ((u16)(0U));
		for (;;) {
			if (!(!atomic_compare_exchange_weak_u16(sub_mtx, &null16, ((u16)(1U))))) break;
			null16 = ((u16)(0U));
		}
		(*(sync__Subscription*)array_get(subscr, i)).prev = subscriber;
		{ // Unsafe block
			(*(sync__Subscription*)array_get(subscr, i)).nxt = ((sync__Subscription*)(atomic_exchange_ptr(((voidptr*)(subscriber)), &(*(sync__Subscription*)array_get(subscr, i)))));
		}
		if (((voidptr)((*(sync__Subscription*)array_get(subscr, i)).nxt)) != ((void*)0)) {
			(*(sync__Subscription*)array_get(subscr, i)).nxt->prev = &(*(sync__Subscription*)array_get(subscr, i)).nxt;
		}
		atomic_store_u16(sub_mtx, ((u16)(0U)));
	}
	time__StopWatch stopwatch = (time__Duration_alias_eq(timeout, _const_time__infinite) || timeout <= 0 ? (((time__StopWatch){.elapsed = 0,.start = 0,.end = 0,})) : (time__new_stopwatch(((time__StopWatchOptions){.auto_start = true,}))));
	int event_idx = -1;
	outer:
	for (;;) {
		_result_int _t1 = rand__intn(channels->len);
		if (_t1.is_error) {
			IError err = _t1.err;
			*(int*) _t1.data = 0;
		}
		
 		int rnd =  (*(int*)_t1.data);
		int num_closed = 0;
		for (int j = 0; j < channels->len; ++j) {
			int i = (int)(j + rnd);
			if (i >= channels->len) {
				i -= channels->len;
			}
			ChanState stat = ((*(sync__Direction*)array_get(dir, i)) == sync__Direction__push ? (sync__Channel_try_push_priv((*(sync__Channel**)array_get(*channels, i)), (*(voidptr*)array_get(*objrefs, i)), true)) : (sync__Channel_try_pop_priv((*(sync__Channel**)array_get(*channels, i)), (*(voidptr*)array_get(*objrefs, i)), true)));
			if (stat == ChanState__success) {
				event_idx = i;
				goto outer__break;
			} else if (stat == ChanState__closed) {
				num_closed++;
			}
		}
		if (num_closed == channels->len) {
			event_idx = -2;
			goto outer__break;
		}
		if (timeout <= 0) {
			goto outer__break;
		}
		if (!time__Duration_alias_eq(timeout, _const_time__infinite)) {
			i64 remaining = timeout - time__StopWatch_elapsed(stopwatch);
			if (!sync__Semaphore_timed_wait(&(*(sem)), remaining)) {
				goto outer__break;
			}
		} else {
			sync__Semaphore_wait(&(*(sem)));
		}
		outer__continue: {}
	}
	outer__break: {}
	for (int i = 0; i < channels->len; ++i) {
		sync__Channel* ch = ((sync__Channel**)channels->data)[i];
		u16* sub_mtx = ((*(sync__Direction*)array_get(dir, i)) == sync__Direction__push ? (&ch->write_sub_mtx) : (&ch->read_sub_mtx));
		u16 null16 = ((u16)(0U));
		for (;;) {
			if (!(!atomic_compare_exchange_weak_u16(sub_mtx, &null16, ((u16)(1U))))) break;
			null16 = ((u16)(0U));
		}
		{ // Unsafe block
			*(*(sync__Subscription*)array_get(subscr, i)).prev = (*(sync__Subscription*)array_get(subscr, i)).nxt;
		}
		if ((*(sync__Subscription*)array_get(subscr, i)).nxt != 0) {
			(*(sync__Subscription*)array_get(subscr, i)).nxt->prev = (*(sync__Subscription*)array_get(subscr, i)).prev;
			sync__Semaphore_post((*(sync__Subscription*)array_get(subscr, i)).nxt->sem);
		}
		atomic_store_u16(sub_mtx, ((u16)(0U)));
	}
	sync__Semaphore_destroy((*(sem)));
	return event_idx;
}

string sync__Mutex_str(sync__Mutex* m) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Mutex("), /*112 &voidptr*/0xfe11, {.d_p = (void*)(((voidptr)(m)))}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	return _t1;
}

string sync__RwMutex_str(sync__RwMutex* m) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("RwMutex("), /*112 &voidptr*/0xfe11, {.d_p = (void*)(((voidptr)(m)))}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	return _t1;
}

sync__ManyTimes* sync__new_many_times(u64 times) {
	sync__ManyTimes* many_times = ((sync__ManyTimes*)memdup(&(sync__ManyTimes){.m = (sync__RwMutex){.mx = {0},},.times = times,.count = 0,}, sizeof(sync__ManyTimes)));
	sync__RwMutex_init(&many_times->m);
	return many_times;
}

void sync__ManyTimes_do(sync__ManyTimes* m, void (*f)(void)) {
	if (sync__stdatomic__load_u64(&m->count) < m->times) {
		sync__ManyTimes_do_slow(m, (voidptr)f);
	}
}

VV_LOCAL_SYMBOL void sync__ManyTimes_do_slow(sync__ManyTimes* m, void (*f)(void)) {
	sync__RwMutex_lock(&m->m);
	if (m->count < m->times) {
		sync__stdatomic__store_u64(&m->count, (u64)(m->count + 1U));
		f();
	}
	sync__RwMutex_unlock(&m->m);
}

sync__Once* sync__new_once(void) {
	sync__Once* once = ((sync__Once*)memdup(&(sync__Once){.m = (sync__RwMutex){.mx = {0},},.count = 0,}, sizeof(sync__Once)));
	sync__RwMutex_init(&once->m);
	return once;
}

void sync__Once_do(sync__Once* o, void (*f)(void)) {
	if (sync__stdatomic__load_u64(&o->count) < 1U) {
		sync__Once_do_slow(o, (voidptr)f);
	}
}

VV_LOCAL_SYMBOL void sync__Once_do_slow(sync__Once* o, void (*f)(void)) {
	sync__RwMutex_lock(&o->m);
	if (o->count < 1U) {
		sync__stdatomic__store_u64(&o->count, 1U);
		f();
	}
	sync__RwMutex_unlock(&o->m);
}

void sync__Once_do_with_param(sync__Once* o, void (*f)(voidptr ), voidptr param) {
	if (sync__stdatomic__load_u64(&o->count) < 1U) {
		sync__Once_do_slow_with_param(o, (voidptr)f, param);
	}
}

VV_LOCAL_SYMBOL void sync__Once_do_slow_with_param(sync__Once* o, void (*f)(voidptr ), voidptr param) {
	sync__RwMutex_lock(&o->m);
	if (o->count < 1U) {
		sync__stdatomic__store_u64(&o->count, 1U);
		f(param);
	}
	sync__RwMutex_unlock(&o->m);
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void sync__cpanic(int res) {
	_v_panic(tos_clone(((u8*)(strerror(res)))));
	VUNREACHABLE();
	while(1);
}

// Attr: [noreturn]
VNORETURN VV_LOCAL_SYMBOL void sync__cpanic_errno(void) {
	sync__cpanic(errno);
	VUNREACHABLE();
	while(1);
}

// TypeDecl
// TypeDecl
sync__Mutex* sync__new_mutex(void) {
	sync__Mutex* m = ((sync__Mutex*)memdup(&(sync__Mutex){EMPTY_STRUCT_INITIALIZATION}, sizeof(sync__Mutex)));
	sync__Mutex_init(m);
	return m;
}

sync__RwMutex* sync__new_rwmutex(void) {
	sync__RwMutex* m = ((sync__RwMutex*)memdup(&(sync__RwMutex){EMPTY_STRUCT_INITIALIZATION}, sizeof(sync__RwMutex)));
	sync__RwMutex_init(m);
	return m;
}

void sync__Mutex_init(sync__Mutex* m) {
	InitializeSRWLock(&m->mx);
}

void sync__RwMutex_init(sync__RwMutex* m) {
	InitializeSRWLock(&m->mx);
}

void sync__Mutex_lock(sync__Mutex* m) {
	AcquireSRWLockExclusive(&m->mx);
}

void sync__Mutex_unlock(sync__Mutex* m) {
	ReleaseSRWLockExclusive(&m->mx);
}

void sync__RwMutex_rlock(sync__RwMutex* m) {
	AcquireSRWLockShared(&m->mx);
}

void sync__RwMutex_lock(sync__RwMutex* m) {
	AcquireSRWLockExclusive(&m->mx);
}

void sync__RwMutex_runlock(sync__RwMutex* m) {
	ReleaseSRWLockShared(&m->mx);
}

void sync__RwMutex_unlock(sync__RwMutex* m) {
	ReleaseSRWLockExclusive(&m->mx);
}

// Attr: [inline]
inline sync__Semaphore* sync__new_semaphore(void) {
	sync__Semaphore* _t1 = sync__new_semaphore_init(0U);
	return _t1;
}

sync__Semaphore* sync__new_semaphore_init(u32 n) {
	sync__Semaphore* sem = ((sync__Semaphore*)memdup(&(sync__Semaphore){.count = 0,}, sizeof(sync__Semaphore)));
	sync__Semaphore_init(sem, n);
	return sem;
}

void sync__Semaphore_init(sync__Semaphore* sem, u32 n) {
	atomic_store_u32(&sem->count, n);
	InitializeSRWLock(&sem->mtx);
	InitializeConditionVariable(&sem->cond);
}

void sync__Semaphore_post(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 1U)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c + 1U))) {
			return;
		}
	}
	AcquireSRWLockExclusive(&sem->mtx);
	c = atomic_fetch_add_u32(&sem->count, 1U);
	if (c == 0U) {
		WakeConditionVariable(&sem->cond);
	}
	ReleaseSRWLockExclusive(&sem->mtx);
}

void sync__Semaphore_wait(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0U)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1U))) {
			return;
		}
	}
	AcquireSRWLockExclusive(&sem->mtx);
	c = atomic_load_u32(&sem->count);
	outer:
	for (;;) {
		if (c == 0U) {
			SleepConditionVariableSRW(&sem->cond, &sem->mtx, INFINITE, 0U);
			c = atomic_load_u32(&sem->count);
		}
		for (;;) {
			if (!(c > 0U)) break;
			if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1U))) {
				if (c > 1U) {
					WakeConditionVariable(&sem->cond);
				}
				goto outer__break;
			}
		}
		outer__continue: {}
	}
	outer__break: {}
	ReleaseSRWLockExclusive(&sem->mtx);
}

bool sync__Semaphore_try_wait(sync__Semaphore* sem) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0U)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1U))) {
			bool _t1 = true;
			return _t1;
		}
	}
	bool _t2 = false;
	return _t2;
}

bool sync__Semaphore_timed_wait(sync__Semaphore* sem, time__Duration timeout) {
	u32 c = atomic_load_u32(&sem->count);
	for (;;) {
		if (!(c > 0U)) break;
		if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1U))) {
			bool _t1 = true;
			return _t1;
		}
	}
	struct _FILETIME ft_start = ((struct _FILETIME){.dwLowDateTime = 0,.dwHighDateTime = 0,});
	GetSystemTimeAsFileTime(&ft_start);
	u64 time_end = (u64)(((((((u64)(ft_start.dwHighDateTime)) << 32U)) | ft_start.dwLowDateTime)) + ((u64)(timeout / (100 * _const_time__nanosecond))));
	u32 t_ms = ((u32)(time__Duration_sys_milliseconds(timeout)));
	AcquireSRWLockExclusive(&sem->mtx);
	int res = 0;
	c = atomic_load_u32(&sem->count);
	outer:
	for (;;) {
		if (c == 0U) {
			res = SleepConditionVariableSRW(&sem->cond, &sem->mtx, t_ms, 0U);
			if (res == 0) {
				goto outer__break;
			}
			c = atomic_load_u32(&sem->count);
		}
		for (;;) {
			if (!(c > 0U)) break;
			if (atomic_compare_exchange_weak_u32(&sem->count, &c, (u32)(c - 1U))) {
				if (c > 1U) {
					WakeConditionVariable(&sem->cond);
				}
				goto outer__break;
			}
		}
		GetSystemTimeAsFileTime(&ft_start);
		u64 time_now = ((((((u64)(ft_start.dwHighDateTime)) << 32U)) | ft_start.dwLowDateTime));
		if (time_now > time_end) {
			goto outer__break;
		}
		t_ms = ((u32)((u64)(((u64)(time_end - time_now)) / 10000U)));
		outer__continue: {}
	}
	outer__break: {}
	ReleaseSRWLockExclusive(&sem->mtx);
	bool _t2 = res != 0;
	return _t2;
}

void sync__RwMutex_destroy(sync__RwMutex* m) {
}

void sync__Mutex_destroy(sync__Mutex* m) {
}

void sync__Semaphore_destroy(sync__Semaphore _v_toheap_s) {
sync__Semaphore* s = HEAP(sync__Semaphore, _v_toheap_s);
}

u64 sync__thread_id(void) {
	u64 _t1 = ((u64)(GetCurrentThreadId()));
	return _t1;
}

// Attr: [trusted]
// Attr: [trusted]
// Attr: [trusted]
sync__WaitGroup* sync__new_waitgroup(void) {
	sync__WaitGroup *wg = HEAP(sync__WaitGroup, (((sync__WaitGroup){.task_count = 0,.wait_count = 0,.sem = (sync__Semaphore){.mtx = {0},.cond = {0},.count = 0,},})));
	sync__WaitGroup_init(&(*(wg)));
	sync__WaitGroup* _t1 = &(*(wg));
	return _t1;
}

void sync__WaitGroup_init(sync__WaitGroup* wg) {
	sync__Semaphore_init(&wg->sem, 0U);
}

void sync__WaitGroup_add(sync__WaitGroup* wg, int delta) {
	int old_nrjobs = ((int)(atomic_fetch_add_u32(&wg->task_count, ((u32)(delta)))));
	int new_nrjobs = (int)(old_nrjobs + delta);
	u32 num_waiters = atomic_load_u32(&wg->wait_count);
	if (new_nrjobs < 0) {
		_v_panic(_SLIT("Negative number of jobs in waitgroup"));
		VUNREACHABLE();
	}
	if (new_nrjobs == 0 && num_waiters > 0U) {
		for (;;) {
			if (!(!atomic_compare_exchange_weak_u32(&wg->wait_count, &num_waiters, 0U))) break;
			if (num_waiters == 0U) {
				return;
			}
		}
		for (;;) {
			if (!((num_waiters > 0U))) break;
			sync__Semaphore_post(&wg->sem);
			num_waiters--;
		}
	}
}

void sync__WaitGroup_done(sync__WaitGroup* wg) {
	sync__WaitGroup_add(wg, -1);
}

void sync__WaitGroup_wait(sync__WaitGroup* wg) {
	int nrjobs = ((int)(atomic_load_u32(&wg->task_count)));
	if (nrjobs == 0) {
		return;
	}
	atomic_fetch_add_u32(&wg->wait_count, 1U);
	sync__Semaphore_wait(&wg->sem);
}

_result_multi_return_os__File_string io__util__temp_file(io__util__TempFileOptions tfo) {
	string d = tfo.path;
	if ((d).len == 0) {
		d = os__temp_dir();
	}
	_result_void _t1 = os__ensure_folder_is_writable(d);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_multi_return_os__File_string){ .is_error=true, .err=_v_error(string__plus(_SLIT("temp_file"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" could not create temporary file in \""), /*115 &string*/0xfe10, {.d_s = d}}, {_SLIT("\". Please ensure write permissions."), 0, { .d_c = 0 }}})))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 ;
	d = string_trim_right(d, _const_os__path_separator);
	_result_multi_return_string_string _t3 = io__util__prefix_and_suffix(tfo.pattern);
	if (_t3.is_error) {
		IError err = _t3.err;
		return (_result_multi_return_os__File_string){ .is_error=true, .err=_v_error(string__plus(_SLIT("temp_file"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}})))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	multi_return_string_string mr_542 =  (*(multi_return_string_string*)_t3.data);
	string prefix = mr_542.arg0;
	string suffix = mr_542.arg1;
	for (int retry = 0; retry < _const_io__util__retries; retry++) {
		string path = os__join_path(d, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string__plus(string__plus(prefix, io__util__random_number()), suffix)})));
		string mode = _SLIT("rw+");
		mode = _SLIT("w+");
		_result_os__File _t5 = os__open_file(path, mode, new_array_from_c_array_noscan(1, 1, sizeof(int), _MOV((int[1]){0600})));
		if (_t5.is_error) {
			IError err = _t5.err;
			continue;
		}
		
 		os__File file =  (*(os__File*)_t5.data);
		if (os__exists(path) && os__is_file(path)) {
			_result_multi_return_os__File_string _t6;
			_result_ok(&(multi_return_os__File_string[]) { (multi_return_os__File_string){.arg0=file, .arg1=path} }, (_result*)(&_t6), sizeof(multi_return_os__File_string));
			return _t6;
		}
	}
	return (_result_multi_return_os__File_string){ .is_error=true, .err=_v_error(string__plus(_SLIT("temp_file"),  str_intp(3, _MOV((StrIntpData[]){{_SLIT(" could not create temporary file in \""), /*115 &string*/0xfe10, {.d_s = d}}, {_SLIT("\". Retry limit ("), /*100 &int literal*/0xfe07, {.d_i32 = _const_io__util__retries}}, {_SLIT(") exhausted. Please ensure write permissions."), 0, { .d_c = 0 }}})))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_string io__util__error_for_temporary_folder(string fn_name, string d) {
	return (_result_string){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = fn_name}}, {_SLIT(" could not create temporary directory \""), /*115 &string*/0xfe10, {.d_s = d}}, {_SLIT("\". Please ensure you have write permissions for it."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_string io__util__temp_dir(io__util__TempFileOptions tdo) {
	string d = tdo.path;
	if ((d).len == 0) {
		d = os__temp_dir();
	}
	_result_void _t1 = os__ensure_folder_is_writable(d);
	if (_t1.is_error) {
		IError err = _t1.err;
		_result_string _t2 = io__util__error_for_temporary_folder(_SLIT("temp_dir"), d);
		return _t2;
	}
	
 ;
	d = string_trim_right(d, _const_os__path_separator);
	_result_multi_return_string_string _t3 = io__util__prefix_and_suffix(tdo.pattern);
	if (_t3.is_error) {
		IError err = _t3.err;
		return (_result_string){ .is_error=true, .err=_v_error(string__plus(_SLIT("temp_dir"),  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT0, 0, { .d_c = 0 }}})))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	multi_return_string_string mr_1645 =  (*(multi_return_string_string*)_t3.data);
	string prefix = mr_1645.arg0;
	string suffix = mr_1645.arg1;
	for (int retry = 0; retry < _const_io__util__retries; retry++) {
		string path = os__join_path(d, new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){string__plus(string__plus(prefix, io__util__random_number()), suffix)})));
		_result_void _t5 = os__mkdir_all(path, ((os__MkdirParams){.mode = 0777,}));
		if (_t5.is_error) {
			IError err = _t5.err;
			continue;
		}
		
 ;
		if (os__is_dir(path) && os__exists(path)) {
			_result_void _t6 = os__ensure_folder_is_writable(path);
			if (_t6.is_error) {
				IError err = _t6.err;
				_result_string _t7 = io__util__error_for_temporary_folder(_SLIT("temp_dir"), d);
				return _t7;
			}
			
 ;
			_result_string _t8;
			_result_ok(&(string[]) { path }, (_result*)(&_t8), sizeof(string));
			return _t8;
		}
	}
	return (_result_string){ .is_error=true, .err=_v_error( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = _SLIT("temp_dir")}}, {_SLIT(" could not create temporary directory \""), /*115 &string*/0xfe10, {.d_s = d}}, {_SLIT("\". Retry limit ("), /*100 &int literal*/0xfe07, {.d_i32 = _const_io__util__retries}}, {_SLIT(") exhausted."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL string io__util__random_number(void) {
	_result_u32 _t1 = rand__u32n(1000000000U);
	if (_t1.is_error) {
		IError err = _t1.err;
		*(u32*) _t1.data = 0U;
	}
	
 	string s = u32_str(((u32)(1000000000 + ((u32)(((u32)(os__getpid())) +  (*(u32*)_t1.data))))));
	string _t2 = string_substr(s, 1, s.len);
	return _t2;
}

VV_LOCAL_SYMBOL _result_multi_return_string_string io__util__prefix_and_suffix(string pattern) {
	string pat = pattern;
	if (string_contains(pat, _const_os__path_separator)) {
		return (_result_multi_return_string_string){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("pattern cannot contain path separators ("), /*115 &string*/0xfe10, {.d_s = _const_os__path_separator}}, {_SLIT(")."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int pos = string_index_u8_last(pat, '*');
	string prefix = _SLIT("");
	string suffix = _SLIT("");
	if (pos != -1) {
		prefix = string_substr(pat, 0, pos);
		suffix = string_substr(pat, (int)(pos + 1), pat.len);
	} else {
		prefix = pat;
	}
	_result_multi_return_string_string _t2;
	_result_ok(&(multi_return_string_string[]) { (multi_return_string_string){.arg0=prefix, .arg1=suffix} }, (_result*)(&_t2), sizeof(multi_return_string_string));
	return _t2;
}

VV_LOCAL_SYMBOL string log__tag_to_cli(log__Level l) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (l) {
		case log__Level__disabled: {
				_t2 = _SLIT("");
				break;
		}
		case log__Level__fatal: {
				_t2 = term__red(_SLIT("FATAL"));
				break;
		}
		case log__Level__error: {
				_t2 = term__red(_SLIT("ERROR"));
				break;
		}
		case log__Level__warn: {
				_t2 = term__yellow(_SLIT("WARN "));
				break;
		}
		case log__Level__info: {
				_t2 = term__white(_SLIT("INFO "));
				break;
		}
		case log__Level__debug: {
				_t2 = term__magenta(_SLIT("DEBUG"));
				break;
		}
	}
	string _t1 = _t2;
	return _t1;
}

VV_LOCAL_SYMBOL string log__tag_to_file(log__Level l) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (l) {
		case log__Level__disabled: {
				_t2 = _SLIT("     ");
				break;
		}
		case log__Level__fatal: {
				_t2 = _SLIT("FATAL");
				break;
		}
		case log__Level__error: {
				_t2 = _SLIT("ERROR");
				break;
		}
		case log__Level__warn: {
				_t2 = _SLIT("WARN ");
				break;
		}
		case log__Level__info: {
				_t2 = _SLIT("INFO ");
				break;
		}
		case log__Level__debug: {
				_t2 = _SLIT("DEBUG");
				break;
		}
	}
	string _t1 = _t2;
	return _t1;
}

_option_log__Level log__level_from_tag(string tag) {
	_option_log__Level _t2 = {0};
	
	if (string__eq(tag, _SLIT("DISABLED"))) {
		_option_ok(&(log__Level[]) { log__Level__disabled }, (_option*)(&_t2), sizeof(log__Level));
	}
	else if (string__eq(tag, _SLIT("FATAL"))) {
		_option_ok(&(log__Level[]) { log__Level__fatal }, (_option*)(&_t2), sizeof(log__Level));
	}
	else if (string__eq(tag, _SLIT("ERROR"))) {
		_option_ok(&(log__Level[]) { log__Level__error }, (_option*)(&_t2), sizeof(log__Level));
	}
	else if (string__eq(tag, _SLIT("WARN"))) {
		_option_ok(&(log__Level[]) { log__Level__warn }, (_option*)(&_t2), sizeof(log__Level));
	}
	else if (string__eq(tag, _SLIT("INFO"))) {
		_option_ok(&(log__Level[]) { log__Level__info }, (_option*)(&_t2), sizeof(log__Level));
	}
	else if (string__eq(tag, _SLIT("DEBUG"))) {
		_option_ok(&(log__Level[]) { log__Level__debug }, (_option*)(&_t2), sizeof(log__Level));
	}
	else {
		_t2.state = 2;
		_t2.err = _const_none__;
	}_option_log__Level _t1 = _t2;
	return _t1;
}

_option_log__LogTarget log__target_from_label(string label) {
	_option_log__LogTarget _t2 = {0};
	
	if (string__eq(label, _SLIT("console"))) {
		_option_ok(&(log__LogTarget[]) { log__LogTarget__console }, (_option*)(&_t2), sizeof(log__LogTarget));
	}
	else if (string__eq(label, _SLIT("file"))) {
		_option_ok(&(log__LogTarget[]) { log__LogTarget__file }, (_option*)(&_t2), sizeof(log__LogTarget));
	}
	else if (string__eq(label, _SLIT("both"))) {
		_option_ok(&(log__LogTarget[]) { log__LogTarget__both }, (_option*)(&_t2), sizeof(log__LogTarget));
	}
	else {
		_t2.state = 2;
		_t2.err = _const_none__;
	}_option_log__LogTarget _t1 = _t2;
	return _t1;
}

// Attr: [manualfree]
void log__set_logger(log__Logger* logger) {
	log__Logger* old_logger = default_logger;
	default_logger = logger;
	log__free_logger(old_logger);
}

// Attr: [unsafe]
log__Logger* log__get_logger(void) {
	return default_logger;
}

log__Level log__get_level(void) {
	log__Level _t1 = log__Logger_name_table[default_logger->_typ]._method_get_level(default_logger->_object);
	return _t1;
}

void log__set_level(log__Level level) {
	log__Logger_name_table[default_logger->_typ]._method_set_level(default_logger->_object, level);
}

void log__fatal(string s) {
	log__Logger_name_table[default_logger->_typ]._method_fatal(default_logger->_object, s);
}

void log__error(string s) {
	log__Logger_name_table[default_logger->_typ]._method__v_error(default_logger->_object, s);
}

void log__warn(string s) {
	log__Logger_name_table[default_logger->_typ]._method_warn(default_logger->_object, s);
}

void log__info(string s) {
	log__Logger_name_table[default_logger->_typ]._method_info(default_logger->_object, s);
}

void log__debug(string s) {
	log__Logger_name_table[default_logger->_typ]._method_debug(default_logger->_object, s);
}

log__Level log__Log_get_level(log__Log* l) {
	log__Level _t1 = l->level;
	return _t1;
}

void log__Log_set_level(log__Log* l, log__Level level) {
	l->level = level;
}

// Attr: [deprecated]
// Attr: [deprecated_after]
void log__Log_set_output_level(log__Log* l, log__Level level) {
	l->level = level;
}

void log__Log_set_full_logpath(log__Log* l, string full_log_path) {
	string rlog_file = os__real_path(full_log_path);
	log__Log_set_output_label(l, os__file_name(rlog_file));
	log__Log_set_output_path(l, os__dir(rlog_file));
}

void log__Log_set_output_label(log__Log* l, string label) {
	l->output_label = label;
}

void log__Log_set_output_path(log__Log* l, string output_file_path) {
	if (l->ofile.is_opened) {
		os__File_close(&l->ofile);
	}
	l->output_target = log__LogTarget__file;
	l->output_file_name = os__join_path(os__real_path(output_file_path), new_array_from_c_array(1, 1, sizeof(string), _MOV((string[1]){l->output_label})));
	_result_os__File _t1 = os__open_append(l->output_file_name);
	if (_t1.is_error) {
		IError err = _t1.err;
		_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("error while opening log file "), /*115 &string*/0xfe10, {.d_s = l->output_file_name}}, {_SLIT(" for appending"), 0, { .d_c = 0 }}})));
		VUNREACHABLE();
	;
	}
	
 	os__File ofile =  (*(os__File*)_t1.data);
	l->ofile = ofile;
}

void log__Log_log_to_console_too(log__Log* l) {
	if (l->output_target != log__LogTarget__file) {
		_v_panic(_SLIT("log_to_console_too should be called *after* .set_output_path"));
		VUNREACHABLE();
	}
	l->output_target = log__LogTarget__both;
}

void log__Log_flush(log__Log* l) {
	os__File_flush(&l->ofile);
}

void log__Log_close(log__Log* l) {
	os__File_close(&l->ofile);
}

_result_void log__Log_reopen(log__Log* l) {
	log__Log_flush(l);
	if (l->output_target == log__LogTarget__file || l->output_target == log__LogTarget__both) {
		_result_void _t1 = os__File_reopen(&l->ofile, l->output_file_name, _SLIT("ab"));
		if (_t1.is_error) {
			IError err = _t1.err;
			return (_result_void){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("re-opening log file `"), /*115 &string*/0xfe10, {.d_s = l->output_file_name}}, {_SLIT("` for appending failed"), 0, { .d_c = 0 }}})), 1), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 ;
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL void log__Log_log_file(log__Log* l, string s, log__Level level) {
	string timestamp = time__Time_format_ss_micro(time__now());
	string e = log__tag_to_file(level);
	_result_int _t1 = os__File_writeln(&l->ofile,  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = timestamp}}, {_SLIT(" ["), /*115 &string*/0xfe10, {.d_s = e}}, {_SLIT("] "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (_t1.is_error) {
		IError err = _t1.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
  (*(int*)_t1.data);
}

VV_LOCAL_SYMBOL void log__Log_log_cli(log__Log* l, string s, log__Level level) {
	string timestamp = time__Time_format_ss_micro(time__now());
	string e = log__tag_to_cli(level);
	println( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = timestamp}}, {_SLIT(" ["), /*115 &string*/0xfe10, {.d_s = e}}, {_SLIT("] "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
}

void log__Log_send_output(log__Log* l, string* s, log__Level level) {
	if (l->output_target == log__LogTarget__file || l->output_target == log__LogTarget__both) {
		log__Log_log_file(l, *s, level);
	}
	if (l->output_target == log__LogTarget__console || l->output_target == log__LogTarget__both) {
		log__Log_log_cli(l, *s, level);
	}
}

// Attr: [noreturn]
VNORETURN void log__Log_fatal(log__Log* l, string s) {
	if (((int)(l->level)) >= ((int)(log__Level__fatal))) {
		log__Log_send_output(l, (voidptr)&/*qq*/s, log__Level__fatal);
		os__File_close(&l->ofile);
	}
	_v_panic( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = l->output_label}}, {_SLIT(": "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}})));
	VUNREACHABLE();
	while(1);
}

void log__Log_error(log__Log* l, string s) {
	if (((int)(l->level)) < ((int)(log__Level__error))) {
		return;
	}
	log__Log_send_output(l, (voidptr)&/*qq*/s, log__Level__error);
}

void log__Log_warn(log__Log* l, string s) {
	if (((int)(l->level)) < ((int)(log__Level__warn))) {
		return;
	}
	log__Log_send_output(l, (voidptr)&/*qq*/s, log__Level__warn);
}

void log__Log_info(log__Log* l, string s) {
	if (((int)(l->level)) < ((int)(log__Level__info))) {
		return;
	}
	log__Log_send_output(l, (voidptr)&/*qq*/s, log__Level__info);
}

void log__Log_debug(log__Log* l, string s) {
	if (((int)(l->level)) < ((int)(log__Level__debug))) {
		return;
	}
	log__Log_send_output(l, (voidptr)&/*qq*/s, log__Level__debug);
}

// Attr: [unsafe]
void log__Log_free(log__Log* f) {
	{ // Unsafe block
		string_free(&f->output_label);
		os__File_close(&f->ofile);
		string_free(&f->output_file_name);
	}
}

log__ThreadSafeLog* log__new_thread_safe_log(void) {
	log__ThreadSafeLog* x = ((log__ThreadSafeLog*)memdup(&(log__ThreadSafeLog){.Log = ((log__Log){.level = log__Level__info,.output_label = (string){.str=(byteptr)"", .is_lit=1},.ofile = (os__File){.cfile = 0,.fd = 0,.is_opened = 0,},.output_target = 0,.output_file_name = (string){.str=(byteptr)"", .is_lit=1},}),.mu = (sync__Mutex){.mx = {0},},}, sizeof(log__ThreadSafeLog)));
	sync__Mutex_init(&x->mu);
	return x;
}

// Attr: [unsafe]
void log__ThreadSafeLog_free(log__ThreadSafeLog* x) {
	{ // Unsafe block
		log__Log_free(&x->Log);
		sync__Mutex_destroy(&x->mu);
	}
}

void log__ThreadSafeLog_set_level(log__ThreadSafeLog* x, log__Level level) {
	sync__Mutex_lock(&x->mu);
	log__Log_set_level(&x->Log, level);
	sync__Mutex_unlock(&x->mu);
}

void log__ThreadSafeLog_debug(log__ThreadSafeLog* x, string s) {
	sync__Mutex_lock(&x->mu);
	log__Log_debug(&x->Log, s);
	sync__Mutex_unlock(&x->mu);
}

void log__ThreadSafeLog_info(log__ThreadSafeLog* x, string s) {
	sync__Mutex_lock(&x->mu);
	log__Log_info(&x->Log, s);
	sync__Mutex_unlock(&x->mu);
}

void log__ThreadSafeLog_warn(log__ThreadSafeLog* x, string s) {
	sync__Mutex_lock(&x->mu);
	log__Log_warn(&x->Log, s);
	sync__Mutex_unlock(&x->mu);
}

void log__ThreadSafeLog_error(log__ThreadSafeLog* x, string s) {
	sync__Mutex_lock(&x->mu);
	log__Log_error(&x->Log, s);
	sync__Mutex_unlock(&x->mu);
}

// Attr: [noreturn]
VNORETURN void log__ThreadSafeLog_fatal(log__ThreadSafeLog* x, string s) {
	bool log__ThreadSafeLog_fatal_defer_0 = false;
	sync__Mutex_lock(&x->mu);
	log__ThreadSafeLog_fatal_defer_0 = true;
	log__Log_fatal(&x->Log, s);
	VUNREACHABLE();
	while(1);
}

VV_LOCAL_SYMBOL void log__init(void) {
	default_logger = HEAP(log__Logger, /*&log.Logger*/I_log__ThreadSafeLog_to_Interface_log__Logger(log__new_thread_safe_log()));
	atexit((voidptr)log__deinit);
}

VV_LOCAL_SYMBOL void log__deinit(void) {
	log__free_logger(default_logger);
}

// Attr: [manualfree]
VV_LOCAL_SYMBOL void log__free_logger(log__Logger* logger) {
	if (((voidptr)(logger)) == ((void*)0)) {
		return;
	}
	{ // Unsafe block
		log__Logger_name_table[logger->_typ]._method__v_free(logger->_object);
		voidptr pobject = ((log__Logger*)(logger))->_object;
		_v_free(pobject);
		_v_free(logger);
	}
}

#if defined(_WIN32)
	#if defined(_MSC_VER)
	#else
	#endif
#else
#endif
net__Addr net__new_ip6(u16 port, Array_fixed_u8_16 addr) {
	u16 n_port = net__conv__hton16(port);
	net__Addr a = ((net__Addr){.f = ((u8)(net__AddrFamily__ip6)),.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = n_port,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
	vmemcpy(&a.addr.Ip6.addr[0], &addr[0], 16);
	return a;
}

net__Addr net__new_ip(u16 port, Array_fixed_u8_4 addr) {
	u16 n_port = net__conv__hton16(port);
	net__Addr a = ((net__Addr){.f = ((u8)(net__AddrFamily__ip)),.addr = ((net__AddrData){.Ip = ((net__Ip){.port = n_port,.addr = {0, 0, 0, 0},.sin_pad = {0, 0, 0, 0, 0, 0, 0, 0},}),}),});
	vmemcpy(&a.addr.Ip.addr[0], &addr[0], 4);
	return a;
}

VV_LOCAL_SYMBOL _result_net__Addr net__temp_unix(void) {
	_result_multi_return_os__File_string _t1 = io__util__temp_file(((io__util__TempFileOptions){.path = os__temp_dir(),.pattern = (string){.str=(byteptr)"", .is_lit=1},}));
	if (_t1.is_error) {
		_result_net__Addr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_os__File_string mr_962 =  (*(multi_return_os__File_string*)_t1.data);
	os__File file = mr_962.arg0;
	string filename = mr_962.arg1;
	os__File_close(&file);
	_result_void _t3 = os__rm(filename);
	if (_t3.is_error) {
		_result_net__Addr _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	_result_Array_net__Addr _t5 = net__resolve_addrs(filename, net__AddrFamily__unix, net__SocketType__udp);
	if (_t5.is_error) {
		_result_net__Addr _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 	Array_net__Addr addrs =  (*(Array_net__Addr*)_t5.data);
	_result_net__Addr _t7;
	_result_ok(&(net__Addr[]) { (*(net__Addr*)array_get(addrs, 0)) }, (_result*)(&_t7), sizeof(net__Addr));
	return _t7;
}

net__AddrFamily net__Addr_family(net__Addr a) {
	net__AddrFamily _t1 = ((net__AddrFamily)(a.f));
	return _t1;
}

string net__Ip_str(net__Ip a) {
	Array_fixed_char_24 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	char* res = ((char*)(inet_ntop(net__AddrFamily__ip, &a.addr, &buf[0], 24)));
	if (res == 0) {
		string _t1 = _SLIT("<Unknown>");
		return _t1;
	}
	string saddr = cstring_to_vstring(&buf[0]);
	u16 port = net__conv__ntoh16(a.port);
	string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = saddr}}, {_SLIT(":"), /*117 &u16*/0xfe04, {.d_u16 = port}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t2;
}

string net__Ip6_str(net__Ip6 a) {
	Array_fixed_char_46 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	char* res = ((char*)(inet_ntop(net__AddrFamily__ip6, &a.addr, &buf[0], 46)));
	if (res == 0) {
		string _t1 = _SLIT("<Unknown>");
		return _t1;
	}
	string saddr = cstring_to_vstring(&buf[0]);
	u16 port = net__conv__ntoh16(a.port);
	string _t2 =  str_intp(3, _MOV((StrIntpData[]){{_SLIT("["), /*115 &string*/0xfe10, {.d_s = saddr}}, {_SLIT("]:"), /*117 &u16*/0xfe04, {.d_u16 = port}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t2;
}

u32 net__Addr_len(net__Addr a) {
	net__AddrFamily /*A*/ _t1 = net__Addr_family(a);
	
	if (_t1 == (net__AddrFamily__ip)) {
		u32 _t2 = (u32)(sizeof(net__Ip) + _const_net__aoffset);
		return _t2;
	}
	else if (_t1 == (net__AddrFamily__ip6)) {
		u32 _t3 = (u32)(sizeof(net__Ip6) + _const_net__aoffset);
		return _t3;
	}
	else if (_t1 == (net__AddrFamily__unix)) {
		u32 _t4 = (u32)(sizeof(net__Unix) + _const_net__aoffset);
		return _t4;
	}
	else {
		_v_panic(_SLIT("Unknown address family"));
		VUNREACHABLE();
	}
	return 0;
}

_result_Array_net__Addr net__resolve_addrs(string addr, net__AddrFamily family, net__SocketType type) {

	if (family == (net__AddrFamily__ip) || family == (net__AddrFamily__ip6) || family == (net__AddrFamily__unspec)) {
		_result_Array_net__Addr _t1 = net__resolve_ipaddrs(addr, family, type);
		return _t1;
	}
	else if (family == (net__AddrFamily__unix)) {
		net__Unix resolved = ((net__Unix){.path = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},});
		if (addr.len > _const_net__max_unix_path) {
			return (_result_Array_net__Addr){ .is_error=true, .err=_v_error(_SLIT("net: resolve_addrs Unix socket address is too long")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		memcpy(&resolved.path, addr.str, addr.len);
		_result_Array_net__Addr _t3;
		_result_ok(&(Array_net__Addr[]) { new_array_from_c_array_noscan(1, 1, sizeof(net__Addr), _MOV((net__Addr[1]){((net__Addr){.f = ((u8)(net__AddrFamily__unix)),.addr = ((net__AddrData){.Unix = resolved,}),})})) }, (_result*)(&_t3), sizeof(Array_net__Addr));
		return _t3;
	}
	return (_result_Array_net__Addr){0};
}

_result_Array_net__Addr net__resolve_addrs_fuzzy(string addr, net__SocketType type) {
	if (addr.len == 0) {
		return (_result_Array_net__Addr){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (string_contains(addr, _SLIT(":"))) {
		_result_Array_net__Addr _t2 = net__resolve_addrs(addr, net__AddrFamily__unspec, type);
		return _t2;
	}
	_result_Array_net__Addr _t3 = net__resolve_addrs(addr, net__AddrFamily__unix, type);
	return _t3;
}

_result_Array_net__Addr net__resolve_ipaddrs(string addr, net__AddrFamily family, net__SocketType typ) {
	bool net__resolve_ipaddrs_defer_0 = false;
	struct addrinfo* results;
	_result_multi_return_string_u16 _t1 = net__split_address(addr);
	if (_t1.is_error) {
		_result_Array_net__Addr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_string_u16 mr_3593 =  (*(multi_return_string_u16*)_t1.data);
	string address = mr_3593.arg0;
	u16 port = mr_3593.arg1;
	if (string_at(addr, 0) == ':') {

		if (family == (net__AddrFamily__ip6)) {
			_result_Array_net__Addr _t3;
			_result_ok(&(Array_net__Addr[]) { new_array_from_c_array_noscan(1, 1, sizeof(net__Addr), _MOV((net__Addr[1]){net__new_ip6(port, _const_net__addr_ip6_any)})) }, (_result*)(&_t3), sizeof(Array_net__Addr));
			return _t3;
		}
		else if (family == (net__AddrFamily__ip) || family == (net__AddrFamily__unspec)) {
			_result_Array_net__Addr _t4;
			_result_ok(&(Array_net__Addr[]) { new_array_from_c_array_noscan(1, 1, sizeof(net__Addr), _MOV((net__Addr[1]){net__new_ip(port, _const_net__addr_ip_any)})) }, (_result*)(&_t4), sizeof(Array_net__Addr));
			return _t4;
		}
		else {
		}
	}
	struct addrinfo hints;
	vmemset(&hints, 0, ((int)(sizeof(struct addrinfo))));
	hints.ai_family = ((int)(family));
	hints.ai_socktype = ((int)(typ));
	hints.ai_flags = AI_PASSIVE;
	results = ((struct addrinfo*)(((void*)0)));
	string sport =  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*117 &u16*/0xfe04, {.d_u16 = port}}, {_SLIT0, 0, { .d_c = 0 }}}));
	#if defined(_WIN32)
	{
		_result_int _t6 = net__socket_error((int)(0 - getaddrinfo(((char*)(address.str)), ((char*)(sport.str)), &hints, &results)));
		if (_t6.is_error) {
			_result_Array_net__Addr _t7;
			memcpy(&_t7, &_t6, sizeof(_result));
			return _t7;
		}
		
  (*(int*)_t6.data);
	}
	#else
	{
	}
	#endif
	net__resolve_ipaddrs_defer_0 = true;
	Array_net__Addr addresses = __new_array_with_default_noscan(0, 0, sizeof(net__Addr), 0);
	for (struct addrinfo* result = results; !isnil(result); result = result->ai_next) {
		net__AddrFamily /*A*/ _t8 = ((net__AddrFamily)(result->ai_family));
		
		if (_t8 == (net__AddrFamily__ip)) {
			net__Addr new_addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip = ((net__Ip){.port = 0,.addr = {0, 0, 0, 0},.sin_pad = {0, 0, 0, 0, 0, 0, 0, 0},}),}),});
			memcpy(&new_addr, result->ai_addr, result->ai_addrlen);
			array_push_noscan((array*)&addresses, _MOV((net__Addr[]){ new_addr }));
		}
		else if (_t8 == (net__AddrFamily__ip6)) {
			net__Addr new_addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
			memcpy(&new_addr, result->ai_addr, result->ai_addrlen);
			array_push_noscan((array*)&addresses, _MOV((net__Addr[]){ new_addr }));
		}
		else {
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Unexpected address family "), /*100 &int*/0xfe07, {.d_i32 = result->ai_family}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
	_result_Array_net__Addr _t11;
	_result_ok(&(Array_net__Addr[]) { addresses }, (_result*)(&_t11), sizeof(Array_net__Addr));
		// Defer begin
		if (net__resolve_ipaddrs_defer_0) {
			freeaddrinfo(results);
		}
		// Defer end
	return _t11;
}

string net__Addr_str(net__Addr a) {
	net__AddrFamily /*A*/ _t1 = ((net__AddrFamily)(a.f));
	
	if (_t1 == (net__AddrFamily__ip)) {
		{ // Unsafe block
			string _t2 = net__Ip_str(a.addr.Ip);
			return _t2;
		}
	}
	else if (_t1 == (net__AddrFamily__ip6)) {
		{ // Unsafe block
			string _t3 = net__Ip6_str(a.addr.Ip6);
			return _t3;
		}
	}
	else if (_t1 == (net__AddrFamily__unix)) {
		{ // Unsafe block
			string _t4 = tos_clone(array_slice(new_array_from_c_array_noscan(108, 108, sizeof(u8), a.addr.Unix.path), 0, _const_net__max_unix_path).data);
			return _t4;
		}
	}
	else if (_t1 == (net__AddrFamily__unspec)) {
		string _t5 = _SLIT("<.unspec>");
		return _t5;
	}
	return (string){.str=(byteptr)"", .is_lit=1};
}

net__Addr net__addr_from_socket_handle(int handle) {
	net__Addr addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
	u32 size = sizeof(net__Addr);
	getsockname(handle, ((voidptr)(&addr)), &size);
	return addr;
}

_result_net__Addr net__peer_addr_from_socket_handle(int handle) {
	net__Addr addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
	u32 size = sizeof(net__Addr);
	_result_int _t1 = net__socket_error_message(getpeername(handle, ((voidptr)(&addr)), &size), _SLIT("peer_addr_from_socket_handle failed"));
	if (_t1.is_error) {
		_result_net__Addr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(int*)_t1.data);
	_result_net__Addr _t3;
	_result_ok(&(net__Addr[]) { addr }, (_result*)(&_t3), sizeof(net__Addr));
	return _t3;
}

int net__shutdown(int handle, net__ShutdownConfig config) {
	#if defined(_WIN32)
	{
		int _t2 = shutdown(handle, ((int)(config.how)));
		return _t2;
	}
	#else
	{
	}
	#endif
	return 0;
}

_result_void net__close(int handle) {
	#if defined(_WIN32)
	{
		_result_int _t2 = net__socket_error(closesocket(handle));
		if (_t2.is_error) {
			_result_void _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
  (*(int*)_t2.data);
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_bool net__select(int handle, net__Select test, time__Duration timeout) {
	fd_set set = ((fd_set){EMPTY_STRUCT_INITIALIZATION});
	FD_ZERO(&set);
	FD_SET(handle, &set);
	i64 seconds = timeout / _const_time__second;
	i64 microseconds = time__Duration_microseconds(((timeout - (seconds * _const_time__second))));
	struct timeval *tt = HEAP(struct timeval, (((struct timeval){.tv_sec = ((u64)(seconds)),.tv_usec = ((u64)(microseconds)),})));
	struct timeval* timeval_timeout = &(*(tt));
	if (time__Duration_alias_eq(timeout, _const_net__infinite_timeout)) {
		timeval_timeout = ((struct timeval*)(((void*)0)));
	}

	if (test == (net__Select__read)) {
		_result_int _t1 = net__socket_error(select((int)(handle + 1), &set, NULL, NULL, timeval_timeout));
		if (_t1.is_error) {
			_result_bool _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
  (*(int*)_t1.data);
	}
	else if (test == (net__Select__write)) {
		_result_int _t3 = net__socket_error(select((int)(handle + 1), NULL, &set, NULL, timeval_timeout));
		if (_t3.is_error) {
			_result_bool _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
  (*(int*)_t3.data);
	}
	else if (test == (net__Select__except)) {
		_result_int _t5 = net__socket_error(select((int)(handle + 1), NULL, NULL, &set, timeval_timeout));
		if (_t5.is_error) {
			_result_bool _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
  (*(int*)_t5.data);
	}
	_result_bool _t7;
	_result_ok(&(bool[]) { FD_ISSET(handle, &set) != 0 }, (_result*)(&_t7), sizeof(bool));
	return _t7;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL _result_bool net__select_deadline(int handle, net__Select test, time__Time deadline) {
	bool infinite = time__Time_unix_time(&deadline) == 0;
	for (;;) {
		if (!(infinite || !time__Time__lt(deadline, time__now()))) break;
		time__Duration timeout = (infinite ? (_const_net__infinite_timeout) : (time__Time__minus(deadline, time__now())));
		_result_bool _t1 = net__select(handle, test, timeout);
		if (_t1.is_error) {
			IError err = _t1.err;
			if (IError_name_table[err._typ]._method_code(err._object) == 4) {
				continue;
			}
			return (_result_bool){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		bool ready =  (*(bool*)_t1.data);
		_result_bool _t3;
		_result_ok(&(bool[]) { ready }, (_result*)(&_t3), sizeof(bool));
		return _t3;
	}
	return (_result_bool){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_void net__wait_for_common(int handle, time__Time deadline, time__Duration timeout, net__Select test) {
	time__Time _t1; /* if prepend */
	if (time__Duration_alias_eq(timeout, _const_net__infinite_timeout)) {
		_t1 = time__unix(0);
	} else if (timeout == 0) {
		_t1 = deadline;
	} else if (timeout < 0) {
		_v_panic(_SLIT("invalid negative timeout"));
		VUNREACHABLE();
	} else {
		_t1 = time__Time_add(ADDR(time__Time, time__now()), timeout);
	}
	time__Time real_deadline =  _t1;
	_result_bool _t2 = net__select_deadline(handle, test, real_deadline);
	if (_t2.is_error) {
		_result_void _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	bool ready =  (*(bool*)_t2.data);
	if (ready) {
		return (_result_void){0};
	}
	return (_result_void){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_void net__wait_for_write(int handle, time__Time deadline, time__Duration timeout) {
	_result_void _t1 = net__wait_for_common(handle, deadline, timeout, net__Select__write);
	return _t1;
}

VV_LOCAL_SYMBOL _result_void net__wait_for_read(int handle, time__Time deadline, time__Duration timeout) {
	_result_void _t1 = net__wait_for_common(handle, deadline, timeout, net__Select__read);
	return _t1;
}

_result_int net__socket_error_message(int potential_code, string s) {
	_result_int _t2 = net__socket_error(potential_code);
	if (_t2.is_error) {
		IError err = _t2.err;
		return (_result_int){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	_result_int _t1;
	_result_ok(&(int[]) {  (*(int*)_t2.data) }, (_result*)(&_t1), sizeof(int));
	return _t1;
}

_result_int net__socket_error(int potential_code) {
	#if defined(_WIN32)
	{
		if (potential_code < 0) {
			int last_error_int = WSAGetLastError();
			net__WsaError last_error = net__wsa_error(last_error_int);
			return (_result_int){ .is_error=true, .err=error_with_code( str_intp(3, _MOV((StrIntpData[]){{_SLIT("net: socket error: ("), /*100 &int*/0xfe07, {.d_i32 = last_error_int}}, {_SLIT(") "), /*115 &net.WsaError*/0xfe10, {.d_s = net__WsaError_str(last_error)}}, {_SLIT0, 0, { .d_c = 0 }}})), ((int)(last_error))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	#else
	{
	}
	#endif
	_result_int _t3;
	_result_ok(&(int[]) { potential_code }, (_result*)(&_t3), sizeof(int));
	return _t3;
}

_result_void net__wrap_error(int error_code) {
	if (error_code == 0) {
		return (_result_void){0};
	}
	#if defined(_WIN32)
	{
		net__WsaError enum_error = net__wsa_error(error_code);
		return (_result_void){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("net: socket error: "), /*115 &net.WsaError*/0xfe10, {.d_s = net__WsaError_str(enum_error)}}, {_SLIT0, 0, { .d_c = 0 }}})), error_code), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL _result_int net__wrap_read_result(int result) {
	if (result == 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t2;
	_result_ok(&(int[]) { result }, (_result*)(&_t2), sizeof(int));
	return _t2;
}

// Attr: [inline]
inline VV_LOCAL_SYMBOL _result_int net__wrap_write_result(int result) {
	if (result == 0) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_int _t2;
	_result_ok(&(int[]) { result }, (_result*)(&_t2), sizeof(int));
	return _t2;
}

net__WsaError net__wsa_error(int code) {
	net__WsaError _t1 = ((net__WsaError)(code));
	return _t1;
}

int net__error_code(void) {
	int _t1 = WSAGetLastError();
	return _t1;
}

VV_LOCAL_SYMBOL void net__init(void) {
	struct WSAData wsadata = ((struct WSAData){.wVersion = 0,.wHighVersion = 0,.szDescription = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.szSystemStatus = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.iMaxSockets = 0,.iMaxUdpDg = 0,.lpVendorInfo = 0,});
	int res = WSAStartup(_const_net__wsa_v22, &wsadata);
	if (res != 0) {
		_v_panic(_SLIT("socket: WSAStartup failed"));
		VUNREACHABLE();
	}
}

_result_net__Addr net__Socket_address(net__Socket* s) {
	_result_net__Addr _t1;
	_result_ok(&(net__Addr[]) { net__addr_from_socket_handle(s->handle) }, (_result*)(&_t1), sizeof(net__Addr));
	return _t1;
}

_result_net__TcpConn_ptr net__dial_tcp(string oaddress) {
	string address = oaddress;
	if (string_starts_with(address, _SLIT(":::"))) {
		address = string_replace_once(address, _SLIT(":::"), _SLIT("localhost:"));
	}
	if (string_starts_with(address, _SLIT("0.0.0.0:"))) {
		address = string_replace_once(address, _SLIT("0.0.0.0:"), _SLIT("localhost:"));
	}
	_result_Array_net__Addr _t1 = net__resolve_addrs_fuzzy(address, net__SocketType__tcp);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not resolve address "), /*115 &string*/0xfe10, {.d_s = address}}, {_SLIT(" in dial_tcp"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	Array_net__Addr addrs =  (*(Array_net__Addr*)_t1.data);
	Array_IError errs = __new_array_with_default(0, 0, sizeof(IError), 0);
	for (int _t3 = 0; _t3 < addrs.len; ++_t3) {
		net__Addr addr = ((net__Addr*)addrs.data)[_t3];
		_result_net__TcpSocket _t4 = net__new_tcp_socket(net__Addr_family(addr));
		if (_t4.is_error) {
			IError err = _t4.err;
			return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not create new tcp socket in dial_tcp"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		net__TcpSocket s =  (*(net__TcpSocket*)_t4.data);
		_result_void _t6 = net__TcpSocket_connect(&s, addr);
		if (_t6.is_error) {
			IError err = _t6.err;
			array_push((array*)&errs, _MOV((IError[]){ err }));
			_result_void _t8 = net__TcpSocket_close(&s);
			if (_t8.is_error) {
				IError err = _t8.err;
				continue;
			}
			
 ;
			continue;
		}
		
 ;
		_result_net__TcpConn_ptr _t9;
		_result_ok(&(net__TcpConn*[]) { ((net__TcpConn*)memdup(&(net__TcpConn){.sock = s,.handle = 0,.write_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_timeout = _const_net__tcp_default_read_timeout,.write_timeout = _const_net__tcp_default_write_timeout,.is_blocking = 0,}, sizeof(net__TcpConn))) }, (_result*)(&_t9), sizeof(net__TcpConn*));
		return _t9;
	}
	strings__Builder err_builder = strings__new_builder(1024);
	strings__Builder_write_string(&err_builder,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("dial_tcp failed for address "), /*115 &string*/0xfe10, {.d_s = address}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
	strings__Builder_write_string(&err_builder, _SLIT("tried addrs:\n"));
	for (int i = 0; i < errs.len; i++) {
		net__Addr addr = (*(net__Addr*)array_get(addrs, i));
		IError why = (*(IError*)array_get(errs, i));
		strings__Builder_write_string(&err_builder,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\t"), /*115 &net.Addr*/0xfe10, {.d_s = net__Addr_str(addr)}}, {_SLIT(": "), /*115 &IError*/0xfe10, {.d_s = IError_str(why)}}, {_SLIT("\n"), 0, { .d_c = 0 }}})));
	}
	return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(strings__Builder_str(&err_builder)), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_net__TcpConn_ptr net__dial_tcp_with_bind(string saddr, string laddr) {
	_result_Array_net__Addr _t1 = net__resolve_addrs_fuzzy(saddr, net__SocketType__tcp);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not resolve address "), /*115 &string*/0xfe10, {.d_s = saddr}}, {_SLIT(" in dial_tcp_with_bind"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	Array_net__Addr addrs =  (*(Array_net__Addr*)_t1.data);
	for (int _t3 = 0; _t3 < addrs.len; ++_t3) {
		net__Addr addr = ((net__Addr*)addrs.data)[_t3];
		_result_net__TcpSocket _t4 = net__new_tcp_socket(net__Addr_family(addr));
		if (_t4.is_error) {
			IError err = _t4.err;
			return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not create new tcp socket in dial_tcp_with_bind"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		net__TcpSocket s =  (*(net__TcpSocket*)_t4.data);
		_result_void _t6 = net__TcpSocket_bind(&s, laddr);
		if (_t6.is_error) {
			IError err = _t6.err;
			_result_void _t7 = net__TcpSocket_close(&s);
			if (_t7.is_error) {
				IError err = _t7.err;
				continue;
			}
			
 ;
			continue;
		}
		
 ;
		_result_void _t8 = net__TcpSocket_connect(&s, addr);
		if (_t8.is_error) {
			IError err = _t8.err;
			_result_void _t9 = net__TcpSocket_close(&s);
			if (_t9.is_error) {
				IError err = _t9.err;
				continue;
			}
			
 ;
			continue;
		}
		
 ;
		_result_net__TcpConn_ptr _t10;
		_result_ok(&(net__TcpConn*[]) { ((net__TcpConn*)memdup(&(net__TcpConn){.sock = s,.handle = 0,.write_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_timeout = _const_net__tcp_default_read_timeout,.write_timeout = _const_net__tcp_default_write_timeout,.is_blocking = 0,}, sizeof(net__TcpConn))) }, (_result*)(&_t10), sizeof(net__TcpConn*));
		return _t10;
	}
	return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("dial_tcp_with_bind failed for address "), /*115 &string*/0xfe10, {.d_s = saddr}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_void net__TcpConn_close(net__TcpConn* c) {
	_result_void _t1 = net__TcpSocket_close(&c->sock);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

_result_int net__TcpConn_read_ptr(net__TcpConn _v_toheap_c, u8* buf_ptr, int len) {
net__TcpConn* c = HEAP(net__TcpConn, _v_toheap_c);
	int _t1;
	#if defined(CUSTOM_DEFINE_is_coroutine)
	#else
_result_int _t2 = net__wrap_read_result(recv((*(c)).sock.Socket.handle, ((voidptr)(buf_ptr)), len, 0));
		if (_t2.is_error) {
			_result_int _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 		_t1 =  (*(int*)_t2.data);
		;
	#endif
	int res = _t1;
	if (res > 0) {
		_result_int _t4;
		_result_ok(&(int[]) { res }, (_result*)(&_t4), sizeof(int));
		return _t4;
	}
	int code = net__error_code();
	if (code == ((int)(_const_net__error_ewouldblock))) {
		_result_void _t5 = net__TcpConn_wait_for_read((*(c)));
		if (_t5.is_error) {
			_result_int _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
		int _t7;
		#if defined(CUSTOM_DEFINE_is_coroutine)
		#else
_result_int _t8 = net__wrap_read_result(recv((*(c)).sock.Socket.handle, ((voidptr)(buf_ptr)), len, 0));
			if (_t8.is_error) {
				_result_int _t9;
				memcpy(&_t9, &_t8, sizeof(_result));
				return _t9;
			}
			
 			_t7 =  (*(int*)_t8.data);
			;
		#endif
		res = _t7;
		_result_int _t10 = net__socket_error(res);
		return _t10;
	} else {
		_result_void _t11 = net__wrap_error(code);
		if (_t11.is_error) {
			_result_int _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 ;
	}
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_int net__TcpConn_read(net__TcpConn _v_toheap_c, Array_u8* buf) {
net__TcpConn* c = HEAP(net__TcpConn, _v_toheap_c);
	_result_int _t2 = net__TcpConn_read_ptr((*(c)), buf->data, buf->len);
	if (_t2.is_error) {
		_result_int _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_int _t1;
	_result_ok(&(int[]) {  (*(int*)_t2.data) }, (_result*)(&_t1), sizeof(int));
	return _t1;
}

_result_time__Time net__TcpConn_read_deadline(net__TcpConn* c) {
	if (c->read_deadline.__v_unix == 0) {
		_result_time__Time _t1;
		_result_ok(&(time__Time[]) { c->read_deadline }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	return (_result_time__Time){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_int net__TcpConn_write_ptr(net__TcpConn* c, u8* b, int len) {
	{ // Unsafe block
		u8* ptr_base = ((u8*)(b));
		int total_sent = 0;
		for (;;) {
			if (!(total_sent < len)) break;
			u8* ptr = ptr_base + total_sent;
			int remaining = (int)(len - total_sent);
			int _t1;
			#if defined(CUSTOM_DEFINE_is_coroutine)
			#else
				_t1 = send(c->sock.Socket.handle, ptr, remaining, _const_net__msg_nosignal);
				;
			#endif
			int sent = _t1;
			if (sent < 0) {
				int code = net__error_code();
				if (code == ((int)(_const_net__error_ewouldblock))) {
					_result_void _t2 = net__TcpConn_wait_for_write(c);
					if (_t2.is_error) {
						_result_int _t3;
						memcpy(&_t3, &_t2, sizeof(_result));
						return _t3;
					}
					
 ;
					continue;
				} else {
					_result_void _t4 = net__wrap_error(code);
					if (_t4.is_error) {
						_result_int _t5;
						memcpy(&_t5, &_t4, sizeof(_result));
						return _t5;
					}
					
 ;
				}
			}
			total_sent += sent;
		}
		_result_int _t6;
		_result_ok(&(int[]) { total_sent }, (_result*)(&_t6), sizeof(int));
		return _t6;
	}
	return (_result_int){0};
}

_result_int net__TcpConn_write(net__TcpConn* c, Array_u8 bytes) {
	_result_int _t1 = net__TcpConn_write_ptr(c, bytes.data, bytes.len);
	return _t1;
}

_result_int net__TcpConn_write_string(net__TcpConn* c, string s) {
	_result_int _t1 = net__TcpConn_write_ptr(c, s.str, s.len);
	return _t1;
}

void net__TcpConn_set_read_deadline(net__TcpConn* c, time__Time deadline) {
	c->read_deadline = deadline;
}

_result_time__Time net__TcpConn_write_deadline(net__TcpConn* c) {
	if (c->write_deadline.__v_unix == 0) {
		_result_time__Time _t1;
		_result_ok(&(time__Time[]) { c->write_deadline }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	return (_result_time__Time){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

void net__TcpConn_set_write_deadline(net__TcpConn* c, time__Time deadline) {
	c->write_deadline = deadline;
}

time__Duration net__TcpConn_read_timeout(net__TcpConn* c) {
	time__Duration _t1 = c->read_timeout;
	return _t1;
}

void net__TcpConn_set_read_timeout(net__TcpConn* c, time__Duration t) {
	c->read_timeout = t;
}

time__Duration net__TcpConn_write_timeout(net__TcpConn* c) {
	time__Duration _t1 = c->write_timeout;
	return _t1;
}

void net__TcpConn_set_write_timeout(net__TcpConn* c, time__Duration t) {
	c->write_timeout = t;
}

// Attr: [inline]
inline _result_void net__TcpConn_wait_for_read(net__TcpConn _v_toheap_c) {
net__TcpConn* c = HEAP(net__TcpConn, _v_toheap_c);
	_result_void _t1 = net__wait_for_read((*(c)).sock.Socket.handle, (*(c)).read_deadline, (*(c)).read_timeout);
	return _t1;
}

// Attr: [inline]
inline _result_void net__TcpConn_wait_for_write(net__TcpConn* c) {
	_result_void _t1 = net__wait_for_write(c->sock.Socket.handle, c->write_deadline, c->write_timeout);
	return _t1;
}

_result_void net__TcpConn_set_sock(net__TcpConn* c) {
	_result_net__TcpSocket _t1 = net__tcp_socket_from_handle(c->handle);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	c->sock =  (*(net__TcpSocket*)_t1.data);
	return (_result_void){0};
}

_result_net__Addr net__TcpConn_peer_addr(net__TcpConn* c) {
	_result_net__Addr _t1 = net__peer_addr_from_socket_handle(c->sock.Socket.handle);
	return _t1;
}

_result_string net__TcpConn_peer_ip(net__TcpConn* c) {
	_result_net__Addr _t2 = net__TcpConn_peer_addr(c);
	if (_t2.is_error) {
		_result_string _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_string _t1;
	_result_ok(&(string[]) { net__Addr_str( (*(net__Addr*)_t2.data)) }, (_result*)(&_t1), sizeof(string));
	return _t1;
}

_result_net__Addr net__TcpConn_addr(net__TcpConn* c) {
	_result_net__Addr _t1 = net__Socket_address(&c->sock.Socket);
	return _t1;
}

string net__TcpConn_str(net__TcpConn _v_toheap_c) {
net__TcpConn* c = HEAP(net__TcpConn, _v_toheap_c);
	string s = string_replace(string_replace(net__TcpSocket_str((*(c)).sock), _SLIT("\n"), _SLIT(" ")), _SLIT("  "), _SLIT(" "));
	string _t1 =  str_intp(6, _MOV((StrIntpData[]){{_SLIT("TcpConn{ write_deadline: "), /*115 &time.Time*/0xfe10, {.d_s = time__Time_str((*(c)).write_deadline)}}, {_SLIT(", read_deadline: "), /*115 &time.Time*/0xfe10, {.d_s = time__Time_str((*(c)).read_deadline)}}, {_SLIT(", read_timeout: "), /*115 &time.Duration*/0xfe10, {.d_s = time__Duration_str((*(c)).read_timeout)}}, {_SLIT(", write_timeout: "), /*115 &time.Duration*/0xfe10, {.d_s = time__Duration_str((*(c)).write_timeout)}}, {_SLIT(", sock: "), /*115 &string*/0xfe10, {.d_s = s}}, {_SLIT(" }"), 0, { .d_c = 0 }}}));
	return _t1;
}

_result_net__TcpListener_ptr net__listen_tcp(net__AddrFamily family, string saddr, net__ListenOptions options) {
	_result_net__TcpSocket _t1 = net__new_tcp_socket(family);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__TcpListener_ptr){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not create new socket"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__TcpSocket s =  (*(net__TcpSocket*)_t1.data);
	_result_void _t3 = net__TcpSocket_set_dualstack(&s, options.dualstack);
	if (_t3.is_error) {
		IError err = _t3.err;
	}
	
 ;
	_result_Array_net__Addr _t4 = net__resolve_addrs(saddr, family, net__SocketType__tcp);
	if (_t4.is_error) {
		IError err = _t4.err;
		return (_result_net__TcpListener_ptr){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not resolve address "), /*115 &string*/0xfe10, {.d_s = saddr}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	Array_net__Addr addrs =  (*(Array_net__Addr*)_t4.data);
	net__Addr addr = (*(net__Addr*)array_get(addrs, 0));
	u32 alen = net__Addr_len(addr);
	_result_int _t6 = net__socket_error_message(bind(s.Socket.handle, ((voidptr)(&addr)), alen),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("binding to "), /*115 &string*/0xfe10, {.d_s = saddr}}, {_SLIT(" failed"), 0, { .d_c = 0 }}})));
	if (_t6.is_error) {
		_result_net__TcpListener_ptr _t7;
		memcpy(&_t7, &_t6, sizeof(_result));
		return _t7;
	}
	
  (*(int*)_t6.data);
	_result_int _t8 = net__socket_error_message(listen(s.Socket.handle, options.backlog),  str_intp(3, _MOV((StrIntpData[]){{_SLIT("listening on "), /*115 &string*/0xfe10, {.d_s = saddr}}, {_SLIT(" with maximum backlog pending queue of "), /*100 &int*/0xfe07, {.d_i32 = options.backlog}}, {_SLIT(", failed"), 0, { .d_c = 0 }}})));
	if (_t8.is_error) {
		_result_net__TcpListener_ptr _t9;
		memcpy(&_t9, &_t8, sizeof(_result));
		return _t9;
	}
	
  (*(int*)_t8.data);
	_result_net__TcpListener_ptr _t10;
	_result_ok(&(net__TcpListener*[]) { ((net__TcpListener*)memdup(&(net__TcpListener){.sock = s,.accept_timeout = _const_net__infinite_timeout,.accept_deadline = _const_net__no_deadline,}, sizeof(net__TcpListener))) }, (_result*)(&_t10), sizeof(net__TcpListener*));
	return _t10;
}

_result_net__TcpConn_ptr net__TcpListener_accept(net__TcpListener* l) {
	_result_net__TcpConn_ptr _t1 = net__TcpListener_accept_only(l);
	if (_t1.is_error) {
		_result_net__TcpConn_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__TcpConn* res =  (*(net__TcpConn**)_t1.data);
	_result_void _t3 = net__TcpConn_set_sock(res);
	if (_t3.is_error) {
		_result_net__TcpConn_ptr _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	_result_net__TcpConn_ptr _t5;
	_result_ok(&(net__TcpConn*[]) { res }, (_result*)(&_t5), sizeof(net__TcpConn*));
	return _t5;
}

_result_net__TcpConn_ptr net__TcpListener_accept_only(net__TcpListener* l) {
	int _t1;
	#if defined(CUSTOM_DEFINE_is_coroutine)
	#else
		_t1 = accept(l->sock.Socket.handle, 0, 0);
		;
	#endif
	int new_handle = _t1;
	if (new_handle <= 0) {
		_result_void _t2 = net__TcpListener_wait_for_accept(l);
		if (_t2.is_error) {
			_result_net__TcpConn_ptr _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
		int _t4;
		#if defined(CUSTOM_DEFINE_is_coroutine)
		#else
			_t4 = accept(l->sock.Socket.handle, 0, 0);
			;
		#endif
		new_handle = _t4;
		if (new_handle == -1 || new_handle == 0) {
			return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(_SLIT("accept failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_net__TcpConn_ptr _t6;
	_result_ok(&(net__TcpConn*[]) { ((net__TcpConn*)memdup(&(net__TcpConn){.sock = (net__TcpSocket){.Socket = (net__Socket){.handle = 0,},},.handle = new_handle,.write_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_timeout = _const_net__tcp_default_read_timeout,.write_timeout = _const_net__tcp_default_write_timeout,.is_blocking = 0,}, sizeof(net__TcpConn))) }, (_result*)(&_t6), sizeof(net__TcpConn*));
	return _t6;
}

_result_time__Time net__TcpListener_accept_deadline(net__TcpListener* c) {
	if (c->accept_deadline.__v_unix != 0) {
		_result_time__Time _t1;
		_result_ok(&(time__Time[]) { c->accept_deadline }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	return (_result_time__Time){ .is_error=true, .err=_v_error(_SLIT("invalid deadline")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

void net__TcpListener_set_accept_deadline(net__TcpListener* c, time__Time deadline) {
	c->accept_deadline = deadline;
}

time__Duration net__TcpListener_accept_timeout(net__TcpListener* c) {
	time__Duration _t1 = c->accept_timeout;
	return _t1;
}

void net__TcpListener_set_accept_timeout(net__TcpListener* c, time__Duration t) {
	c->accept_timeout = t;
}

_result_void net__TcpListener_wait_for_accept(net__TcpListener* c) {
	_result_void _t1 = net__wait_for_read(c->sock.Socket.handle, c->accept_deadline, c->accept_timeout);
	return _t1;
}

_result_void net__TcpListener_close(net__TcpListener* c) {
	_result_void _t1 = net__TcpSocket_close(&c->sock);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

_result_net__Addr net__TcpListener_addr(net__TcpListener* c) {
	_result_net__Addr _t1 = net__Socket_address(&c->sock.Socket);
	return _t1;
}

VV_LOCAL_SYMBOL _result_net__TcpSocket net__new_tcp_socket(net__AddrFamily family) {
	int _t1;
	#if defined(CUSTOM_DEFINE_is_coroutine)
	#else
_result_int _t2 = net__socket_error(socket(family, net__SocketType__tcp, 0));
		if (_t2.is_error) {
			_result_net__TcpSocket _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 		_t1 =  (*(int*)_t2.data);
		;
	#endif
	int handle = _t1;
	net__TcpSocket s = ((net__TcpSocket){.Socket = ((net__Socket){.handle = handle,}),});
	_result_void _t4 = net__TcpSocket_set_default_options(&s);
	if (_t4.is_error) {
		_result_net__TcpSocket _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 ;
	#if !defined(CUSTOM_DEFINE_net_blocking_sockets)
	{
		#if defined(_WIN32)
		{
			u32 t = ((u32)(1U));
			_result_int _t8 = net__socket_error(ioctlsocket(handle, _const_net__fionbio, &t));
			if (_t8.is_error) {
				_result_net__TcpSocket _t9;
				memcpy(&_t9, &_t8, sizeof(_result));
				return _t9;
			}
			
  (*(int*)_t8.data);
		}
		#else
		{
		}
		#endif
	}
	#endif
	_result_net__TcpSocket _t10;
	_result_ok(&(net__TcpSocket[]) { s }, (_result*)(&_t10), sizeof(net__TcpSocket));
	return _t10;
}

VV_LOCAL_SYMBOL _result_net__TcpSocket net__tcp_socket_from_handle(int sockfd) {
	net__TcpSocket s = ((net__TcpSocket){.Socket = ((net__Socket){.handle = sockfd,}),});
	_result_void _t1 = net__TcpSocket_set_dualstack(&s, true);
	if (_t1.is_error) {
		IError err = _t1.err;
	}
	
 ;
	_result_void _t2 = net__TcpSocket_set_default_options(&s);
	if (_t2.is_error) {
		_result_net__TcpSocket _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 ;
	#if !defined(CUSTOM_DEFINE_net_blocking_sockets)
	{
		#if defined(_WIN32)
		{
			u32 t = ((u32)(1U));
			_result_int _t6 = net__socket_error(ioctlsocket(sockfd, _const_net__fionbio, &t));
			if (_t6.is_error) {
				_result_net__TcpSocket _t7;
				memcpy(&_t7, &_t6, sizeof(_result));
				return _t7;
			}
			
  (*(int*)_t6.data);
		}
		#else
		{
		}
		#endif
	}
	#endif
	_result_net__TcpSocket _t8;
	_result_ok(&(net__TcpSocket[]) { s }, (_result*)(&_t8), sizeof(net__TcpSocket));
	return _t8;
}

net__TcpSocket net__tcp_socket_from_handle_raw(int sockfd) {
	net__TcpSocket s = ((net__TcpSocket){.Socket = ((net__Socket){.handle = sockfd,}),});
	return s;
}

VV_LOCAL_SYMBOL _result_void net__TcpSocket_set_option(net__TcpSocket* s, int level, int opt, int value) {
	_result_int _t1 = net__socket_error(setsockopt(s->Socket.handle, level, opt, &value, sizeof(int)));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(int*)_t1.data);
	return (_result_void){0};
}

_result_void net__TcpSocket_set_option_bool(net__TcpSocket* s, net__SocketOption opt, bool value) {
	int x = (int[]){(value)?1:0}[0];
	_result_void _t1 = net__TcpSocket_set_option(s, SOL_SOCKET, ((int)(opt)), *&x);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

_result_void net__TcpSocket_set_option_int(net__TcpSocket* s, net__SocketOption opt, int value) {
	_result_void _t1 = net__TcpSocket_set_option(s, SOL_SOCKET, ((int)(opt)), value);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

_result_void net__TcpSocket_set_dualstack(net__TcpSocket* s, bool on) {
	int x = (int[]){(!on)?1:0}[0];
	_result_void _t1 = net__TcpSocket_set_option(s, IPPROTO_IPV6, ((int)(net__SocketOption__ipv6_only)), *&x);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void net__TcpSocket_set_default_options(net__TcpSocket* s) {
	_result_void _t1 = net__TcpSocket_set_option_int(s, net__SocketOption__reuse_addr, 1);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_void _t3 = net__TcpSocket_set_option(s, IPPROTO_TCP, TCP_NODELAY, 1);
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	return (_result_void){0};
}

_result_void net__TcpSocket_bind(net__TcpSocket* s, string addr) {
	_result_Array_net__Addr _t1 = net__resolve_addrs(addr, net__AddrFamily__ip, net__SocketType__tcp);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_void){ .is_error=true, .err=_v_error( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = IError_name_table[err._typ]._method_msg(err._object)}}, {_SLIT("; could not resolve address "), /*115 &string*/0xfe10, {.d_s = addr}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	Array_net__Addr addrs =  (*(Array_net__Addr*)_t1.data);
	net__Addr a = (*(net__Addr*)array_get(addrs, 0));
	u32 alen = net__Addr_len(a);
	_result_int _t3 = net__socket_error_message(bind(s->Socket.handle, ((voidptr)(&a)), alen),  str_intp(2, _MOV((StrIntpData[]){{_SLIT("binding to "), /*115 &string*/0xfe10, {.d_s = addr}}, {_SLIT(" failed"), 0, { .d_c = 0 }}})));
	if (_t3.is_error) {
		IError err = _t3.err;
		return (_result_void){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
  (*(int*)_t3.data);
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void net__TcpSocket_close(net__TcpSocket* s) {
	net__shutdown(s->Socket.handle, ((net__ShutdownConfig){.how = net__ShutdownDirection__read_and_write,}));
	_result_void _t1 = net__close(s->Socket.handle);
	return _t1;
}

VV_LOCAL_SYMBOL _result_bool net__TcpSocket_select(net__TcpSocket* s, net__Select test, time__Duration timeout) {
	_result_bool _t1 = net__select(s->Socket.handle, test, timeout);
	return _t1;
}

VV_LOCAL_SYMBOL _result_void net__TcpSocket_connect(net__TcpSocket* s, net__Addr a) {
	#if !defined(CUSTOM_DEFINE_net_blocking_sockets)
	{
		int _t2;
		#if defined(CUSTOM_DEFINE_is_coroutine)
		#else
			_t2 = connect(s->Socket.handle, ((voidptr)(&a)), net__Addr_len(a));
			;
		#endif
		int res = _t2;
		if (res == 0) {
			return (_result_void){0};
		}
		int ecode = net__error_code();
		if ((_const_net__is_windows && ecode == ((int)(_const_net__error_ewouldblock))) || (!_const_net__is_windows && res == -1 && ecode == ((int)(_const_net__error_einprogress)))) {
			_result_bool _t3 = net__TcpSocket_select(s, net__Select__write, _const_net__connect_timeout);
			if (_t3.is_error) {
				_result_void _t4;
				memcpy(&_t4, &_t3, sizeof(_result));
				return _t4;
			}
			
 			bool write_result =  (*(bool*)_t3.data);
			int err = 0;
			u32 len = sizeof(int);
			int xyz = getsockopt(s->Socket.handle, SOL_SOCKET, SO_ERROR, &err, &len);
			if (xyz == 0 && err == 0) {
				return (_result_void){0};
			}
			if (write_result) {
				if (xyz == 0) {
					_result_void _t5 = net__wrap_error(err);
					if (_t5.is_error) {
						_result_void _t6;
						memcpy(&_t6, &_t5, sizeof(_result));
						return _t6;
					}
					
 ;
					return (_result_void){0};
				}
				return (_result_void){0};
			}
			return (_result_void){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_result_void _t8 = net__wrap_error(ecode);
		if (_t8.is_error) {
			_result_void _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		
 ;
		return (_result_void){0};
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

bool net__TcpConn_get_blocking(net__TcpConn* con) {
	bool _t1 = con->is_blocking;
	return _t1;
}

_result_void net__TcpConn_set_blocking(net__TcpConn* con, bool state) {
	con->is_blocking = state;
	#if defined(_WIN32)
	{
		u32 t = ((u32)(0U));
		if (!con->is_blocking) {
			t = 1U;
		}
		_result_int _t2 = net__socket_error(ioctlsocket(con->sock.Socket.handle, _const_net__fionbio, &t));
		if (_t2.is_error) {
			_result_void _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
  (*(int*)_t2.data);
	}
	#else
	{
	}
	#endif
	return (_result_void){0};
}

string net__TcpConn_read_line(net__TcpConn* con) {
	string _t1 = net__TcpConn_read_line_max(con, _const_net__max_read_line_len);
	return _t1;
}

// Attr: [manualfree]
string net__TcpConn_read_line_max(net__TcpConn* con, int max_line_len) {
	bool net__TcpConn_read_line_max_defer_0 = false;
	strings__Builder res;
	if (!con->is_blocking) {
		_result_void _t1 = net__TcpConn_set_blocking(con, true);
		if (_t1.is_error) {
			IError err = _t1.err;
		}
		
 ;
	}
	Array_fixed_u8_400 buf = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	res = strings__new_builder(_const_net__max_read);
	net__TcpConn_read_line_max_defer_0 = true;
	u8* bstart = &buf[0];
	for (;;) {
		int n = recv(con->sock.Socket.handle, bstart, (int_literal)(_const_net__max_read - 1), (_const_net__msg_peek | _const_net__msg_nosignal));
		if (n <= 0) {
			string _t2 = strings__Builder_str(&res);
				// Defer begin
				if (net__TcpConn_read_line_max_defer_0) {
					strings__Builder_free(&res);
				}
				// Defer end
			return _t2;
		}
		buf[v_fixed_index(n, 400)] = '\0';
		int eol_idx = -1;
		int lend = n;
		for (int i = 0; i < n; ++i) {
			if (buf[v_fixed_index(i, 400)] == '\n') {
				eol_idx = i;
				lend = (int_literal)(i + 1);
				buf[v_fixed_index(lend, 400)] = '\0';
				break;
			}
		}
		if (eol_idx > 0) {
			recv(con->sock.Socket.handle, bstart, lend, _const_net__msg_nosignal);
			strings__Builder_write_ptr(&res, bstart, lend);
			break;
		}
		recv(con->sock.Socket.handle, bstart, n, _const_net__msg_nosignal);
		strings__Builder_write_ptr(&res, bstart, lend);
		if (res.len > max_line_len) {
			break;
		}
	}
	string _t3 = strings__Builder_str(&res);
		// Defer begin
		if (net__TcpConn_read_line_max_defer_0) {
			strings__Builder_free(&res);
		}
		// Defer end
	return _t3;
}

_result_net__UdpConn_ptr net__dial_udp(string raddr) {
	_result_Array_net__Addr _t1 = net__resolve_addrs_fuzzy(raddr, net__SocketType__udp);
	if (_t1.is_error) {
		_result_net__UdpConn_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	Array_net__Addr addrs =  (*(Array_net__Addr*)_t1.data);
	for (int _t3 = 0; _t3 < addrs.len; ++_t3) {
		net__Addr addr = ((net__Addr*)addrs.data)[_t3];
		_result_net__UdpSocket_ptr _t4;
		if (_t4 = net__new_udp_socket_for_remote(addr), !_t4.is_error) {
			net__UdpSocket* sock = *(net__UdpSocket**)_t4.data;
			_result_net__UdpConn_ptr _t5;
			_result_ok(&(net__UdpConn*[]) { ((net__UdpConn*)memdup(&(net__UdpConn){.sock = *sock,.write_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_timeout = _const_net__udp_default_read_timeout,.write_timeout = _const_net__udp_default_write_timeout,}, sizeof(net__UdpConn))) }, (_result*)(&_t5), sizeof(net__UdpConn*));
			return _t5;
		}
	}
	return (_result_net__UdpConn_ptr){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_int net__UdpConn_write_ptr(net__UdpConn* c, u8* b, int len) {
	_result_net__Addr _t1 = net__UdpSocket_remote(&c->sock);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_int){ .is_error=true, .err=_const_net__err_no_udp_remote, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__Addr remote =  (*(net__Addr*)_t1.data);
	_result_int _t3 = net__UdpConn_write_to_ptr(c, remote, b, len);
	return _t3;
}

_result_int net__UdpConn_write(net__UdpConn* c, Array_u8 buf) {
	_result_int _t1 = net__UdpConn_write_ptr(c, buf.data, buf.len);
	return _t1;
}

_result_int net__UdpConn_write_string(net__UdpConn* c, string s) {
	_result_int _t1 = net__UdpConn_write_ptr(c, s.str, s.len);
	return _t1;
}

_result_int net__UdpConn_write_to_ptr(net__UdpConn* c, net__Addr addr, u8* b, int len) {
	int res = sendto(c->sock.Socket.handle, b, len, 0, ((voidptr)(&addr)), net__Addr_len(addr));
	if (res >= 0) {
		_result_int _t1;
		_result_ok(&(int[]) { res }, (_result*)(&_t1), sizeof(int));
		return _t1;
	}
	int code = net__error_code();
	if (code == ((int)(_const_net__error_ewouldblock))) {
		_result_void _t2 = net__UdpConn_wait_for_write(c);
		if (_t2.is_error) {
			_result_int _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
		_result_int _t4 = net__socket_error(sendto(c->sock.Socket.handle, b, len, 0, ((voidptr)(&addr)), net__Addr_len(addr)));
		if (_t4.is_error) {
			_result_int _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
  (*(int*)_t4.data);
	} else {
		_result_void _t6 = net__wrap_error(code);
		if (_t6.is_error) {
			_result_int _t7;
			memcpy(&_t7, &_t6, sizeof(_result));
			return _t7;
		}
		
 ;
	}
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_int net__UdpConn_write_to(net__UdpConn* c, net__Addr addr, Array_u8 buf) {
	_result_int _t1 = net__UdpConn_write_to_ptr(c, addr, buf.data, buf.len);
	return _t1;
}

_result_int net__UdpConn_write_to_string(net__UdpConn* c, net__Addr addr, string s) {
	_result_int _t1 = net__UdpConn_write_to_ptr(c, addr, s.str, s.len);
	return _t1;
}

_result_multi_return_int_net__Addr net__UdpConn_read(net__UdpConn* c, Array_u8* buf) {
	net__Addr addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
	u32 len = sizeof(net__Addr);
	_result_int _t1 = net__wrap_read_result(recvfrom(c->sock.Socket.handle, ((voidptr)(buf->data)), buf->len, 0, ((voidptr)(&addr)), &len));
	if (_t1.is_error) {
		_result_multi_return_int_net__Addr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	int res =  (*(int*)_t1.data);
	if (res > 0) {
		_result_multi_return_int_net__Addr _t3;
		_result_ok(&(multi_return_int_net__Addr[]) { (multi_return_int_net__Addr){.arg0=res, .arg1=addr} }, (_result*)(&_t3), sizeof(multi_return_int_net__Addr));
		return _t3;
	}
	int code = net__error_code();
	if (code == ((int)(_const_net__error_ewouldblock))) {
		_result_void _t4 = net__UdpConn_wait_for_read(c);
		if (_t4.is_error) {
			_result_multi_return_int_net__Addr _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 ;
		_result_int _t6 = net__wrap_read_result(recvfrom(c->sock.Socket.handle, ((voidptr)(buf->data)), buf->len, 0, ((voidptr)(&addr)), &len));
		if (_t6.is_error) {
			_result_multi_return_int_net__Addr _t7;
			memcpy(&_t7, &_t6, sizeof(_result));
			return _t7;
		}
		
 		res =  (*(int*)_t6.data);
		_result_int _t8 = net__socket_error(res);
		if (_t8.is_error) {
			_result_multi_return_int_net__Addr _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		
 		int res2 =  (*(int*)_t8.data);
		_result_multi_return_int_net__Addr _t10;
		_result_ok(&(multi_return_int_net__Addr[]) { (multi_return_int_net__Addr){.arg0=res2, .arg1=addr} }, (_result*)(&_t10), sizeof(multi_return_int_net__Addr));
		return _t10;
	} else {
		_result_void _t11 = net__wrap_error(code);
		if (_t11.is_error) {
			_result_multi_return_int_net__Addr _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 ;
	}
	return (_result_multi_return_int_net__Addr){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_time__Time net__UdpConn_read_deadline(net__UdpConn* c) {
	if (c->read_deadline.__v_unix == 0) {
		_result_time__Time _t1;
		_result_ok(&(time__Time[]) { c->read_deadline }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	return (_result_time__Time){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

void net__UdpConn_set_read_deadline(net__UdpConn* c, time__Time deadline) {
	c->read_deadline = deadline;
}

_result_time__Time net__UdpConn_write_deadline(net__UdpConn* c) {
	if (c->write_deadline.__v_unix == 0) {
		_result_time__Time _t1;
		_result_ok(&(time__Time[]) { c->write_deadline }, (_result*)(&_t1), sizeof(time__Time));
		return _t1;
	}
	return (_result_time__Time){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

void net__UdpConn_set_write_deadline(net__UdpConn* c, time__Time deadline) {
	c->write_deadline = deadline;
}

time__Duration net__UdpConn_read_timeout(net__UdpConn* c) {
	time__Duration _t1 = c->read_timeout;
	return _t1;
}

void net__UdpConn_set_read_timeout(net__UdpConn* c, time__Duration t) {
	c->read_timeout = t;
}

time__Duration net__UdpConn_write_timeout(net__UdpConn* c) {
	time__Duration _t1 = c->write_timeout;
	return _t1;
}

void net__UdpConn_set_write_timeout(net__UdpConn* c, time__Duration t) {
	c->write_timeout = t;
}

// Attr: [inline]
inline _result_void net__UdpConn_wait_for_read(net__UdpConn* c) {
	_result_void _t1 = net__wait_for_read(c->sock.Socket.handle, c->read_deadline, c->read_timeout);
	return _t1;
}

// Attr: [inline]
inline _result_void net__UdpConn_wait_for_write(net__UdpConn* c) {
	_result_void _t1 = net__wait_for_write(c->sock.Socket.handle, c->write_deadline, c->write_timeout);
	return _t1;
}

string net__UdpConn_str(net__UdpConn* c) {
	string _t1 = _SLIT("UdpConn");
	return _t1;
}

_result_void net__UdpConn_close(net__UdpConn* c) {
	_result_void _t1 = net__UdpSocket_close(&c->sock);
	return _t1;
}

_result_net__UdpConn_ptr net__listen_udp(string laddr) {
	_result_Array_net__Addr _t1 = net__resolve_addrs_fuzzy(laddr, net__SocketType__udp);
	if (_t1.is_error) {
		_result_net__UdpConn_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	Array_net__Addr addrs =  (*(Array_net__Addr*)_t1.data);
	net__Addr addr = (*(net__Addr*)array_get(addrs, 0));
	_result_net__UdpSocket_ptr _t4 = net__new_udp_socket(addr);
	if (_t4.is_error) {
		_result_net__UdpConn_ptr _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	_result_net__UdpConn_ptr _t3;
	_result_ok(&(net__UdpConn*[]) { ((net__UdpConn*)memdup(&(net__UdpConn){.sock = * (*(net__UdpSocket**)_t4.data),.write_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_deadline = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.read_timeout = _const_net__udp_default_read_timeout,.write_timeout = _const_net__udp_default_write_timeout,}, sizeof(net__UdpConn))) }, (_result*)(&_t3), sizeof(net__UdpConn*));
	return _t3;
}

VV_LOCAL_SYMBOL _result_net__UdpSocket_ptr net__new_udp_socket(net__Addr local_addr) {
	net__AddrFamily family = net__Addr_family(local_addr);
	_result_int _t1 = net__socket_error(socket(family, net__SocketType__udp, 0));
	if (_t1.is_error) {
		_result_net__UdpSocket_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	int sockfd =  (*(int*)_t1.data);
	net__UdpSocket* s = ((net__UdpSocket*)memdup(&(net__UdpSocket){.Socket = ((net__Socket){.handle = sockfd,}),.l = local_addr,.has_r = 0,.r = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),}),}, sizeof(net__UdpSocket)));
	_result_void _t3 = net__UdpSocket_set_option_bool(s, net__SocketOption__reuse_addr, true);
	if (_t3.is_error) {
		_result_net__UdpSocket_ptr _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	if (family == net__AddrFamily__ip6) {
		_result_void _t5 = net__UdpSocket_set_dualstack(s, true);
		if (_t5.is_error) {
			_result_net__UdpSocket_ptr _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
	}
	#if !defined(CUSTOM_DEFINE_net_blocking_sockets)
	{
		#if defined(_WIN32)
		{
			u32 t = ((u32)(1U));
			_result_int _t9 = net__socket_error(ioctlsocket(sockfd, _const_net__fionbio, &t));
			if (_t9.is_error) {
				_result_net__UdpSocket_ptr _t10;
				memcpy(&_t10, &_t9, sizeof(_result));
				return _t10;
			}
			
  (*(int*)_t9.data);
		}
		#else
		{
		}
		#endif
	}
	#endif
	_result_int _t11 = net__socket_error(bind(s->Socket.handle, ((voidptr)(&local_addr)), net__Addr_len(local_addr)));
	if (_t11.is_error) {
		_result_net__UdpSocket_ptr _t12;
		memcpy(&_t12, &_t11, sizeof(_result));
		return _t12;
	}
	
  (*(int*)_t11.data);
	_result_net__UdpSocket_ptr _t13;
	_result_ok(&(net__UdpSocket*[]) { s }, (_result*)(&_t13), sizeof(net__UdpSocket*));
	return _t13;
}

VV_LOCAL_SYMBOL _result_net__UdpSocket_ptr net__new_udp_socket_for_remote(net__Addr raddr) {
	net__Addr addr = ((net__Addr){.f = 0,.addr = ((net__AddrData){.Ip6 = ((net__Ip6){.port = 0,.flow_info = 0,.addr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},.scope_id = 0,}),}),});
	net__AddrFamily /*A*/ _t1 = net__Addr_family(raddr);
	
	if (_t1 == (net__AddrFamily__ip)) {
		addr = net__new_ip(0U, _const_net__addr_ip_any);
	}
	else if (_t1 == (net__AddrFamily__ip6)) {
		addr = net__new_ip6(0U, _const_net__addr_ip6_any);
	}
	else if (_t1 == (net__AddrFamily__unix)) {
		_result_net__Addr _t2 = net__temp_unix();
		if (_t2.is_error) {
			_result_net__UdpSocket_ptr _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 		addr =  (*(net__Addr*)_t2.data);
	}
	else {
		_v_panic(_SLIT("Invalid family"));
		VUNREACHABLE();
	}
	_result_net__UdpSocket_ptr _t4 = net__new_udp_socket(addr);
	if (_t4.is_error) {
		_result_net__UdpSocket_ptr _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	net__UdpSocket* sock =  (*(net__UdpSocket**)_t4.data);
	sock->has_r = true;
	sock->r = raddr;
	_result_net__UdpSocket_ptr _t6;
	_result_ok(&(net__UdpSocket*[]) { sock }, (_result*)(&_t6), sizeof(net__UdpSocket*));
	return _t6;
}

_result_void net__UdpSocket_set_option_bool(net__UdpSocket* s, net__SocketOption opt, bool value) {
	int x = (int[]){(value)?1:0}[0];
	_result_int _t1 = net__socket_error(setsockopt(s->Socket.handle, SOL_SOCKET, ((int)(opt)), &x, sizeof(int)));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(int*)_t1.data);
	return (_result_void){0};
}

_result_void net__UdpSocket_set_dualstack(net__UdpSocket* s, bool on) {
	int x = (int[]){(!on)?1:0}[0];
	_result_int _t1 = net__socket_error(setsockopt(s->Socket.handle, IPPROTO_IPV6, ((int)(net__SocketOption__ipv6_only)), &x, sizeof(int)));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(int*)_t1.data);
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void net__UdpSocket_close(net__UdpSocket* s) {
	net__shutdown(s->Socket.handle, ((net__ShutdownConfig){.how = net__ShutdownDirection__read_and_write,}));
	_result_void _t1 = net__close(s->Socket.handle);
	return _t1;
}

VV_LOCAL_SYMBOL _result_bool net__UdpSocket_select(net__UdpSocket* s, net__Select test, time__Duration timeout) {
	_result_bool _t1 = net__select(s->Socket.handle, test, timeout);
	return _t1;
}

VV_LOCAL_SYMBOL _result_net__Addr net__UdpSocket_remote(net__UdpSocket* s) {
	if (s->has_r) {
		_result_net__Addr _t1;
		_result_ok(&(net__Addr[]) { s->r }, (_result*)(&_t1), sizeof(net__Addr));
		return _t1;
	}
	return (_result_net__Addr){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_u16 net__validate_port(int port) {
	if (port <= _const_net__socket_max_port) {
		_result_u16 _t1;
		_result_ok(&(u16[]) { ((u16)(port)) }, (_result*)(&_t1), sizeof(u16));
		return _t1;
	} else {
		return (_result_u16){ .is_error=true, .err=_const_net__err_port_out_of_range, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_u16){0};
}

_result_multi_return_string_u16 net__split_address(string addr) {
	int port = string_int(string_all_after_last(addr, _SLIT(":")));
	string address = string_all_before_last(addr, _SLIT(":"));
	_result_u16 _t1 = net__validate_port(port);
	if (_t1.is_error) {
		_result_multi_return_string_u16 _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	u16 p =  (*(u16*)_t1.data);
	_result_multi_return_string_u16 _t3;
	_result_ok(&(multi_return_string_u16[]) { (multi_return_string_u16){.arg0=address, .arg1=p} }, (_result*)(&_t3), sizeof(multi_return_string_u16));
	return _t3;
}

VV_LOCAL_SYMBOL void net__mbedtls__init(void) {
	{ // Unsafe block
		mbedtls_ctr_drbg_init(&_const_net__mbedtls__ctr_drbg);
		mbedtls_entropy_init(&_const_net__mbedtls__entropy);
		int ret = mbedtls_ctr_drbg_seed(&_const_net__mbedtls__ctr_drbg, (voidptr)mbedtls_entropy_func, &_const_net__mbedtls__entropy, 0, 0);
		if (ret != 0) {
			mbedtls_ctr_drbg_free(&_const_net__mbedtls__ctr_drbg);
			_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed to seed ssl context: "), /*100 &int*/0xfe07, {.d_i32 = ret}}, {_SLIT0, 0, { .d_c = 0 }}})));
			VUNREACHABLE();
		}
	}
}

_result_net__mbedtls__SSLListener_ptr net__mbedtls__new_ssl_listener(string saddr, net__mbedtls__SSLConnectConfig config) {
	net__mbedtls__SSLListener* listener = ((net__mbedtls__SSLListener*)memdup(&(net__mbedtls__SSLListener){.saddr = saddr,.config = config,.server_fd = {0},.certs = ((void*)0),.opened = 0,}, sizeof(net__mbedtls__SSLListener)));
	_result_void _t1 = net__mbedtls__SSLListener_init(listener);
	if (_t1.is_error) {
		_result_net__mbedtls__SSLListener_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	listener->opened = true;
	_result_net__mbedtls__SSLListener_ptr _t3;
	_result_ok(&(net__mbedtls__SSLListener*[]) { listener }, (_result*)(&_t3), sizeof(net__mbedtls__SSLListener*));
	return _t3;
}

_result_void net__mbedtls__SSLListener_shutdown(net__mbedtls__SSLListener* l) {
	if (l->certs != ((void*)0)) {
		mbedtls_x509_crt_free(&l->certs->cacert);
		mbedtls_x509_crt_free(&l->certs->client_cert);
		mbedtls_pk_free(&l->certs->client_key);
	}
	mbedtls_ssl_free(&l->ssl);
	mbedtls_ssl_config_free(&l->conf);
	if (l->opened) {
		mbedtls_net_free(&l->server_fd);
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLListener_init(net__mbedtls__SSLListener* l) {
	_result_multi_return_string_u16 _t1 = net__split_address(l->saddr);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_string_u16 mr_2146 =  (*(multi_return_string_u16*)_t1.data);
	string lhost = mr_2146.arg0;
	u16 lport = mr_2146.arg1;
	if ((l->config.cert).len == 0 || (l->config.cert_key).len == 0) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("No certificate or key provided")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (l->config.validate && (l->config.verify).len == 0) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("No root CA provided")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_net_init(&l->server_fd);
	mbedtls_ssl_init(&l->ssl);
	mbedtls_ssl_config_init(&l->conf);
	l->certs = ((net__mbedtls__SSLCerts*)memdup(&(net__mbedtls__SSLCerts){EMPTY_STRUCT_INITIALIZATION}, sizeof(net__mbedtls__SSLCerts)));
	mbedtls_x509_crt_init(&l->certs->client_cert);
	mbedtls_pk_init(&l->certs->client_key);
	mbedtls_ssl_conf_rng(&l->conf, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
	int ret = 0;
	if (l->config.in_memory_verification) {
		if ((l->config.verify).len != 0) {
			ret = mbedtls_x509_crt_parse(&l->certs->cacert, l->config.verify.str, (int)(l->config.verify.len + 1));
		}
		if ((l->config.cert).len != 0) {
			ret = mbedtls_x509_crt_parse(&l->certs->client_cert, l->config.cert.str, (int)(l->config.cert.len + 1));
		}
		if ((l->config.cert_key).len != 0) {
			{ // Unsafe block
				ret = mbedtls_pk_parse_key(&l->certs->client_key, l->config.cert_key.str, (int)(l->config.cert_key.len + 1), 0, 0, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
			}
		}
	} else {
		if ((l->config.verify).len != 0) {
			ret = mbedtls_x509_crt_parse_file(&l->certs->cacert, ((char*)(l->config.verify.str)));
		}
		ret = mbedtls_x509_crt_parse_file(&l->certs->client_cert, ((char*)(l->config.cert.str)));
		{ // Unsafe block
			ret = mbedtls_pk_parse_keyfile(&l->certs->client_key, ((char*)(l->config.cert_key.str)), 0, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
		}
	}
	if (l->config.validate) {
		mbedtls_ssl_conf_authmode(&l->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
	}
	voidptr bind_ip = ((void*)0);
	if ((lhost).len != 0) {
		bind_ip = ((voidptr)(lhost.str));
	}
	string bind_port = u16_str(lport);
	ret = mbedtls_net_bind(&l->server_fd, bind_ip, ((voidptr)(bind_port.str)), MBEDTLS_NET_PROTO_TCP);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("can't bind to "), /*115 &string*/0xfe10, {.d_s = l->saddr}}, {_SLIT0, 0, { .d_c = 0 }}})), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	ret = mbedtls_ssl_config_defaults(&l->conf, MBEDTLS_SSL_IS_SERVER, MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("can't to set config defaults"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_ssl_conf_ca_chain(&l->conf, &l->certs->cacert, ((void*)0));
	ret = mbedtls_ssl_conf_own_cert(&l->conf, &l->certs->client_cert, &l->certs->client_key);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("can't load certificate"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	ret = mbedtls_ssl_setup(&l->ssl, &l->conf);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("can't setup ssl"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

_result_net__mbedtls__SSLConn_ptr net__mbedtls__SSLListener_accept(net__mbedtls__SSLListener* l) {
	net__mbedtls__SSLConn* conn = ((net__mbedtls__SSLConn*)memdup(&(net__mbedtls__SSLConn){.config = l->config,.server_fd = {0},.certs = ((void*)0),.handle = 0,.duration = 0,.opened = true,.owns_socket = 0,}, sizeof(net__mbedtls__SSLConn)));
	int ret = mbedtls_net_accept(&l->server_fd, &conn->server_fd, ((void*)0), 0, ((void*)0));
	if (ret != 0) {
		return (_result_net__mbedtls__SSLConn_ptr){ .is_error=true, .err=error_with_code(_SLIT("can't accept connection"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	conn->handle = conn->server_fd.fd;
	conn->owns_socket = true;
	mbedtls_ssl_init(&conn->ssl);
	mbedtls_ssl_config_init(&conn->conf);
	ret = mbedtls_ssl_setup(&conn->ssl, &l->conf);
	if (ret != 0) {
		return (_result_net__mbedtls__SSLConn_ptr){ .is_error=true, .err=error_with_code(_SLIT("SSL setup failed"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_ssl_set_bio(&conn->ssl, &conn->server_fd, mbedtls_net_send, mbedtls_net_recv, ((void*)0));
	ret = mbedtls_ssl_handshake(&conn->ssl);
	for (;;) {
		if (!(ret != 0)) break;
		if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE) {
			return (_result_net__mbedtls__SSLConn_ptr){ .is_error=true, .err=error_with_code(_SLIT("SSL handshake failed"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		ret = mbedtls_ssl_handshake(&conn->ssl);
	}
	_result_net__mbedtls__SSLConn_ptr _t4;
	_result_ok(&(net__mbedtls__SSLConn*[]) { conn }, (_result*)(&_t4), sizeof(net__mbedtls__SSLConn*));
	return _t4;
}

_result_net__mbedtls__SSLConn_ptr net__mbedtls__new_ssl_conn(net__mbedtls__SSLConnectConfig config) {
	net__mbedtls__SSLConn* conn = ((net__mbedtls__SSLConn*)memdup(&(net__mbedtls__SSLConn){.config = config,.server_fd = {0},.certs = ((void*)0),.handle = 0,.duration = 0,.opened = 0,.owns_socket = 0,}, sizeof(net__mbedtls__SSLConn)));
	_result_void _t1 = net__mbedtls__SSLConn_init(conn);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__mbedtls__SSLConn_ptr){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 ;
	_result_net__mbedtls__SSLConn_ptr _t3;
	_result_ok(&(net__mbedtls__SSLConn*[]) { conn }, (_result*)(&_t3), sizeof(net__mbedtls__SSLConn*));
	return _t3;
}

_result_void net__mbedtls__SSLConn_shutdown(net__mbedtls__SSLConn* s) {
	if (!s->opened) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("ssl connection not open")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (s->certs != ((void*)0)) {
		mbedtls_x509_crt_free(&s->certs->cacert);
		mbedtls_x509_crt_free(&s->certs->client_cert);
		mbedtls_pk_free(&s->certs->client_key);
	}
	mbedtls_ssl_free(&s->ssl);
	mbedtls_ssl_config_free(&s->conf);
	if (s->owns_socket) {
		net__shutdown(s->handle, ((net__ShutdownConfig){.how = net__ShutdownDirection__read_and_write,}));
		_result_void _t2 = net__close(s->handle);
		if (_t2.is_error) {
			_result_void _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 ;
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_init(net__mbedtls__SSLConn* s) {
	mbedtls_net_init(&s->server_fd);
	mbedtls_ssl_init(&s->ssl);
	mbedtls_ssl_config_init(&s->conf);
	int ret = 0;
	ret = mbedtls_ssl_config_defaults(&s->conf, MBEDTLS_SSL_IS_CLIENT, MBEDTLS_SSL_TRANSPORT_STREAM, MBEDTLS_SSL_PRESET_DEFAULT);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to set SSL configuration"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_ssl_conf_rng(&s->conf, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
	if ((s->config.verify).len != 0 || (s->config.cert).len != 0 || (s->config.cert_key).len != 0) {
		s->certs = ((net__mbedtls__SSLCerts*)memdup(&(net__mbedtls__SSLCerts){EMPTY_STRUCT_INITIALIZATION}, sizeof(net__mbedtls__SSLCerts)));
		mbedtls_x509_crt_init(&s->certs->cacert);
		mbedtls_x509_crt_init(&s->certs->client_cert);
		mbedtls_pk_init(&s->certs->client_key);
	}
	if (s->config.in_memory_verification) {
		if ((s->config.verify).len != 0) {
			ret = mbedtls_x509_crt_parse(&s->certs->cacert, s->config.verify.str, (int)(s->config.verify.len + 1));
		}
		if ((s->config.cert).len != 0) {
			ret = mbedtls_x509_crt_parse(&s->certs->client_cert, s->config.cert.str, (int)(s->config.cert.len + 1));
		}
		if ((s->config.cert_key).len != 0) {
			{ // Unsafe block
				ret = mbedtls_pk_parse_key(&s->certs->client_key, s->config.cert_key.str, (int)(s->config.cert_key.len + 1), 0, 0, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
			}
		}
	} else {
		if ((s->config.verify).len != 0) {
			ret = mbedtls_x509_crt_parse_file(&s->certs->cacert, ((char*)(s->config.verify.str)));
		}
		if ((s->config.cert).len != 0) {
			ret = mbedtls_x509_crt_parse_file(&s->certs->client_cert, ((char*)(s->config.cert.str)));
		}
		if ((s->config.cert_key).len != 0) {
			{ // Unsafe block
				ret = mbedtls_pk_parse_keyfile(&s->certs->client_key, ((char*)(s->config.cert_key.str)), 0, (voidptr)mbedtls_ctr_drbg_random, &_const_net__mbedtls__ctr_drbg);
			}
		}
	}
	if (ret < 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to set certificates"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (s->certs != ((void*)0)) {
		mbedtls_ssl_conf_ca_chain(&s->conf, &s->certs->cacert, 0);
		mbedtls_ssl_conf_own_cert(&s->conf, &s->certs->client_cert, &s->certs->client_key);
	}
	if (s->config.validate) {
		mbedtls_ssl_conf_authmode(&s->conf, MBEDTLS_SSL_VERIFY_REQUIRED);
	} else {
		mbedtls_ssl_conf_authmode(&s->conf, MBEDTLS_SSL_VERIFY_OPTIONAL);
	}
	ret = mbedtls_ssl_setup(&s->ssl, &s->conf);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to setup SSL connection"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

_result_void net__mbedtls__SSLConn_connect(net__mbedtls__SSLConn* s, net__TcpConn* tcp_conn, string hostname) {
	if (s->opened) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("ssl connection already open")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->handle = tcp_conn->sock.Socket.handle;
	s->duration = 30 * _const_time__second;
	int ret = mbedtls_ssl_set_hostname(&s->ssl, ((char*)(hostname.str)));
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to set hostname"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->server_fd.fd = s->handle;
	mbedtls_ssl_set_bio(&s->ssl, &s->server_fd, mbedtls_net_send, mbedtls_net_recv, mbedtls_net_recv_timeout);
	ret = mbedtls_ssl_handshake(&s->ssl);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("SSL handshake failed"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->opened = true;
	return (_result_void){0};
}

_result_void net__mbedtls__SSLConn_dial(net__mbedtls__SSLConn* s, string hostname, int port) {
	s->owns_socket = true;
	if (s->opened) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("ssl connection already open")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->duration = 30 * _const_time__second;
	int ret = mbedtls_ssl_set_hostname(&s->ssl, ((char*)(hostname.str)));
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to set hostname"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string port_str = int_str(port);
	ret = mbedtls_net_connect(&s->server_fd, ((char*)(hostname.str)), ((char*)(port_str.str)), MBEDTLS_NET_PROTO_TCP);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("Failed to connect to host"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	mbedtls_ssl_set_bio(&s->ssl, &s->server_fd, mbedtls_net_send, mbedtls_net_recv, mbedtls_net_recv_timeout);
	s->handle = s->server_fd.fd;
	ret = mbedtls_ssl_handshake(&s->ssl);
	if (ret != 0) {
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("SSL handshake failed"), ret), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	s->opened = true;
	return (_result_void){0};
}

_result_net__Addr net__mbedtls__SSLConn_peer_addr(net__mbedtls__SSLConn* s) {
	_result_net__Addr _t1 = net__peer_addr_from_socket_handle(s->handle);
	return _t1;
}

_result_int net__mbedtls__SSLConn_socket_read_into_ptr(net__mbedtls__SSLConn* s, u8* buf_ptr, int len) {
	int res = 0;
	time__Time deadline = time__Time_add(ADDR(time__Time, time__now()), s->duration);
	for (;;) {
		res = mbedtls_ssl_read(&s->ssl, buf_ptr, len);
		if (res > 0) {
			_result_int _t1;
			_result_ok(&(int[]) { res }, (_result*)(&_t1), sizeof(int));
			return _t1;
		} else if (res == 0) {
			return (_result_int){ .is_error=true, .err=I_io__Eof_to_Interface_IError(((io__Eof*)memdup(&(io__Eof){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(io__Eof)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else {

			if (res == (MBEDTLS_ERR_SSL_WANT_READ)) {
				_result_void _t3 = net__mbedtls__SSLConn_wait_for_read(s, time__Time__minus(deadline, time__now()));
				if (_t3.is_error) {
					IError err = _t3.err;
					return (_result_int){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 ;
			}
			else if (res == (MBEDTLS_ERR_SSL_WANT_WRITE)) {
				_result_void _t5 = net__mbedtls__SSLConn_wait_for_write(s, time__Time__minus(deadline, time__now()));
				if (_t5.is_error) {
					IError err = _t5.err;
					return (_result_int){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 ;
			}
			else if (res == (MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY)) {
				_result_int _t7;
				_result_ok(&(int[]) { 0 }, (_result*)(&_t7), sizeof(int));
				return _t7;
			}
			else {
				return (_result_int){ .is_error=true, .err=error_with_code(_SLIT("Could not read using SSL"), res), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
	}
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("Unknown error")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_int net__mbedtls__SSLConn_read(net__mbedtls__SSLConn* s, Array_u8* buffer) {
	_result_int _t1 = net__mbedtls__SSLConn_socket_read_into_ptr(s, ((u8*)(buffer->data)), buffer->len);
	return _t1;
}

_result_int net__mbedtls__SSLConn_write_ptr(net__mbedtls__SSLConn* s, u8* bytes, int len) {
	int total_sent = 0;
	time__Time deadline = time__Time_add(ADDR(time__Time, time__now()), s->duration);
	{ // Unsafe block
		u8* ptr_base = bytes;
		for (;;) {
			if (!(total_sent < len)) break;
			u8* ptr = ptr_base + total_sent;
			int remaining = (int)(len - total_sent);
			int sent = mbedtls_ssl_write(&s->ssl, ptr, remaining);
			if (sent <= 0) {

				if (sent == (MBEDTLS_ERR_SSL_WANT_READ)) {
					_result_void _t1 = net__mbedtls__SSLConn_wait_for_read(s, time__Time__minus(deadline, time__now()));
					if (_t1.is_error) {
						_result_int _t2;
						memcpy(&_t2, &_t1, sizeof(_result));
						return _t2;
					}
					
 ;
					continue;
				}
				else if (sent == (MBEDTLS_ERR_SSL_WANT_WRITE)) {
					_result_void _t3 = net__mbedtls__SSLConn_wait_for_write(s, time__Time__minus(deadline, time__now()));
					if (_t3.is_error) {
						_result_int _t4;
						memcpy(&_t4, &_t3, sizeof(_result));
						return _t4;
					}
					
 ;
					continue;
				}
				else {
					return (_result_int){ .is_error=true, .err=error_with_code(_SLIT("Could not write using SSL"), sent), .data={EMPTY_STRUCT_INITIALIZATION} };
				}
			}
			total_sent += sent;
		}
	}
	_result_int _t6;
	_result_ok(&(int[]) { total_sent }, (_result*)(&_t6), sizeof(int));
	return _t6;
}

_result_int net__mbedtls__SSLConn_write(net__mbedtls__SSLConn* s, Array_u8 bytes) {
	_result_int _t1 = net__mbedtls__SSLConn_write_ptr(s, ((u8*)(bytes.data)), bytes.len);
	return _t1;
}

_result_int net__mbedtls__SSLConn_write_string(net__mbedtls__SSLConn* s, string str) {
	_result_int _t1 = net__mbedtls__SSLConn_write_ptr(s, str.str, str.len);
	return _t1;
}

VV_LOCAL_SYMBOL _result_bool net__mbedtls__select(int handle, net__mbedtls__Select test, time__Duration timeout) {
	fd_set set = ((fd_set){EMPTY_STRUCT_INITIALIZATION});
	FD_ZERO(&set);
	FD_SET(handle, &set);
	time__Time deadline = time__Time_add(ADDR(time__Time, time__now()), timeout);
	i64 remaining_time = time__Duration_milliseconds(timeout);
	for (;;) {
		if (!(remaining_time > 0)) break;
		i64 seconds = (i64)(remaining_time / 1000);
		i64 microseconds = (i64)(((i64)(remaining_time % 1000)) * 1000);
		struct timeval *tt = HEAP(struct timeval, (((struct timeval){.tv_sec = ((u64)(seconds)),.tv_usec = ((u64)(microseconds)),})));
		struct timeval* timeval_timeout = (timeout < 0 ? (((struct timeval*)(((void*)0)))) : (&(*(tt))));
		int res = -1;

		if (test == (net__mbedtls__Select__read)) {
			_result_int _t1 = net__socket_error(select((int)(handle + 1), &set, NULL, NULL, timeval_timeout));
			if (_t1.is_error) {
				_result_bool _t2;
				memcpy(&_t2, &_t1, sizeof(_result));
				return _t2;
			}
			
 			res =  (*(int*)_t1.data);
		}
		else if (test == (net__mbedtls__Select__write)) {
			_result_int _t3 = net__socket_error(select((int)(handle + 1), NULL, &set, NULL, timeval_timeout));
			if (_t3.is_error) {
				_result_bool _t4;
				memcpy(&_t4, &_t3, sizeof(_result));
				return _t4;
			}
			
 			res =  (*(int*)_t3.data);
		}
		else if (test == (net__mbedtls__Select__except)) {
			_result_int _t5 = net__socket_error(select((int)(handle + 1), NULL, NULL, &set, timeval_timeout));
			if (_t5.is_error) {
				_result_bool _t6;
				memcpy(&_t6, &_t5, sizeof(_result));
				return _t6;
			}
			
 			res =  (*(int*)_t5.data);
		}
		if (res < 0) {
			if (errno == EINTR) {
				remaining_time = time__Duration_milliseconds((time__Time__minus(deadline, time__now())));
				continue;
			}
			return (_result_bool){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Select failed: "), /*100 &int*/0xfe07, {.d_i32 = res}}, {_SLIT0, 0, { .d_c = 0 }}})), errno), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else if (res == 0) {
			return (_result_bool){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		res = FD_ISSET(handle, &set);
		_result_bool _t9;
		_result_ok(&(bool[]) { res != 0 }, (_result*)(&_t9), sizeof(bool));
		return _t9;
	}
	return (_result_bool){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_void net__mbedtls__wait_for(int handle, net__mbedtls__Select what, time__Duration timeout) {
	_result_bool _t1 = net__mbedtls__select(handle, what, timeout);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	bool ready =  (*(bool*)_t1.data);
	if (ready) {
		return (_result_void){0};
	}
	return (_result_void){ .is_error=true, .err=_const_net__err_timed_out, .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_wait_for_write(net__mbedtls__SSLConn* s, time__Duration timeout) {
	_result_void _t1 = net__mbedtls__wait_for(s->handle, net__mbedtls__Select__write, timeout);
	return _t1;
}

VV_LOCAL_SYMBOL _result_void net__mbedtls__SSLConn_wait_for_read(net__mbedtls__SSLConn* s, time__Duration timeout) {
	_result_void _t1 = net__mbedtls__wait_for(s->handle, net__mbedtls__Select__read, timeout);
	return _t1;
}

_result_net__ssl__SSLConn_ptr net__ssl__new_ssl_conn(net__ssl__SSLConnectConfig config) {
	_result_net__mbedtls__SSLConn_ptr _t1 = net__mbedtls__new_ssl_conn(config.SSLConnectConfig);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__ssl__SSLConn_ptr){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__mbedtls__SSLConn* c =  (*(net__mbedtls__SSLConn**)_t1.data);
	_result_net__ssl__SSLConn_ptr _t3;
	_result_ok(&(net__ssl__SSLConn*[]) { ((net__ssl__SSLConn*)memdup(&(net__ssl__SSLConn){.SSLConn = *c,}, sizeof(net__ssl__SSLConn))) }, (_result*)(&_t3), sizeof(net__ssl__SSLConn*));
	return _t3;
}

_result_net__TcpConn_ptr net__socks__socks5_dial(string proxy_url, string host, string username, string password) {
	_result_net__TcpConn_ptr _t1 = net__dial_tcp(proxy_url);
	if (_t1.is_error) {
		_result_net__TcpConn_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__TcpConn* con =  (*(net__TcpConn**)_t1.data);
	_result_net__TcpConn_ptr _t4 = net__socks__handshake(con, host, username, password);
	if (_t4.is_error) {
		_result_net__TcpConn_ptr _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	_result_net__TcpConn_ptr _t3;
	_result_ok(&(net__TcpConn*[]) {  (*(net__TcpConn**)_t4.data) }, (_result*)(&_t3), sizeof(net__TcpConn*));
	return _t3;
}

_result_net__ssl__SSLConn_ptr net__socks__socks5_ssl_dial(string proxy_url, string host, string username, string password) {
	_result_net__ssl__SSLConn_ptr _t1 = net__ssl__new_ssl_conn(((net__ssl__SSLConnectConfig){.SSLConnectConfig = ((net__mbedtls__SSLConnectConfig){.verify = _SLIT(""),.cert = _SLIT(""),.cert_key = _SLIT(""),.validate = false,.in_memory_verification = false,}),}));
	if (_t1.is_error) {
		_result_net__ssl__SSLConn_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__ssl__SSLConn* ssl_conn =  (*(net__ssl__SSLConn**)_t1.data);
	_result_net__TcpConn_ptr _t3 = net__socks__socks5_dial(proxy_url, host, username, password);
	if (_t3.is_error) {
		_result_net__ssl__SSLConn_ptr _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	net__TcpConn* con =  (*(net__TcpConn**)_t3.data);
	_result_void _t5 = net__mbedtls__SSLConn_connect(&ssl_conn->SSLConn, con, string_all_before_last(host, _SLIT(":")));
	if (_t5.is_error) {
		IError err = _t5.err;
		_v_panic(IError_str(err));
		VUNREACHABLE();
	;
	}
	
 ;
	_result_net__ssl__SSLConn_ptr _t6;
	_result_ok(&(net__ssl__SSLConn*[]) { ssl_conn }, (_result*)(&_t6), sizeof(net__ssl__SSLConn*));
	return _t6;
}

VV_LOCAL_SYMBOL _result_net__TcpConn_ptr net__socks__handshake(net__TcpConn* con, string host, string username, string password) {
	Array_u8 v = new_array_from_c_array_noscan(2, 2, sizeof(u8), _MOV((u8[2]){_const_net__socks__socks_version5, 1}));
	if (username.len > 0) {
		array_push_noscan((array*)&v, _MOV((u8[]){ _const_net__socks__auth_user_password }));
	} else {
		array_push_noscan((array*)&v, _MOV((u8[]){ _const_net__socks__no_auth }));
	}
	_result_int _t3 = net__TcpConn_write(con, v);
	if (_t3.is_error) {
		_result_net__TcpConn_ptr _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
  (*(int*)_t3.data);
	Array_u8 bf = __new_array_with_default_noscan(2, 0, sizeof(u8), 0);
	_result_int _t5 = net__TcpConn_read(/*rec*/*con, &/*arr*/bf);
	if (_t5.is_error) {
		_result_net__TcpConn_ptr _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
  (*(int*)_t5.data);
	if ((*(u8*)array_get(bf, 0)) != _const_net__socks__socks_version5) {
		_result_void _t7 = net__TcpConn_close(con);
		if (_t7.is_error) {
			_result_net__TcpConn_ptr _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 ;
		return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected protocol version "), /*117 &u8*/0xfe02, {.d_u8 = (*(u8*)array_get(bf, 0))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (username.len == 0) {
		if ((*(u8*)array_get(bf, 1)) != 0) {
			_result_void _t10 = net__TcpConn_close(con);
			if (_t10.is_error) {
				_result_net__TcpConn_ptr _t11;
				memcpy(&_t11, &_t10, sizeof(_result));
				return _t11;
			}
			
 ;
			return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(net__socks__reply((*(u8*)array_get(bf, 1)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if (username.len > 0) {
		array_clear(&v);
		array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(1)) }));
		array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(username.len)) }));
		_PUSH_MANY_noscan(&v, (string_bytes(username)), _t15, Array_u8);
		array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(password.len)) }));
		_PUSH_MANY_noscan(&v, (string_bytes(password)), _t17, Array_u8);
		_result_int _t18 = net__TcpConn_write(con, v);
		if (_t18.is_error) {
			_result_net__TcpConn_ptr _t19;
			memcpy(&_t19, &_t18, sizeof(_result));
			return _t19;
		}
		
  (*(int*)_t18.data);
		Array_u8 resp = __new_array_with_default_noscan(2, 0, sizeof(u8), 0);
		_result_int _t20 = net__TcpConn_read(/*rec*/*con, &/*arr*/resp);
		if (_t20.is_error) {
			_result_net__TcpConn_ptr _t21;
			memcpy(&_t21, &_t20, sizeof(_result));
			return _t21;
		}
		
  (*(int*)_t20.data);
		if ((*(u8*)array_get(resp, 0)) != 1) {
			_result_void _t22 = net__TcpConn_close(con);
			if (_t22.is_error) {
				_result_net__TcpConn_ptr _t23;
				memcpy(&_t23, &_t22, sizeof(_result));
				return _t23;
			}
			
 ;
			return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(_SLIT("server does not support user/password version 1")), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else if ((*(u8*)array_get(resp, 1)) != 0) {
			_result_void _t25 = net__TcpConn_close(con);
			if (_t25.is_error) {
				_result_net__TcpConn_ptr _t26;
				memcpy(&_t26, &_t25, sizeof(_result));
				return _t26;
			}
			
 ;
			return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(_SLIT("user/password login failed")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	array_clear(&v);
	v = new_array_from_c_array_noscan(3, 3, sizeof(u8), _MOV((u8[3]){_const_net__socks__socks_version5, 1, 0}));
	u64 port = string_u64(string_all_after_last(host, _SLIT(":")));
	if (port == 0U) {
		port = ((u64)(80U));
	}
	string address = string_all_before_last(host, _SLIT(":"));
	if (string_contains_only(address, _SLIT(".1234567890"))) {
		array_push_noscan((array*)&v, _MOV((u8[]){ _const_net__socks__addr_type_ipv4 }));
		_result_Array_u8 _t30 = net__socks__parse_ipv4(address);
		if (_t30.is_error) {
			_result_net__TcpConn_ptr _t31;
			memcpy(&_t31, &_t30, sizeof(_result));
			return _t31;
		}
		
 		_PUSH_MANY_noscan(&v, ( (*(Array_u8*)_t30.data)), _t29, Array_u8);
	} else if (string_contains_only(address, _SLIT(":1234567890abcdf"))) {
	} else {
		if (address.len > 255) {
			return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = address}}, {_SLIT(" is too long"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		} else {
			array_push_noscan((array*)&v, _MOV((u8[]){ _const_net__socks__addr_type_fqdn }));
			array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(address.len)) }));
			_PUSH_MANY_noscan(&v, (string_bytes(address)), _t35, Array_u8);
		}
	}
	array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)((port >> 8U))) }));
	array_push_noscan((array*)&v, _MOV((u8[]){ ((u8)(port)) }));
	_result_int _t38 = net__TcpConn_write(con, v);
	if (_t38.is_error) {
		_result_net__TcpConn_ptr _t39;
		memcpy(&_t39, &_t38, sizeof(_result));
		return _t39;
	}
	
  (*(int*)_t38.data);
	Array_u8 bff = __new_array_with_default_noscan(v.len, 0, sizeof(u8), 0);
	_result_int _t40 = net__TcpConn_read(/*rec*/*con, &/*arr*/bff);
	if (_t40.is_error) {
		_result_net__TcpConn_ptr _t41;
		memcpy(&_t41, &_t40, sizeof(_result));
		return _t41;
	}
	
  (*(int*)_t40.data);
	if ((*(u8*)array_get(bff, 1)) != 0) {
		_result_void _t42 = net__TcpConn_close(con);
		if (_t42.is_error) {
			_result_net__TcpConn_ptr _t43;
			memcpy(&_t43, &_t42, sizeof(_result));
			return _t43;
		}
		
 ;
		return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(net__socks__reply((*(u8*)array_get(bff, 1)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_net__TcpConn_ptr _t45;
	_result_ok(&(net__TcpConn*[]) { con }, (_result*)(&_t45), sizeof(net__TcpConn*));
	return _t45;
}

VV_LOCAL_SYMBOL string net__socks__reply(u8 code) {
	switch (code) {
		case 0: {
				string _t1 = _SLIT("succeeded");
				return _t1;
		}
		case 1: {
				string _t2 = _SLIT("general SOCKS server failure");
				return _t2;
		}
		case 2: {
				string _t3 = _SLIT("connection not allowed by ruleset");
				return _t3;
		}
		case 3: {
				string _t4 = _SLIT("network unreachable");
				return _t4;
		}
		case 4: {
				string _t5 = _SLIT("host unreachable");
				return _t5;
		}
		case 5: {
				string _t6 = _SLIT("connection refused");
				return _t6;
		}
		case 6: {
				string _t7 = _SLIT("TTL expired");
				return _t7;
		}
		case 7: {
				string _t8 = _SLIT("command not supported");
				return _t8;
		}
		case 8: {
				string _t9 = _SLIT("address type not supported");
				return _t9;
		}
		default: {
				string _t10 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unknown code: "), /*117 &u8*/0xfe02, {.d_u8 = code}}, {_SLIT0, 0, { .d_c = 0 }}}));
				return _t10;
		}
	}
	
	return (string){.str=(byteptr)"", .is_lit=1};
}

VV_LOCAL_SYMBOL _result_Array_u8 net__socks__parse_ipv4(string addr) {
	Array_u8 ip = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	Array_string _t1 = string_split(addr, _SLIT("."));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string part = ((string*)_t1.data)[_t2];
		array_push_noscan((array*)&ip, _MOV((u8[]){ string_u8(part) }));
	}
	_result_Array_u8 _t4;
	_result_ok(&(Array_u8[]) { ip }, (_result*)(&_t4), sizeof(Array_u8));
	return _t4;
}

#if defined(_VGCBOEHM)
#endif
VV_LOCAL_SYMBOL _result_net__http__Response net__http__Request_ssl_do(net__http__Request* req, int port, net__http__Method method, string host_name, string path) {
	struct TlsContext ctx = new_tls_context();
	vschannel_init(&ctx);
	u8* buff = malloc_noscan(vsc_init_resp_buff_size);
	string addr = host_name;
	string sdata = net__http__Request_build_request_headers(req, method, host_name, path);
	int length = request(&ctx, port, string_to_wide(addr), sdata.str, sdata.len, &buff);
	vschannel_cleanup(&ctx);
	string response_text = u8_vstring_with_len(buff, length);
	if (req->on_progress != (voidptr)((void*)0)) {
		_result_void _t1 = req->on_progress(req, u8_vbytes(buff, length), ((u64)(length)));
		if (_t1.is_error) {
			_result_net__http__Response _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
	}
	if (req->on_finish != (voidptr)((void*)0)) {
		_result_void _t3 = req->on_finish(req, ((u64)(response_text.len)));
		if (_t3.is_error) {
			_result_net__http__Response _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 ;
	}
	_result_net__http__Response _t5 = net__http__parse_response(response_text);
	return _t5;
}

Array_net__http__Cookie_ptr net__http__read_set_cookies(Map_string_Array_string h) {
	Array_string cookies_s = (*(Array_string*)map_get(ADDR(map, h), &(string[]){_SLIT("Set-Cookie")}, &(Array_string[]){ __new_array(0, 0, sizeof(string)) }));
	int cookie_count = cookies_s.len;
	if (cookie_count == 0) {
		Array_net__http__Cookie_ptr _t1 = __new_array_with_default(0, 0, sizeof(net__http__Cookie*), 0);
		return _t1;
	}
	Array_net__http__Cookie_ptr cookies = __new_array_with_default(0, 0, sizeof(net__http__Cookie*), 0);
	for (int _t2 = 0; _t2 < cookies_s.len; ++_t2) {
		string line = ((string*)cookies_s.data)[_t2];
		_result_net__http__Cookie _t3 = net__http__parse_cookie(line);
		if (_t3.is_error) {
			IError err = _t3.err;
			continue;
		}
		
 		net__http__Cookie *c = HEAP(net__http__Cookie, ( (*(net__http__Cookie*)_t3.data)));
		array_push((array*)&cookies, _MOV((net__http__Cookie*[]){ &(*(c)) }));
	}
	return cookies;
}

Array_net__http__Cookie_ptr net__http__read_cookies(net__http__Header h, string filter) {
	Array_string lines = net__http__Header_values(h, net__http__CommonHeader__cookie);
	if (lines.len == 0) {
		Array_net__http__Cookie_ptr _t1 = __new_array_with_default(0, 0, sizeof(net__http__Cookie*), 0);
		return _t1;
	}
	Array_net__http__Cookie_ptr cookies = __new_array_with_default(0, 0, sizeof(net__http__Cookie*), 0);
	for (int _t2 = 0; _t2 < lines.len; ++_t2) {
		string line_ = ((string*)lines.data)[_t2];
		string line = string_trim_space(line_);
		string part = _SLIT("");
		for (;;) {
			if (!(line.len > 0)) break;
			int semicolon_position = string_index_any(line, _SLIT(";"));
			if (semicolon_position > 0) {
				Array_string line_parts = string_split(string_substr(line, 0, semicolon_position), _SLIT(";"));
				line = string_substr(line, ((int)(semicolon_position + 1)), 2147483647);
				part = (*(string*)array_get(line_parts, 0));
			} else {
				part = line;
				line = _SLIT("");
			}
			part = string_trim_space(part);
			if (part.len == 0) {
				continue;
			}
			string name = part;
			string val = _SLIT("");
			if (string_contains(part, _SLIT("="))) {
				Array_string val_parts = string_split(part, _SLIT("="));
				name = (*(string*)array_get(val_parts, 0));
				val = (*(string*)array_get(val_parts, 1));
			}
			if (!net__http__is_cookie_name_valid(name)) {
				continue;
			}
			if ((filter).len != 0 && !string__eq(filter, name)) {
				continue;
			}
			_result_string _t3 = net__http__parse_cookie_value(val, true);
			if (_t3.is_error) {
				IError err = _t3.err;
				continue;
			}
			
 			val =  (*(string*)_t3.data);
			array_push((array*)&cookies, _MOV((net__http__Cookie*[]){ ((net__http__Cookie*)memdup(&(net__http__Cookie){.name = name,.value = val,.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}, sizeof(net__http__Cookie))) }));
		}
	}
	return cookies;
}

string net__http__Cookie_str(net__http__Cookie* c) {
	if (!net__http__is_cookie_name_valid(c->name)) {
		string _t1 = _SLIT("");
		return _t1;
	}
	int extra_cookie_length = 110;
	strings__Builder b = strings__new_builder((int)((int)((int)((int)(c->name.len + c->value.len) + c->domain.len) + c->path.len) + extra_cookie_length));
	strings__Builder_write_string(&b, c->name);
	strings__Builder_write_string(&b, _SLIT("="));
	strings__Builder_write_string(&b, net__http__sanitize_cookie_value(c->value));
	if (c->path.len > 0) {
		strings__Builder_write_string(&b, _SLIT("; path="));
		strings__Builder_write_string(&b, net__http__sanitize_cookie_path(c->path));
	}
	if (c->domain.len > 0) {
		if (net__http__valid_cookie_domain(c->domain)) {
			string d = c->domain;
			if (string_at(d, 0) == '.') {
				d = string_substr(d, 1, d.len);
			}
			strings__Builder_write_string(&b, _SLIT("; domain="));
			strings__Builder_write_string(&b, d);
		} else {
		}
	}
	if (c->expires.year > 1600) {
		time__Time e = c->expires;
		string time_str =  str_intp(6, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = time__Time_weekday_str(&e)}}, {_SLIT(", "), /*115 &string*/0xfe10, {.d_s = int_str(e.day)}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = time__Time_smonth(&e)}}, {_SLIT(" "), /*100 &int*/0xfe07, {.d_i32 = e.year}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = time__Time_hhmmss(e)}}, {_SLIT(" GMT"), 0, { .d_c = 0 }}}));
		strings__Builder_write_string(&b, _SLIT("; expires="));
		strings__Builder_write_string(&b, time_str);
	}
	if (c->max_age > 0) {
		strings__Builder_write_string(&b, _SLIT("; Max-Age="));
		strings__Builder_write_string(&b, int_str(c->max_age));
	} else if (c->max_age < 0) {
		strings__Builder_write_string(&b, _SLIT("; Max-Age=0"));
	}
	if (c->http_only) {
		strings__Builder_write_string(&b, _SLIT("; HttpOnly"));
	}
	if (c->secure) {
		strings__Builder_write_string(&b, _SLIT("; Secure"));
	}

	if (c->same_site == (net__http__SameSite__same_site_not_set)) {
	}
	else if (c->same_site == (net__http__SameSite__same_site_default_mode)) {
		strings__Builder_write_string(&b, _SLIT("; SameSite"));
	}
	else if (c->same_site == (net__http__SameSite__same_site_none_mode)) {
		strings__Builder_write_string(&b, _SLIT("; SameSite=None"));
	}
	else if (c->same_site == (net__http__SameSite__same_site_lax_mode)) {
		strings__Builder_write_string(&b, _SLIT("; SameSite=Lax"));
	}
	else if (c->same_site == (net__http__SameSite__same_site_strict_mode)) {
		strings__Builder_write_string(&b, _SLIT("; SameSite=Strict"));
	}
	string _t2 = strings__Builder_str(&b);
	return _t2;
}

VV_LOCAL_SYMBOL string net__http__sanitize(bool (*valid)(u8 ), string v) {
	bool ok = true;
	for (int i = 0; i < v.len; ++i) {
		if (valid(string_at(v, i))) {
			continue;
		}
		ok = false;
		break;
	}
	if (ok) {
		string _t1 = string_clone(v);
		return _t1;
	}
	Array_u8 _t3 = {0};
	Array_u8 _t3_orig = string_bytes(v);
	int _t3_len = _t3_orig.len;
	_t3 = __new_array_noscan(0, _t3_len, sizeof(u8));

	for (int _t4 = 0; _t4 < _t3_len; ++_t4) {
		u8 it = ((u8*) _t3_orig.data)[_t4];
		if (valid(it)) {
			array_push_noscan((array*)&_t3, &it);
		}
	}
	string _t2 = Array_u8_bytestr(_t3);
	return _t2;
}

VV_LOCAL_SYMBOL string net__http__sanitize_cookie_name(string name) {
	string _t1 = string_replace_each(name, new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("\n"), _SLIT("-"), _SLIT("\r"), _SLIT("-")})));
	return _t1;
}

string net__http__sanitize_cookie_value(string v) {
	string val = net__http__sanitize((voidptr)net__http__valid_cookie_value_byte, v);
	if (v.len == 0) {
		return v;
	}
	if (string_starts_with(val, _SLIT(" ")) || string_ends_with(val, _SLIT(" ")) || string_starts_with(val, _SLIT(",")) || string_ends_with(val, _SLIT(","))) {
		string _t2 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("\""), /*115 &string*/0xfe10, {.d_s = v}}, {_SLIT("\""), 0, { .d_c = 0 }}}));
		return _t2;
	}
	return v;
}

VV_LOCAL_SYMBOL string net__http__sanitize_cookie_path(string v) {
	string _t1 = net__http__sanitize((voidptr)net__http__valid_cookie_path_byte, v);
	return _t1;
}

VV_LOCAL_SYMBOL bool net__http__valid_cookie_value_byte(u8 b) {
	bool _t1 = 0x20 <= b && b < 0x7f && b != '"' && b != ';' && b != '\\';
	return _t1;
}

VV_LOCAL_SYMBOL bool net__http__valid_cookie_path_byte(u8 b) {
	bool _t1 = 0x20 <= b && b < 0x7f && b != '!';
	return _t1;
}

VV_LOCAL_SYMBOL bool net__http__valid_cookie_domain(string v) {
	if (net__http__is_cookie_domain_name(v)) {
		bool _t1 = true;
		return _t1;
	}
	bool _t2 = false;
	return _t2;
}

bool net__http__is_cookie_domain_name(string _s) {
	string s = _s;
	if (s.len == 0) {
		bool _t1 = false;
		return _t1;
	}
	if (s.len > 255) {
		bool _t2 = false;
		return _t2;
	}
	if (string_at(s, 0) == '.') {
		s = string_substr(s, 1, s.len);
	}
	rune last = '.';
	bool ok = false;
	int part_len = 0;
	for (int i = 0; i < s.len; ++i) {
		u8 c = string_at(s, i);
		if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {
			ok = true;
			part_len++;
		} else if ('0' <= c && c <= '9') {
			part_len++;
		} else if (c == '-') {
			if (last == '.') {
				bool _t3 = false;
				return _t3;
			}
			part_len++;
		} else if (c == '.') {
			if (last == '.' || last == '-') {
				bool _t4 = false;
				return _t4;
			}
			if (part_len > 63 || part_len == 0) {
				bool _t5 = false;
				return _t5;
			}
			part_len = 0;
		} else {
			bool _t6 = false;
			return _t6;
		}
		last = c;
	}
	if (last == '-' || part_len > 63) {
		bool _t7 = false;
		return _t7;
	}
	return ok;
}

VV_LOCAL_SYMBOL _result_string net__http__parse_cookie_value(string _raw, bool allow_double_quote) {
	string raw = _raw;
	if (allow_double_quote && raw.len > 1 && string_at(raw, 0) == '"' && string_at(raw, (int)(raw.len - 1)) == '"') {
		raw = string_substr(raw, 1, (int)(raw.len - 1));
	}
	for (int i = 0; i < raw.len; ++i) {
		if (!net__http__valid_cookie_value_byte(string_at(raw, i))) {
			return (_result_string){ .is_error=true, .err=_v_error(_SLIT("http.cookie: invalid cookie value")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	_result_string _t2;
	_result_ok(&(string[]) { raw }, (_result*)(&_t2), sizeof(string));
	return _t2;
}

VV_LOCAL_SYMBOL bool net__http__is_cookie_name_valid(string name) {
	if ((name).len == 0) {
		bool _t1 = false;
		return _t1;
	}
	for (int _t2 = 0; _t2 < name.len; ++_t2) {
		u8 b = name.str[_t2];
		if (b < 33 || b > 126) {
			bool _t3 = false;
			return _t3;
		}
	}
	bool _t4 = true;
	return _t4;
}

VV_LOCAL_SYMBOL _result_net__http__Cookie net__http__parse_cookie(string line) {
	Array_string parts = string_split(string_trim_space(line), _SLIT(";"));
	if (parts.len == 1 && ((*(string*)array_get(parts, 0))).len == 0) {
		return (_result_net__http__Cookie){ .is_error=true, .err=_v_error(_SLIT("malformed cookie")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	array_set(&parts, 0, &(string[]) { string_trim_space((*(string*)array_get(parts, 0))) });
	Array_string keyval = string_split((*(string*)array_get(parts, 0)), _SLIT("="));
	if (keyval.len != 2) {
		return (_result_net__http__Cookie){ .is_error=true, .err=_v_error(_SLIT("malformed cookie")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string name = (*(string*)array_get(keyval, 0));
	string raw_value = (*(string*)array_get(keyval, 1));
	if (!net__http__is_cookie_name_valid(name)) {
		return (_result_net__http__Cookie){ .is_error=true, .err=_v_error(_SLIT("malformed cookie")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_string _t4 = net__http__parse_cookie_value(raw_value, true);
	if (_t4.is_error) {
		IError err = _t4.err;
		return (_result_net__http__Cookie){ .is_error=true, .err=_v_error(_SLIT("malformed cookie")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string value =  (*(string*)_t4.data);
	net__http__Cookie c = ((net__http__Cookie){.name = name,.value = value,.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = line,.unparsed = __new_array(0, 0, sizeof(string)),});
	for (int i = 0; i < parts.len; ++i) {
		array_set(&parts, i, &(string[]) { string_trim_space((*(string*)array_get(parts, i))) });
		if ((*(string*)array_get(parts, i)).len == 0) {
			continue;
		}
		string attr = (*(string*)array_get(parts, i));
		string raw_val = _SLIT("");
		if (string_contains(attr, _SLIT("="))) {
			Array_string pieces = string_split(attr, _SLIT("="));
			attr = (*(string*)array_get(pieces, 0));
			raw_val = (*(string*)array_get(pieces, 1));
		}
		string lower_attr = string_to_lower(attr);
		_result_string _t6 = net__http__parse_cookie_value(raw_val, false);
		if (_t6.is_error) {
			IError err = _t6.err;
			array_push((array*)&c.unparsed, _MOV((string[]){ string_clone((*(string*)array_get(parts, i))) }));
			continue;
		}
		
 		string val =  (*(string*)_t6.data);

		if (string__eq(lower_attr, _SLIT("samesite"))) {
			string lower_val = string_to_lower(val);

			if (string__eq(lower_val, _SLIT("lax"))) {
				c.same_site = net__http__SameSite__same_site_lax_mode;
			}
			else if (string__eq(lower_val, _SLIT("strict"))) {
				c.same_site = net__http__SameSite__same_site_strict_mode;
			}
			else if (string__eq(lower_val, _SLIT("none"))) {
				c.same_site = net__http__SameSite__same_site_none_mode;
			}
			else {
				c.same_site = net__http__SameSite__same_site_default_mode;
			}
		}
		else if (string__eq(lower_attr, _SLIT("secure"))) {
			c.secure = true;
			continue;
		}
		else if (string__eq(lower_attr, _SLIT("httponly"))) {
			c.http_only = true;
			continue;
		}
		else if (string__eq(lower_attr, _SLIT("domain"))) {
			c.domain = val;
			continue;
		}
		else if (string__eq(lower_attr, _SLIT("max-age"))) {
			int secs = string_int(val);
			if (secs != 0 && string_at(val, 0) != '0') {
				break;
			}
			if (secs <= 0) {
				secs = -1;
			}
			c.max_age = secs;
			continue;
		}
		else if (string__eq(lower_attr, _SLIT("path"))) {
			c.path = val;
			continue;
		}
		else {
			array_push((array*)&c.unparsed, _MOV((string[]){ string_clone((*(string*)array_get(parts, i))) }));
		}
	}
	_result_net__http__Cookie _t9;
	_result_ok(&(net__http__Cookie[]) { c }, (_result*)(&_t9), sizeof(net__http__Cookie));
	return _t9;
}

_result_void net__http__download_file(string url, string out_file_path) {
	_result_net__http__Response _t1 = net__http__get(url);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_void){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__http__Response s =  (*(net__http__Response*)_t1.data);
	if (net__http__Response_status(s) != net__http__Status__ok) {
		return (_result_void){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("received http code "), /*100 &int*/0xfe07, {.d_i32 = s.status_code}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_void _t4 = os__write_file(out_file_path, s.body);
	if (_t4.is_error) {
		_result_void _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 ;
	return (_result_void){0};
}

string net__http__CommonHeader_str(net__http__CommonHeader h) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (h) {
		case net__http__CommonHeader__accept: {
				_t2 = _SLIT("Accept");
				break;
		}
		case net__http__CommonHeader__accept_ch: {
				_t2 = _SLIT("Accept-CH");
				break;
		}
		case net__http__CommonHeader__accept_charset: {
				_t2 = _SLIT("Accept-Charset");
				break;
		}
		case net__http__CommonHeader__accept_ch_lifetime: {
				_t2 = _SLIT("Accept-CH-Lifetime");
				break;
		}
		case net__http__CommonHeader__accept_encoding: {
				_t2 = _SLIT("Accept-Encoding");
				break;
		}
		case net__http__CommonHeader__accept_language: {
				_t2 = _SLIT("Accept-Language");
				break;
		}
		case net__http__CommonHeader__accept_patch: {
				_t2 = _SLIT("Accept-Patch");
				break;
		}
		case net__http__CommonHeader__accept_post: {
				_t2 = _SLIT("Accept-Post");
				break;
		}
		case net__http__CommonHeader__accept_ranges: {
				_t2 = _SLIT("Accept-Ranges");
				break;
		}
		case net__http__CommonHeader__access_control_allow_credentials: {
				_t2 = _SLIT("Access-Control-Allow-Credentials");
				break;
		}
		case net__http__CommonHeader__access_control_allow_headers: {
				_t2 = _SLIT("Access-Control-Allow-Headers");
				break;
		}
		case net__http__CommonHeader__access_control_allow_methods: {
				_t2 = _SLIT("Access-Control-Allow-Methods");
				break;
		}
		case net__http__CommonHeader__access_control_allow_origin: {
				_t2 = _SLIT("Access-Control-Allow-Origin");
				break;
		}
		case net__http__CommonHeader__access_control_expose_headers: {
				_t2 = _SLIT("Access-Control-Expose-Headers");
				break;
		}
		case net__http__CommonHeader__access_control_max_age: {
				_t2 = _SLIT("Access-Control-Max-Age");
				break;
		}
		case net__http__CommonHeader__access_control_request_headers: {
				_t2 = _SLIT("Access-Control-Request-Headers");
				break;
		}
		case net__http__CommonHeader__access_control_request_method: {
				_t2 = _SLIT("Access-Control-Request-Method");
				break;
		}
		case net__http__CommonHeader__age: {
				_t2 = _SLIT("Age");
				break;
		}
		case net__http__CommonHeader__allow: {
				_t2 = _SLIT("Allow");
				break;
		}
		case net__http__CommonHeader__alt_svc: {
				_t2 = _SLIT("Alt-Svc");
				break;
		}
		case net__http__CommonHeader__authorization: {
				_t2 = _SLIT("Authorization");
				break;
		}
		case net__http__CommonHeader__authority: {
				_t2 = _SLIT("Authority");
				break;
		}
		case net__http__CommonHeader__cache_control: {
				_t2 = _SLIT("Cache-Control");
				break;
		}
		case net__http__CommonHeader__clear_site_data: {
				_t2 = _SLIT("Clear-Site-Data");
				break;
		}
		case net__http__CommonHeader__connection: {
				_t2 = _SLIT("Connection");
				break;
		}
		case net__http__CommonHeader__content_disposition: {
				_t2 = _SLIT("Content-Disposition");
				break;
		}
		case net__http__CommonHeader__content_encoding: {
				_t2 = _SLIT("Content-Encoding");
				break;
		}
		case net__http__CommonHeader__content_language: {
				_t2 = _SLIT("Content-Language");
				break;
		}
		case net__http__CommonHeader__content_length: {
				_t2 = _SLIT("Content-Length");
				break;
		}
		case net__http__CommonHeader__content_location: {
				_t2 = _SLIT("Content-Location");
				break;
		}
		case net__http__CommonHeader__content_range: {
				_t2 = _SLIT("Content-Range");
				break;
		}
		case net__http__CommonHeader__content_security_policy: {
				_t2 = _SLIT("Content-Security-Policy");
				break;
		}
		case net__http__CommonHeader__content_security_policy_report_only: {
				_t2 = _SLIT("Content-Security-Policy-Report-Only");
				break;
		}
		case net__http__CommonHeader__content_type: {
				_t2 = _SLIT("Content-Type");
				break;
		}
		case net__http__CommonHeader__cookie: {
				_t2 = _SLIT("Cookie");
				break;
		}
		case net__http__CommonHeader__cross_origin_embedder_policy: {
				_t2 = _SLIT("Cross-Origin-Embedder-Policy");
				break;
		}
		case net__http__CommonHeader__cross_origin_opener_policy: {
				_t2 = _SLIT("Cross-Origin-Opener-Policy");
				break;
		}
		case net__http__CommonHeader__cross_origin_resource_policy: {
				_t2 = _SLIT("Cross-Origin-Resource-Policy");
				break;
		}
		case net__http__CommonHeader__date: {
				_t2 = _SLIT("Date");
				break;
		}
		case net__http__CommonHeader__device_memory: {
				_t2 = _SLIT("Device-Memory");
				break;
		}
		case net__http__CommonHeader__digest: {
				_t2 = _SLIT("Digest");
				break;
		}
		case net__http__CommonHeader__dnt: {
				_t2 = _SLIT("DNT");
				break;
		}
		case net__http__CommonHeader__early_data: {
				_t2 = _SLIT("Early-Data");
				break;
		}
		case net__http__CommonHeader__etag: {
				_t2 = _SLIT("ETag");
				break;
		}
		case net__http__CommonHeader__expect: {
				_t2 = _SLIT("Expect");
				break;
		}
		case net__http__CommonHeader__expect_ct: {
				_t2 = _SLIT("Expect-CT");
				break;
		}
		case net__http__CommonHeader__expires: {
				_t2 = _SLIT("Expires");
				break;
		}
		case net__http__CommonHeader__feature_policy: {
				_t2 = _SLIT("Feature-Policy");
				break;
		}
		case net__http__CommonHeader__forwarded: {
				_t2 = _SLIT("Forwarded");
				break;
		}
		case net__http__CommonHeader__from: {
				_t2 = _SLIT("From");
				break;
		}
		case net__http__CommonHeader__host: {
				_t2 = _SLIT("Host");
				break;
		}
		case net__http__CommonHeader__if_match: {
				_t2 = _SLIT("If-Match");
				break;
		}
		case net__http__CommonHeader__if_modified_since: {
				_t2 = _SLIT("If-Modified-Since");
				break;
		}
		case net__http__CommonHeader__if_none_match: {
				_t2 = _SLIT("If-None-Match");
				break;
		}
		case net__http__CommonHeader__if_range: {
				_t2 = _SLIT("If-Range");
				break;
		}
		case net__http__CommonHeader__if_unmodified_since: {
				_t2 = _SLIT("If-Unmodified-Since");
				break;
		}
		case net__http__CommonHeader__index: {
				_t2 = _SLIT("Index");
				break;
		}
		case net__http__CommonHeader__keep_alive: {
				_t2 = _SLIT("Keep-Alive");
				break;
		}
		case net__http__CommonHeader__large_allocation: {
				_t2 = _SLIT("Large-Allocation");
				break;
		}
		case net__http__CommonHeader__last_modified: {
				_t2 = _SLIT("Last-Modified");
				break;
		}
		case net__http__CommonHeader__link: {
				_t2 = _SLIT("Link");
				break;
		}
		case net__http__CommonHeader__location: {
				_t2 = _SLIT("Location");
				break;
		}
		case net__http__CommonHeader__nel: {
				_t2 = _SLIT("NEL");
				break;
		}
		case net__http__CommonHeader__origin: {
				_t2 = _SLIT("Origin");
				break;
		}
		case net__http__CommonHeader__pragma: {
				_t2 = _SLIT("Pragma");
				break;
		}
		case net__http__CommonHeader__proxy_authenticate: {
				_t2 = _SLIT("Proxy-Authenticate");
				break;
		}
		case net__http__CommonHeader__proxy_authorization: {
				_t2 = _SLIT("Proxy-Authorization");
				break;
		}
		case net__http__CommonHeader__range: {
				_t2 = _SLIT("Range");
				break;
		}
		case net__http__CommonHeader__referer: {
				_t2 = _SLIT("Referer");
				break;
		}
		case net__http__CommonHeader__referrer_policy: {
				_t2 = _SLIT("Referrer-Policy");
				break;
		}
		case net__http__CommonHeader__retry_after: {
				_t2 = _SLIT("Retry-After");
				break;
		}
		case net__http__CommonHeader__save_data: {
				_t2 = _SLIT("Save-Data");
				break;
		}
		case net__http__CommonHeader__sec_fetch_dest: {
				_t2 = _SLIT("Sec-Fetch-Dest");
				break;
		}
		case net__http__CommonHeader__sec_fetch_mode: {
				_t2 = _SLIT("Sec-Fetch-Mode");
				break;
		}
		case net__http__CommonHeader__sec_fetch_site: {
				_t2 = _SLIT("Sec-Fetch-Site");
				break;
		}
		case net__http__CommonHeader__sec_fetch_user: {
				_t2 = _SLIT("Sec-Fetch-User");
				break;
		}
		case net__http__CommonHeader__sec_websocket_accept: {
				_t2 = _SLIT("Sec-WebSocket-Accept");
				break;
		}
		case net__http__CommonHeader__server: {
				_t2 = _SLIT("Server");
				break;
		}
		case net__http__CommonHeader__server_timing: {
				_t2 = _SLIT("Server-Timing");
				break;
		}
		case net__http__CommonHeader__set_cookie: {
				_t2 = _SLIT("Set-Cookie");
				break;
		}
		case net__http__CommonHeader__sourcemap: {
				_t2 = _SLIT("SourceMap");
				break;
		}
		case net__http__CommonHeader__strict_transport_security: {
				_t2 = _SLIT("Strict-Transport-Security");
				break;
		}
		case net__http__CommonHeader__te: {
				_t2 = _SLIT("TE");
				break;
		}
		case net__http__CommonHeader__timing_allow_origin: {
				_t2 = _SLIT("Timing-Allow-Origin");
				break;
		}
		case net__http__CommonHeader__tk: {
				_t2 = _SLIT("Tk");
				break;
		}
		case net__http__CommonHeader__trailer: {
				_t2 = _SLIT("Trailer");
				break;
		}
		case net__http__CommonHeader__transfer_encoding: {
				_t2 = _SLIT("Transfer-Encoding");
				break;
		}
		case net__http__CommonHeader__upgrade: {
				_t2 = _SLIT("Upgrade");
				break;
		}
		case net__http__CommonHeader__upgrade_insecure_requests: {
				_t2 = _SLIT("Upgrade-Insecure-Requests");
				break;
		}
		case net__http__CommonHeader__user_agent: {
				_t2 = _SLIT("User-Agent");
				break;
		}
		case net__http__CommonHeader__vary: {
				_t2 = _SLIT("Vary");
				break;
		}
		case net__http__CommonHeader__via: {
				_t2 = _SLIT("Via");
				break;
		}
		case net__http__CommonHeader__want_digest: {
				_t2 = _SLIT("Want-Digest");
				break;
		}
		case net__http__CommonHeader__warning: {
				_t2 = _SLIT("Warning");
				break;
		}
		case net__http__CommonHeader__www_authenticate: {
				_t2 = _SLIT("WWW-Authenticate");
				break;
		}
		case net__http__CommonHeader__x_content_type_options: {
				_t2 = _SLIT("X-Content-Type-Options");
				break;
		}
		case net__http__CommonHeader__x_dns_prefetch_control: {
				_t2 = _SLIT("X-DNS-Prefetch-Control");
				break;
		}
		case net__http__CommonHeader__x_forwarded_for: {
				_t2 = _SLIT("X-Forwarded-For");
				break;
		}
		case net__http__CommonHeader__x_forwarded_host: {
				_t2 = _SLIT("X-Forwarded-Host");
				break;
		}
		case net__http__CommonHeader__x_forwarded_proto: {
				_t2 = _SLIT("X-Forwarded-Proto");
				break;
		}
		case net__http__CommonHeader__x_frame_options: {
				_t2 = _SLIT("X-Frame-Options");
				break;
		}
		case net__http__CommonHeader__x_xss_protection: {
				_t2 = _SLIT("X-XSS-Protection");
				break;
		}
	}
	string _t1 = _t2;
	return _t1;
}

void net__http__Header_free(net__http__Header* h) {
	{ // Unsafe block
	}
}

net__http__Header net__http__new_header(Array_net__http__HeaderConfig kvs) {
	net__http__Header h = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,});
	for (int i = 0; i < kvs.len; ++i) {
		net__http__HeaderConfig kv = ((net__http__HeaderConfig*)kvs.data)[i];
		h.data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = net__http__CommonHeader_str(kv.key),.value = kv.value,});
	}
	h.cur_pos = kvs.len;
	return h;
}

net__http__Header net__http__new_header_from_map(Map_net__http__CommonHeader_string kvs) {
	net__http__Header h = net__http__new_header(__new_array(0, 0, sizeof(net__http__HeaderConfig)));
	net__http__Header_add_map(&h, kvs);
	return h;
}

_result_net__http__Header net__http__new_custom_header_from_map(Map_string_string kvs) {
	net__http__Header h = net__http__new_header(__new_array(0, 0, sizeof(net__http__HeaderConfig)));
	_result_void _t1 = net__http__Header_add_custom_map(&h, kvs);
	if (_t1.is_error) {
		_result_net__http__Header _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_net__http__Header _t3;
	_result_ok(&(net__http__Header[]) { h }, (_result*)(&_t3), sizeof(net__http__Header));
	return _t3;
}

void net__http__Header_add(net__http__Header* h, net__http__CommonHeader key, string value) {
	string k = net__http__CommonHeader_str(key);
	h->data[v_fixed_index(h->cur_pos, 50)] = ((net__http__HeaderKV){.key = k,.value = value,});
	h->cur_pos++;
}

_result_void net__http__Header_add_custom(net__http__Header* h, string key, string value) {
	_result_void _t1 = net__http__is_valid(key);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	h->data[v_fixed_index(h->cur_pos, 50)] = ((net__http__HeaderKV){.key = key,.value = value,});
	h->cur_pos++;
	return (_result_void){0};
}

void net__http__Header_add_map(net__http__Header* h, Map_net__http__CommonHeader_string kvs) {
	int _t2 = kvs.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = kvs.key_values.len - _t2;
		_t2 = kvs.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&kvs.key_values, _t1)) {continue;}
		net__http__CommonHeader k = /*key*/ *(net__http__CommonHeader*)DenseArray_key(&kvs.key_values, _t1);
		string v = (*(string*)DenseArray_value(&kvs.key_values, _t1));
		net__http__Header_add(h, k, v);
	}
}

_result_void net__http__Header_add_custom_map(net__http__Header* h, Map_string_string kvs) {
	int _t2 = kvs.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = kvs.key_values.len - _t2;
		_t2 = kvs.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&kvs.key_values, _t1)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&kvs.key_values, _t1);
		k = string_clone(k);
		string v = (*(string*)DenseArray_value(&kvs.key_values, _t1));
		_result_void _t4 = net__http__Header_add_custom(h, k, v);
		if (_t4.is_error) {
			_result_void _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 ;
	}
	return (_result_void){0};
}

void net__http__Header_set(net__http__Header* h, net__http__CommonHeader key, string value) {
	string key_str = net__http__CommonHeader_str(key);
	for (int i = 0; i < h->cur_pos; i++) {
		if (string__eq(h->data[v_fixed_index(i, 50)].key, key_str)) {
			h->data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = key_str,.value = value,});
			return;
		}
	}
	h->data[v_fixed_index(h->cur_pos, 50)] = ((net__http__HeaderKV){.key = key_str,.value = value,});
	h->cur_pos++;
}

_result_void net__http__Header_set_custom(net__http__Header* h, string key, string value) {
	_result_void _t1 = net__http__is_valid(key);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	bool set = false;
for (int i = 0; i != 50; ++i) {
		net__http__HeaderKV kv = h->data[i];
		if (string__eq(kv.key, key)) {
			if (!set) {
				h->data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = key,.value = value,});
				set = true;
			} else {
				h->data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = key,.value = _SLIT(""),});
			}
		}
	}
	if (set) {
		return (_result_void){0};
	}
	h->data[v_fixed_index(h->cur_pos, 50)] = ((net__http__HeaderKV){.key = key,.value = value,});
	h->cur_pos++;
	return (_result_void){0};
}

void net__http__Header_delete(net__http__Header* h, net__http__CommonHeader key) {
	net__http__Header_delete_custom(h, net__http__CommonHeader_str(key));
}

void net__http__Header_delete_custom(net__http__Header* h, string key) {
	for (int i = 0; i < h->cur_pos; i++) {
		if (string__eq(h->data[v_fixed_index(i, 50)].key, key)) {
			h->data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = key,.value = _SLIT(""),});
		}
	}
}

void net__http__Header_coerce(net__http__Header* h, net__http__HeaderCoerceConfig flags) {
	Array_string keys = net__http__Header_keys(/*rec*/*h);
	Array_string _t1 = {0};
	Array_string _t1_orig = net__http__Header_keys(/*rec*/*h);
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(string));

	for (int _t3 = 0; _t3 < _t1_len; ++_t3) {
		string it = ((string*) _t1_orig.data)[_t3];
		string _t2 = string_to_lower(it);
		array_push((array*)&_t1, &_t2);
	}
	Array_string new_keys = arrays__distinct_T_string(_t1);
	if (keys.len == new_keys.len) {
		return;
	}
	Array_fixed_net__http__HeaderKV_50 new_data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}};
	int i = 0;
	for (int _t4 = 0; _t4 < new_keys.len; ++_t4) {
		string key = ((string*)new_keys.data)[_t4];
		for (int _t5 = 0; _t5 < keys.len; ++_t5) {
			string old_key = ((string*)keys.data)[_t5];
			if (string__eq(string_to_lower(old_key), key)) {
				_result_string _t6 = net__http__Header_get_custom(/*rec*/*h, old_key, ((net__http__HeaderQueryConfig){.exact = true,}));
				if (_t6.is_error) {
					IError err = _t6.err;
					continue;
				}
				
 				new_data[v_fixed_index(i, 50)] = ((net__http__HeaderKV){.key = key,.value =  (*(string*)_t6.data),});
				i++;
			}
		}
	}

	memcpy(&h->data, new_data, sizeof(Array_fixed_net__http__HeaderKV_50));
	;
	h->cur_pos = i;
}

bool net__http__Header_contains(net__http__Header h, net__http__CommonHeader key) {
	if (h.cur_pos == 0) {
		bool _t1 = false;
		return _t1;
	}
	string key_str = net__http__CommonHeader_str(key);
	for (int i = 0; i < h.cur_pos; i++) {
		if (string__eq(h.data[v_fixed_index(i, 50)].key, key_str)) {
			bool _t2 = true;
			return _t2;
		}
	}
	bool _t3 = false;
	return _t3;
}

bool net__http__Header_contains_custom(net__http__Header h, string key, net__http__HeaderQueryConfig flags) {
	if (flags.exact) {
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(kv.key, key)) {
				bool _t1 = true;
				return _t1;
			}
		}
		bool _t2 = false;
		return _t2;
	} else {
		string lower_key = string_to_lower(key);
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(string_to_lower(kv.key), lower_key)) {
				bool _t3 = true;
				return _t3;
			}
		}
		bool _t4 = false;
		return _t4;
	}
	return 0;
}

_result_string net__http__Header_get(net__http__Header h, net__http__CommonHeader key) {
	_result_string _t1 = net__http__Header_get_custom(h, net__http__CommonHeader_str(key), ((net__http__HeaderQueryConfig){.exact = 0,}));
	return _t1;
}

_result_string net__http__Header_get_custom(net__http__Header h, string key, net__http__HeaderQueryConfig flags) {
	if (flags.exact) {
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(kv.key, key)) {
				_result_string _t1;
				_result_ok(&(string[]) { kv.value }, (_result*)(&_t1), sizeof(string));
				return _t1;
			}
		}
	} else {
		string lower_key = string_to_lower(key);
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(string_to_lower(kv.key), lower_key)) {
				_result_string _t2;
				_result_ok(&(string[]) { kv.value }, (_result*)(&_t2), sizeof(string));
				return _t2;
			}
		}
	}
	return (_result_string){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_string net__http__Header_starting_with(net__http__Header h, string key) {
for (int _t1 = 0; _t1 != 50; ++_t1) {
		net__http__HeaderKV kv = h.data[_t1];
		if (string_starts_with(kv.key, key)) {
			_result_string _t2;
			_result_ok(&(string[]) { kv.key }, (_result*)(&_t2), sizeof(string));
			return _t2;
		}
	}
	return (_result_string){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

Array_string net__http__Header_values(net__http__Header h, net__http__CommonHeader key) {
	Array_string _t1 = net__http__Header_custom_values(h, net__http__CommonHeader_str(key), ((net__http__HeaderQueryConfig){.exact = 0,}));
	return _t1;
}

Array_string net__http__Header_custom_values(net__http__Header h, string key, net__http__HeaderQueryConfig flags) {
	if (h.cur_pos == 0) {
		Array_string _t1 = __new_array_with_default(0, 0, sizeof(string), 0);
		return _t1;
	}
	Array_string res = __new_array_with_default(0, 2, sizeof(string), 0);
	if (flags.exact) {
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(kv.key, key) && (kv.value).len != 0) {
				array_push((array*)&res, _MOV((string[]){ string_clone(kv.value) }));
			}
		}
		return res;
	} else {
		string lower_key = string_to_lower(key);
		for (int i = 0; i < h.cur_pos; i++) {
			net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
			if (string__eq(string_to_lower(kv.key), lower_key) && (kv.value).len != 0) {
				array_push((array*)&res, _MOV((string[]){ string_clone(kv.value) }));
			}
		}
		return res;
	}
	return __new_array(0, 0, sizeof(string));
}

Array_string net__http__Header_keys(net__http__Header h) {
	Array_string res = __new_array_with_default(0, h.cur_pos, sizeof(string), 0);
	for (int i = 0; i < h.cur_pos; i++) {
		if ((h.data[v_fixed_index(i, 50)].value).len == 0) {
			continue;
		}
		array_push((array*)&res, _MOV((string[]){ string_clone(h.data[v_fixed_index(i, 50)].key) }));
	}
	Array_string _t2 = arrays__uniq_T_string(res);
	return _t2;
}

// Attr: [manualfree]
string net__http__Header_render(net__http__Header h, net__http__HeaderRenderConfig flags) {
	strings__Builder sb = strings__new_builder((int)(50 * 48));
	net__http__Header_render_into_sb(h, (voidptr)&/*qq*/sb, flags);
	string res = strings__Builder_str(&sb);
	strings__Builder_free(&sb);
	return res;
}

void net__http__Header_render_into_sb(net__http__Header h, strings__Builder* sb, net__http__HeaderRenderConfig flags) {
	for (int i = 0; i < h.cur_pos; i++) {
		net__http__HeaderKV kv = h.data[v_fixed_index(i, 50)];
		string key = (flags.version == net__http__Version__v2_0 ? (string_to_lower(kv.key)) : flags.canonicalize ? (net__http__canonicalize(string_to_lower(kv.key))) : (kv.key));
		strings__Builder_write_string(sb, key);
		strings__Builder_write_string(sb, _SLIT(": "));
		strings__Builder_write_string(sb, kv.value);
		strings__Builder_write_string(sb, _SLIT("\r\n"));
	}
}

net__http__Header net__http__Header_join(net__http__Header h, net__http__Header other) {
	net__http__Header combined = ((net__http__Header){.data = {h.data[0], h.data[1], h.data[2], h.data[3], h.data[4], h.data[5], h.data[6], h.data[7], h.data[8], h.data[9], h.data[10], h.data[11], h.data[12], h.data[13], h.data[14], h.data[15], h.data[16], h.data[17], h.data[18], h.data[19], h.data[20], h.data[21], h.data[22], h.data[23], h.data[24], h.data[25], h.data[26], h.data[27], h.data[28], h.data[29], h.data[30], h.data[31], h.data[32], h.data[33], h.data[34], h.data[35], h.data[36], h.data[37], h.data[38], h.data[39], h.data[40], h.data[41], h.data[42], h.data[43], h.data[44], h.data[45], h.data[46], h.data[47], h.data[48], h.data[49]},.cur_pos = h.cur_pos,});
	Array_string _t1 = net__http__Header_keys(other);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string k = ((string*)_t1.data)[_t2];
		Array_string _t3 = net__http__Header_custom_values(other, k, ((net__http__HeaderQueryConfig){.exact = true,}));
		for (int _t4 = 0; _t4 < _t3.len; ++_t4) {
			string v = ((string*)_t3.data)[_t4];
			_result_void _t5 = net__http__Header_add_custom(&combined, k, v);
			if (_t5.is_error) {
				IError err = _t5.err;
				_v_panic( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				VUNREACHABLE();
			;
			}
			
 ;
		}
	}
	return combined;
}

VV_LOCAL_SYMBOL string net__http__canonicalize(string name) {
	if (_IN_MAP(ADDR(string, name), ADDR(map, _const_net__http__common_header_map))) {
		string _t1 = net__http__CommonHeader_str((*(net__http__CommonHeader*)map_get(ADDR(map, _const_net__http__common_header_map), &(string[]){name}, &(net__http__CommonHeader[]){ 0 })));
		return _t1;
	}
	Array_string _t3 = {0};
	Array_string _t3_orig = string_split(name, _SLIT("-"));
	int _t3_len = _t3_orig.len;
	_t3 = __new_array(0, _t3_len, sizeof(string));

	for (int _t5 = 0; _t5 < _t3_len; ++_t5) {
		string it = ((string*) _t3_orig.data)[_t5];
		string _t4 = string_capitalize(it);
		array_push((array*)&_t3, &_t4);
	}
	string _t2 = Array_string_join(_t3, _SLIT("-"));
	return _t2;
}

string net__http__HeaderKeyError_msg(net__http__HeaderKeyError err) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Invalid header key: '"), /*115 &string*/0xfe10, {.d_s = err.header}}, {_SLIT("'"), 0, { .d_c = 0 }}}));
	return _t1;
}

int net__http__HeaderKeyError_code(net__http__HeaderKeyError err) {
	int _t1 = err.code;
	return _t1;
}

VV_LOCAL_SYMBOL _result_void net__http__is_valid(string header) {
	for (int _t1 = 0; _t1 < header.len; ++_t1) {
		u8 c = header.str[_t1];
		if (((int)(c)) >= 128 || !net__http__is_token(c)) {
			return (_result_void){ .is_error=true, .err=I_net__http__HeaderKeyError_to_Interface_IError(((net__http__HeaderKeyError*)memdup(&(net__http__HeaderKeyError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),.code = 1,.header = header,.invalid_char = c,}, sizeof(net__http__HeaderKeyError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if (header.len == 0) {
		return (_result_void){ .is_error=true, .err=I_net__http__HeaderKeyError_to_Interface_IError(((net__http__HeaderKeyError*)memdup(&(net__http__HeaderKeyError){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),.code = 2,.header = header,.invalid_char = 0,}, sizeof(net__http__HeaderKeyError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL bool net__http__is_token(u8 b) {
	bool _t1 = ((b == (33) || (b >= 35 && b <= 39) || b == (42) || b == (43) || b == (45) || b == (46) || (b >= 48 && b <= 57) || (b >= 65 && b <= 90) || (b >= 94 && b <= 122) || b == (124) || b == (126))? (true) : (false));
	return _t1;
}

string net__http__Header_str(net__http__Header h) {
	string _t1 = net__http__Header_render(h, ((net__http__HeaderRenderConfig){.version = net__http__Version__v1_1,.coerce = 0,.canonicalize = 0,}));
	return _t1;
}

VV_LOCAL_SYMBOL _result_net__http__Header net__http__parse_headers(string s) {
	net__http__Header h = net__http__new_header(__new_array(0, 0, sizeof(net__http__HeaderConfig)));
	string last_key = _SLIT("");
	string last_value = _SLIT("");
	Array_string _t1 = string_split_into_lines(s);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string line = ((string*)_t1.data)[_t2];
		if (line.len == 0) {
			break;
		}
		if (string_at(line, 0) == ' ' || string_at(line, 0) == '\t') {
			last_value = string__plus(last_value,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(" "), /*115 &string*/0xfe10, {.d_s = string_trim(line, _SLIT(" \t"))}}, {_SLIT0, 0, { .d_c = 0 }}})));
			continue;
		} else if ((last_key).len != 0) {
			_result_void _t3 = net__http__Header_add_custom(&h, last_key, last_value);
			if (_t3.is_error) {
				_result_net__http__Header _t4;
				memcpy(&_t4, &_t3, sizeof(_result));
				return _t4;
			}
			
 ;
		}
		_result_multi_return_string_string _t5 = net__http__parse_header(line);
		if (_t5.is_error) {
			_result_net__http__Header _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 		multi_return_string_string mr_23228 =  (*(multi_return_string_string*)_t5.data);
		last_key = mr_23228.arg0;
		last_value = mr_23228.arg1;
	}
	_result_void _t7 = net__http__Header_add_custom(&h, last_key, last_value);
	if (_t7.is_error) {
		_result_net__http__Header _t8;
		memcpy(&_t8, &_t7, sizeof(_result));
		return _t8;
	}
	
 ;
	_result_net__http__Header _t9;
	_result_ok(&(net__http__Header[]) { h }, (_result*)(&_t9), sizeof(net__http__Header));
	return _t9;
}

VV_LOCAL_SYMBOL _result_multi_return_string_string net__http__parse_header(string s) {
	if (!string_contains(s, _SLIT(":"))) {
		return (_result_multi_return_string_string){ .is_error=true, .err=_v_error(_SLIT("missing colon in header")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_string words = string_split_nth(s, _SLIT(":"), 2);
	_result_multi_return_string_string _t2;
	_result_ok(&(multi_return_string_string[]) { (multi_return_string_string){.arg0=(*(string*)array_get(words, 0)), .arg1=string_trim((*(string*)array_get(words, 1)), _SLIT(" \t"))} }, (_result*)(&_t2), sizeof(multi_return_string_string));
	return _t2;
}

VV_LOCAL_SYMBOL _result_int net__http__parse_header_fast(string s) {
	_option_int _t1 = string_index(s, _SLIT(":"));
	if (_t1.state != 0) {
		IError err = _t1.err;
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("missing colon in header")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int pos =  (*(int*)_t1.data);
	_result_int _t3;
	_result_ok(&(int[]) { pos }, (_result*)(&_t3), sizeof(int));
	return _t3;
}

net__http__Request net__http__new_request(net__http__Method method, string url_, string data) {
	string url = (method == net__http__Method__get && !string_contains(url_, _SLIT("?")) ? (string__plus(string__plus(url_, _SLIT("?")), data)) : (url_));
	net__http__Request _t1 = ((net__http__Request){.version = net__http__Version__v1_1,.method = method,.header = (net__http__Header){.cur_pos = 0,},.host = (string){.str=(byteptr)"", .is_lit=1},.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.data = data,.url = url,.user_agent = _SLIT("v.http"),.verbose = 0,.user_ptr = 0,.proxy = ((void*)0),.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),});
	return _t1;
}

_result_net__http__Response net__http__get(string url) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__get,.header = (net__http__Header){.cur_pos = 0,},.data = (string){.str=(byteptr)"", .is_lit=1},.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__post(string url, string data) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__post,.header = net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _const_net__http__content_type_default,})}))),.data = data,.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__post_json(string url, string data) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__post,.header = net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _SLIT("application/json"),})}))),.data = data,.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__post_form(string url, Map_string_string data) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__post,.header = net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _SLIT("application/x-www-form-urlencoded"),})}))),.data = net__http__url_encode_form_data(data),.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__post_multipart_form(string url, net__http__PostMultipartFormConfig conf) {
	multi_return_string_string mr_3435 = net__http__multipart_form_body(conf.form, conf.files);
	string body = mr_3435.arg0;
	string boundary = mr_3435.arg1;
	println(net__http__Header_str(conf.header));
	net__http__Header header = conf.header;
	net__http__Header_set(&header, net__http__CommonHeader__content_type,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("multipart/form-data; boundary=\""), /*115 &string*/0xfe10, {.d_s = boundary}}, {_SLIT("\""), 0, { .d_c = 0 }}})));
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__post,.header = header,.data = body,.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__put(string url, string data) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__put,.header = net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _const_net__http__content_type_default,})}))),.data = data,.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__patch(string url, string data) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__patch,.header = net__http__new_header(new_array_from_c_array(1, 1, sizeof(net__http__HeaderConfig), _MOV((net__http__HeaderConfig[1]){((net__http__HeaderConfig){.key = net__http__CommonHeader__content_type,.value = _const_net__http__content_type_default,})}))),.data = data,.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__head(string url) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__head,.header = (net__http__Header){.cur_pos = 0,},.data = (string){.str=(byteptr)"", .is_lit=1},.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__delete(string url) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__delete,.header = (net__http__Header){.cur_pos = 0,},.data = (string){.str=(byteptr)"", .is_lit=1},.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	return _t1;
}

_result_net__http__Response net__http__fetch(net__http__FetchConfig config) {
	if ((config.url).len == 0) {
		return (_result_net__http__Response){ .is_error=true, .err=_v_error(_SLIT("http.fetch: empty url")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_string _t2 = net__http__build_url_from_fetch(config);
	if (_t2.is_error) {
		IError err = _t2.err;
		return (_result_net__http__Response){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("http.fetch: invalid url "), /*115 &string*/0xfe10, {.d_s = config.url}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	string url =  (*(string*)_t2.data);
	net__http__Request req = ((net__http__Request){
		.version = net__http__Version__v1_1,
		.method = config.method,
		.header = config.header,
		.host = (string){.str=(byteptr)"", .is_lit=1},
		.cookies = config.cookies,
		.data = config.data,
		.url = url,
		.user_agent = config.user_agent,
		.verbose = config.verbose,
		.user_ptr = config.user_ptr,
		.proxy = config.proxy,
		.read_timeout = 30 * _const_time__second,
		.write_timeout = 30 * _const_time__second,
		.validate = config.validate,
		.verify = config.verify,
		.cert = config.cert,
		.cert_key = config.cert_key,
		.in_memory_verification = config.in_memory_verification,
		.allow_redirect = config.allow_redirect,
		.max_retries = config.max_retries,
		.on_redirect = (voidptr)config.on_redirect,
		.on_progress = (voidptr)config.on_progress,
		.on_finish = (voidptr)config.on_finish,
	});
	_result_net__http__Response _t4 = net__http__Request_do(&req);
	if (_t4.is_error) {
		_result_net__http__Response _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	net__http__Response res =  (*(net__http__Response*)_t4.data);
	_result_net__http__Response _t6;
	_result_ok(&(net__http__Response[]) { res }, (_result*)(&_t6), sizeof(net__http__Response));
	return _t6;
}

string net__http__get_text(string url) {
	_result_net__http__Response _t1 = net__http__fetch(((net__http__FetchConfig){.url = url,.method = net__http__Method__get,.header = (net__http__Header){.cur_pos = 0,},.data = (string){.str=(byteptr)"", .is_lit=1},.params = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),.user_agent = _SLIT("v.http"),.user_ptr = ((void*)0),.verbose = 0,.proxy = ((void*)0),.validate = 0,.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.in_memory_verification = 0,.allow_redirect = true,.max_retries = 5,.on_redirect = ((void*)0),.on_progress = ((void*)0),.on_finish = ((void*)0),}));
	if (_t1.is_error) {
		IError err = _t1.err;
		string _t2 = _SLIT("");
		return _t2;
	}
	
 	net__http__Response resp =  (*(net__http__Response*)_t1.data);
	string _t3 = resp.body;
	return _t3;
}

string net__http__url_encode_form_data(Map_string_string data) {
	Array_string pieces = __new_array_with_default(0, 0, sizeof(string), 0);
	int _t2 = data.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = data.key_values.len - _t2;
		_t2 = data.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&data.key_values, _t1)) {continue;}
		string key_ = /*key*/ *(string*)DenseArray_key(&data.key_values, _t1);
		key_ = string_clone(key_);
		string value_ = (*(string*)DenseArray_value(&data.key_values, _t1));
		string key = net__urllib__query_escape(key_);
		string value = net__urllib__query_escape(value_);
		array_push((array*)&pieces, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = key}}, {_SLIT("="), /*115 &string*/0xfe10, {.d_s = value}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	}
	string _t5 = Array_string_join(pieces, _SLIT("&"));
	return _t5;
}

VV_LOCAL_SYMBOL _result_string net__http__build_url_from_fetch(net__http__FetchConfig config) {
	_result_net__urllib__URL _t1 = net__urllib__parse(config.url);
	if (_t1.is_error) {
		_result_string _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__urllib__URL url =  (*(net__urllib__URL*)_t1.data);
	if (config.params.len == 0) {
		_result_string _t3;
		_result_ok(&(string[]) { net__urllib__URL_str(&url) }, (_result*)(&_t3), sizeof(string));
		return _t3;
	}
	Array_string pieces = __new_array_with_default(0, config.params.len, sizeof(string), 0);
	Map_string_string _t4 = config.params;
	int _t6 = _t4.key_values.len;
	for (int _t5 = 0; _t5 < _t6; ++_t5 ) {
		int _t7 = _t4.key_values.len - _t6;
		_t6 = _t4.key_values.len;
		if (_t7 < 0) {
			_t5 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t4.key_values, _t5)) {continue;}
		string key = /*key*/ *(string*)DenseArray_key(&_t4.key_values, _t5);
		key = string_clone(key);
		string val = (*(string*)DenseArray_value(&_t4.key_values, _t5));
		array_push((array*)&pieces, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = key}}, {_SLIT("="), /*115 &string*/0xfe10, {.d_s = val}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	}
	string query = Array_string_join(pieces, _SLIT("&"));
	if (url.raw_query.len > 1) {
		query = string__plus(string__plus(url.raw_query, _SLIT("&")), query);
	}
	url.raw_query = query;
	_result_string _t9;
	_result_ok(&(string[]) { net__urllib__URL_str(&url) }, (_result*)(&_t9), sizeof(string));
	return _t9;
}

_result_net__http__HttpProxy_ptr net__http__new_http_proxy(string raw_url) {
	_result_net__urllib__URL _t1 = net__urllib__parse(raw_url);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__http__HttpProxy_ptr){ .is_error=true, .err=_v_error(_SLIT("malformed proxy url")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__urllib__URL url =  (*(net__urllib__URL*)_t1.data);
	string scheme = url.scheme;
	if (!(string__eq(scheme, _SLIT("http")) || string__eq(scheme, _SLIT("https")) || string__eq(scheme, _SLIT("socks5")))) {
		return (_result_net__http__HttpProxy_ptr){ .is_error=true, .err=_v_error(_SLIT("invalid scheme")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	url.path = _SLIT("");
	url.raw_path = _SLIT("");
	url.raw_query = _SLIT("");
	url.fragment = _SLIT("");
	string str_url = net__urllib__URL_str(&url);
	string host = url.host;
	int port = string_int(net__urllib__URL_port(&url));
	if (port == 0) {
		if (string__eq(scheme, _SLIT("https"))) {
			port = 443;
			host = string__plus(host, string__plus(_SLIT(":"), int_str(port)));
		} else if (string__eq(scheme, _SLIT("http"))) {
			port = 80;
			host = string__plus(host, string__plus(_SLIT(":"), int_str(port)));
		}
	}
	if (port == 0) {
		return (_result_net__http__HttpProxy_ptr){ .is_error=true, .err=_v_error(_SLIT("Unknown port")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_net__http__HttpProxy_ptr _t5;
	_result_ok(&(net__http__HttpProxy*[]) { ((net__http__HttpProxy*)memdup(&(net__http__HttpProxy){.scheme = scheme,
		.username = url.user->username,
		.password = url.user->password,
		.host = host,
		.hostname = net__urllib__URL_hostname(&url),
		.port = port,
		.url = str_url,
	}, sizeof(net__http__HttpProxy))) }, (_result*)(&_t5), sizeof(net__http__HttpProxy*));
	return _t5;
}

VV_LOCAL_SYMBOL string net__http__HttpProxy_build_proxy_headers(net__http__HttpProxy* pr, string host) {
	Array_string uheaders = __new_array_with_default(0, 0, sizeof(string), 0);
	string address = string_all_before_last(host, _SLIT(":"));
	array_push((array*)&uheaders, _MOV((string[]){ string_clone(_SLIT("Proxy-Connection: Keep-Alive\r\n")) }));
	if ((pr->username).len != 0) {
		string authinfo = _SLIT("");
		authinfo = string__plus(authinfo, pr->username);
		if ((pr->password).len != 0) {
			authinfo = string__plus(authinfo,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(":"), /*115 &string*/0xfe10, {.d_s = pr->password}}, {_SLIT0, 0, { .d_c = 0 }}})));
		}
		string encoded_authinfo = encoding__base64__encode(string_bytes(authinfo));
		array_push((array*)&uheaders, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Proxy-Authorization: Basic "), /*115 &string*/0xfe10, {.d_s = encoded_authinfo}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}}))) }));
	}
	net__http__Version version = net__http__Version__v1_1;
	string _t3 = string__plus(string__plus( str_intp(4, _MOV((StrIntpData[]){{_SLIT("CONNECT "), /*115 &string*/0xfe10, {.d_s = host}}, {_SLIT(" "), /*115 &net.http.Version*/0xfe10, {.d_s = net__http__Version_str(version)}}, {_SLIT("\r\nHost: "), /*115 &string*/0xfe10, {.d_s = address}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}})), Array_string_join(uheaders, _SLIT(""))), _SLIT("\r\n"));
	return _t3;
}

VV_LOCAL_SYMBOL _result_net__http__Response net__http__HttpProxy_http_do(net__http__HttpProxy* pr, net__urllib__URL host, net__http__Method method, string path, net__http__Request* req) {
	_result_multi_return_string_u16 _t1 = net__split_address(net__urllib__URL_hostname(&host));
	if (_t1.is_error) {
		_result_net__http__Response _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_string_u16 mr_1804 =  (*(multi_return_string_u16*)_t1.data);
	string host_name = mr_1804.arg0;
	string s = net__http__Request_build_request_headers(req, req->method, host_name, path);
	if (string__eq(host.scheme, _SLIT("https"))) {
		_result_net__ssl__SSLConn_ptr _t3 = net__http__HttpProxy_ssl_dial(pr,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = host.host}}, {_SLIT(":443"), 0, { .d_c = 0 }}})));
		if (_t3.is_error) {
			_result_net__http__Response _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 		net__ssl__SSLConn* client =  (*(net__ssl__SSLConn**)_t3.data);
		#if defined(_WIN32)
		{
			return (_result_net__http__Response){ .is_error=true, .err=_v_error(_SLIT("Windows Not SUPPORTED")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		#else
		{
		}
		#endif
	} else if (string__eq(host.scheme, _SLIT("http"))) {
		_result_net__TcpConn_ptr _t7 = net__http__HttpProxy_dial(pr,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = host.host}}, {_SLIT(":80"), 0, { .d_c = 0 }}})));
		if (_t7.is_error) {
			_result_net__http__Response _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 		net__TcpConn* client =  (*(net__TcpConn**)_t7.data);
		net__TcpConn_set_read_timeout(client, req->read_timeout);
		net__TcpConn_set_write_timeout(client, req->write_timeout);
		_result_int _t9 = net__TcpConn_write_string(client, s);
		if (_t9.is_error) {
			_result_net__http__Response _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
  (*(int*)_t9.data);
		_result_Array_u8 _t11 = net__http__Request_read_all_from_client_connection(req, client);
		if (_t11.is_error) {
			_result_net__http__Response _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 		Array_u8 bytes =  (*(Array_u8*)_t11.data);
		_result_void _t13 = net__TcpConn_close(client);
		if (_t13.is_error) {
			_result_net__http__Response _t14;
			memcpy(&_t14, &_t13, sizeof(_result));
			return _t14;
		}
		
 ;
		string response_text = Array_u8_bytestr(bytes);
		if (req->on_finish != (voidptr)((void*)0)) {
			_result_void _t15 = req->on_finish(req, ((u64)(response_text.len)));
			if (_t15.is_error) {
				_result_net__http__Response _t16;
				memcpy(&_t16, &_t15, sizeof(_result));
				return _t16;
			}
			
 ;
		}
		_result_net__http__Response _t17 = net__http__parse_response(response_text);
		return _t17;
	}
	return (_result_net__http__Response){ .is_error=true, .err=_v_error(_SLIT("Invalid Scheme")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_net__TcpConn_ptr net__http__HttpProxy_dial(net__http__HttpProxy* pr, string host) {
	if (string__eq(pr->scheme, _SLIT("http")) || string__eq(pr->scheme, _SLIT("https"))) {
		_result_net__TcpConn_ptr _t1 = net__dial_tcp(pr->host);
		if (_t1.is_error) {
			_result_net__TcpConn_ptr _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 		net__TcpConn* tcp =  (*(net__TcpConn**)_t1.data);
		_result_int _t3 = net__TcpConn_write(tcp, string_bytes(net__http__HttpProxy_build_proxy_headers(pr, host)));
		if (_t3.is_error) {
			_result_net__TcpConn_ptr _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
  (*(int*)_t3.data);
		Array_u8 bf = __new_array_with_default_noscan(4096, 0, sizeof(u8), 0);
		_result_int _t5 = net__TcpConn_read(/*rec*/*tcp, &/*arr*/bf);
		if (_t5.is_error) {
			_result_net__TcpConn_ptr _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
  (*(int*)_t5.data);
		_result_net__TcpConn_ptr _t7;
		_result_ok(&(net__TcpConn*[]) { tcp }, (_result*)(&_t7), sizeof(net__TcpConn*));
		return _t7;
	} else if (string__eq(pr->scheme, _SLIT("socks5"))) {
		_result_net__TcpConn_ptr _t9 = net__socks__socks5_dial(pr->host, host, pr->username, pr->password);
		if (_t9.is_error) {
			_result_net__TcpConn_ptr _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 		_result_net__TcpConn_ptr _t8;
		_result_ok(&(net__TcpConn*[]) {  (*(net__TcpConn**)_t9.data) }, (_result*)(&_t8), sizeof(net__TcpConn*));
		return _t8;
	} else {
		return (_result_net__TcpConn_ptr){ .is_error=true, .err=_v_error(_SLIT("http_proxy dial: invalid proxy scheme")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_net__TcpConn_ptr){0};
}

VV_LOCAL_SYMBOL _result_net__ssl__SSLConn_ptr net__http__HttpProxy_ssl_dial(net__http__HttpProxy* pr, string host) {
	if (string__eq(pr->scheme, _SLIT("http")) || string__eq(pr->scheme, _SLIT("https"))) {
		_result_net__TcpConn_ptr _t1 = net__dial_tcp(pr->host);
		if (_t1.is_error) {
			_result_net__ssl__SSLConn_ptr _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 		net__TcpConn* tcp =  (*(net__TcpConn**)_t1.data);
		_result_int _t3 = net__TcpConn_write(tcp, string_bytes(net__http__HttpProxy_build_proxy_headers(pr, host)));
		if (_t3.is_error) {
			_result_net__ssl__SSLConn_ptr _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
  (*(int*)_t3.data);
		Array_u8 bf = __new_array_with_default_noscan(4096, 0, sizeof(u8), 0);
		_result_int _t5 = net__TcpConn_read(/*rec*/*tcp, &/*arr*/bf);
		if (_t5.is_error) {
			_result_net__ssl__SSLConn_ptr _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
  (*(int*)_t5.data);
		if (!string_contains(Array_u8_bytestr(bf), _SLIT("HTTP/1.1 200"))) {
			return (_result_net__ssl__SSLConn_ptr){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("ssl dial error: "), /*115 &string*/0xfe10, {.d_s = Array_u8_bytestr(bf)}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_result_net__ssl__SSLConn_ptr _t8 = net__ssl__new_ssl_conn(((net__ssl__SSLConnectConfig){.SSLConnectConfig = ((net__mbedtls__SSLConnectConfig){.verify = _SLIT(""),.cert = _SLIT(""),.cert_key = _SLIT(""),.validate = false,.in_memory_verification = false,}),}));
		if (_t8.is_error) {
			_result_net__ssl__SSLConn_ptr _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		
 		net__ssl__SSLConn* ssl_conn =  (*(net__ssl__SSLConn**)_t8.data);
		_result_void _t10 = net__mbedtls__SSLConn_connect(&ssl_conn->SSLConn, tcp, string_all_before_last(host, _SLIT(":")));
		if (_t10.is_error) {
			_result_net__ssl__SSLConn_ptr _t11;
			memcpy(&_t11, &_t10, sizeof(_result));
			return _t11;
		}
		
 ;
		_result_net__ssl__SSLConn_ptr _t12;
		_result_ok(&(net__ssl__SSLConn*[]) { ssl_conn }, (_result*)(&_t12), sizeof(net__ssl__SSLConn*));
		return _t12;
	} else if (string__eq(pr->scheme, _SLIT("socks5"))) {
		_result_net__ssl__SSLConn_ptr _t14 = net__socks__socks5_ssl_dial(pr->host, host, pr->username, pr->password);
		if (_t14.is_error) {
			_result_net__ssl__SSLConn_ptr _t15;
			memcpy(&_t15, &_t14, sizeof(_result));
			return _t15;
		}
		
 		_result_net__ssl__SSLConn_ptr _t13;
		_result_ok(&(net__ssl__SSLConn*[]) {  (*(net__ssl__SSLConn**)_t14.data) }, (_result*)(&_t13), sizeof(net__ssl__SSLConn*));
		return _t13;
	} else {
		return (_result_net__ssl__SSLConn_ptr){ .is_error=true, .err=_v_error(_SLIT("http_proxy ssl_dial: invalid proxy scheme")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_net__ssl__SSLConn_ptr){0};
}

string net__http__Method_str(net__http__Method m) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (m) {
		case net__http__Method__get: {
				_t2 = _SLIT("GET");
				break;
		}
		case net__http__Method__head: {
				_t2 = _SLIT("HEAD");
				break;
		}
		case net__http__Method__post: {
				_t2 = _SLIT("POST");
				break;
		}
		case net__http__Method__put: {
				_t2 = _SLIT("PUT");
				break;
		}
		case net__http__Method__acl: {
				_t2 = _SLIT("ACL");
				break;
		}
		case net__http__Method__baseline_control: {
				_t2 = _SLIT("BASELINE-CONTROL");
				break;
		}
		case net__http__Method__bind: {
				_t2 = _SLIT("BIND");
				break;
		}
		case net__http__Method__checkin: {
				_t2 = _SLIT("CHECKIN");
				break;
		}
		case net__http__Method__checkout: {
				_t2 = _SLIT("CHECKOUT");
				break;
		}
		case net__http__Method__connect: {
				_t2 = _SLIT("CONNECT");
				break;
		}
		case net__http__Method__copy: {
				_t2 = _SLIT("COPY");
				break;
		}
		case net__http__Method__delete: {
				_t2 = _SLIT("DELETE");
				break;
		}
		case net__http__Method__label: {
				_t2 = _SLIT("LABEL");
				break;
		}
		case net__http__Method__link: {
				_t2 = _SLIT("LINK");
				break;
		}
		case net__http__Method__lock: {
				_t2 = _SLIT("LOCK");
				break;
		}
		case net__http__Method__merge: {
				_t2 = _SLIT("MERGE");
				break;
		}
		case net__http__Method__mkactivity: {
				_t2 = _SLIT("MKACTIVITY");
				break;
		}
		case net__http__Method__mkcalendar: {
				_t2 = _SLIT("MKCALENDAR");
				break;
		}
		case net__http__Method__mkcol: {
				_t2 = _SLIT("MKCOL");
				break;
		}
		case net__http__Method__mkredirectref: {
				_t2 = _SLIT("MKREDIRECTREF");
				break;
		}
		case net__http__Method__mkworkspace: {
				_t2 = _SLIT("MKWORKSPACE");
				break;
		}
		case net__http__Method__move: {
				_t2 = _SLIT("MOVE");
				break;
		}
		case net__http__Method__options: {
				_t2 = _SLIT("OPTIONS");
				break;
		}
		case net__http__Method__orderpatch: {
				_t2 = _SLIT("ORDERPATCH");
				break;
		}
		case net__http__Method__patch: {
				_t2 = _SLIT("PATCH");
				break;
		}
		case net__http__Method__pri: {
				_t2 = _SLIT("PRI");
				break;
		}
		case net__http__Method__propfind: {
				_t2 = _SLIT("PROPFIND");
				break;
		}
		case net__http__Method__proppatch: {
				_t2 = _SLIT("PROPPATCH");
				break;
		}
		case net__http__Method__rebind: {
				_t2 = _SLIT("REBIND");
				break;
		}
		case net__http__Method__report: {
				_t2 = _SLIT("REPORT");
				break;
		}
		case net__http__Method__search: {
				_t2 = _SLIT("SEARCH");
				break;
		}
		case net__http__Method__trace: {
				_t2 = _SLIT("TRACE");
				break;
		}
		case net__http__Method__unbind: {
				_t2 = _SLIT("UNBIND");
				break;
		}
		case net__http__Method__uncheckout: {
				_t2 = _SLIT("UNCHECKOUT");
				break;
		}
		case net__http__Method__unlink: {
				_t2 = _SLIT("UNLINK");
				break;
		}
		case net__http__Method__unlock: {
				_t2 = _SLIT("UNLOCK");
				break;
		}
		case net__http__Method__update: {
				_t2 = _SLIT("UPDATE");
				break;
		}
		case net__http__Method__updateredirectref: {
				_t2 = _SLIT("UPDATEREDIRECTREF");
				break;
		}
		case net__http__Method__version_control: {
				_t2 = _SLIT("VERSION-CONTROL");
				break;
		}
	}
	string _t1 = _t2;
	return _t1;
}

net__http__Method net__http__method_from_str(string m) {
	net__http__Method _t1 = ((string__eq(m, _SLIT("GET")))? (net__http__Method__get) : (string__eq(m, _SLIT("HEAD")))? (net__http__Method__head) : (string__eq(m, _SLIT("POST")))? (net__http__Method__post) : (string__eq(m, _SLIT("PUT")))? (net__http__Method__put) : (string__eq(m, _SLIT("ACL")))? (net__http__Method__acl) : (string__eq(m, _SLIT("BASELINE-CONTROL")))? (net__http__Method__baseline_control) : (string__eq(m, _SLIT("BIND")))? (net__http__Method__bind) : (string__eq(m, _SLIT("CHECKIN")))? (net__http__Method__checkin) : (string__eq(m, _SLIT("CHECKOUT")))? (net__http__Method__checkout) : (string__eq(m, _SLIT("CONNECT")))? (net__http__Method__connect) : (string__eq(m, _SLIT("COPY")))? (net__http__Method__copy) : (string__eq(m, _SLIT("DELETE")))? (net__http__Method__delete) : (string__eq(m, _SLIT("LABEL")))? (net__http__Method__label) : (string__eq(m, _SLIT("LINK")))? (net__http__Method__link) : (string__eq(m, _SLIT("LOCK")))? (net__http__Method__lock) : (string__eq(m, _SLIT("MERGE")))? (net__http__Method__merge) : (string__eq(m, _SLIT("MKACTIVITY")))? (net__http__Method__mkactivity) : (string__eq(m, _SLIT("MKCALENDAR")))? (net__http__Method__mkcalendar) : (string__eq(m, _SLIT("MKCOL")))? (net__http__Method__mkcol) : (string__eq(m, _SLIT("MKREDIRECTREF")))? (net__http__Method__mkredirectref) : (string__eq(m, _SLIT("MKWORKSPACE")))? (net__http__Method__mkworkspace) : (string__eq(m, _SLIT("MOVE")))? (net__http__Method__move) : (string__eq(m, _SLIT("OPTIONS")))? (net__http__Method__options) : (string__eq(m, _SLIT("ORDERPATCH")))? (net__http__Method__orderpatch) : (string__eq(m, _SLIT("PATCH")))? (net__http__Method__patch) : (string__eq(m, _SLIT("PRI")))? (net__http__Method__pri) : (string__eq(m, _SLIT("PROPFIND")))? (net__http__Method__propfind) : (string__eq(m, _SLIT("PROPPATCH")))? (net__http__Method__proppatch) : (string__eq(m, _SLIT("REBIND")))? (net__http__Method__rebind) : (string__eq(m, _SLIT("REPORT")))? (net__http__Method__report) : (string__eq(m, _SLIT("SEARCH")))? (net__http__Method__search) : (string__eq(m, _SLIT("TRACE")))? (net__http__Method__trace) : (string__eq(m, _SLIT("UNBIND")))? (net__http__Method__unbind) : (string__eq(m, _SLIT("UNCHECKOUT")))? (net__http__Method__uncheckout) : (string__eq(m, _SLIT("UNLINK")))? (net__http__Method__unlink) : (string__eq(m, _SLIT("UNLOCK")))? (net__http__Method__unlock) : (string__eq(m, _SLIT("UPDATE")))? (net__http__Method__update) : (string__eq(m, _SLIT("UPDATEREDIRECTREF")))? (net__http__Method__updateredirectref) : (string__eq(m, _SLIT("VERSION-CONTROL")))? (net__http__Method__version_control) : (net__http__Method__get));
	return _t1;
}

// TypeDecl
// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL void net__http__Request_free(net__http__Request* req) {
	net__http__Header_free(&req->header);
}

void net__http__Request_add_header(net__http__Request* req, net__http__CommonHeader key, string val) {
	net__http__Header_add(&req->header, key, val);
}

_result_void net__http__Request_add_custom_header(net__http__Request* req, string key, string val) {
	_result_void _t1 = net__http__Header_add_custom(&req->header, key, val);
	return _t1;
}

void net__http__Request_add_cookie(net__http__Request* req, net__http__Cookie c) {
	map_set(&req->cookies, &(string[]){c.name}, &(string[]) { c.value });
}

_option_net__http__Cookie net__http__Request_cookie(net__http__Request* req, string name) {
	string* _t2 = (string*)(map_get_check(ADDR(map, req->cookies), &(string[]){name}));
	_option_string _t1 = {0};
	if (_t2) {
		*((string*)&_t1.data) = *((string*)_t2);
	} else {
		_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t1.state == 0) {
		string value = (*(string*)_t1.data);
		_option_net__http__Cookie _t3;
		_option_ok(&(net__http__Cookie[]) { ((net__http__Cookie){.name = name,.value = value,.path = (string){.str=(byteptr)"", .is_lit=1},.domain = (string){.str=(byteptr)"", .is_lit=1},.expires = (time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,},.raw_expires = (string){.str=(byteptr)"", .is_lit=1},.max_age = 0,.secure = 0,.http_only = 0,.same_site = 0,.raw = (string){.str=(byteptr)"", .is_lit=1},.unparsed = __new_array(0, 0, sizeof(string)),}) }, (_option*)(&_t3), sizeof(net__http__Cookie));
		return _t3;
	}
	return (_option_net__http__Cookie){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
}

_result_net__http__Response net__http__Request_do(net__http__Request* req) {
	_result_net__urllib__URL _t1 = net__urllib__parse(req->url);
	if (_t1.is_error) {
		IError err = _t1.err;
		return (_result_net__http__Response){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("http.Request.do: invalid url "), /*115 &string*/0xfe10, {.d_s = req->url}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	net__urllib__URL url =  (*(net__urllib__URL*)_t1.data);
	net__urllib__URL rurl = url;
	net__http__Response resp = ((net__http__Response){.body = (string){.str=(byteptr)"", .is_lit=1},.header = (net__http__Header){.cur_pos = 0,},.status_code = 0,.status_msg = (string){.str=(byteptr)"", .is_lit=1},.http_version = (string){.str=(byteptr)"", .is_lit=1},});
	int nredirects = 0;
	for (;;) {
		if (nredirects == _const_net__http__max_redirects) {
			return (_result_net__http__Response){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("http.request.do: maximum number of redirects reached ("), /*100 &int literal*/0xfe07, {.d_i32 = _const_net__http__max_redirects}}, {_SLIT(")"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_result_net__http__Response _t4 = net__http__Request_method_and_url_to_response(req, req->method, rurl);
		if (_t4.is_error) {
			_result_net__http__Response _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 		net__http__Response qresp =  (*(net__http__Response*)_t4.data);
		resp = qresp;
		if (!req->allow_redirect) {
			break;
		}
		if (!(net__http__Response_status(resp) == net__http__Status__moved_permanently || net__http__Response_status(resp) == net__http__Status__found || net__http__Response_status(resp) == net__http__Status__see_other || net__http__Response_status(resp) == net__http__Status__temporary_redirect || net__http__Response_status(resp) == net__http__Status__permanent_redirect)) {
			break;
		}
		_result_string _t6 = net__http__Header_get(resp.header, net__http__CommonHeader__location);
		if (_t6.is_error) {
			IError err = _t6.err;
			*(string*) _t6.data = _SLIT("");
		}
		
 		string redirect_url =  (*(string*)_t6.data);
		if (redirect_url.len > 0 && string_at(redirect_url, 0) == '/') {
			_result_bool _t7 = net__urllib__URL_set_path(&url, redirect_url);
			if (_t7.is_error) {
				IError err = _t7.err;
				return (_result_net__http__Response){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("http.request.do: invalid path in redirect: \""), /*115 &string*/0xfe10, {.d_s = redirect_url}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
  (*(bool*)_t7.data);
			redirect_url = net__urllib__URL_str(&url);
		}
		if (req->on_redirect != (voidptr)((void*)0)) {
			_result_void _t9 = req->on_redirect(req, nredirects, redirect_url);
			if (_t9.is_error) {
				_result_net__http__Response _t10;
				memcpy(&_t10, &_t9, sizeof(_result));
				return _t10;
			}
			
 ;
		}
		_result_net__urllib__URL _t11 = net__urllib__parse(redirect_url);
		if (_t11.is_error) {
			IError err = _t11.err;
			return (_result_net__http__Response){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("http.request.do: invalid URL in redirect \""), /*115 &string*/0xfe10, {.d_s = redirect_url}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
 		net__urllib__URL qrurl =  (*(net__urllib__URL*)_t11.data);
		rurl = qrurl;
		nredirects++;
	}
	_result_net__http__Response _t13;
	_result_ok(&(net__http__Response[]) { resp }, (_result*)(&_t13), sizeof(net__http__Response));
	return _t13;
}

VV_LOCAL_SYMBOL _result_net__http__Response net__http__Request_method_and_url_to_response(net__http__Request* req, net__http__Method method, net__urllib__URL url) {
	string host_name = net__urllib__URL_hostname(&url);
	string scheme = url.scheme;
	string p = string_trim_left(net__urllib__URL_escaped_path(&url), _SLIT("/"));
	string path = (net__urllib__URL_query(&url).len > 0 ? ( str_intp(3, _MOV((StrIntpData[]){{_SLIT("/"), /*115 &string*/0xfe10, {.d_s = p}}, {_SLIT("?"), /*115 &string*/0xfe10, {.d_s = net__urllib__Values_encode(net__urllib__URL_query(&url))}}, {_SLIT0, 0, { .d_c = 0 }}}))) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("/"), /*115 &string*/0xfe10, {.d_s = p}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	int nport = string_int(net__urllib__URL_port(&url));
	if (nport == 0) {
		if (string__eq(scheme, _SLIT("http"))) {
			nport = 80;
		}
		if (string__eq(scheme, _SLIT("https"))) {
			nport = 443;
		}
	}
	if (string__eq(scheme, _SLIT("https")) && req->proxy == ((void*)0)) {
		for (int i = 0; i < req->max_retries; ++i) {
			_result_net__http__Response _t1 = net__http__Request_ssl_do(req, nport, method, host_name, path);
			if (_t1.is_error) {
				IError err = _t1.err;
				if (i == (int)(req->max_retries - 1) || net__http__is_no_need_retry_error(IError_name_table[err._typ]._method_code(err._object))) {
					return (_result_net__http__Response){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				continue;
			}
			
 			net__http__Response res =  (*(net__http__Response*)_t1.data);
			_result_net__http__Response _t3;
			_result_ok(&(net__http__Response[]) { res }, (_result*)(&_t3), sizeof(net__http__Response));
			return _t3;
		}
	} else if (string__eq(scheme, _SLIT("http")) && req->proxy == ((void*)0)) {
		for (int i = 0; i < req->max_retries; ++i) {
			_result_net__http__Response _t4 = net__http__Request_http_do(req,  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = host_name}}, {_SLIT(":"), /*100 &int*/0xfe07, {.d_i32 = nport}}, {_SLIT0, 0, { .d_c = 0 }}})), method, path);
			if (_t4.is_error) {
				IError err = _t4.err;
				if (i == (int)(req->max_retries - 1) || net__http__is_no_need_retry_error(IError_name_table[err._typ]._method_code(err._object))) {
					return (_result_net__http__Response){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				continue;
			}
			
 			net__http__Response res =  (*(net__http__Response*)_t4.data);
			_result_net__http__Response _t6;
			_result_ok(&(net__http__Response[]) { res }, (_result*)(&_t6), sizeof(net__http__Response));
			return _t6;
		}
	} else if (req->proxy != ((void*)0)) {
		for (int i = 0; i < req->max_retries; ++i) {
			_result_net__http__Response _t7 = net__http__HttpProxy_http_do(req->proxy, url, method, path, req);
			if (_t7.is_error) {
				IError err = _t7.err;
				if (i == (int)(req->max_retries - 1) || net__http__is_no_need_retry_error(IError_name_table[err._typ]._method_code(err._object))) {
					return (_result_net__http__Response){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				continue;
			}
			
 			net__http__Response res =  (*(net__http__Response*)_t7.data);
			_result_net__http__Response _t9;
			_result_ok(&(net__http__Response[]) { res }, (_result*)(&_t9), sizeof(net__http__Response));
			return _t9;
		}
	}
	return (_result_net__http__Response){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("http.request.method_and_url_to_response: unsupported scheme: \""), /*115 &string*/0xfe10, {.d_s = scheme}}, {_SLIT("\""), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL string net__http__Request_build_request_headers(net__http__Request* req, net__http__Method method, string host_name, string path) {
	string ua = req->user_agent;
	Array_string uheaders = __new_array_with_default(0, 0, sizeof(string), 0);
	if (!net__http__Header_contains(req->header, net__http__CommonHeader__host)) {
		array_push((array*)&uheaders, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Host: "), /*115 &string*/0xfe10, {.d_s = host_name}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}}))) }));
	}
	if (!net__http__Header_contains(req->header, net__http__CommonHeader__user_agent)) {
		array_push((array*)&uheaders, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("User-Agent: "), /*115 &string*/0xfe10, {.d_s = ua}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}}))) }));
	}
	if (req->data.len > 0 && !net__http__Header_contains(req->header, net__http__CommonHeader__content_length)) {
		array_push((array*)&uheaders, _MOV((string[]){ string_clone( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Content-Length: "), /*100 &int*/0xfe07, {.d_i32 = req->data.len}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}}))) }));
	}
	Array_string _t4 = net__http__Header_keys(req->header);
	for (int _t5 = 0; _t5 < _t4.len; ++_t5) {
		string key = ((string*)_t4.data)[_t5];
		if (string__eq(key, net__http__CommonHeader_str(net__http__CommonHeader__cookie))) {
			continue;
		}
		string val = Array_string_join(net__http__Header_custom_values(req->header, key, ((net__http__HeaderQueryConfig){.exact = 0,})), _SLIT("; "));
		array_push((array*)&uheaders, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = key}}, {_SLIT(": "), /*115 &string*/0xfe10, {.d_s = val}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}}))) }));
	}
	array_push((array*)&uheaders, _MOV((string[]){ string_clone(net__http__Request_build_request_cookies_header(req)) }));
	net__http__Version version = (req->version == net__http__Version__unknown ? (net__http__Version__v1_1) : (req->version));
	string _t8 = string__plus(string__plus(string__plus( str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*115 &net.http.Method*/0xfe10, {.d_s = net__http__Method_str(method)}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = path}}, {_SLIT(" "), /*115 &net.http.Version*/0xfe10, {.d_s = net__http__Version_str(version)}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}})), Array_string_join(uheaders, _SLIT(""))), _SLIT("Connection: close\r\n\r\n")), req->data);
	return _t8;
}

VV_LOCAL_SYMBOL string net__http__Request_build_request_cookies_header(net__http__Request* req) {
	if (map_keys(&req->cookies).len < 1) {
		string _t1 = _SLIT("");
		return _t1;
	}
	Array_string cookie = __new_array_with_default(0, 0, sizeof(string), 0);
	Map_string_string _t2 = req->cookies;
	int _t4 = _t2.key_values.len;
	for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
		int _t5 = _t2.key_values.len - _t4;
		_t4 = _t2.key_values.len;
		if (_t5 < 0) {
			_t3 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t2.key_values, _t3)) {continue;}
		string key = /*key*/ *(string*)DenseArray_key(&_t2.key_values, _t3);
		key = string_clone(key);
		string val = (*(string*)DenseArray_value(&_t2.key_values, _t3));
		array_push((array*)&cookie, _MOV((string[]){ string_clone( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = key}}, {_SLIT("="), /*115 &string*/0xfe10, {.d_s = val}}, {_SLIT0, 0, { .d_c = 0 }}}))) }));
	}
	_PUSH_MANY(&cookie, (net__http__Header_values(req->header, net__http__CommonHeader__cookie)), _t7, Array_string);
	string _t8 = string__plus(string__plus(_SLIT("Cookie: "), Array_string_join(cookie, _SLIT("; "))), _SLIT("\r\n"));
	return _t8;
}

VV_LOCAL_SYMBOL _result_net__http__Response net__http__Request_http_do(net__http__Request* req, string host, net__http__Method method, string path) {
	_result_multi_return_string_u16 _t1 = net__split_address(host);
	if (_t1.is_error) {
		_result_net__http__Response _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_string_u16 mr_6851 =  (*(multi_return_string_u16*)_t1.data);
	string host_name = mr_6851.arg0;
	string s = net__http__Request_build_request_headers(req, method, host_name, path);
	_result_net__TcpConn_ptr _t3 = net__dial_tcp(host);
	if (_t3.is_error) {
		_result_net__http__Response _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	net__TcpConn* client =  (*(net__TcpConn**)_t3.data);
	net__TcpConn_set_read_timeout(client, req->read_timeout);
	net__TcpConn_set_write_timeout(client, req->write_timeout);
	_result_int _t5 = net__TcpConn_write(client, string_bytes(s));
	if (_t5.is_error) {
		_result_net__http__Response _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
  (*(int*)_t5.data);
	_result_Array_u8 _t7 = net__http__Request_read_all_from_client_connection(req, client);
	if (_t7.is_error) {
		_result_net__http__Response _t8;
		memcpy(&_t8, &_t7, sizeof(_result));
		return _t8;
	}
	
 	Array_u8 bytes =  (*(Array_u8*)_t7.data);
	_result_void _t9 = net__TcpConn_close(client);
	if (_t9.is_error) {
		_result_net__http__Response _t10;
		memcpy(&_t10, &_t9, sizeof(_result));
		return _t10;
	}
	
 ;
	string response_text = Array_u8_bytestr(bytes);
	if (req->on_finish != (voidptr)((void*)0)) {
		_result_void _t11 = req->on_finish(req, ((u64)(response_text.len)));
		if (_t11.is_error) {
			_result_net__http__Response _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 ;
	}
	_result_net__http__Response _t13 = net__http__parse_response(response_text);
	return _t13;
}

VV_LOCAL_SYMBOL _result_Array_u8 net__http__Request_read_all_from_client_connection(net__http__Request* req, net__TcpConn* r) {
	i64 read = ((i64)(0));
	Array_u8 b = __new_array_with_default_noscan(32768, 0, sizeof(u8), 0);
	for (;;) {
		i64 old_read = read;
		_result_int _t1 = net__TcpConn_read(/*rec*/*r, &/*111*/(array[]){array_slice(b, read, 2147483647)}[0]);
		if (_t1.is_error) {
			IError err = _t1.err;
			break;
		}
		
 		int new_read =  (*(int*)_t1.data);
		if (new_read <= 0) {
			break;
		}
		read += new_read;
		if (req->on_progress != (voidptr)((void*)0)) {
			_result_void _t2 = req->on_progress(req, array_slice(b, old_read, read), ((u64)(read)));
			if (_t2.is_error) {
				_result_Array_u8 _t3;
				memcpy(&_t3, &_t2, sizeof(_result));
				return _t3;
			}
			
 ;
		}
		for (;;) {
			if (!(b.len <= read)) break;
			array_grow_len_noscan(&b, 4096);
		}
	}
	_result_Array_u8 _t4;
	_result_ok(&(Array_u8[]) { array_slice(b, 0, read) }, (_result*)(&_t4), sizeof(Array_u8));
	return _t4;
}

string net__http__Request_referer(net__http__Request* req) {
	_result_string _t2 = net__http__Header_get(req->header, net__http__CommonHeader__referer);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(string*) _t2.data = _SLIT("");
	}
	
 	string _t1 =  (*(string*)_t2.data);
	return _t1;
}

_result_net__http__Request net__http__parse_request(io__BufferedReader* reader) {
	_result_net__http__Request _t1 = net__http__parse_request_head(reader);
	if (_t1.is_error) {
		_result_net__http__Request _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__http__Request request =  (*(net__http__Request*)_t1.data);
	Array_u8 body = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	_result_string _t3;
	if (_t3 = net__http__Header_get(request.header, net__http__CommonHeader__content_length), !_t3.is_error) {
		string length = *(string*)_t3.data;
		int n = string_int(length);
		if (n > 0) {
			body = __new_array_with_default_noscan(n, 0, sizeof(u8), 0);
			int count = 0;
			for (;;) {
				if (!(count < body.len)) break;
				_result_int _t4 = io__BufferedReader_read(reader, &/*111*/(array[]){array_slice(body, count, 2147483647)}[0]);
				if (_t4.is_error) {
					IError err = _t4.err;
					break;
				}
				
 				count +=  (*(int*)_t4.data);
			}
		}
	}
	request.data = Array_u8_bytestr(body);
	_result_net__http__Request _t5;
	_result_ok(&(net__http__Request[]) { request }, (_result*)(&_t5), sizeof(net__http__Request));
	return _t5;
}

_result_net__http__Request net__http__parse_request_head(io__BufferedReader* reader) {
	_result_string _t1 = io__BufferedReader_read_line(reader);
	if (_t1.is_error) {
		_result_net__http__Request _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string line =  (*(string*)_t1.data);
	_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version _t3 = net__http__parse_request_line(line);
	if (_t3.is_error) {
		_result_net__http__Request _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	multi_return_net__http__Method_net__urllib__URL_net__http__Version mr_8846 =  (*(multi_return_net__http__Method_net__urllib__URL_net__http__Version*)_t3.data);
	net__http__Method method = mr_8846.arg0;
	net__urllib__URL target = mr_8846.arg1;
	net__http__Version version = mr_8846.arg2;
	net__http__Header header = net__http__new_header(__new_array(0, 0, sizeof(net__http__HeaderConfig)));
	_result_string _t5 = io__BufferedReader_read_line(reader);
	if (_t5.is_error) {
		_result_net__http__Request _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 	line =  (*(string*)_t5.data);
	for (;;) {
		if (!((line).len != 0)) break;
		_result_int _t7 = net__http__parse_header_fast(line);
		if (_t7.is_error) {
			_result_net__http__Request _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 		int pos =  (*(int*)_t7.data);
		string key = string_substr_unsafe(line, 0, pos);
		for (;;) {
			if (!(pos < (int)(line.len - 1) && u8_is_space(string_at(line, (int)(pos + 1))))) break;
			if (u8_is_space(string_at(line, (int)(pos + 1)))) {
				pos++;
			}
		}
		string value = string_substr_unsafe(line, (int)(pos + 1), line.len);
		{string _ = key;}
		;
		{string _ = value;}
		;
		_result_void _t9 = net__http__Header_add_custom(&header, key, value);
		if (_t9.is_error) {
			_result_net__http__Request _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 ;
		_result_string _t11 = io__BufferedReader_read_line(reader);
		if (_t11.is_error) {
			_result_net__http__Request _t12;
			memcpy(&_t12, &_t11, sizeof(_result));
			return _t12;
		}
		
 		line =  (*(string*)_t11.data);
	}
	Map_string_string request_cookies = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	Array_net__http__Cookie_ptr _t13 = net__http__read_cookies(header, _SLIT(""));
	for (int _t14 = 0; _t14 < _t13.len; ++_t14) {
		net__http__Cookie* cookie = ((net__http__Cookie**)_t13.data)[_t14];
		map_set(&request_cookies, &(string[]){cookie->name}, &(string[]) { cookie->value });
	}
		_result_string _t16 = net__http__Header_get(header, net__http__CommonHeader__host);
		if (_t16.is_error) {
			IError err = _t16.err;
			*(string*) _t16.data = _SLIT("");
		}
		
 	_result_net__http__Request _t15;
	_result_ok(&(net__http__Request[]) { ((net__http__Request){
		.version = version,
		.method = method,
		.header = header,
		.host =  (*(string*)_t16.data),
		.cookies = request_cookies,
		.data = (string){.str=(byteptr)"", .is_lit=1},
		.url = net__urllib__URL_str(&target),
		.user_agent = _SLIT("v.http"),
		.verbose = 0,
		.user_ptr = 0,
		.proxy = ((void*)0),
		.read_timeout = 30 * _const_time__second,
		.write_timeout = 30 * _const_time__second,
		.validate = 0,
		.verify = (string){.str=(byteptr)"", .is_lit=1},
		.cert = (string){.str=(byteptr)"", .is_lit=1},
		.cert_key = (string){.str=(byteptr)"", .is_lit=1},
		.in_memory_verification = 0,
		.allow_redirect = true,
		.max_retries = 5,
		.on_redirect = ((void*)0),
		.on_progress = ((void*)0),
		.on_finish = ((void*)0),
	}) }, (_result*)(&_t15), sizeof(net__http__Request));
	return _t15;
}

VV_LOCAL_SYMBOL _result_multi_return_net__http__Method_net__urllib__URL_net__http__Version net__http__parse_request_line(string s) {
	multi_return_int_int mr_9882 = net__http__fast_request_words(s);
	int space1 = mr_9882.arg0;
	int space2 = mr_9882.arg1;
	if (space1 == 0 || space2 == 0) {
		return (_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version){ .is_error=true, .err=_v_error(_SLIT("malformed request line")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string method_str = string_substr_unsafe(s, 0, space1);
	string target_str = string_substr_unsafe(s, (int)(space1 + 1), space2);
	string version_str = string_substr_unsafe(s, (int)(space2 + 1), s.len);
	net__http__Method method = net__http__method_from_str(method_str);
	_result_net__urllib__URL _t2 = net__urllib__parse(target_str);
	if (_t2.is_error) {
		_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	net__urllib__URL target =  (*(net__urllib__URL*)_t2.data);
	net__http__Version version = net__http__version_from_str(version_str);
	if (version == net__http__Version__unknown) {
		return (_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version){ .is_error=true, .err=_v_error(_SLIT("unsupported version")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_result_multi_return_net__http__Method_net__urllib__URL_net__http__Version _t5;
	_result_ok(&(multi_return_net__http__Method_net__urllib__URL_net__http__Version[]) { (multi_return_net__http__Method_net__urllib__URL_net__http__Version){.arg0=method, .arg1=target, .arg2=version} }, (_result*)(&_t5), sizeof(multi_return_net__http__Method_net__urllib__URL_net__http__Version));
	return _t5;
}

Map_string_string net__http__parse_form(string body) {
	Map_string_string form = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	if (string_match_glob(body, _SLIT("{*}"))) {
		map_set(&form, &(string[]){_SLIT("json")}, &(string[]) { body });
	} else {
		Array_string words = string_split(body, _SLIT("&"));
		for (int _t1 = 0; _t1 < words.len; ++_t1) {
			string word = ((string*)words.data)[_t1];
			Array_string kv = string_split_nth(word, _SLIT("="), 2);
			if (kv.len != 2) {
				continue;
			}
			_result_string _t2 = net__urllib__query_unescape((*(string*)array_get(kv, 0)));
			if (_t2.is_error) {
				IError err = _t2.err;
				continue;
			}
			
 			string key =  (*(string*)_t2.data);
			_result_string _t3 = net__urllib__query_unescape((*(string*)array_get(kv, 1)));
			if (_t3.is_error) {
				IError err = _t3.err;
				continue;
			}
			
 			string val =  (*(string*)_t3.data);
			map_set(&form, &(string[]){key}, &(string[]) { val });
		}
	}
	return form;
}

string net__http__UnexpectedExtraAttributeError_msg(net__http__UnexpectedExtraAttributeError err) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Encountered unexpected extra attributes: "), /*115 &[]string*/0xfe10, {.d_s = Array_string_str(err.attributes)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

string net__http__MultiplePathAttributesError_msg(net__http__MultiplePathAttributesError err) {
	string _t1 = _SLIT("Expected at most one path attribute");
	return _t1;
}

VV_LOCAL_SYMBOL multi_return_string_string net__http__multipart_form_body(Map_string_string form, Map_string_Array_net__http__FileData files) {
	string rboundary = rand__ulid();
	strings__Builder sb = strings__new_builder(1024);
	int _t2 = form.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = form.key_values.len - _t2;
		_t2 = form.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&form.key_values, _t1)) {continue;}
		string name = /*key*/ *(string*)DenseArray_key(&form.key_values, _t1);
		name = string_clone(name);
		string value = (*(string*)DenseArray_value(&form.key_values, _t1));
		strings__Builder_write_string(&sb, _SLIT("\r\n--"));
		strings__Builder_write_string(&sb, rboundary);
		strings__Builder_write_string(&sb, _SLIT("\r\nContent-Disposition: form-data; name=\""));
		strings__Builder_write_string(&sb, name);
		strings__Builder_write_string(&sb, _SLIT("\"\r\n\r\n"));
		strings__Builder_write_string(&sb, value);
	}
	int _t5 = files.key_values.len;
	for (int _t4 = 0; _t4 < _t5; ++_t4 ) {
		int _t6 = files.key_values.len - _t5;
		_t5 = files.key_values.len;
		if (_t6 < 0) {
			_t4 = -1;
			continue;
		}
		if (!DenseArray_has_index(&files.key_values, _t4)) {continue;}
		string name = /*key*/ *(string*)DenseArray_key(&files.key_values, _t4);
		name = string_clone(name);
		Array_net__http__FileData fs = (*(Array_net__http__FileData*)DenseArray_value(&files.key_values, _t4));
		for (int _t7 = 0; _t7 < fs.len; ++_t7) {
			net__http__FileData f = ((net__http__FileData*)fs.data)[_t7];
			strings__Builder_write_string(&sb, _SLIT("\r\n--"));
			strings__Builder_write_string(&sb, rboundary);
			strings__Builder_write_string(&sb, _SLIT("\r\nContent-Disposition: form-data; name=\""));
			strings__Builder_write_string(&sb, name);
			strings__Builder_write_string(&sb, _SLIT("\"; filename=\""));
			strings__Builder_write_string(&sb, f.filename);
			strings__Builder_write_string(&sb, _SLIT("\"\r\nContent-Type: "));
			strings__Builder_write_string(&sb, f.content_type);
			strings__Builder_write_string(&sb, _SLIT("\r\n\r\n"));
			strings__Builder_write_string(&sb, f.data);
		}
	}
	strings__Builder_write_string(&sb, _SLIT("\r\n--"));
	strings__Builder_write_string(&sb, rboundary);
	strings__Builder_write_string(&sb, _SLIT("--"));
	return (multi_return_string_string){.arg0=strings__Builder_str(&sb), .arg1=rboundary};
}

multi_return_Map_string_string_Map_string_Array_net__http__FileData net__http__parse_multipart_form(string body, string boundary) {
	Map_string_string form = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	Map_string_Array_net__http__FileData files = new_map(sizeof(string), sizeof(Array_net__http__FileData), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	Array_string sections = string_split(body, boundary);
	Array_string fields = array_slice(sections, 1, (int)(sections.len - 1));
	for (int _t1 = 0; _t1 < fields.len; ++_t1) {
		string field = ((string*)fields.data)[_t1];
		Array_net__http__LineSegmentIndexes line_segments = __new_array_with_default_noscan(0, 100, sizeof(net__http__LineSegmentIndexes), 0);
		int line_idx = 0;
		int line_start = 0;
		for (int cidx = 0; cidx < field.len; ++cidx) {
			u8 c = field.str[cidx];
			if (line_idx >= 6) {
				break;
			}
			if (c == '\n') {
				array_push_noscan((array*)&line_segments, _MOV((net__http__LineSegmentIndexes[]){ ((net__http__LineSegmentIndexes){.start = line_start,.end = cidx,}) }));
				line_start = (int)(cidx + 1);
				line_idx++;
			}
		}
		array_push_noscan((array*)&line_segments, _MOV((net__http__LineSegmentIndexes[]){ ((net__http__LineSegmentIndexes){.start = line_start,.end = field.len,}) }));
		string line1 = string_substr(field, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 1)).start, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 1)).end);
		string line2 = string_substr(field, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 2)).start, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 2)).end);
		Map_string_string disposition = net__http__parse_disposition(string_trim_space(line1));
		string* _t5 = (string*)(map_get_check(ADDR(map, disposition), &(string[]){_SLIT("name")}));
		_option_string _t4 = {0};
		if (_t5) {
			*((string*)&_t4.data) = *((string*)_t5);
		} else {
			_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t4.state != 0) {
			IError err = _t4.err;
			continue;
		}
		
		string name = (*(string*)_t4.data);
		string* _t7 = (string*)(map_get_check(ADDR(map, disposition), &(string[]){_SLIT("filename")}));
		_option_string _t6 = {0};
		if (_t7) {
			*((string*)&_t6.data) = *((string*)_t7);
		} else {
			_t6.state = 2; _t6.err = _v_error(_SLIT("array index out of range"));
		}
		
		if (_t6.state == 0) {
			string filename = (*(string*)_t6.data);
			if (line_segments.len < 5) {
				continue;
			}
			if (!string_starts_with(string_to_lower(line2), _SLIT("content-type:"))) {
				continue;
			}
			string content_type = string_trim_space((*(string*)array_get(string_split_nth(line2, _SLIT(":"), 2), 1)));
			string data = string_substr(field, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 4)).start, (int)(field.len - 4));
			array_push((array*)&(*(Array_net__http__FileData*)map_get_and_set((map*)&files, &(string[]){name}, &(Array_net__http__FileData[]){ __new_array(0, 0, sizeof(net__http__FileData)) })), _MOV((net__http__FileData[]){ ((net__http__FileData){.filename = filename,.content_type = content_type,.data = data,}) }));
			continue;
		}
		if (line_segments.len < 4) {
			continue;
		}
		map_set(&form, &(string[]){name}, &(string[]) { string_substr(field, (*(net__http__LineSegmentIndexes*)array_get(line_segments, 3)).start, (int)(field.len - 4)) });
	}
	return (multi_return_Map_string_string_Map_string_Array_net__http__FileData){.arg0=form, .arg1=files};
}

VV_LOCAL_SYMBOL Map_string_string net__http__parse_disposition(string line) {
	Map_string_string data = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	Array_string _t1 = string_split(line, _SLIT(";"));
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string word = ((string*)_t1.data)[_t2];
		Array_string kv = string_split_nth(word, _SLIT("="), 2);
		if (kv.len != 2) {
			continue;
		}
		string key = string_trim_left(string_to_lower((*(string*)array_get(kv, 0))), _SLIT(" \t"));
		string value = (*(string*)array_get(kv, 1));
		if (string_starts_with(value, _SLIT("\"")) && string_ends_with(value, _SLIT("\""))) {
			map_set(&data, &(string[]){key}, &(string[]) { string_substr(value, 1, (int)(value.len - 1)) });
		} else {
			map_set(&data, &(string[]){key}, &(string[]) { value });
		}
	}
	return data;
}

VV_LOCAL_SYMBOL bool net__http__is_no_need_retry_error(int err_code) {
	bool _t1 = (err_code == IError_name_table[_const_net__err_port_out_of_range._typ]._method_code(_const_net__err_port_out_of_range._object) || err_code == IError_name_table[_const_net__err_no_udp_remote._typ]._method_code(_const_net__err_no_udp_remote._object) || err_code == IError_name_table[_const_net__err_connect_timed_out._typ]._method_code(_const_net__err_connect_timed_out._object) || err_code == _const_net__err_timed_out_code);
	return _t1;
}

VV_LOCAL_SYMBOL void net__http__Response_free(net__http__Response* resp) {
	net__http__Header_free(&resp->header);
}

Array_u8 net__http__Response_bytes(net__http__Response resp) {
	Array_u8 _t1 = string_bytes(net__http__Response_bytestr(resp));
	return _t1;
}

string net__http__Response_bytestr(net__http__Response resp) {
	string _t1 = string__plus(string__plus( str_intp(4, _MOV((StrIntpData[]){{_SLIT("HTTP/"), /*115 &string*/0xfe10, {.d_s = resp.http_version}}, {_SLIT(" "), /*100 &int*/0xfe07, {.d_i32 = resp.status_code}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = resp.status_msg}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}})),  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = net__http__Header_render(resp.header, ((net__http__HeaderRenderConfig){.version = net__http__Response_version(resp),.coerce = 0,.canonicalize = 0,}))}}, {_SLIT("\r\n"), 0, { .d_c = 0 }}}))), resp.body);
	return _t1;
}

_result_net__http__Response net__http__parse_response(string resp) {
	_result_multi_return_string_int_string _t1 = net__http__parse_status_line(string_all_before(resp, _SLIT("\r\n")));
	if (_t1.is_error) {
		_result_net__http__Response _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_string_int_string mr_1065 =  (*(multi_return_string_int_string*)_t1.data);
	string version = mr_1065.arg0;
	int status_code = mr_1065.arg1;
	string status_msg = mr_1065.arg2;
	_result_multi_return_int_int _t3 = net__http__find_headers_range(resp);
	if (_t3.is_error) {
		_result_net__http__Response _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	multi_return_int_int mr_1180 =  (*(multi_return_int_int*)_t3.data);
	int start_idx = mr_1180.arg0;
	int end_idx = mr_1180.arg1;
	_result_net__http__Header _t5 = net__http__parse_headers(string_substr(resp, start_idx, end_idx));
	if (_t5.is_error) {
		_result_net__http__Response _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 	net__http__Header header =  (*(net__http__Header*)_t5.data);
	string body = string_substr(resp, end_idx, resp.len);
	_result_string _t7 = net__http__Header_get(header, net__http__CommonHeader__transfer_encoding);
	if (_t7.is_error) {
		IError err = _t7.err;
		*(string*) _t7.data = _SLIT("");
	}
	
 	if (string__eq( (*(string*)_t7.data), _SLIT("chunked"))) {
		_result_string _t8 = net__http__chunked__decode(body);
		if (_t8.is_error) {
			_result_net__http__Response _t9;
			memcpy(&_t9, &_t8, sizeof(_result));
			return _t9;
		}
		
 		body =  (*(string*)_t8.data);
	}
	_result_net__http__Response _t10;
	_result_ok(&(net__http__Response[]) { ((net__http__Response){.body = body,.header = header,.status_code = status_code,.status_msg = status_msg,.http_version = version,}) }, (_result*)(&_t10), sizeof(net__http__Response));
	return _t10;
}

VV_LOCAL_SYMBOL _result_multi_return_string_int_string net__http__parse_status_line(string line) {
	if (line.len < 5 || !string__eq(string_to_lower(string_substr(line, 0, 5)), _SLIT("http/"))) {
		return (_result_multi_return_string_int_string){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("response does not start with HTTP/, line: `"), /*115 &string*/0xfe10, {.d_s = line}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	Array_string data = string_split_nth(line, _SLIT(" "), 3);
	if (data.len != 3) {
		return (_result_multi_return_string_int_string){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected at least 3 tokens, but found: "), /*100 &int*/0xfe07, {.d_i32 = data.len}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string version = string_substr((*(string*)array_get(data, 0)), 5, (*(string*)array_get(data, 0)).len);
	Array_string digits = string_split_nth(version, _SLIT("."), 3);
	if (digits.len != 2) {
		return (_result_multi_return_string_int_string){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("HTTP version malformed, found: `"), /*115 &[]string*/0xfe10, {.d_s = Array_string_str(digits)}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	for (int _t4 = 0; _t4 < digits.len; ++_t4) {
		string digit = ((string*)digits.data)[_t4];
		_result_int _t5 = strconv__atoi(digit);
		if (_t5.is_error) {
			IError err = _t5.err;
			return (_result_multi_return_string_int_string){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("HTTP version must contain only integers, found: `"), /*115 &string*/0xfe10, {.d_s = digit}}, {_SLIT("`"), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
  (*(int*)_t5.data);
	}
	_result_int _t8 = strconv__atoi((*(string*)array_get(data, 1)));
	if (_t8.is_error) {
		_result_multi_return_string_int_string _t9;
		memcpy(&_t9, &_t8, sizeof(_result));
		return _t9;
	}
	
 	_result_multi_return_string_int_string _t7;
	_result_ok(&(multi_return_string_int_string[]) { (multi_return_string_int_string){.arg0=version, .arg1= (*(int*)_t8.data), .arg2=(*(string*)array_get(data, 2))} }, (_result*)(&_t7), sizeof(multi_return_string_int_string));
	return _t7;
}

Array_net__http__Cookie net__http__Response_cookies(net__http__Response r) {
	Array_net__http__Cookie cookies = __new_array_with_default(0, 0, sizeof(net__http__Cookie), 0);
	Array_string _t1 = net__http__Header_values(r.header, net__http__CommonHeader__set_cookie);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string cookie = ((string*)_t1.data)[_t2];
		_result_net__http__Cookie _t4 = net__http__parse_cookie(cookie);
		if (_t4.is_error) {
			IError err = _t4.err;
			continue;
		}
		
 		array_push((array*)&cookies, _MOV((net__http__Cookie[]){  (*(net__http__Cookie*)_t4.data) }));
	}
	return cookies;
}

net__http__Status net__http__Response_status(net__http__Response r) {
	net__http__Status _t1 = net__http__status_from_int(r.status_code);
	return _t1;
}

void net__http__Response_set_status(net__http__Response* r, net__http__Status s) {
	r->status_code = net__http__Status_int(s);
	r->status_msg = net__http__Status_str(s);
}

net__http__Version net__http__Response_version(net__http__Response r) {
	net__http__Version _t1 = ((string__eq(r.http_version, _SLIT("1.0")))? (net__http__Version__v1_0) : (string__eq(r.http_version, _SLIT("1.1")))? (net__http__Version__v1_1) : (string__eq(r.http_version, _SLIT("2.0")))? (net__http__Version__v2_0) : (net__http__Version__unknown));
	return _t1;
}

void net__http__Response_set_version(net__http__Response* r, net__http__Version v) {
	if (v == net__http__Version__unknown) {
		r->http_version = _SLIT("");
		return;
	}
	multi_return_int_int mr_3257 = net__http__Version_protos(v);
	int maj = mr_3257.arg0;
	int min = mr_3257.arg1;
	r->http_version =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = maj}}, {_SLIT("."), /*100 &int*/0xfe07, {.d_i32 = min}}, {_SLIT0, 0, { .d_c = 0 }}}));
}

net__http__Response net__http__new_response(net__http__ResponseConfig conf) {
	net__http__Response resp = ((net__http__Response){.body = conf.body,.header = conf.header,.status_code = 0,.status_msg = (string){.str=(byteptr)"", .is_lit=1},.http_version = (string){.str=(byteptr)"", .is_lit=1},});
	if (resp.body.len > 0 && !net__http__Header_contains(resp.header, net__http__CommonHeader__content_length)) {
		net__http__Header_add(&resp.header, net__http__CommonHeader__content_length, int_str(resp.body.len));
	}
	net__http__Response_set_status(&resp, conf.status);
	net__http__Response_set_version(&resp, conf.version);
	return resp;
}

VV_LOCAL_SYMBOL _result_multi_return_int_int net__http__find_headers_range(string data) {
	_option_int _t1 = string_index(data, _SLIT("\n"));
	if (_t1.state != 0) {
		IError err = _t1.err;
		return (_result_multi_return_int_int){ .is_error=true, .err=_v_error(_SLIT("no start index found")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
 	int start_idx = (int)( (*(int*)_t1.data) + 1);
	int count = 0;
	for (int i = start_idx; i < data.len; i++) {
		if (string_at(data, i) == '\n') {
			count++;
		} else if (string_at(data, i) != '\r') {
			count = 0;
		}
		if (count == 2) {
			_result_multi_return_int_int _t3;
			_result_ok(&(multi_return_int_int[]) { (multi_return_int_int){.arg0=start_idx, .arg1=(int)(i + 1)} }, (_result*)(&_t3), sizeof(multi_return_int_int));
			return _t3;
		}
	}
	return (_result_multi_return_int_int){ .is_error=true, .err=_v_error(_SLIT("no end index found")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

void net__http__Server_listen_and_serve(net__http__Server* s) {
	if ((s->handler)._typ == _net__http__Handler_net__http__DebugHandler_index) {
		eprintln(_SLIT("Server handler not set, using debug handler"));
	}
	Array_string addr = string_split(s->addr, _SLIT(":"));
	if (addr.len > 1 && s->port != 8080) {
		s->addr =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = (*(string*)array_get(addr, 0))}}, {_SLIT(":"), /*100 &int*/0xfe07, {.d_i32 = s->port}}, {_SLIT0, 0, { .d_c = 0 }}}));
	}
	_result_net__Addr _t1 = net__TcpListener_addr(&s->listener);
	if (_t1.is_error) {
		IError err = _t1.err;
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed getting listener address, err: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		return;
	}
	
 	net__Addr l =  (*(net__Addr*)_t1.data);
	string listening_address = string_clone(s->addr);
	if (net__Addr_family(l) == net__AddrFamily__unspec) {
		if (string__eq(listening_address, _SLIT(":0"))) {
			listening_address = _SLIT("localhost:0");
		}
		net__AddrFamily listen_family = net__AddrFamily__ip;
		_result_net__TcpListener_ptr _t2 = net__listen_tcp(listen_family, listening_address, ((net__ListenOptions){.dualstack = true,.backlog = 128,}));
		if (_t2.is_error) {
			IError err = _t2.err;
			eprintln( str_intp(3, _MOV((StrIntpData[]){{_SLIT("Listening on "), /*115 &string*/0xfe10, {.d_s = s->addr}}, {_SLIT(" failed, err: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			return;
		}
		
 		s->listener = * (*(net__TcpListener**)_t2.data);
		_result_net__Addr _t3 = net__TcpListener_addr(&s->listener);
		if (_t3.is_error) {
			IError err = _t3.err;
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Failed getting listener address 2, err: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			return;
		}
		
 		l =  (*(net__Addr*)_t3.data);
	}
	s->addr = net__Addr_str(l);
	net__TcpListener_set_accept_timeout(&s->listener, s->accept_timeout);
	chan_net__TcpConn_ptr ch = sync__new_channel_st(s->pool_channel_slots, sizeof(net__TcpConn*)>0 ? sizeof(net__TcpConn*) : 1);
	Array___v_thread ws = __new_array_with_default(0, s->worker_num, sizeof(__v_thread), 0);
	for (int wid = 0; wid < s->worker_num; ++wid) {
		array_push((array*)&ws, _MOV((__v_thread[]){ net__http__new_handler_worker(wid, ch, s->handler) }));
	}
	if (s->show_startup_message) {
		println( str_intp(2, _MOV((StrIntpData[]){{_SLIT("Listening on http://"), /*115 &string*/0xfe10, {.d_s = s->addr}}, {_SLIT("/"), 0, { .d_c = 0 }}})));
		flush_stdout();
	}
	time__sleep(20 * _const_time__millisecond);
	s->state = net__http__ServerStatus__running;
	if (s->on_running != (voidptr)((void*)0)) {
		s->on_running(s);
	}
	for (;;) {
		if (s->state != net__http__ServerStatus__running) {
			break;
		}
		_result_net__TcpConn_ptr _t5 = net__TcpListener_accept(&s->listener);
		if (_t5.is_error) {
			IError err = _t5.err;
			if (IError_name_table[err._typ]._method_code(err._object) == _const_net__err_timed_out_code) {
				continue;
			}
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("accept() failed, reason: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT("; skipping"), 0, { .d_c = 0 }}})));
			continue;
		}
		
 		net__TcpConn* conn =  (*(net__TcpConn**)_t5.data);
		net__TcpConn_set_read_timeout(conn, s->read_timeout);
		net__TcpConn_set_write_timeout(conn, s->write_timeout);
		__chan_net__TcpConn_ptr_pushval(ch, conn);
	}
	if (s->state == net__http__ServerStatus__stopped) {
		net__http__Server_close(s);
	}
}

// Attr: [inline]
inline void net__http__Server_stop(net__http__Server* s) {
	s->state = net__http__ServerStatus__stopped;
	if (s->on_stopped != (voidptr)((void*)0)) {
		s->on_stopped(s);
	}
}

// Attr: [inline]
inline void net__http__Server_close(net__http__Server* s) {
	s->state = net__http__ServerStatus__closed;
	_result_void _t1 = net__TcpListener_close(&s->listener);
	if (_t1.is_error) {
		IError err = _t1.err;
		return;
	}
	
 ;
	if (s->on_closed != (voidptr)((void*)0)) {
		s->on_closed(s);
	}
}

// Attr: [inline]
inline net__http__ServerStatus net__http__Server_status(net__http__Server* s) {
	net__http__ServerStatus _t1 = s->state;
	return _t1;
}

_result_int net__http__Server_wait_till_running(net__http__Server* s, net__http__WaitTillRunningParams params) {
	int i = 0;
	for (;;) {
		if (!(net__http__Server_status(s) != net__http__ServerStatus__running && i < params.max_retries)) break;
		time__sleep(params.retry_period_ms * _const_time__millisecond);
		i++;
	}
	if (i >= params.max_retries) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("maximum retries reached")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	time__sleep(params.retry_period_ms);
	_result_int _t2;
	_result_ok(&(int[]) { i }, (_result*)(&_t2), sizeof(int));
	return _t2;
}

VV_LOCAL_SYMBOL __v_thread net__http__new_handler_worker(int wid, chan_net__TcpConn_ptr ch, net__http__Handler handler) {
	net__http__HandlerWorker* w = ((net__http__HandlerWorker*)memdup(&(net__http__HandlerWorker){.id = wid,.ch = ch,.handler = handler,}, sizeof(net__http__HandlerWorker)));
	// start go
	thread_arg_net__http__HandlerWorker_process_requests *arg__t2 = (thread_arg_net__http__HandlerWorker_process_requests *) _v_malloc(sizeof(thread_arg_net__http__HandlerWorker_process_requests));
	arg__t2->fn = net__http__HandlerWorker_process_requests;
	arg__t2->arg0 = w;
	HANDLE thread__t2 = CreateThread(0, 8388608, (LPTHREAD_START_ROUTINE)net__http__HandlerWorker_process_requests_thread_wrapper, arg__t2, 0, 0); // fn: process_requests
	if (!thread__t2) panic_lasterr(tos3("`go net__http__HandlerWorker_process_requests()`: "));
	// end go
	__v_thread _t1 = /*spawn (thread) */
thread__t2;
	return _t1;
}

VV_LOCAL_SYMBOL void net__http__HandlerWorker_process_requests(net__http__HandlerWorker* w) {
	for (;;) {
		_option_net__TcpConn_ptr _t1 = __Option_chan_net__TcpConn_ptr_popval(w->ch)/*JJJ*/;
		if (_t1.state != 0) {
			IError err = _t1.err;
			break;
		}
		;
		net__TcpConn* conn = *(net__TcpConn**)_t1.data;
		net__http__HandlerWorker_handle_conn(w, conn);
	}
}

VV_LOCAL_SYMBOL void net__http__HandlerWorker_handle_conn(net__http__HandlerWorker* w, net__TcpConn* conn) {
	bool net__http__HandlerWorker_handle_conn_defer_0 = false;
	bool net__http__HandlerWorker_handle_conn_defer_1 = false;
	io__BufferedReader* reader;
	net__http__HandlerWorker_handle_conn_defer_0 = true;
	reader = io__new_buffered_reader(((io__BufferedReaderConfig){.reader = /*&io.Reader*/I_net__TcpConn_to_Interface_io__Reader(conn),.cap = (int_literal)(128 * 1024),.retries = 2,}));
	net__http__HandlerWorker_handle_conn_defer_1 = true;
	_result_net__http__Request _t1 = net__http__parse_request(reader);
	if (_t1.is_error) {
		IError err = _t1.err;
			// Defer begin
			if (net__http__HandlerWorker_handle_conn_defer_1) {
				io__BufferedReader_free(reader);
			}
			// Defer end
			// Defer begin
			if (net__http__HandlerWorker_handle_conn_defer_0) {
				_result_void _t2 = net__TcpConn_close(conn);
				if (_t2.is_error) {
					IError err = _t2.err;
					eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("close() failed: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				;
				}
				
 ;
			}
			// Defer end
		return;
	}
	
 	net__http__Request req =  (*(net__http__Request*)_t1.data);
	_result_string _t3 = net__TcpConn_peer_ip(conn);
	if (_t3.is_error) {
		IError err = _t3.err;
		*(string*) _t3.data = _SLIT("0.0.0.0");
	}
	
 	string remote_ip =  (*(string*)_t3.data);
	_result_void _t4 = net__http__Header_add_custom(&req.header, _SLIT("Remote-Addr"), remote_ip);
	if (_t4.is_error) {
		IError err = _t4.err;
	}
	
 ;
	net__http__Response resp = net__http__Handler_name_table[w->handler._typ]._method_handle(w->handler._object, req);
	if (net__http__Response_version(resp) == net__http__Version__unknown) {
		net__http__Response_set_version(&resp, req.version);
	}
	if (!net__http__Header_contains(resp.header, net__http__CommonHeader__content_length)) {
		net__http__Header_set(&resp.header, net__http__CommonHeader__content_length,  str_intp(2, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = resp.body.len}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	_result_int _t5 = net__TcpConn_write(conn, net__http__Response_bytes(resp));
	if (_t5.is_error) {
		IError err = _t5.err;
		eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("error sending response: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	;
	}
	
  (*(int*)_t5.data);
	// Defer begin
	if (net__http__HandlerWorker_handle_conn_defer_1) {
		io__BufferedReader_free(reader);
	}
	// Defer end
	// Defer begin
	if (net__http__HandlerWorker_handle_conn_defer_0) {
		_result_void _t6 = net__TcpConn_close(conn);
		if (_t6.is_error) {
			IError err = _t6.err;
			eprintln( str_intp(2, _MOV((StrIntpData[]){{_SLIT("close() failed: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
		;
		}
		
 ;
	}
	// Defer end
}

VV_LOCAL_SYMBOL net__http__Response net__http__DebugHandler_handle(net__http__DebugHandler d, net__http__Request req) {
	#if defined(_VDEBUG)
	{
	}
	#else
	{
		eprintln( str_intp(4, _MOV((StrIntpData[]){{_SLIT("["), /*115 &time.Time*/0xfe10, {.d_s = time__Time_str(time__now())}}, {_SLIT("] "), /*115 &net.http.Method*/0xfe10, {.d_s = net__http__Method_str(req.method)}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = req.url}}, {_SLIT(" - 200"), 0, { .d_c = 0 }}})));
	}
	#endif
	net__http__Response r = ((net__http__Response){.body = req.data,.header = req.header,.status_code = 0,.status_msg = (string){.str=(byteptr)"", .is_lit=1},.http_version = (string){.str=(byteptr)"", .is_lit=1},});
	net__http__Response_set_status(&r, net__http__Status__ok);
	net__http__Response_set_version(&r, req.version);
	return r;
}

net__http__Status net__http__status_from_int(int code) {
	net__http__Status _t1 = ((code == (100))? (net__http__Status__cont) : (code == (101))? (net__http__Status__switching_protocols) : (code == (102))? (net__http__Status__processing) : (code == (103))? (net__http__Status__checkpoint_draft) : ((code >= 104 && code <= 199))? (net__http__Status__unassigned) : (code == (200))? (net__http__Status__ok) : (code == (201))? (net__http__Status__created) : (code == (202))? (net__http__Status__accepted) : (code == (203))? (net__http__Status__non_authoritative_information) : (code == (204))? (net__http__Status__no_content) : (code == (205))? (net__http__Status__reset_content) : (code == (206))? (net__http__Status__partial_content) : (code == (207))? (net__http__Status__multi_status) : (code == (208))? (net__http__Status__already_reported) : ((code >= 209 && code <= 225))? (net__http__Status__unassigned) : (code == (226))? (net__http__Status__im_used) : ((code >= 227 && code <= 299))? (net__http__Status__unassigned) : (code == (300))? (net__http__Status__multiple_choices) : (code == (301))? (net__http__Status__moved_permanently) : (code == (302))? (net__http__Status__found) : (code == (303))? (net__http__Status__see_other) : (code == (304))? (net__http__Status__not_modified) : (code == (305))? (net__http__Status__use_proxy) : (code == (306))? (net__http__Status__switch_proxy) : (code == (307))? (net__http__Status__temporary_redirect) : (code == (308))? (net__http__Status__permanent_redirect) : ((code >= 309 && code <= 399))? (net__http__Status__unassigned) : (code == (400))? (net__http__Status__bad_request) : (code == (401))? (net__http__Status__unauthorized) : (code == (402))? (net__http__Status__payment_required) : (code == (403))? (net__http__Status__forbidden) : (code == (404))? (net__http__Status__not_found) : (code == (405))? (net__http__Status__method_not_allowed) : (code == (406))? (net__http__Status__not_acceptable) : (code == (407))? (net__http__Status__proxy_authentication_required) : (code == (408))? (net__http__Status__request_timeout) : (code == (409))? (net__http__Status__conflict) : (code == (410))? (net__http__Status__gone) : (code == (411))? (net__http__Status__length_required) : (code == (412))? (net__http__Status__precondition_failed) : (code == (413))? (net__http__Status__request_entity_too_large) : (code == (414))? (net__http__Status__request_uri_too_long) : (code == (415))? (net__http__Status__unsupported_media_type) : (code == (416))? (net__http__Status__requested_range_not_satisfiable) : (code == (417))? (net__http__Status__expectation_failed) : (code == (418))? (net__http__Status__im_a_teapot) : ((code >= 419 && code <= 420))? (net__http__Status__unassigned) : (code == (421))? (net__http__Status__misdirected_request) : (code == (422))? (net__http__Status__unprocessable_entity) : (code == (423))? (net__http__Status__locked) : (code == (424))? (net__http__Status__failed_dependency) : (code == (425))? (net__http__Status__unordered_collection) : (code == (426))? (net__http__Status__upgrade_required) : (code == (428))? (net__http__Status__precondition_required) : (code == (429))? (net__http__Status__too_many_requests) : (code == (431))? (net__http__Status__request_header_fields_too_large) : ((code >= 432 && code <= 450))? (net__http__Status__unassigned) : (code == (451))? (net__http__Status__unavailable_for_legal_reasons) : ((code >= 452 && code <= 499))? (net__http__Status__unassigned) : (code == (500))? (net__http__Status__internal_server_error) : (code == (501))? (net__http__Status__not_implemented) : (code == (502))? (net__http__Status__bad_gateway) : (code == (503))? (net__http__Status__service_unavailable) : (code == (504))? (net__http__Status__gateway_timeout) : (code == (505))? (net__http__Status__http_version_not_supported) : (code == (506))? (net__http__Status__variant_also_negotiates) : (code == (507))? (net__http__Status__insufficient_storage) : (code == (508))? (net__http__Status__loop_detected) : (code == (509))? (net__http__Status__bandwidth_limit_exceeded) : (code == (510))? (net__http__Status__not_extended) : (code == (511))? (net__http__Status__network_authentication_required) : ((code >= 512 && code <= 599))? (net__http__Status__unassigned) : (net__http__Status__unknown));
	return _t1;
}

string net__http__Status_str(net__http__Status code) {
	string _t2 = (string){.str=(byteptr)"", .is_lit=1};
	switch (code) {
		case net__http__Status__cont: {
				_t2 = _SLIT("Continue");
				break;
		}
		case net__http__Status__switching_protocols: {
				_t2 = _SLIT("Switching Protocols");
				break;
		}
		case net__http__Status__processing: {
				_t2 = _SLIT("Processing");
				break;
		}
		case net__http__Status__checkpoint_draft: {
				_t2 = _SLIT("Checkpoint Draft");
				break;
		}
		case net__http__Status__ok: {
				_t2 = _SLIT("OK");
				break;
		}
		case net__http__Status__created: {
				_t2 = _SLIT("Created");
				break;
		}
		case net__http__Status__accepted: {
				_t2 = _SLIT("Accepted");
				break;
		}
		case net__http__Status__non_authoritative_information: {
				_t2 = _SLIT("Non Authoritative Information");
				break;
		}
		case net__http__Status__no_content: {
				_t2 = _SLIT("No Content");
				break;
		}
		case net__http__Status__reset_content: {
				_t2 = _SLIT("Reset Content");
				break;
		}
		case net__http__Status__partial_content: {
				_t2 = _SLIT("Partial Content");
				break;
		}
		case net__http__Status__multi_status: {
				_t2 = _SLIT("Multi Status");
				break;
		}
		case net__http__Status__already_reported: {
				_t2 = _SLIT("Already Reported");
				break;
		}
		case net__http__Status__im_used: {
				_t2 = _SLIT("IM Used");
				break;
		}
		case net__http__Status__multiple_choices: {
				_t2 = _SLIT("Multiple Choices");
				break;
		}
		case net__http__Status__moved_permanently: {
				_t2 = _SLIT("Moved Permanently");
				break;
		}
		case net__http__Status__found: {
				_t2 = _SLIT("Found");
				break;
		}
		case net__http__Status__see_other: {
				_t2 = _SLIT("See Other");
				break;
		}
		case net__http__Status__not_modified: {
				_t2 = _SLIT("Not Modified");
				break;
		}
		case net__http__Status__use_proxy: {
				_t2 = _SLIT("Use Proxy");
				break;
		}
		case net__http__Status__switch_proxy: {
				_t2 = _SLIT("Switch Proxy");
				break;
		}
		case net__http__Status__temporary_redirect: {
				_t2 = _SLIT("Temporary Redirect");
				break;
		}
		case net__http__Status__permanent_redirect: {
				_t2 = _SLIT("Permanent Redirect");
				break;
		}
		case net__http__Status__bad_request: {
				_t2 = _SLIT("Bad Request");
				break;
		}
		case net__http__Status__unauthorized: {
				_t2 = _SLIT("Unauthorized");
				break;
		}
		case net__http__Status__payment_required: {
				_t2 = _SLIT("Payment Required");
				break;
		}
		case net__http__Status__forbidden: {
				_t2 = _SLIT("Forbidden");
				break;
		}
		case net__http__Status__not_found: {
				_t2 = _SLIT("Not Found");
				break;
		}
		case net__http__Status__method_not_allowed: {
				_t2 = _SLIT("Method Not Allowed");
				break;
		}
		case net__http__Status__not_acceptable: {
				_t2 = _SLIT("Not Acceptable");
				break;
		}
		case net__http__Status__proxy_authentication_required: {
				_t2 = _SLIT("Proxy Authentication Required");
				break;
		}
		case net__http__Status__request_timeout: {
				_t2 = _SLIT("Request Timeout");
				break;
		}
		case net__http__Status__conflict: {
				_t2 = _SLIT("Conflict");
				break;
		}
		case net__http__Status__gone: {
				_t2 = _SLIT("Gone");
				break;
		}
		case net__http__Status__length_required: {
				_t2 = _SLIT("Length Required");
				break;
		}
		case net__http__Status__precondition_failed: {
				_t2 = _SLIT("Precondition Failed");
				break;
		}
		case net__http__Status__request_entity_too_large: {
				_t2 = _SLIT("Request Entity Too Large");
				break;
		}
		case net__http__Status__request_uri_too_long: {
				_t2 = _SLIT("Request URI Too Long");
				break;
		}
		case net__http__Status__unsupported_media_type: {
				_t2 = _SLIT("Unsupported Media Type");
				break;
		}
		case net__http__Status__requested_range_not_satisfiable: {
				_t2 = _SLIT("Requested Range Not Satisfiable");
				break;
		}
		case net__http__Status__expectation_failed: {
				_t2 = _SLIT("Expectation Failed");
				break;
		}
		case net__http__Status__im_a_teapot: {
				_t2 = _SLIT("Im a teapot");
				break;
		}
		case net__http__Status__misdirected_request: {
				_t2 = _SLIT("Misdirected Request");
				break;
		}
		case net__http__Status__unprocessable_entity: {
				_t2 = _SLIT("Unprocessable Entity");
				break;
		}
		case net__http__Status__locked: {
				_t2 = _SLIT("Locked");
				break;
		}
		case net__http__Status__failed_dependency: {
				_t2 = _SLIT("Failed Dependency");
				break;
		}
		case net__http__Status__unordered_collection: {
				_t2 = _SLIT("Unordered Collection");
				break;
		}
		case net__http__Status__upgrade_required: {
				_t2 = _SLIT("Upgrade Required");
				break;
		}
		case net__http__Status__precondition_required: {
				_t2 = _SLIT("Precondition Required");
				break;
		}
		case net__http__Status__too_many_requests: {
				_t2 = _SLIT("Too Many Requests");
				break;
		}
		case net__http__Status__request_header_fields_too_large: {
				_t2 = _SLIT("Request Header Fields Too Large");
				break;
		}
		case net__http__Status__unavailable_for_legal_reasons: {
				_t2 = _SLIT("Unavailable For Legal Reasons");
				break;
		}
		case net__http__Status__internal_server_error: {
				_t2 = _SLIT("Internal Server Error");
				break;
		}
		case net__http__Status__not_implemented: {
				_t2 = _SLIT("Not Implemented");
				break;
		}
		case net__http__Status__bad_gateway: {
				_t2 = _SLIT("Bad Gateway");
				break;
		}
		case net__http__Status__service_unavailable: {
				_t2 = _SLIT("Service Unavailable");
				break;
		}
		case net__http__Status__gateway_timeout: {
				_t2 = _SLIT("Gateway Timeout");
				break;
		}
		case net__http__Status__http_version_not_supported: {
				_t2 = _SLIT("HTTP Version Not Supported");
				break;
		}
		case net__http__Status__variant_also_negotiates: {
				_t2 = _SLIT("Variant Also Negotiates");
				break;
		}
		case net__http__Status__insufficient_storage: {
				_t2 = _SLIT("Insufficient Storage");
				break;
		}
		case net__http__Status__loop_detected: {
				_t2 = _SLIT("Loop Detected");
				break;
		}
		case net__http__Status__bandwidth_limit_exceeded: {
				_t2 = _SLIT("Bandwidth Limit Exceeded");
				break;
		}
		case net__http__Status__not_extended: {
				_t2 = _SLIT("Not Extended");
				break;
		}
		case net__http__Status__network_authentication_required: {
				_t2 = _SLIT("Network Authentication Required");
				break;
		}
		case net__http__Status__unassigned: {
				_t2 = _SLIT("Unassigned");
				break;
		}
		case net__http__Status__unknown:
		case net__http__Status__client_closed_request:
		default: {
				_t2 = _SLIT("Unknown");
				break;
		}
	}
	string _t1 = _t2;
	return _t1;
}

int net__http__Status_int(net__http__Status code) {
	if (code == net__http__Status__unknown || code == net__http__Status__unassigned) {
		int _t1 = 0;
		return _t1;
	}
	int _t2 = ((int)(code));
	return _t2;
}

bool net__http__Status_is_valid(net__http__Status code) {
	int number = net__http__Status_int(code);
	bool _t1 = number >= 100 && number < 600;
	return _t1;
}

bool net__http__Status_is_error(net__http__Status code) {
	int number = net__http__Status_int(code);
	bool _t1 = number >= 400 && number < 600;
	return _t1;
}

bool net__http__Status_is_success(net__http__Status code) {
	int number = net__http__Status_int(code);
	bool _t1 = number >= 100 && number < 400;
	return _t1;
}

VV_LOCAL_SYMBOL multi_return_int_int net__http__fast_request_words(string line) {
	_option_int _t1 = string_index(line, _SLIT(" "));
	if (_t1.state != 0) {
		IError err = _t1.err;
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	
 	int space1 =  (*(int*)_t1.data);
	int space2 = string_index_after(line, _SLIT(" "), (int)(space1 + 1));
	if (space2 == -1) {
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	return (multi_return_int_int){.arg0=space1, .arg1=space2};
}

string net__http__Version_str(net__http__Version v) {
	string _t1 = ((v == (net__http__Version__v1_1))? (_SLIT("HTTP/1.1")) : (v == (net__http__Version__v2_0))? (_SLIT("HTTP/2.0")) : (v == (net__http__Version__v1_0))? (_SLIT("HTTP/1.0")) : (_SLIT("unknown")));
	return _t1;
}

net__http__Version net__http__version_from_str(string v) {
	string /*A*/ _t2 = string_to_lower(v);
		net__http__Version _t1 = ((string__eq(_t2, _SLIT("http/1.1")))? (net__http__Version__v1_1) : (string__eq(_t2, _SLIT("http/2.0")))? (net__http__Version__v2_0) : (string__eq(_t2, _SLIT("http/1.0")))? (net__http__Version__v1_0) : (net__http__Version__unknown));
	return _t1;
}

multi_return_int_int net__http__Version_protos(net__http__Version v) {

	if (v == (net__http__Version__v1_1)) {
		return (multi_return_int_int){.arg0=1, .arg1=1};
	}
	else if (v == (net__http__Version__v2_0)) {
		return (multi_return_int_int){.arg0=2, .arg1=0};
	}
	else if (v == (net__http__Version__v1_0)) {
		return (multi_return_int_int){.arg0=1, .arg1=0};
	}
	else if (v == (net__http__Version__unknown)) {
		return (multi_return_int_int){.arg0=0, .arg1=0};
	}
	return (multi_return_int_int){0};
}

// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
// TypeDecl
_result_void net__websocket__Server_on_connect(net__websocket__Server* s, _result_bool (*fun)(net__websocket__ServerClient* c)) {
	if (s->accept_client_callbacks.len > 0) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("only one callback can be registered for accept client")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	array_push((array*)&s->accept_client_callbacks, _MOV((voidptr[]){ (voidptr)fun }));
	return (_result_void){0};
}

void net__websocket__Server_on_message(net__websocket__Server* s, _result_void (*fun)(net__websocket__Client* c, net__websocket__Message* msg)) {
	array_push((array*)&s->message_callbacks, _MOV((net__websocket__MessageEventHandler[]){ ((net__websocket__MessageEventHandler){.handler = (voidptr)fun,.handler2 = ((void*)0),.is_ref = 0,.ref = 0,}) }));
}

void net__websocket__Server_on_message_ref(net__websocket__Server* s, _result_void (*fun)(net__websocket__Client* c, net__websocket__Message* msg, voidptr v), voidptr ref) {
	array_push((array*)&s->message_callbacks, _MOV((net__websocket__MessageEventHandler[]){ ((net__websocket__MessageEventHandler){.handler = ((void*)0),.handler2 = (voidptr)fun,.is_ref = true,.ref = ref,}) }));
}

void net__websocket__Server_on_close(net__websocket__Server* s, _result_void (*fun)(net__websocket__Client* c, int code, string reason)) {
	array_push((array*)&s->close_callbacks, _MOV((net__websocket__CloseEventHandler[]){ ((net__websocket__CloseEventHandler){.handler = (voidptr)fun,.handler2 = ((void*)0),.is_ref = 0,.ref = 0,}) }));
}

void net__websocket__Server_on_close_ref(net__websocket__Server* s, _result_void (*fun)(net__websocket__Client* c, int code, string reason, voidptr v), voidptr ref) {
	array_push((array*)&s->close_callbacks, _MOV((net__websocket__CloseEventHandler[]){ ((net__websocket__CloseEventHandler){.handler = ((void*)0),.handler2 = (voidptr)fun,.is_ref = true,.ref = ref,}) }));
}

void net__websocket__Client_on_message(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, net__websocket__Message* msg)) {
	array_push((array*)&ws->message_callbacks, _MOV((net__websocket__MessageEventHandler[]){ ((net__websocket__MessageEventHandler){.handler = (voidptr)fun,.handler2 = ((void*)0),.is_ref = 0,.ref = 0,}) }));
}

void net__websocket__Client_on_message_ref(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, net__websocket__Message* msg, voidptr v), voidptr ref) {
	array_push((array*)&ws->message_callbacks, _MOV((net__websocket__MessageEventHandler[]){ ((net__websocket__MessageEventHandler){.handler = ((void*)0),.handler2 = (voidptr)fun,.is_ref = true,.ref = ref,}) }));
}

void net__websocket__Client_on_error(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, string err)) {
	array_push((array*)&ws->error_callbacks, _MOV((net__websocket__ErrorEventHandler[]){ ((net__websocket__ErrorEventHandler){.handler = (voidptr)fun,.handler2 = ((void*)0),.is_ref = 0,.ref = 0,}) }));
}

void net__websocket__Client_on_error_ref(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, string err, voidptr v), voidptr ref) {
	array_push((array*)&ws->error_callbacks, _MOV((net__websocket__ErrorEventHandler[]){ ((net__websocket__ErrorEventHandler){.handler = ((void*)0),.handler2 = (voidptr)fun,.is_ref = true,.ref = ref,}) }));
}

void net__websocket__Client_on_open(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c)) {
	array_push((array*)&ws->open_callbacks, _MOV((net__websocket__OpenEventHandler[]){ ((net__websocket__OpenEventHandler){.handler = (voidptr)fun,.handler2 = ((void*)0),.is_ref = 0,.ref = 0,}) }));
}

void net__websocket__Client_on_open_ref(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, voidptr v), voidptr ref) {
	array_push((array*)&ws->open_callbacks, _MOV((net__websocket__OpenEventHandler[]){ ((net__websocket__OpenEventHandler){.handler = ((void*)0),.handler2 = (voidptr)fun,.is_ref = true,.ref = ref,}) }));
}

void net__websocket__Client_on_close(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, int code, string reason)) {
	array_push((array*)&ws->close_callbacks, _MOV((net__websocket__CloseEventHandler[]){ ((net__websocket__CloseEventHandler){.handler = (voidptr)fun,.handler2 = ((void*)0),.is_ref = 0,.ref = 0,}) }));
}

void net__websocket__Client_on_close_ref(net__websocket__Client* ws, _result_void (*fun)(net__websocket__Client* c, int code, string reason, voidptr v), voidptr ref) {
	array_push((array*)&ws->close_callbacks, _MOV((net__websocket__CloseEventHandler[]){ ((net__websocket__CloseEventHandler){.handler = ((void*)0),.handler2 = (voidptr)fun,.is_ref = true,.ref = ref,}) }));
}

VV_LOCAL_SYMBOL _result_bool net__websocket__Server_send_connect_event(net__websocket__Server* s, net__websocket__ServerClient* c) {
	if (s->accept_client_callbacks.len == 0) {
		_result_bool _t1;
		_result_ok(&(bool[]) { true }, (_result*)(&_t1), sizeof(bool));
		return _t1;
	}
	_result_bool (*fun) (net__websocket__ServerClient* c) = (*(voidptr*)array_get(s->accept_client_callbacks, 0));
	_result_bool _t2 = fun(c);
	if (_t2.is_error) {
		_result_bool _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	bool res =  (*(bool*)_t2.data);
	_result_bool _t4;
	_result_ok(&(bool[]) { res }, (_result*)(&_t4), sizeof(bool));
	return _t4;
}

VV_LOCAL_SYMBOL void net__websocket__Client_send_message_event(net__websocket__Client* ws, net__websocket__Message* msg) {
	net__websocket__Client_debug_log(ws, _SLIT("sending on_message event"));
	for (int _t1 = 0; _t1 < ws->message_callbacks.len; ++_t1) {
		net__websocket__MessageEventHandler ev_handler = ((net__websocket__MessageEventHandler*)ws->message_callbacks.data)[_t1];
		if (!ev_handler.is_ref) {
			_result_void _t2 = ev_handler.handler(ws, msg);
			if (_t2.is_error) {
				IError err = _t2.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("send_message_event error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			;
			}
			
 ;
		} else {
			_result_void _t3 = ev_handler.handler2(ws, msg, ev_handler.ref);
			if (_t3.is_error) {
				IError err = _t3.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("send_message_event error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			;
			}
			
 ;
		}
	}
}

VV_LOCAL_SYMBOL void net__websocket__Client_send_error_event(net__websocket__Client* ws, string __v_error) {
	net__websocket__Client_debug_log(ws, _SLIT("sending on_error event"));
	for (int _t1 = 0; _t1 < ws->error_callbacks.len; ++_t1) {
		net__websocket__ErrorEventHandler ev_handler = ((net__websocket__ErrorEventHandler*)ws->error_callbacks.data)[_t1];
		if (!ev_handler.is_ref) {
			_result_void _t2 = ev_handler.handler(ws, __v_error);
			if (_t2.is_error) {
				IError err = _t2.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("send_error_event error: "), /*115 &string*/0xfe10, {.d_s = __v_error}}, {_SLIT(", err: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			;
			}
			
 ;
		} else {
			_result_void _t3 = ev_handler.handler2(ws, __v_error, ev_handler.ref);
			if (_t3.is_error) {
				IError err = _t3.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("send_error_event error: "), /*115 &string*/0xfe10, {.d_s = __v_error}}, {_SLIT(", err: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			;
			}
			
 ;
		}
	}
}

VV_LOCAL_SYMBOL void net__websocket__Client_send_close_event(net__websocket__Client* ws, int code, string reason) {
	net__websocket__Client_debug_log(ws, _SLIT("sending on_close event"));
	for (int _t1 = 0; _t1 < ws->close_callbacks.len; ++_t1) {
		net__websocket__CloseEventHandler ev_handler = ((net__websocket__CloseEventHandler*)ws->close_callbacks.data)[_t1];
		if (!ev_handler.is_ref) {
			_result_void _t2 = ev_handler.handler(ws, code, reason);
			if (_t2.is_error) {
				IError err = _t2.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("send_close_event error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			;
			}
			
 ;
		} else {
			_result_void _t3 = ev_handler.handler2(ws, code, reason, ev_handler.ref);
			if (_t3.is_error) {
				IError err = _t3.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("send_close_event error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			;
			}
			
 ;
		}
	}
}

VV_LOCAL_SYMBOL void net__websocket__Client_send_open_event(net__websocket__Client* ws) {
	net__websocket__Client_debug_log(ws, _SLIT("sending on_open event"));
	for (int _t1 = 0; _t1 < ws->open_callbacks.len; ++_t1) {
		net__websocket__OpenEventHandler ev_handler = ((net__websocket__OpenEventHandler*)ws->open_callbacks.data)[_t1];
		if (!ev_handler.is_ref) {
			_result_void _t2 = ev_handler.handler(ws);
			if (_t2.is_error) {
				IError err = _t2.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("send_open_event error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			;
			}
			
 ;
		} else {
			_result_void _t3 = ev_handler.handler2(ws, ev_handler.ref);
			if (_t3.is_error) {
				IError err = _t3.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("send_open_event error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			;
			}
			
 ;
		}
	}
}

VV_LOCAL_SYMBOL _result_void net__websocket__Client_handshake(net__websocket__Client* ws) {
	bool net__websocket__Client_handshake_defer_0 = false;
	strings__Builder sb;
	string nonce = net__websocket__get_nonce(ws->nonce_size);
	string seckey = encoding__base64__encode_str(nonce);
	sb = strings__new_builder(1024);
	net__websocket__Client_handshake_defer_0 = true;
	strings__Builder_write_string(&sb, _SLIT("GET "));
	strings__Builder_write_string(&sb, ws->uri.resource);
	strings__Builder_write_string(&sb, ws->uri.querystring);
	strings__Builder_write_string(&sb, _SLIT(" HTTP/1.1\r\nHost: "));
	strings__Builder_write_string(&sb, ws->uri.hostname);
	strings__Builder_write_string(&sb, _SLIT(":"));
	strings__Builder_write_string(&sb, ws->uri.port);
	strings__Builder_write_string(&sb, _SLIT("\r\nUpgrade: websocket\r\nConnection: Upgrade\r\n"));
	strings__Builder_write_string(&sb, _SLIT("Sec-WebSocket-Key: "));
	strings__Builder_write_string(&sb, seckey);
	strings__Builder_write_string(&sb, _SLIT("\r\nSec-WebSocket-Version: 13"));
	Array_string _t1 = net__http__Header_keys(ws->header);
	for (int _t2 = 0; _t2 < _t1.len; ++_t2) {
		string key = ((string*)_t1.data)[_t2];
		string val = Array_string_join(net__http__Header_custom_values(ws->header, key, ((net__http__HeaderQueryConfig){.exact = 0,})), _SLIT(","));
		strings__Builder_write_string(&sb,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("\r\n"), /*115 &string*/0xfe10, {.d_s = key}}, {_SLIT(":"), /*115 &string*/0xfe10, {.d_s = val}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
	strings__Builder_write_string(&sb, _SLIT("\r\n\r\n"));
	string handshake = strings__Builder_str(&sb);
	Array_u8 handshake_bytes = string_bytes(handshake);
	net__websocket__Client_debug_log(ws,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("sending handshake: "), /*115 &string*/0xfe10, {.d_s = handshake}}, {_SLIT0, 0, { .d_c = 0 }}})));
	_result_int _t3 = net__websocket__Client_socket_write(ws, handshake_bytes);
	if (_t3.is_error) {
		// Defer begin
		if (net__websocket__Client_handshake_defer_0) {
			strings__Builder_free(&sb);
		}
		// Defer end
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
  (*(int*)_t3.data);
	_result_void _t5 = net__websocket__Client_read_handshake(ws, seckey);
	if (_t5.is_error) {
		// Defer begin
		if (net__websocket__Client_handshake_defer_0) {
			strings__Builder_free(&sb);
		}
		// Defer end
		_result_void _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 ;
		// Defer begin
		if (net__websocket__Client_handshake_defer_0) {
			strings__Builder_free(&sb);
		}
		// Defer end
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_multi_return_string_ref_net__websocket__ServerClient net__websocket__Server_handle_server_handshake(net__websocket__Server* s, net__websocket__Client* c) {
	_result_string _t1 = net__websocket__Client_read_handshake_str(c);
	if (_t1.is_error) {
		_result_multi_return_string_ref_net__websocket__ServerClient _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string msg =  (*(string*)_t1.data);
	_result_multi_return_string_ref_net__websocket__ServerClient _t3 = net__websocket__Server_parse_client_handshake(s, msg, c);
	if (_t3.is_error) {
		_result_multi_return_string_ref_net__websocket__ServerClient _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	multi_return_string_ref_net__websocket__ServerClient mr_1234 =  (*(multi_return_string_ref_net__websocket__ServerClient*)_t3.data);
	string handshake_response = mr_1234.arg0;
	net__websocket__ServerClient* client = mr_1234.arg1;
	_result_multi_return_string_ref_net__websocket__ServerClient _t5;
	_result_ok(&(multi_return_string_ref_net__websocket__ServerClient[]) { (multi_return_string_ref_net__websocket__ServerClient){.arg0=handshake_response, .arg1=client} }, (_result*)(&_t5), sizeof(multi_return_string_ref_net__websocket__ServerClient));
	return _t5;
}

VV_LOCAL_SYMBOL _result_multi_return_string_ref_net__websocket__ServerClient net__websocket__Server_parse_client_handshake(net__websocket__Server* s, string client_handshake, net__websocket__Client* c) {
	log__Logger_name_table[s->logger->_typ]._method_debug(s->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> client handshake:\n"), /*115 &string*/0xfe10, {.d_s = client_handshake}}, {_SLIT0, 0, { .d_c = 0 }}})));
	Array_string lines = string_split_into_lines(client_handshake);
	Array_string get_tokens = string_split((*(string*)array_get(lines, 0)), _SLIT(" "));
	if (get_tokens.len < 3) {
		return (_result_multi_return_string_ref_net__websocket__ServerClient){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected get operation, "), /*115 &[]string*/0xfe10, {.d_s = Array_string_str(get_tokens)}}, {_SLIT0, 0, { .d_c = 0 }}})), 1), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!string__eq(string_trim_space((*(string*)array_get(get_tokens, 0))), _SLIT("GET"))) {
		return (_result_multi_return_string_ref_net__websocket__ServerClient){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected request '"), /*115 &string*/0xfe10, {.d_s = (*(string*)array_get(get_tokens, 0))}}, {_SLIT("', expected 'GET'"), 0, { .d_c = 0 }}})), 2), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (!string__eq(string_trim_space((*(string*)array_get(get_tokens, 2))), _SLIT("HTTP/1.1"))) {
		return (_result_multi_return_string_ref_net__websocket__ServerClient){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexpected request "), /*115 &[]string*/0xfe10, {.d_s = Array_string_str(get_tokens)}}, {_SLIT(", expected 'HTTP/1.1'"), 0, { .d_c = 0 }}})), 3), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string seckey = _SLIT("");
	Array_net__websocket__Flag flags = __new_array_with_default_noscan(0, 0, sizeof(net__websocket__Flag), 0);
	string key = _SLIT("");
	for (int i = 1; i < lines.len; ++i) {
		if ((*(string*)array_get(lines, i)).len <= 0 || string__eq((*(string*)array_get(lines, i)), _SLIT("\r\n"))) {
			continue;
		}
		Array_string _t4 = {0};
		Array_string _t4_orig = string_split((*(string*)array_get(lines, i)), _SLIT(":"));
		int _t4_len = _t4_orig.len;
		_t4 = __new_array(0, _t4_len, sizeof(string));

		for (int _t6 = 0; _t6 < _t4_len; ++_t6) {
			string it = ((string*) _t4_orig.data)[_t6];
			string _t5 = string_trim_space(it);
			array_push((array*)&_t4, &_t5);
		}
		Array_string keys =_t4;
		string /*A*/ _t7 = string_to_lower((*(string*)array_get(keys, 0)));
		
		if (string__eq(_t7, _SLIT("upgrade"))) {
			array_push_noscan((array*)&flags, _MOV((net__websocket__Flag[]){ net__websocket__Flag__has_upgrade }));
		}
		else if (string__eq(_t7, _SLIT("connection"))) {
			array_push_noscan((array*)&flags, _MOV((net__websocket__Flag[]){ net__websocket__Flag__has_connection }));
		}
		else if (string__eq(_t7, _SLIT("sec-websocket-key"))) {
			key = (*(string*)array_get(keys, 1));
			log__Logger_name_table[s->logger->_typ]._method_debug(s->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> got key: "), /*115 &string*/0xfe10, {.d_s = key}}, {_SLIT0, 0, { .d_c = 0 }}})));
			_result_string _t10 = net__websocket__create_key_challenge_response(key);
			if (_t10.is_error) {
				_result_multi_return_string_ref_net__websocket__ServerClient _t11;
				memcpy(&_t11, &_t10, sizeof(_result));
				return _t11;
			}
			
 			seckey =  (*(string*)_t10.data);
			log__Logger_name_table[s->logger->_typ]._method_debug(s->logger->_object,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("server-> challenge: "), /*115 &string*/0xfe10, {.d_s = seckey}}, {_SLIT(", response: "), /*115 &string*/0xfe10, {.d_s = key}}, {_SLIT0, 0, { .d_c = 0 }}})));
			array_push_noscan((array*)&flags, _MOV((net__websocket__Flag[]){ net__websocket__Flag__has_accept }));
		}
		else {
		}
	}
	if (flags.len < 3) {
		return (_result_multi_return_string_ref_net__websocket__ServerClient){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid client handshake, "), /*115 &string*/0xfe10, {.d_s = client_handshake}}, {_SLIT0, 0, { .d_c = 0 }}})), 4), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string server_handshake =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "), /*115 &string*/0xfe10, {.d_s = seckey}}, {_SLIT("\r\n\r\n"), 0, { .d_c = 0 }}}));
	net__websocket__ServerClient* server_client = ((net__websocket__ServerClient*)memdup(&(net__websocket__ServerClient){.resource_name = (*(string*)array_get(get_tokens, 1)),.client_key = key,.server = s,.client = c,}, sizeof(net__websocket__ServerClient)));
	_result_multi_return_string_ref_net__websocket__ServerClient _t14;
	_result_ok(&(multi_return_string_ref_net__websocket__ServerClient[]) { (multi_return_string_ref_net__websocket__ServerClient){.arg0=server_handshake, .arg1=server_client} }, (_result*)(&_t14), sizeof(multi_return_string_ref_net__websocket__ServerClient));
	return _t14;
}

VV_LOCAL_SYMBOL _result_string net__websocket__Client_read_handshake_str(net__websocket__Client* ws) {
	int total_bytes_read = 0;
	Array_fixed_u8_1024 msg = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	Array_fixed_u8_1 buffer = {0};
	for (;;) {
		if (!(total_bytes_read < 1024)) break;
		_result_int _t1 = net__websocket__Client_socket_read_ptr(ws, &buffer[0], 1);
		if (_t1.is_error) {
			_result_string _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 		int bytes_read =  (*(int*)_t1.data);
		if (bytes_read == 0) {
			return (_result_string){ .is_error=true, .err=error_with_code(_SLIT("unexpected no response from handshake"), 5), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		msg[v_fixed_index(total_bytes_read, 1024)] = buffer[0];
		total_bytes_read++;
		if (total_bytes_read > 5 && msg[v_fixed_index((int)(total_bytes_read - 1), 1024)] == '\n' && msg[v_fixed_index((int)(total_bytes_read - 2), 1024)] == '\r' && msg[v_fixed_index((int)(total_bytes_read - 3), 1024)] == '\n' && msg[v_fixed_index((int)(total_bytes_read - 4), 1024)] == '\r') {
			break;
		}
	}
	string res = Array_u8_bytestr(array_slice(new_array_from_c_array_noscan(1024, 1024, sizeof(u8), msg), 0, total_bytes_read));
	_result_string _t4;
	_result_ok(&(string[]) { res }, (_result*)(&_t4), sizeof(string));
	return _t4;
}

VV_LOCAL_SYMBOL _result_void net__websocket__Client_read_handshake(net__websocket__Client* ws, string seckey) {
	_result_string _t1 = net__websocket__Client_read_handshake_str(ws);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	string msg =  (*(string*)_t1.data);
	_result_void _t3 = net__websocket__Client_check_handshake_response(ws, msg, seckey);
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void net__websocket__Client_check_handshake_response(net__websocket__Client* ws, string handshake_response, string seckey) {
	net__websocket__Client_debug_log(ws,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("handshake response:\n"), /*115 &string*/0xfe10, {.d_s = handshake_response}}, {_SLIT0, 0, { .d_c = 0 }}})));
	Array_string lines = string_split_into_lines(handshake_response);
	string header = (*(string*)array_get(lines, 0));
	if (!string_starts_with(header, _SLIT("HTTP/1.1 101")) && !string_starts_with(header, _SLIT("HTTP/1.0 101"))) {
		return (_result_void){ .is_error=true, .err=error_with_code( str_intp(2, _MOV((StrIntpData[]){{_SLIT("handshake_handler: invalid HTTP status response code, "), /*115 &string*/0xfe10, {.d_s = header}}, {_SLIT0, 0, { .d_c = 0 }}})), 6), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	for (int i = 1; i < lines.len; ++i) {
		if ((*(string*)array_get(lines, i)).len <= 0 || string__eq((*(string*)array_get(lines, i)), _SLIT("\r\n"))) {
			continue;
		}
		Array_string _t2 = {0};
		Array_string _t2_orig = string_split((*(string*)array_get(lines, i)), _SLIT(":"));
		int _t2_len = _t2_orig.len;
		_t2 = __new_array(0, _t2_len, sizeof(string));

		for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
			string it = ((string*) _t2_orig.data)[_t4];
			string _t3 = string_trim_space(it);
			array_push((array*)&_t2, &_t3);
		}
		Array_string keys =_t2;
		string /*A*/ _t5 = string_to_lower((*(string*)array_get(keys, 0)));
		
		if (string__eq(_t5, _SLIT("upgrade"))) {
			array_push_noscan((array*)&ws->flags, _MOV((net__websocket__Flag[]){ net__websocket__Flag__has_upgrade }));
		}
		else if (string__eq(_t5, _SLIT("connection"))) {
			array_push_noscan((array*)&ws->flags, _MOV((net__websocket__Flag[]){ net__websocket__Flag__has_connection }));
		}
		else if (string__eq(_t5, _SLIT("sec-websocket-accept"))) {
			net__websocket__Client_debug_log(ws,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("seckey: "), /*115 &string*/0xfe10, {.d_s = seckey}}, {_SLIT0, 0, { .d_c = 0 }}})));
			_result_string _t8 = net__websocket__create_key_challenge_response(seckey);
			if (_t8.is_error) {
				_result_void _t9;
				memcpy(&_t9, &_t8, sizeof(_result));
				return _t9;
			}
			
 			string challenge =  (*(string*)_t8.data);
			net__websocket__Client_debug_log(ws,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("challenge: "), /*115 &string*/0xfe10, {.d_s = challenge}}, {_SLIT(", response: "), /*115 &string*/0xfe10, {.d_s = (*(string*)array_get(keys, 1))}}, {_SLIT0, 0, { .d_c = 0 }}})));
			if (!string__eq(string_trim_space((*(string*)array_get(keys, 1))), challenge)) {
				return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("handshake_handler: Sec-WebSocket-Accept header does not match computed sha1/base64 response."), 7), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			array_push_noscan((array*)&ws->flags, _MOV((net__websocket__Flag[]){ net__websocket__Flag__has_accept }));
		}
		else {
		}
	}
	if (ws->flags.len < 3) {
		_result_void _t12 = net__websocket__Client_close(ws, 1002, _SLIT("invalid websocket HTTP headers"));
		if (_t12.is_error) {
			_result_void _t13;
			memcpy(&_t13, &_t12, sizeof(_result));
			return _t13;
		}
		
 ;
		return (_result_void){ .is_error=true, .err=error_with_code(_SLIT("invalid websocket HTTP headers"), 8), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_int net__websocket__Client_socket_read(net__websocket__Client* ws, Array_u8* buffer) {
	/*lock*/ {
		if ((net__websocket__Client_get_state(ws) == net__websocket__State__closed || net__websocket__Client_get_state(ws) == net__websocket__State__closing) || ws->conn->sock.Socket.handle <= 1) {
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("socket_read: trying to read a closed socket")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ws->is_ssl) {
			_result_int _t2 = net__mbedtls__SSLConn_read(&ws->ssl_conn->SSLConn, buffer);
			if (_t2.is_error) {
				IError err = _t2.err;
				return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			int r =  (*(int*)_t2.data);
			_result_int _t4;
			_result_ok(&(int[]) { r }, (_result*)(&_t4), sizeof(int));
			return _t4;
		} else {
			_result_int _t5 = net__TcpConn_read(/*rec*/*ws->conn, buffer);
			if (_t5.is_error) {
				IError err = _t5.err;
				return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 			int r =  (*(int*)_t5.data);
			_result_int _t7;
			_result_ok(&(int[]) { r }, (_result*)(&_t7), sizeof(int));
			return _t7;
		}
	}
	;
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_int net__websocket__Client_socket_read_ptr(net__websocket__Client* ws, u8* buf_ptr, int len) {
	/*lock*/ {
		if ((net__websocket__Client_get_state(ws) == net__websocket__State__closed || net__websocket__Client_get_state(ws) == net__websocket__State__closing) || ws->conn->sock.Socket.handle <= 1) {
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("socket_read_ptr: trying to read a closed socket")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ws->is_ssl) {
			_result_int _t2 = net__mbedtls__SSLConn_socket_read_into_ptr(&ws->ssl_conn->SSLConn, buf_ptr, len);
			if (_t2.is_error) {
				_result_int _t3;
				memcpy(&_t3, &_t2, sizeof(_result));
				return _t3;
			}
			
 			int r =  (*(int*)_t2.data);
			_result_int _t4;
			_result_ok(&(int[]) { r }, (_result*)(&_t4), sizeof(int));
			return _t4;
		} else {
			_result_int _t5 = net__TcpConn_read_ptr(/*rec*/*ws->conn, buf_ptr, len);
			if (_t5.is_error) {
				_result_int _t6;
				memcpy(&_t6, &_t5, sizeof(_result));
				return _t6;
			}
			
 			int r =  (*(int*)_t5.data);
			_result_int _t7;
			_result_ok(&(int[]) { r }, (_result*)(&_t7), sizeof(int));
			return _t7;
		}
	}
	;
	return (_result_int){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
}

VV_LOCAL_SYMBOL _result_int net__websocket__Client_socket_write(net__websocket__Client* ws, Array_u8 bytes) {
	/*lock*/ {
		if (net__websocket__Client_get_state(ws) == net__websocket__State__closed || ws->conn->sock.Socket.handle <= 1) {
			net__websocket__Client_debug_log(ws, _SLIT("socket_write: Socket already closed"));
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("socket_write: trying to write on a closed socket")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (ws->is_ssl) {
			_result_int _t2 = net__mbedtls__SSLConn_write(&ws->ssl_conn->SSLConn, bytes);
			return _t2;
		} else {
			for (;;) {
				_result_int _t3 = net__TcpConn_write(ws->conn, bytes);
				if (_t3.is_error) {
					IError err = _t3.err;
					if (IError_name_table[err._typ]._method_code(err._object) == _const_net__err_timed_out_code) {
						continue;
					}
					return (_result_int){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				}
				
 				int n =  (*(int*)_t3.data);
				_result_int _t5;
				_result_ok(&(int[]) { n }, (_result*)(&_t5), sizeof(int));
				return _t5;
			}
			_v_panic(_SLIT("reached unreachable code"));
			VUNREACHABLE();
		}
	}
	;
	return (_result_int){0};
}

VV_LOCAL_SYMBOL _result_void net__websocket__Client_shutdown_socket(net__websocket__Client* ws) {
	net__websocket__Client_debug_log(ws, _SLIT("shutting down socket"));
	if (ws->is_ssl) {
		_result_void _t1 = net__mbedtls__SSLConn_shutdown(&ws->ssl_conn->SSLConn);
		if (_t1.is_error) {
			_result_void _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
	} else {
		_result_void _t3 = net__TcpConn_close(ws->conn);
		if (_t3.is_error) {
			_result_void _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 ;
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_net__TcpConn_ptr net__websocket__Client_dial_socket(net__websocket__Client* ws) {
	string tcp_address =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = ws->uri.hostname}}, {_SLIT(":"), /*115 &string*/0xfe10, {.d_s = ws->uri.port}}, {_SLIT0, 0, { .d_c = 0 }}}));
	_result_net__TcpConn_ptr _t1 = net__dial_tcp(tcp_address);
	if (_t1.is_error) {
		_result_net__TcpConn_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__TcpConn* t =  (*(net__TcpConn**)_t1.data);
	int optval = ((int)(1));
	_result_void _t3 = net__TcpSocket_set_option_int(&t->sock, net__SocketOption__keep_alive, optval);
	if (_t3.is_error) {
		_result_net__TcpConn_ptr _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	net__TcpConn_set_read_timeout(t, ws->read_timeout);
	net__TcpConn_set_write_timeout(t, ws->write_timeout);
	if (ws->is_ssl) {
		_result_void _t5 = net__mbedtls__SSLConn_connect(&ws->ssl_conn->SSLConn, t, ws->uri.hostname);
		if (_t5.is_error) {
			_result_net__TcpConn_ptr _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
	}
	_result_net__TcpConn_ptr _t7;
	_result_ok(&(net__TcpConn*[]) { t }, (_result*)(&_t7), sizeof(net__TcpConn*));
	return _t7;
}

_result_void net__websocket__Client_validate_frame(net__websocket__Client* ws, net__websocket__Frame* frame) {
	if (frame->rsv1 || frame->rsv2 || frame->rsv3) {
		_result_void _t1 = net__websocket__Client_close(ws, 1002, _SLIT("rsv cannot be other than 0, not negotiated"));
		if (_t1.is_error) {
			_result_void _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("rsv cannot be other than 0, not negotiated")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if ((((int)(frame->opcode)) >= 3 && ((int)(frame->opcode)) <= 7) || (((int)(frame->opcode)) >= 11 && ((int)(frame->opcode)) <= 15)) {
		_result_void _t4 = net__websocket__Client_close(ws, 1002, _SLIT("use of reserved opcode"));
		if (_t4.is_error) {
			_result_void _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 ;
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("use of reserved opcode")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (frame->has_mask && !ws->is_server) {
		_result_void _t7 = net__websocket__Client_close(ws, 1002, _SLIT("client got masked frame"));
		if (_t7.is_error) {
			_result_void _t8;
			memcpy(&_t8, &_t7, sizeof(_result));
			return _t8;
		}
		
 ;
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("client sent masked frame")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (net__websocket__is_control_frame(frame->opcode)) {
		if (!frame->fin) {
			_result_void _t10 = net__websocket__Client_close(ws, 1002, _SLIT("control message must not be fragmented"));
			if (_t10.is_error) {
				_result_void _t11;
				memcpy(&_t11, &_t10, sizeof(_result));
				return _t11;
			}
			
 ;
			return (_result_void){ .is_error=true, .err=_v_error(_SLIT("unexpected control frame with no fin")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		if (frame->payload_len > 125) {
			_result_void _t13 = net__websocket__Client_close(ws, 1002, _SLIT("control frames must not exceed 125 bytes"));
			if (_t13.is_error) {
				_result_void _t14;
				memcpy(&_t14, &_t13, sizeof(_result));
				return _t14;
			}
			
 ;
			return (_result_void){ .is_error=true, .err=_v_error(_SLIT("unexpected control frame payload length")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	if (frame->fin == false && ws->fragments.len == 0 && frame->opcode == net__websocket__OPCode__continuation) {
		string err_msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("unexecpected continuation, there are no frames to continue, "), /*115 &net.websocket.Frame*/0xfe10, {.d_s = str_intp(1, _MOV((StrIntpData[]){{_SLIT("&"), 0xfe10 ,{.d_s = isnil(frame) ? _SLIT("nil") : net__websocket__Frame_str(*frame)}}}))}}, {_SLIT0, 0, { .d_c = 0 }}}));
		_result_void _t16 = net__websocket__Client_close(ws, 1002, err_msg);
		if (_t16.is_error) {
			_result_void _t17;
			memcpy(&_t17, &_t16, sizeof(_result));
			return _t17;
		}
		
 ;
		return (_result_void){ .is_error=true, .err=_v_error(err_msg), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

VV_LOCAL_SYMBOL bool net__websocket__is_control_frame(net__websocket__OPCode opcode) {
	bool _t1 = !(opcode == net__websocket__OPCode__text_frame || opcode == net__websocket__OPCode__binary_frame || opcode == net__websocket__OPCode__continuation);
	return _t1;
}

VV_LOCAL_SYMBOL bool net__websocket__is_data_frame(net__websocket__OPCode opcode) {
	bool _t1 = (opcode == net__websocket__OPCode__text_frame || opcode == net__websocket__OPCode__binary_frame);
	return _t1;
}

VV_LOCAL_SYMBOL _result_Array_u8 net__websocket__Client_read_payload(net__websocket__Client* ws, net__websocket__Frame* frame) {
	if (frame->payload_len == 0) {
		_result_Array_u8 _t1;
		_result_ok(&(Array_u8[]) { __new_array_with_default_noscan(0, 0, sizeof(u8), 0) }, (_result*)(&_t1), sizeof(Array_u8));
		return _t1;
	}
	Array_u8 buffer = __new_array_with_default_noscan(0, frame->payload_len, sizeof(u8), 0);
	Array_fixed_u8_1 read_buf = {0};
	int bytes_read = 0;
	for (;;) {
		if (!(bytes_read < frame->payload_len)) break;
		_result_int _t2 = net__websocket__Client_socket_read_ptr(ws, &read_buf[0], 1);
		if (_t2.is_error) {
			_result_Array_u8 _t3;
			memcpy(&_t3, &_t2, sizeof(_result));
			return _t3;
		}
		
 		int len =  (*(int*)_t2.data);
		if (len != 1) {
			return (_result_Array_u8){ .is_error=true, .err=_v_error(_SLIT("expected read all message, got zero")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		bytes_read += len;
		array_push_noscan((array*)&buffer, _MOV((u8[]){ read_buf[0] }));
	}
	if (bytes_read != frame->payload_len) {
		return (_result_Array_u8){ .is_error=true, .err=_v_error(_SLIT("failed to read payload")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	if (frame->has_mask) {
		for (int i = 0; i < frame->payload_len; ++i) {
			(*(u8*)array_get(buffer, i)) ^= (frame->masking_key[v_fixed_index((int_literal)(i % 4), 4)] & 0xff);
		}
	}
	_result_Array_u8 _t7;
	_result_ok(&(Array_u8[]) { buffer }, (_result*)(&_t7), sizeof(Array_u8));
	return _t7;
}

VV_LOCAL_SYMBOL _result_void net__websocket__Client_validate_utf_8(net__websocket__Client* ws, net__websocket__OPCode opcode, Array_u8 payload) {
	if ((opcode == net__websocket__OPCode__text_frame || opcode == net__websocket__OPCode__close) && !encoding__utf8__validate(payload.data, payload.len)) {
		log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("malformed utf8 payload, payload len: ("), /*100 &int*/0xfe07, {.d_i32 = payload.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		net__websocket__Client_send_error_event(ws, _SLIT("Received malformed utf8."));
		_result_void _t1 = net__websocket__Client_close(ws, 1007, _SLIT("malformed utf8 payload"));
		if (_t1.is_error) {
			_result_void _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 ;
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("malformed utf8 payload")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	return (_result_void){0};
}

_result_net__websocket__Message net__websocket__Client_read_next_message(net__websocket__Client* ws) {
	bool net__websocket__Client_read_next_message_defer_0 = false;
	for (;;) {
		_result_net__websocket__Frame _t1 = net__websocket__Client_parse_frame_header(ws);
		if (_t1.is_error) {
			_result_net__websocket__Message _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 		net__websocket__Frame frame =  (*(net__websocket__Frame*)_t1.data);
		_result_void _t3 = net__websocket__Client_validate_frame(ws, &frame);
		if (_t3.is_error) {
			_result_net__websocket__Message _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 ;
		_result_Array_u8 _t5 = net__websocket__Client_read_payload(ws, &frame);
		if (_t5.is_error) {
			_result_net__websocket__Message _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 		Array_u8 frame_payload =  (*(Array_u8*)_t5.data);
		if (net__websocket__is_control_frame(frame.opcode)) {
			net__websocket__Message msg = ((net__websocket__Message){.opcode = ((net__websocket__OPCode)(frame.opcode)),.payload = array_clone_to_depth_noscan(&frame_payload, 0),});
			array_free(&frame_payload);
			_result_net__websocket__Message _t7;
			_result_ok(&(net__websocket__Message[]) { msg }, (_result*)(&_t7), sizeof(net__websocket__Message));
			return _t7;
		}
		if (!frame.fin) {
			array_push((array*)&ws->fragments, _MOV((net__websocket__Fragment[]){ *((net__websocket__Fragment*)memdup(&(net__websocket__Fragment){.data = array_clone_to_depth_noscan(&frame_payload, 0),.opcode = frame.opcode,}, sizeof(net__websocket__Fragment))) }));
			array_free(&frame_payload);
			continue;
		}
		if (ws->fragments.len == 0) {
			_result_void _t9 = net__websocket__Client_validate_utf_8(ws, frame.opcode, frame_payload);
			if (_t9.is_error) {
				IError err = _t9.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("UTF8 validation error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT(", len of payload("), /*100 &int*/0xfe07, {.d_i32 = frame_payload.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
				net__websocket__Client_send_error_event(ws,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("UTF8 validation error: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT(", len of payload("), /*100 &int*/0xfe07, {.d_i32 = frame_payload.len}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
				return (_result_net__websocket__Message){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			
 ;
			net__websocket__Message msg = ((net__websocket__Message){.opcode = ((net__websocket__OPCode)(frame.opcode)),.payload = array_clone_to_depth_noscan(&frame_payload, 0),});
			array_free(&frame_payload);
			_result_net__websocket__Message _t11;
			_result_ok(&(net__websocket__Message[]) { msg }, (_result*)(&_t11), sizeof(net__websocket__Message));
			return _t11;
		}
		net__websocket__Client_read_next_message_defer_0 = true;
		if (net__websocket__is_data_frame(frame.opcode)) {
			_result_void _t12 = net__websocket__Client_close(ws, 0, _SLIT(""));
			if (_t12.is_error) {
				// Defer begin
				if (net__websocket__Client_read_next_message_defer_0) {
					ws->fragments = __new_array_with_default(0, 0, sizeof(net__websocket__Fragment), 0);
				}
				// Defer end
				_result_net__websocket__Message _t13;
				memcpy(&_t13, &_t12, sizeof(_result));
				return _t13;
			}
			
 ;
			_result_net__websocket__Message _t14 = (_result_net__websocket__Message){ .is_error=true, .err=_v_error(_SLIT("Unexpected frame opcode")), .data={EMPTY_STRUCT_INITIALIZATION} };
				// Defer begin
				if (net__websocket__Client_read_next_message_defer_0) {
					ws->fragments = __new_array_with_default(0, 0, sizeof(net__websocket__Fragment), 0);
				}
				// Defer end
			return _t14;
		}
		_result_Array_u8 _t15 = net__websocket__Client_payload_from_fragments(/*rec*/*ws, frame_payload);
		if (_t15.is_error) {
			// Defer begin
			if (net__websocket__Client_read_next_message_defer_0) {
				ws->fragments = __new_array_with_default(0, 0, sizeof(net__websocket__Fragment), 0);
			}
			// Defer end
			_result_net__websocket__Message _t16;
			memcpy(&_t16, &_t15, sizeof(_result));
			return _t16;
		}
		
 		Array_u8 payload =  (*(Array_u8*)_t15.data);
		net__websocket__OPCode opcode = net__websocket__Client_opcode_from_fragments(/*rec*/*ws);
		_result_void _t17 = net__websocket__Client_validate_utf_8(ws, opcode, payload);
		if (_t17.is_error) {
			// Defer begin
			if (net__websocket__Client_read_next_message_defer_0) {
				ws->fragments = __new_array_with_default(0, 0, sizeof(net__websocket__Fragment), 0);
			}
			// Defer end
			_result_net__websocket__Message _t18;
			memcpy(&_t18, &_t17, sizeof(_result));
			return _t18;
		}
		
 ;
		net__websocket__Message msg = ((net__websocket__Message){.opcode = opcode,.payload = array_clone_to_depth_noscan(&payload, 0),});
		{ // Unsafe block
			array_free(&frame_payload);
			array_free(&payload);
		}
		_result_net__websocket__Message _t19;
		_result_ok(&(net__websocket__Message[]) { msg }, (_result*)(&_t19), sizeof(net__websocket__Message));
			// Defer begin
			if (net__websocket__Client_read_next_message_defer_0) {
				ws->fragments = __new_array_with_default(0, 0, sizeof(net__websocket__Fragment), 0);
			}
			// Defer end
		return _t19;
	}
	_result_net__websocket__Message _t20 = (_result_net__websocket__Message){ .is_error=true, .err=_v_error(_SLIT("none")), .data={EMPTY_STRUCT_INITIALIZATION} };
		// Defer begin
		if (net__websocket__Client_read_next_message_defer_0) {
			ws->fragments = __new_array_with_default(0, 0, sizeof(net__websocket__Fragment), 0);
		}
		// Defer end
	return _t20;
}

VV_LOCAL_SYMBOL _result_Array_u8 net__websocket__Client_payload_from_fragments(net__websocket__Client ws, Array_u8 fin_payload) {
	int total_size = 0;
	for (int _t1 = 0; _t1 < ws.fragments.len; ++_t1) {
		net__websocket__Fragment f = ((net__websocket__Fragment*)ws.fragments.data)[_t1];
		if (f.data.len > 0) {
			total_size += f.data.len;
		}
	}
	total_size += fin_payload.len;
	if (total_size == 0) {
		_result_Array_u8 _t2;
		_result_ok(&(Array_u8[]) { __new_array_with_default_noscan(0, 0, sizeof(u8), 0) }, (_result*)(&_t2), sizeof(Array_u8));
		return _t2;
	}
	Array_u8 total_buffer = __new_array_with_default_noscan(0, total_size, sizeof(u8), 0);
	for (int _t3 = 0; _t3 < ws.fragments.len; ++_t3) {
		net__websocket__Fragment f = ((net__websocket__Fragment*)ws.fragments.data)[_t3];
		if (f.data.len > 0) {
			_PUSH_MANY_noscan(&total_buffer, (f.data), _t4, Array_u8);
		}
	}
	_PUSH_MANY_noscan(&total_buffer, (fin_payload), _t5, Array_u8);
	_result_Array_u8 _t6;
	_result_ok(&(Array_u8[]) { total_buffer }, (_result*)(&_t6), sizeof(Array_u8));
	return _t6;
}

VV_LOCAL_SYMBOL net__websocket__OPCode net__websocket__Client_opcode_from_fragments(net__websocket__Client ws) {
	net__websocket__OPCode _t1 = ((net__websocket__OPCode)((*(net__websocket__Fragment*)array_get(ws.fragments, 0)).opcode));
	return _t1;
}

_result_net__websocket__Frame net__websocket__Client_parse_frame_header(net__websocket__Client* ws) {
	Array_fixed_u8_256 buffer = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	int bytes_read = 0;
	net__websocket__Frame frame = ((net__websocket__Frame){.header_len = 2,.frame_size = 2,.fin = 0,.rsv1 = 0,.rsv2 = 0,.rsv3 = 0,.opcode = 0x00,.has_mask = 0,.payload_len = 0,.masking_key = {0, 0, 0, 0},});
	Array_fixed_u8_1 rbuff = {0};
	int mask_end_byte = 0;
	for (;;) {
		if (!(net__websocket__Client_get_state(ws) == net__websocket__State__open)) break;
		_result_int _t1 = net__websocket__Client_socket_read_ptr(ws, &rbuff[0], 1);
		if (_t1.is_error) {
			_result_net__websocket__Frame _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 		int read_bytes =  (*(int*)_t1.data);
		if (read_bytes == 0) {
			continue;
		}
		buffer[v_fixed_index(bytes_read, 256)] = rbuff[0];
		bytes_read++;
		if (bytes_read == _const_net__websocket__header_len_offset) {
			frame.fin = ((buffer[0] & 0x80)) == 0x80;
			frame.rsv1 = ((buffer[0] & 0x40)) == 0x40;
			frame.rsv2 = ((buffer[0] & 0x20)) == 0x20;
			frame.rsv3 = ((buffer[0] & 0x10)) == 0x10;
			frame.opcode = ((net__websocket__OPCode)(((int)((buffer[0] & 0x7F)))));
			frame.has_mask = ((buffer[1] & 0x80)) == 0x80;
			frame.payload_len = (buffer[1] & 0x7F);
			if (frame.has_mask) {
				mask_end_byte = (frame.payload_len < 126 ? ((int_literal)(_const_net__websocket__header_len_offset + 4)) : frame.payload_len == 126 ? ((int_literal)(_const_net__websocket__header_len_offset + 6)) : frame.payload_len == 127 ? ((int_literal)(_const_net__websocket__header_len_offset + 12)) : (0));
			}
			frame.payload_len = frame.payload_len;
			frame.frame_size = (int)(frame.header_len + frame.payload_len);
			if (!frame.has_mask && frame.payload_len < 126) {
				break;
			}
		}
		if (frame.payload_len == 126 && bytes_read == _const_net__websocket__extended_payload16_end_byte) {
			frame.header_len += 2;
			frame.payload_len = 0;
			frame.payload_len |= ((int)((((u32)(buffer[2])) << 8U)));
			frame.payload_len |= ((int)(buffer[3]));
			frame.frame_size = (int)(frame.header_len + frame.payload_len);
			if (!frame.has_mask) {
				break;
			}
		}
		if (frame.payload_len == 127 && bytes_read == _const_net__websocket__extended_payload64_end_byte) {
			frame.header_len += 8;
			u64 payload_len = ((u64)(0U));
			payload_len |= (((u64)(buffer[2])) << 56U);
			payload_len |= (((u64)(buffer[3])) << 48U);
			payload_len |= (((u64)(buffer[4])) << 40U);
			payload_len |= (((u64)(buffer[5])) << 32U);
			payload_len |= (((u64)(buffer[6])) << 24U);
			payload_len |= (((u64)(buffer[7])) << 16U);
			payload_len |= (((u64)(buffer[8])) << 8U);
			payload_len |= ((u64)(buffer[9]));
			frame.payload_len = ((int)(payload_len));
			if (!frame.has_mask) {
				break;
			}
		}
		if (frame.has_mask && bytes_read == mask_end_byte) {
			frame.masking_key[0] = buffer[v_fixed_index((int)(mask_end_byte - 4), 256)];
			frame.masking_key[1] = buffer[v_fixed_index((int)(mask_end_byte - 3), 256)];
			frame.masking_key[2] = buffer[v_fixed_index((int)(mask_end_byte - 2), 256)];
			frame.masking_key[3] = buffer[v_fixed_index((int)(mask_end_byte - 1), 256)];
			break;
		}
	}
	_result_net__websocket__Frame _t3;
	_result_ok(&(net__websocket__Frame[]) { frame }, (_result*)(&_t3), sizeof(net__websocket__Frame));
	return _t3;
}

VV_LOCAL_SYMBOL void net__websocket__Frame_unmask_sequence(net__websocket__Frame* f, Array_u8* buffer) {
	for (int i = 0; i < buffer->len; ++i) {
		(*(u8*)array_get(*buffer, i)) ^= (f->masking_key[v_fixed_index((int_literal)(i % 4), 4)] & 0xff);
	}
}

string net__websocket__Uri_str(net__websocket__Uri u) {
	string _t1 = u.url;
	return _t1;
}

VV_LOCAL_SYMBOL Array_u8 net__websocket__htonl64(u64 payload_len) {
	Array_u8 ret = __new_array_with_default_noscan(8, 0, sizeof(u8), 0);
	encoding__binary__big_endian_put_u64(&/*arr*/ret, payload_len);
	return ret;
}

VV_LOCAL_SYMBOL Array_u8 net__websocket__create_masking_key(void) {
	_result_Array_u8 _t2 = rand__bytes(4);
	if (_t2.is_error) {
		IError err = _t2.err;
		*(Array_u8*) _t2.data = new_array_from_c_array_noscan(4, 4, sizeof(int), _MOV((int[4]){0, 0, 0, 0}));
	}
	
 	Array_u8 _t1 =  (*(Array_u8*)_t2.data);
	return _t1;
}

VV_LOCAL_SYMBOL _result_string net__websocket__create_key_challenge_response(string seckey) {
	if (seckey.len == 0) {
		return (_result_string){ .is_error=true, .err=_v_error(_SLIT("unexpected seckey length zero")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string guid = _SLIT("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
	string sha1buf = string__plus(seckey, guid);
	Array_u8 shabytes = string_bytes(sha1buf);
	Array_u8 hash = crypto__sha1__sum(shabytes);
	string b64 = encoding__base64__encode(hash);
	{ // Unsafe block
		array_free(&hash);
		array_free(&shabytes);
	}
	_result_string _t2;
	_result_ok(&(string[]) { b64 }, (_result*)(&_t2), sizeof(string));
	return _t2;
}

VV_LOCAL_SYMBOL string net__websocket__get_nonce(int nonce_size) {
	string _t1 = rand__string_from_set(_SLIT("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz"), nonce_size);
	return _t1;
}

_result_net__websocket__Client_ptr net__websocket__new_client(string address, net__websocket__ClientOpt opt) {
	_result_net__websocket__Uri_ptr _t1 = net__websocket__parse_uri(address);
	if (_t1.is_error) {
		_result_net__websocket__Client_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__websocket__Uri* uri =  (*(net__websocket__Uri**)_t1.data);
		_result_net__ssl__SSLConn_ptr _t4 = net__ssl__new_ssl_conn(((net__ssl__SSLConnectConfig){.SSLConnectConfig = ((net__mbedtls__SSLConnectConfig){.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.validate = 0,.in_memory_verification = 0,}),}));
		if (_t4.is_error) {
			_result_net__websocket__Client_ptr _t5;
			memcpy(&_t5, &_t4, sizeof(_result));
			return _t5;
		}
		
 	_result_net__websocket__Client_ptr _t3;
	_result_ok(&(net__websocket__Client*[]) { ((net__websocket__Client*)memdup(&(net__websocket__Client){.is_server = false,
		.ssl_conn =  (*(net__ssl__SSLConn**)_t4.data),
		.flags = __new_array_noscan(0, 0, sizeof(net__websocket__Flag)),
		.fragments = __new_array(0, 0, sizeof(net__websocket__Fragment)),
		.message_callbacks = __new_array(0, 0, sizeof(net__websocket__MessageEventHandler)),
		.error_callbacks = __new_array(0, 0, sizeof(net__websocket__ErrorEventHandler)),
		.open_callbacks = __new_array(0, 0, sizeof(net__websocket__OpenEventHandler)),
		.close_callbacks = __new_array(0, 0, sizeof(net__websocket__CloseEventHandler)),
		.is_ssl = string_starts_with(address, _SLIT("wss")),
		.uri = *uri,
		.id = rand__uuid_v4(),
		.read_timeout = opt.read_timeout,
		.write_timeout = opt.write_timeout,
		.header = net__http__new_header(__new_array(0, 0, sizeof(net__http__HeaderConfig))),
		.conn = ((void*)0),
		.nonce_size = 16,
		.panic_on_callback = 0,
		.client_state = (__shared__net__websocket__ClientState*)__dup__shared__net__websocket__ClientState(&(__shared__net__websocket__ClientState){.mtx = {0}, .val =
		((net__websocket__ClientState){.state = net__websocket__State__closed,})}, sizeof(__shared__net__websocket__ClientState))
		,
		.logger = opt.logger,
		.resource_name = (string){.str=(byteptr)"", .is_lit=1},
		.last_pong_ut = 0,
	}, sizeof(net__websocket__Client))) }, (_result*)(&_t3), sizeof(net__websocket__Client*));
	return _t3;
}

_result_void net__websocket__Client_connect(net__websocket__Client* ws) {
	_result_void _t1 = net__websocket__Client_assert_not_connected(ws);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	net__websocket__Client_set_state(ws, net__websocket__State__connecting);
	log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("connecting to host "), /*115 &net.websocket.Uri*/0xfe10, {.d_s = net__websocket__Uri_str(ws->uri)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	_result_net__TcpConn_ptr _t3 = net__websocket__Client_dial_socket(ws);
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	ws->conn =  (*(net__TcpConn**)_t3.data);
	_result_void _t5 = net__websocket__Client_handshake(ws);
	if (_t5.is_error) {
		_result_void _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 ;
	net__websocket__Client_set_state(ws, net__websocket__State__open);
	log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("successfully connected to host "), /*115 &net.websocket.Uri*/0xfe10, {.d_s = net__websocket__Uri_str(ws->uri)}}, {_SLIT0, 0, { .d_c = 0 }}})));
	net__websocket__Client_send_open_event(ws);
	return (_result_void){0};
}

_result_void net__websocket__Client_listen(net__websocket__Client* ws) {
	bool net__websocket__Client_listen_defer_0 = false;
	bool net__websocket__Client_listen_defer_1 = false;
	string log_msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Starting client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}}));
	log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object, log_msg);
	string_free(&log_msg);
	net__websocket__Client_listen_defer_0 = true;
	for (;;) {
		if (!(net__websocket__Client_get_state(ws) == net__websocket__State__open)) break;
		_result_net__websocket__Message _t1 = net__websocket__Client_read_next_message(ws);
		if (_t1.is_error) {
			IError err = _t1.err;
			if (net__websocket__Client_get_state(ws) == net__websocket__State__closed || net__websocket__Client_get_state(ws) == net__websocket__State__closing) {
					// Defer begin
					if (net__websocket__Client_listen_defer_0) {
						log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
						if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
							_result_void _t2 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
							if (_t2.is_error) {
								IError err = _t2.err;
							}
							
 ;
						}
					}
					// Defer end
				return (_result_void){0};
			}
			net__websocket__Client_debug_log(ws,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to read next message: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			net__websocket__Client_send_error_event(ws,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("failed to read next message: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
			_result_void _t3 = (_result_void){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
				// Defer begin
				if (net__websocket__Client_listen_defer_0) {
					log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
					if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
						_result_void _t4 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
						if (_t4.is_error) {
							IError err = _t4.err;
						}
						
 ;
					}
				}
				// Defer end
			return _t3;
		}
		
 		net__websocket__Message msg =  (*(net__websocket__Message*)_t1.data);
		if (net__websocket__Client_get_state(ws) == net__websocket__State__closed || net__websocket__Client_get_state(ws) == net__websocket__State__closing) {
				// Defer begin
				if (net__websocket__Client_listen_defer_0) {
					log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
					if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
						_result_void _t5 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
						if (_t5.is_error) {
							IError err = _t5.err;
						}
						
 ;
					}
				}
				// Defer end
			return (_result_void){0};
		}
		net__websocket__Client_debug_log(ws,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("got message: "), /*115 &net.websocket.OPCode*/0xfe10, {.d_s = net__websocket__OPCode_str(msg.opcode)}}, {_SLIT0, 0, { .d_c = 0 }}})));

		if (msg.opcode == (net__websocket__OPCode__text_frame)) {
			net__websocket__Client_debug_log(ws, _SLIT("read: text"));
			net__websocket__Client_send_message_event(ws, (voidptr)&/*qq*/msg);
			net__websocket__Message_free(&msg);
		}
		else if (msg.opcode == (net__websocket__OPCode__binary_frame)) {
			net__websocket__Client_debug_log(ws, _SLIT("read: binary"));
			net__websocket__Client_send_message_event(ws, (voidptr)&/*qq*/msg);
			net__websocket__Message_free(&msg);
		}
		else if (msg.opcode == (net__websocket__OPCode__ping)) {
			net__websocket__Client_debug_log(ws, _SLIT("read: ping, sending pong"));
			_result_void _t6 = net__websocket__Client_send_control_frame(ws, net__websocket__OPCode__pong, _SLIT("PONG"), msg.payload);
			if (_t6.is_error) {
				IError err = _t6.err;
				log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("error in message callback sending PONG: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				net__websocket__Client_send_error_event(ws,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("error in message callback sending PONG: "), /*115 &IError*/0xfe10, {.d_s = IError_str(err)}}, {_SLIT0, 0, { .d_c = 0 }}})));
				if (ws->panic_on_callback) {
					_v_panic(IError_str(err));
					VUNREACHABLE();
				}
				continue;
			}
			
 ;
			if (msg.payload.len > 0) {
				net__websocket__Message_free(&msg);
			}
		}
		else if (msg.opcode == (net__websocket__OPCode__pong)) {
			net__websocket__Client_debug_log(ws, _SLIT("read: pong"));
			ws->last_pong_ut = time__now().__v_unix;
			net__websocket__Client_send_message_event(ws, (voidptr)&/*qq*/msg);
			if (msg.payload.len > 0) {
				net__websocket__Message_free(&msg);
			}
		}
		else if (msg.opcode == (net__websocket__OPCode__close)) {
			net__websocket__Client_debug_log(ws, _SLIT("read: close"));
			net__websocket__Client_listen_defer_1 = true;
			if (msg.payload.len > 0) {
				if (msg.payload.len == 1) {
					_result_void _t7 = net__websocket__Client_close(ws, 1002, _SLIT("close payload cannot be 1 byte"));
					if (_t7.is_error) {
						// Defer begin
						if (net__websocket__Client_listen_defer_1) {
							net__websocket__Client_manage_clean_close(ws);
						}
						// Defer end
						// Defer begin
						if (net__websocket__Client_listen_defer_0) {
							log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
							if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
								_result_void _t8 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
								if (_t8.is_error) {
									IError err = _t8.err;
								}
								
 ;
							}
						}
						// Defer end
						_result_void _t9;
						memcpy(&_t9, &_t7, sizeof(_result));
						return _t9;
					}
					
 ;
					_result_void _t10 = (_result_void){ .is_error=true, .err=_v_error(_SLIT("close payload cannot be 1 byte")), .data={EMPTY_STRUCT_INITIALIZATION} };
						// Defer begin
						if (net__websocket__Client_listen_defer_1) {
							net__websocket__Client_manage_clean_close(ws);
						}
						// Defer end
						// Defer begin
						if (net__websocket__Client_listen_defer_0) {
							log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
							if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
								_result_void _t11 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
								if (_t11.is_error) {
									IError err = _t11.err;
								}
								
 ;
							}
						}
						// Defer end
					return _t10;
				}
				u16 code = ((((u16)((*(u8*)array_get(msg.payload, 0)))) << 8U) | ((u16)((*(u8*)array_get(msg.payload, 1)))));
				if (Array_int_contains(_const_net__websocket__invalid_close_codes, code)) {
					_result_void _t12 = net__websocket__Client_close(ws, 1002,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid close code: "), /*117 &u16*/0xfe04, {.d_u16 = code}}, {_SLIT0, 0, { .d_c = 0 }}})));
					if (_t12.is_error) {
						// Defer begin
						if (net__websocket__Client_listen_defer_1) {
							net__websocket__Client_manage_clean_close(ws);
						}
						// Defer end
						// Defer begin
						if (net__websocket__Client_listen_defer_0) {
							log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
							if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
								_result_void _t13 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
								if (_t13.is_error) {
									IError err = _t13.err;
								}
								
 ;
							}
						}
						// Defer end
						_result_void _t14;
						memcpy(&_t14, &_t12, sizeof(_result));
						return _t14;
					}
					
 ;
					_result_void _t15 = (_result_void){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("invalid close code: "), /*117 &u16*/0xfe04, {.d_u16 = code}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
						// Defer begin
						if (net__websocket__Client_listen_defer_1) {
							net__websocket__Client_manage_clean_close(ws);
						}
						// Defer end
						// Defer begin
						if (net__websocket__Client_listen_defer_0) {
							log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
							if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
								_result_void _t16 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
								if (_t16.is_error) {
									IError err = _t16.err;
								}
								
 ;
							}
						}
						// Defer end
					return _t15;
				}
				Array_u8 reason = (msg.payload.len > 2 ? (array_slice(msg.payload, 2, 2147483647)) : (__new_array_with_default_noscan(0, 0, sizeof(u8), 0)));
				if (reason.len > 0) {
					_result_void _t17 = net__websocket__Client_validate_utf_8(ws, net__websocket__OPCode__close, reason);
					if (_t17.is_error) {
						// Defer begin
						if (net__websocket__Client_listen_defer_1) {
							net__websocket__Client_manage_clean_close(ws);
						}
						// Defer end
						// Defer begin
						if (net__websocket__Client_listen_defer_0) {
							log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
							if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
								_result_void _t18 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
								if (_t18.is_error) {
									IError err = _t18.err;
								}
								
 ;
							}
						}
						// Defer end
						_result_void _t19;
						memcpy(&_t19, &_t17, sizeof(_result));
						return _t19;
					}
					
 ;
				}
				if (!(net__websocket__Client_get_state(ws) == net__websocket__State__closing || net__websocket__Client_get_state(ws) == net__websocket__State__closed)) {
					net__websocket__Client_debug_log(ws,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("close with reason, code: "), /*117 &u16*/0xfe04, {.d_u16 = code}}, {_SLIT(", reason: "), /*115 &[]u8*/0xfe10, {.d_s = Array_u8_str(reason)}}, {_SLIT0, 0, { .d_c = 0 }}})));
					string r = Array_u8_bytestr(reason);
					_result_void _t20 = net__websocket__Client_close(ws, code, r);
					if (_t20.is_error) {
						// Defer begin
						if (net__websocket__Client_listen_defer_1) {
							net__websocket__Client_manage_clean_close(ws);
						}
						// Defer end
						// Defer begin
						if (net__websocket__Client_listen_defer_0) {
							log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
							if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
								_result_void _t21 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
								if (_t21.is_error) {
									IError err = _t21.err;
								}
								
 ;
							}
						}
						// Defer end
						_result_void _t22;
						memcpy(&_t22, &_t20, sizeof(_result));
						return _t22;
					}
					
 ;
				}
				net__websocket__Message_free(&msg);
			} else {
				if (!(net__websocket__Client_get_state(ws) == net__websocket__State__closing || net__websocket__Client_get_state(ws) == net__websocket__State__closed)) {
					net__websocket__Client_debug_log(ws, _SLIT("close with reason, no code"));
					_result_void _t23 = net__websocket__Client_close(ws, 1000, _SLIT("normal"));
					if (_t23.is_error) {
						// Defer begin
						if (net__websocket__Client_listen_defer_1) {
							net__websocket__Client_manage_clean_close(ws);
						}
						// Defer end
						// Defer begin
						if (net__websocket__Client_listen_defer_0) {
							log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
							if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
								_result_void _t24 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
								if (_t24.is_error) {
									IError err = _t24.err;
								}
								
 ;
							}
						}
						// Defer end
						_result_void _t25;
						memcpy(&_t25, &_t23, sizeof(_result));
						return _t25;
					}
					
 ;
				}
				net__websocket__Message_free(&msg);
			}
				// Defer begin
				if (net__websocket__Client_listen_defer_1) {
					net__websocket__Client_manage_clean_close(ws);
				}
				// Defer end
				// Defer begin
				if (net__websocket__Client_listen_defer_0) {
					log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
					if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
						_result_void _t26 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
						if (_t26.is_error) {
							IError err = _t26.err;
						}
						
 ;
					}
				}
				// Defer end
			return (_result_void){0};
		}
		else if (msg.opcode == (net__websocket__OPCode__continuation)) {
			log__Logger_name_table[ws->logger->_typ]._method__v_error(ws->logger->_object, _SLIT("unexpected opcode continuation, nothing to continue"));
			net__websocket__Client_send_error_event(ws, _SLIT("unexpected opcode continuation, nothing to continue"));
			_result_void _t27 = net__websocket__Client_close(ws, 1002, _SLIT("nothing to continue"));
			if (_t27.is_error) {
				// Defer begin
				if (net__websocket__Client_listen_defer_1) {
					net__websocket__Client_manage_clean_close(ws);
				}
				// Defer end
				// Defer begin
				if (net__websocket__Client_listen_defer_0) {
					log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
					if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
						_result_void _t28 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
						if (_t28.is_error) {
							IError err = _t28.err;
						}
						
 ;
					}
				}
				// Defer end
				_result_void _t29;
				memcpy(&_t29, &_t27, sizeof(_result));
				return _t29;
			}
			
 ;
			_result_void _t30 = (_result_void){ .is_error=true, .err=_v_error(_SLIT("unexpected opcode continuation, nothing to continue")), .data={EMPTY_STRUCT_INITIALIZATION} };
				// Defer begin
				if (net__websocket__Client_listen_defer_1) {
					net__websocket__Client_manage_clean_close(ws);
				}
				// Defer end
				// Defer begin
				if (net__websocket__Client_listen_defer_0) {
					log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
					if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
						_result_void _t31 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
						if (_t31.is_error) {
							IError err = _t31.err;
						}
						
 ;
					}
				}
				// Defer end
			return _t30;
		}
	}
		// Defer begin
		if (net__websocket__Client_listen_defer_1) {
			net__websocket__Client_manage_clean_close(ws);
		}
		// Defer end
		// Defer begin
		if (net__websocket__Client_listen_defer_0) {
			log__Logger_name_table[ws->logger->_typ]._method_info(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Quit client listener, server("), /*115 &bool*/0xfe10, {.d_s = ws->is_server ? _SLIT("true") : _SLIT("false")}}, {_SLIT(")..."), 0, { .d_c = 0 }}})));
			if (net__websocket__Client_get_state(ws) == net__websocket__State__open) {
				_result_void _t32 = net__websocket__Client_close(ws, 1000, _SLIT("closed by client"));
				if (_t32.is_error) {
					IError err = _t32.err;
				}
				
 ;
			}
		}
		// Defer end
	return (_result_void){0};
}

VV_LOCAL_SYMBOL void net__websocket__Client_manage_clean_close(net__websocket__Client* ws) {
	net__websocket__Client_send_close_event(ws, 1000, _SLIT("closed by client"));
}

_result_void net__websocket__Client_ping(net__websocket__Client* ws) {
	_result_void _t1 = net__websocket__Client_send_control_frame(ws, net__websocket__OPCode__ping, _SLIT("PING"), __new_array_with_default_noscan(0, 0, sizeof(u8), 0));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

_result_void net__websocket__Client_pong(net__websocket__Client* ws) {
	_result_void _t1 = net__websocket__Client_send_control_frame(ws, net__websocket__OPCode__pong, _SLIT("PONG"), __new_array_with_default_noscan(0, 0, sizeof(u8), 0));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

_result_int net__websocket__Client_write_ptr(net__websocket__Client* ws, u8* bytes, int payload_len, net__websocket__OPCode code) {
	if (net__websocket__Client_get_state(ws) != net__websocket__State__open || ws->conn->sock.Socket.handle < 1) {
		return (_result_int){ .is_error=true, .err=_v_error(_SLIT("trying to write on a closed socket!")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int header_len = (int)((int)(2 + (payload_len > 125 ? (2) : (0))) + (payload_len > 0xffff ? (6) : (0)));
	if (!ws->is_server) {
		header_len += 4;
	}
	Array_u8 header = __new_array_with_default_noscan(header_len, 0, sizeof(u8), &(u8[]){'0'});
	array_set(&header, 0, &(u8[]) { (((u8)(((int)(code)))) | 0x80) });
	Array_u8 masking_key = net__websocket__create_masking_key();
	if (ws->is_server) {
		if (payload_len <= 125) {
			array_set(&header, 1, &(u8[]) { ((u8)(payload_len)) });
		} else if (payload_len > 125 && payload_len <= 0xffff) {
			u16 len16 = net__conv__hton16(((u16)(payload_len)));
			array_set(&header, 1, &(u8[]) { 126 });
			vmemcpy(&(*(u8*)array_get(header, 2)), &len16, 2);
		} else if (payload_len > 0xffff && payload_len <= 0x7fffffff) {
			Array_u8 len_bytes = net__websocket__htonl64(((u64)(payload_len)));
			array_set(&header, 1, &(u8[]) { 127 });
			vmemcpy(&(*(u8*)array_get(header, 2)), len_bytes.data, 8);
		}
	} else {
		if (payload_len <= 125) {
			array_set(&header, 1, &(u8[]) { ((u8)((payload_len | 0x80))) });
			array_set(&header, 2, &(u8[]) { (*(u8*)array_get(masking_key, 0)) });
			array_set(&header, 3, &(u8[]) { (*(u8*)array_get(masking_key, 1)) });
			array_set(&header, 4, &(u8[]) { (*(u8*)array_get(masking_key, 2)) });
			array_set(&header, 5, &(u8[]) { (*(u8*)array_get(masking_key, 3)) });
		} else if (payload_len > 125 && payload_len <= 0xffff) {
			u16 len16 = net__conv__hton16(((u16)(payload_len)));
			array_set(&header, 1, &(u8[]) { ((126 | 0x80)) });
			vmemcpy(&(*(u8*)array_get(header, 2)), &len16, 2);
			array_set(&header, 4, &(u8[]) { (*(u8*)array_get(masking_key, 0)) });
			array_set(&header, 5, &(u8[]) { (*(u8*)array_get(masking_key, 1)) });
			array_set(&header, 6, &(u8[]) { (*(u8*)array_get(masking_key, 2)) });
			array_set(&header, 7, &(u8[]) { (*(u8*)array_get(masking_key, 3)) });
		} else if (payload_len > 0xffff && payload_len <= 0x7fffffff) {
			Array_u8 len64 = net__websocket__htonl64(((u64)(payload_len)));
			array_set(&header, 1, &(u8[]) { ((127 | 0x80)) });
			vmemcpy(&(*(u8*)array_get(header, 2)), len64.data, 8);
			array_set(&header, 10, &(u8[]) { (*(u8*)array_get(masking_key, 0)) });
			array_set(&header, 11, &(u8[]) { (*(u8*)array_get(masking_key, 1)) });
			array_set(&header, 12, &(u8[]) { (*(u8*)array_get(masking_key, 2)) });
			array_set(&header, 13, &(u8[]) { (*(u8*)array_get(masking_key, 3)) });
		} else {
			_result_void _t2 = net__websocket__Client_close(ws, 1009, _SLIT("frame too large"));
			if (_t2.is_error) {
				_result_int _t3;
				memcpy(&_t3, &_t2, sizeof(_result));
				return _t3;
			}
			
 ;
			return (_result_int){ .is_error=true, .err=_v_error(_SLIT("frame too large")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
	}
	int len = (int)(header.len + payload_len);
	Array_u8 frame_buf = __new_array_with_default_noscan(len, 0, sizeof(u8), 0);
	{ // Unsafe block
		vmemcpy(&(*(u8*)array_get(frame_buf, 0)), ((u8*)(header.data)), header.len);
		if (payload_len > 0) {
			vmemcpy(&(*(u8*)array_get(frame_buf, header.len)), bytes, payload_len);
		}
	}
	if (!ws->is_server) {
		for (int i = 0; i < payload_len; ++i) {
			(*(u8*)array_get(frame_buf, (int)(header_len + i))) ^= ((*(u8*)array_get(masking_key, (int_literal)(i % 4))) & 0xff);
		}
	}
	_result_int _t5 = net__websocket__Client_socket_write(ws, frame_buf);
	if (_t5.is_error) {
		_result_int _t6;
		memcpy(&_t6, &_t5, sizeof(_result));
		return _t6;
	}
	
 	int written_len =  (*(int*)_t5.data);
	{ // Unsafe block
		array_free(&frame_buf);
		array_free(&masking_key);
		array_free(&header);
	}
	_result_int _t7;
	_result_ok(&(int[]) { written_len }, (_result*)(&_t7), sizeof(int));
	return _t7;
}

_result_int net__websocket__Client_write(net__websocket__Client* ws, Array_u8 bytes, net__websocket__OPCode code) {
	_result_int _t1 = net__websocket__Client_write_ptr(ws, ((u8*)(bytes.data)), bytes.len, code);
	return _t1;
}

_result_int net__websocket__Client_write_string(net__websocket__Client* ws, string str) {
	_result_int _t1 = net__websocket__Client_write_ptr(ws, str.str, str.len, net__websocket__OPCode__text_frame);
	return _t1;
}

_result_void net__websocket__Client_close(net__websocket__Client* ws, int code, string message) {
	bool net__websocket__Client_close_defer_0 = false;
	net__websocket__Client_debug_log(ws,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("sending close, "), /*100 &int*/0xfe07, {.d_i32 = code}}, {_SLIT(", "), /*115 &string*/0xfe10, {.d_s = message}}, {_SLIT0, 0, { .d_c = 0 }}})));
	net__websocket__State ws_state = net__websocket__Client_get_state(ws);
	if ((ws_state == net__websocket__State__closed || ws_state == net__websocket__State__closing) || ws->conn->sock.Socket.handle <= 1) {
		net__websocket__Client_debug_log(ws,  str_intp(5, _MOV((StrIntpData[]){{_SLIT("close: Websocket already closed ("), /*115 &net.websocket.State*/0xfe10, {.d_s = net__websocket__State_str(ws_state)}}, {_SLIT("), "), /*115 &string*/0xfe10, {.d_s = message}}, {_SLIT(", "), /*100 &int*/0xfe07, {.d_i32 = code}}, {_SLIT(" handle("), /*100 &int*/0xfe07, {.d_i32 = ws->conn->sock.Socket.handle}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		string err_msg =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Socket already closed: "), /*100 &int*/0xfe07, {.d_i32 = code}}, {_SLIT0, 0, { .d_c = 0 }}}));
		return (_result_void){ .is_error=true, .err=_v_error(err_msg), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	net__websocket__Client_close_defer_0 = true;
	net__websocket__Client_set_state(ws, net__websocket__State__closing);
	if (code > 0) {
		u16 code_ = net__conv__hton16(((u16)(code)));
		int message_len = (int)(message.len + 2);
		Array_u8 close_frame = __new_array_with_default_noscan(message_len, 0, sizeof(u8), 0);
		array_set(&close_frame, 0, &(u8[]) { ((u8)((code_ & 0xFFU))) });
		array_set(&close_frame, 1, &(u8[]) { ((u8)((code_ >> 8U))) });
		for (int i = 0; i < message.len; ++i) {
			array_set(&close_frame, (int_literal)(i + 2), &(u8[]) { string_at(message, i) });
		}
		_result_void _t2 = net__websocket__Client_send_control_frame(ws, net__websocket__OPCode__close, _SLIT("CLOSE"), close_frame);
		if (_t2.is_error) {
			// Defer begin
			if (net__websocket__Client_close_defer_0) {
				_result_void _t3 = net__websocket__Client_shutdown_socket(ws);
				if (_t3.is_error) {
					IError err = _t3.err;
				}
				
 ;
				_result_void _t4 = net__websocket__Client_reset_state(ws);
				if (_t4.is_error) {
					IError err = _t4.err;
				}
				
 ;
				net__websocket__Client_send_close_event(ws, code, message);
			}
			// Defer end
			_result_void _t5;
			memcpy(&_t5, &_t2, sizeof(_result));
			return _t5;
		}
		
 ;
		array_free(&close_frame);
	} else {
		_result_void _t6 = net__websocket__Client_send_control_frame(ws, net__websocket__OPCode__close, _SLIT("CLOSE"), __new_array_with_default_noscan(0, 0, sizeof(u8), 0));
		if (_t6.is_error) {
			// Defer begin
			if (net__websocket__Client_close_defer_0) {
				_result_void _t7 = net__websocket__Client_shutdown_socket(ws);
				if (_t7.is_error) {
					IError err = _t7.err;
				}
				
 ;
				_result_void _t8 = net__websocket__Client_reset_state(ws);
				if (_t8.is_error) {
					IError err = _t8.err;
				}
				
 ;
				net__websocket__Client_send_close_event(ws, code, message);
			}
			// Defer end
			_result_void _t9;
			memcpy(&_t9, &_t6, sizeof(_result));
			return _t9;
		}
		
 ;
	}
	ws->fragments = __new_array_with_default(0, 0, sizeof(net__websocket__Fragment), 0);
		// Defer begin
		if (net__websocket__Client_close_defer_0) {
			_result_void _t10 = net__websocket__Client_shutdown_socket(ws);
			if (_t10.is_error) {
				IError err = _t10.err;
			}
			
 ;
			_result_void _t11 = net__websocket__Client_reset_state(ws);
			if (_t11.is_error) {
				IError err = _t11.err;
			}
			
 ;
			net__websocket__Client_send_close_event(ws, code, message);
		}
		// Defer end
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void net__websocket__Client_send_control_frame(net__websocket__Client* ws, net__websocket__OPCode code, string frame_typ, Array_u8 payload) {
	bool net__websocket__Client_send_control_frame_defer_0 = false;
	Array_u8 control_frame;
	Array_u8 masking_key;
	net__websocket__Client_debug_log(ws,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("send control frame "), /*115 &net.websocket.OPCode*/0xfe10, {.d_s = net__websocket__OPCode_str(code)}}, {_SLIT(", frame_type: "), /*115 &string*/0xfe10, {.d_s = frame_typ}}, {_SLIT0, 0, { .d_c = 0 }}})));
	if (!(net__websocket__Client_get_state(ws) == net__websocket__State__open || net__websocket__Client_get_state(ws) == net__websocket__State__closing) && ws->conn->sock.Socket.handle > 1) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("socket is not connected")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int header_len = (ws->is_server ? (2) : (6));
	int frame_len = (int)(header_len + payload.len);
	control_frame = __new_array_with_default_noscan(frame_len, 0, sizeof(u8), 0);
	masking_key = (!ws->is_server ? (net__websocket__create_masking_key()) : (_const_net__websocket__empty_bytearr));
	net__websocket__Client_send_control_frame_defer_0 = true;
	array_set(&control_frame, 0, &(u8[]) { ((u8)((((int)(code)) | 0x80))) });
	if (!ws->is_server) {
		array_set(&control_frame, 1, &(u8[]) { ((u8)((payload.len | 0x80))) });
		array_set(&control_frame, 2, &(u8[]) { (*(u8*)array_get(masking_key, 0)) });
		array_set(&control_frame, 3, &(u8[]) { (*(u8*)array_get(masking_key, 1)) });
		array_set(&control_frame, 4, &(u8[]) { (*(u8*)array_get(masking_key, 2)) });
		array_set(&control_frame, 5, &(u8[]) { (*(u8*)array_get(masking_key, 3)) });
	} else {
		array_set(&control_frame, 1, &(u8[]) { ((u8)(payload.len)) });
	}
	if (code == net__websocket__OPCode__close) {
		if (payload.len >= 2) {
			if (!ws->is_server) {
				Array_u8 parsed_payload = __new_array_with_default_noscan((int)(payload.len + 1), 0, sizeof(u8), 0);
				vmemcpy(parsed_payload.data, &(*(u8*)array_get(payload, 0)), payload.len);
				array_set(&parsed_payload, payload.len, &(u8[]) { '\0' });
				for (int i = 0; i < payload.len; ++i) {
					array_set(&control_frame, (int_literal)(6 + i), &(u8[]) { ((((*(u8*)array_get(parsed_payload, i)) ^ (*(u8*)array_get(masking_key, (int_literal)(i % 4))))) & 0xff) });
				}
				array_free(&parsed_payload);
			} else {
				vmemcpy(&(*(u8*)array_get(control_frame, 2)), &(*(u8*)array_get(payload, 0)), payload.len);
			}
		}
	} else {
		if (!ws->is_server) {
			if (payload.len > 0) {
				for (int i = 0; i < payload.len; ++i) {
					array_set(&control_frame, (int)(header_len + i), &(u8[]) { ((((*(u8*)array_get(payload, i)) ^ (*(u8*)array_get(masking_key, (int_literal)(i % 4))))) & 0xff) });
				}
			}
		} else {
			if (payload.len > 0) {
				vmemcpy(&(*(u8*)array_get(control_frame, 2)), &(*(u8*)array_get(payload, 0)), payload.len);
			}
		}
	}
	_result_int _t2 = net__websocket__Client_socket_write(ws, control_frame);
	if (_t2.is_error) {
		IError err = _t2.err;
		_result_void _t3 = (_result_void){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("send_control_frame: error sending "), /*115 &string*/0xfe10, {.d_s = frame_typ}}, {_SLIT(" control frame."), 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (net__websocket__Client_send_control_frame_defer_0) {
				{ // Unsafe block
					array_free(&control_frame);
					if (masking_key.len > 0) {
						array_free(&masking_key);
					}
				}
			}
			// Defer end
		return _t3;
	}
	
  (*(int*)_t2.data);
		// Defer begin
		if (net__websocket__Client_send_control_frame_defer_0) {
			{ // Unsafe block
				array_free(&control_frame);
				if (masking_key.len > 0) {
					array_free(&masking_key);
				}
			}
		}
		// Defer end
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_net__websocket__Uri_ptr net__websocket__parse_uri(string url) {
	_result_net__urllib__URL _t1 = net__urllib__parse(url);
	if (_t1.is_error) {
		_result_net__websocket__Uri_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__urllib__URL u =  (*(net__urllib__URL*)_t1.data);
	string request_uri = net__urllib__URL_request_uri(&u);
	Array_string v = string_split(request_uri, _SLIT("?"));
	string port = net__urllib__URL_port(&u);
	string uri = net__urllib__URL_str(&u);
	if ((port).len == 0) {
		port = (string_starts_with(uri, _SLIT("ws://")) ? (_SLIT("80")) : string_starts_with(uri, _SLIT("wss://")) ? (_SLIT("443")) : (net__urllib__URL_port(&u)));
	}
	string querystring = (v.len > 1 ? (string__plus(_SLIT("?"), (*(string*)array_get(v, 1)))) : (_SLIT("")));
	_result_net__websocket__Uri_ptr _t3;
	_result_ok(&(net__websocket__Uri*[]) { ((net__websocket__Uri*)memdup(&(net__websocket__Uri){.url = url,.hostname = net__urllib__URL_hostname(&u),.port = port,.resource = (*(string*)array_get(v, 0)),.querystring = querystring,}, sizeof(net__websocket__Uri))) }, (_result*)(&_t3), sizeof(net__websocket__Uri*));
	return _t3;
}

void net__websocket__Client_set_state(net__websocket__Client* ws, net__websocket__State state) {
	sync__RwMutex_lock(&ws->client_state->mtx);
	/*lock*/ {
		ws->client_state->val.state = state;
	}
	sync__RwMutex_unlock(&ws->client_state->mtx);;
}

net__websocket__State net__websocket__Client_get_state(net__websocket__Client* ws) {
net__websocket__State _t2;
	sync__RwMutex_rlock(&ws->client_state->mtx);
	/*lock*/ {
		_t2 = ws->client_state->val.state;
	;
	}
	sync__RwMutex_runlock(&ws->client_state->mtx);
		net__websocket__State _t1 = _t2;
	return _t1;
}

VV_LOCAL_SYMBOL _result_void net__websocket__Client_assert_not_connected(net__websocket__Client* ws) {
	net__websocket__State /*A*/ _t1 = net__websocket__Client_get_state(ws);
	
	if (_t1 == (net__websocket__State__connecting)) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("connect: websocket is connecting")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	else if (_t1 == (net__websocket__State__open)) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("connect: websocket already open")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	else if (_t1 == (net__websocket__State__closing)) {
		return (_result_void){ .is_error=true, .err=_v_error(_SLIT("connect: reconnect on closing websocket not supported, please use new client")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	else {
	}
	return (_result_void){0};
}

_result_void net__websocket__Client_reset_state(net__websocket__Client* ws) {
	sync__RwMutex_lock(&ws->client_state->mtx);
	/*lock*/ {
		ws->client_state->val.state = net__websocket__State__closed;
		_result_net__ssl__SSLConn_ptr _t1 = net__ssl__new_ssl_conn(((net__ssl__SSLConnectConfig){.SSLConnectConfig = ((net__mbedtls__SSLConnectConfig){.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.validate = 0,.in_memory_verification = 0,}),}));
		if (_t1.is_error) {
			_result_void _t2;
			memcpy(&_t2, &_t1, sizeof(_result));
			return _t2;
		}
		
 		ws->ssl_conn =  (*(net__ssl__SSLConn**)_t1.data);
		ws->flags = __new_array_with_default_noscan(0, 0, sizeof(net__websocket__Flag), 0);
		ws->fragments = __new_array_with_default(0, 0, sizeof(net__websocket__Fragment), 0);
	}
	sync__RwMutex_unlock(&ws->client_state->mtx);;
	return (_result_void){0};
}

VV_LOCAL_SYMBOL void net__websocket__Client_debug_log(net__websocket__Client* ws, string text) {
	if (ws->is_server) {
		log__Logger_name_table[ws->logger->_typ]._method_debug(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> "), /*115 &string*/0xfe10, {.d_s = text}}, {_SLIT0, 0, { .d_c = 0 }}})));
	} else {
		log__Logger_name_table[ws->logger->_typ]._method_debug(ws->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("client-> "), /*115 &string*/0xfe10, {.d_s = text}}, {_SLIT0, 0, { .d_c = 0 }}})));
	}
}

void net__websocket__Message_free(net__websocket__Message* m) {
	array_free(&m->payload);
}

void net__websocket__Client_free(net__websocket__Client* c) {
	{ // Unsafe block
		array_free(&c->flags);
		array_free(&c->fragments);
		array_free(&c->message_callbacks);
		array_free(&c->error_callbacks);
		array_free(&c->open_callbacks);
		array_free(&c->close_callbacks);
		net__http__Header_free(&c->header);
	}
}

net__websocket__Server* net__websocket__new_server(net__AddrFamily family, int port, string route, net__websocket__ServerOpt opt) {
	net__websocket__Server* _t1 = ((net__websocket__Server*)memdup(&(net__websocket__Server){.logger = opt.logger,.ls = ((void*)0),.accept_client_callbacks = __new_array(0, 0, sizeof(net__websocket__AcceptClientFn)),.message_callbacks = __new_array(0, 0, sizeof(net__websocket__MessageEventHandler)),.close_callbacks = __new_array(0, 0, sizeof(net__websocket__CloseEventHandler)),.family = family,.port = port,.is_ssl = 0,.server_state = (__shared__net__websocket__ServerState*)__dup__shared__net__websocket__ServerState(&(__shared__net__websocket__ServerState){.mtx = {0}, .val = {.ping_interval = 30,.state = net__websocket__State__closed,.clients = new_map(sizeof(string), sizeof(net__websocket__ServerClient*), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}}, sizeof(__shared__net__websocket__ServerState)),}, sizeof(net__websocket__Server)));
	return _t1;
}

void net__websocket__Server_set_ping_interval(net__websocket__Server* s, int seconds) {
	sync__RwMutex_lock(&s->server_state->mtx);
	/*lock*/ {
		s->server_state->val.ping_interval = seconds;
	}
	sync__RwMutex_unlock(&s->server_state->mtx);;
}

int net__websocket__Server_get_ping_interval(net__websocket__Server* s) {
int _t2;
	sync__RwMutex_rlock(&s->server_state->mtx);
	/*lock*/ {
		_t2 = s->server_state->val.ping_interval;
	;
	}
	sync__RwMutex_runlock(&s->server_state->mtx);
		int _t1 = _t2;
	return _t1;
}

_result_void net__websocket__Server_listen(net__websocket__Server* s) {
	log__Logger_name_table[s->logger->_typ]._method_info(s->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("websocket server: start listen on port "), /*100 &int*/0xfe07, {.d_i32 = s->port}}, {_SLIT0, 0, { .d_c = 0 }}})));
	_result_net__TcpListener_ptr _t1 = net__listen_tcp(s->family,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(":"), /*100 &int*/0xfe07, {.d_i32 = s->port}}, {_SLIT0, 0, { .d_c = 0 }}})), ((net__ListenOptions){.dualstack = true,.backlog = 128,}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	s->ls =  (*(net__TcpListener**)_t1.data);
	net__websocket__Server_set_state(s, net__websocket__State__open);
	// start go
	thread_arg_net__websocket__Server_handle_ping *arg__t3 = (thread_arg_net__websocket__Server_handle_ping *) _v_malloc(sizeof(thread_arg_net__websocket__Server_handle_ping));
	arg__t3->fn = net__websocket__Server_handle_ping;
	arg__t3->arg0 = s;
	HANDLE thread__t3 = CreateThread(0, 8388608, (LPTHREAD_START_ROUTINE)net__websocket__Server_handle_ping_thread_wrapper, arg__t3, 0, 0); // fn: handle_ping
	if (!thread__t3) panic_lasterr(tos3("`go net__websocket__Server_handle_ping()`: "));
	CloseHandle(thread__t3);
	// end go
	;
	for (;;) {
		_result_net__websocket__Client_ptr _t5 = net__websocket__Server_accept_new_client(s);
		if (_t5.is_error) {
			IError err = _t5.err;
			continue;
		}
		
 		net__websocket__Client* c =  (*(net__websocket__Client**)_t5.data);
		// start go
		thread_arg_net__websocket__Server_serve_client *arg__t6 = (thread_arg_net__websocket__Server_serve_client *) _v_malloc(sizeof(thread_arg_net__websocket__Server_serve_client));
		arg__t6->fn = net__websocket__Server_serve_client;
		arg__t6->arg0 = s;
		arg__t6->arg1 = c;
		arg__t6->ret_ptr = (void *) _v_malloc(sizeof(_result_void));
		HANDLE thread__t6 = CreateThread(0, 8388608, (LPTHREAD_START_ROUTINE)net__websocket__Server_serve_client_thread_wrapper, arg__t6, 0, 0); // fn: serve_client
		if (!thread__t6) panic_lasterr(tos3("`go net__websocket__Server_serve_client()`: "));
		CloseHandle(thread__t6);
		// end go
		;
	}
	log__Logger_name_table[s->logger->_typ]._method_info(s->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("websocket server: end listen on port "), /*100 &int*/0xfe07, {.d_i32 = s->port}}, {_SLIT0, 0, { .d_c = 0 }}})));
	return (_result_void){0};
}

VV_LOCAL_SYMBOL void net__websocket__Server_close(net__websocket__Server* s) {
}

VV_LOCAL_SYMBOL void net__websocket__Server_handle_ping(net__websocket__Server* s) {
	Array_string clients_to_remove = __new_array_with_default(0, 0, sizeof(string), 0);
	for (;;) {
		if (!(net__websocket__Server_get_state(s) == net__websocket__State__open)) break;
		time__sleep(net__websocket__Server_get_ping_interval(s) * _const_time__second);
Map_string_net__websocket__ServerClient_ptr _t2;
		sync__RwMutex_rlock(&s->server_state->mtx);
		/*lock*/ {
			_t2 = s->server_state->val.clients;
		;
		}
		sync__RwMutex_runlock(&s->server_state->mtx);
				Map_string_net__websocket__ServerClient_ptr _t1 = _t2;
		int _t4 = _t1.key_values.len;
		for (int _t3 = 0; _t3 < _t4; ++_t3 ) {
			int _t5 = _t1.key_values.len - _t4;
			_t4 = _t1.key_values.len;
			if (_t5 < 0) {
				_t3 = -1;
				continue;
			}
			if (!DenseArray_has_index(&_t1.key_values, _t3)) {continue;}
			string i = /*key*/ *(string*)DenseArray_key(&_t1.key_values, _t3);
			i = string_clone(i);
net__websocket__ServerClient* _t6;
			sync__RwMutex_rlock(&s->server_state->mtx);
			/*lock*/ {
				net__websocket__ServerClient** _t8 = (net__websocket__ServerClient**)(map_get_check(ADDR(map, s->server_state->val.clients), &(string[]){i}));
				_option_net__websocket__ServerClient_ptr _t7 = {0};
				if (_t8) {
					*((net__websocket__ServerClient**)&_t7.data) = *((net__websocket__ServerClient**)_t8);
				} else {
					_t7.state = 2; _t7.err = _v_error(_SLIT("array index out of range"));
				}
				;
				if (_t7.state != 0) {
					IError err = _t7.err;
					sync__RwMutex_runlock(&s->server_state->mtx);continue;
				}
				
				_t6 = (*(net__websocket__ServerClient**)_t7.data);
			;
			}
			sync__RwMutex_runlock(&s->server_state->mtx);
						net__websocket__ServerClient* c = _t6;
			if (net__websocket__Client_get_state(c->client) == net__websocket__State__open) {
				_result_void _t9 = net__websocket__Client_ping(c->client);
				if (_t9.is_error) {
					IError err = _t9.err;
					log__Logger_name_table[s->logger->_typ]._method_debug(s->logger->_object, _SLIT("server-> error sending ping to client"));
					_result_void _t10 = net__websocket__Client_close(c->client, 1002, _SLIT("Closing connection: ping send error"));
					if (_t10.is_error) {
						IError err = _t10.err;
						continue;
					}
					
 ;
					array_push((array*)&clients_to_remove, _MOV((string[]){ string_clone(c->client->id) }));
				;
				}
				
 ;
				if (((i64)(time__now().__v_unix - c->client->last_pong_ut)) > (int)(net__websocket__Server_get_ping_interval(s) * 2)) {
					array_push((array*)&clients_to_remove, _MOV((string[]){ string_clone(c->client->id) }));
					_result_void _t13 = net__websocket__Client_close(c->client, 1000, _SLIT("no pong received"));
					if (_t13.is_error) {
						IError err = _t13.err;
						continue;
					}
					
 ;
				}
			}
		}
		for (int _t14 = 0; _t14 < clients_to_remove.len; ++_t14) {
			string client = ((string*)clients_to_remove.data)[_t14];
			sync__RwMutex_lock(&s->server_state->mtx);
			/*lock*/ {
				map_delete(&s->server_state->val.clients, &(string[]){client});
			}
			sync__RwMutex_unlock(&s->server_state->mtx);;
		}
		array_clear(&clients_to_remove);
	}
}

VV_LOCAL_SYMBOL _result_void net__websocket__Server_serve_client(net__websocket__Server* s, net__websocket__Client* c) {
	bool net__websocket__Server_serve_client_defer_0 = false;
	log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> Start serve client ("), /*115 &string*/0xfe10, {.d_s = c->id}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
	net__websocket__Server_serve_client_defer_0 = true;
	_result_multi_return_string_ref_net__websocket__ServerClient _t1 = net__websocket__Server_handle_server_handshake(s, c);
	if (_t1.is_error) {
		// Defer begin
		if (net__websocket__Server_serve_client_defer_0) {
			log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> End serve client ("), /*115 &string*/0xfe10, {.d_s = c->id}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		}
		// Defer end
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	multi_return_string_ref_net__websocket__ServerClient mr_4051 =  (*(multi_return_string_ref_net__websocket__ServerClient*)_t1.data);
	string handshake_response = mr_4051.arg0;
	net__websocket__ServerClient* server_client = mr_4051.arg1;
	_result_bool _t3 = net__websocket__Server_send_connect_event(s, server_client);
	if (_t3.is_error) {
		// Defer begin
		if (net__websocket__Server_serve_client_defer_0) {
			log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> End serve client ("), /*115 &string*/0xfe10, {.d_s = c->id}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		}
		// Defer end
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	bool accept =  (*(bool*)_t3.data);
	if (!accept) {
		log__Logger_name_table[s->logger->_typ]._method_debug(s->logger->_object, _SLIT("server-> client not accepted"));
		_result_void _t5 = net__websocket__Client_shutdown_socket(c);
		if (_t5.is_error) {
			// Defer begin
			if (net__websocket__Server_serve_client_defer_0) {
				log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> End serve client ("), /*115 &string*/0xfe10, {.d_s = c->id}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			}
			// Defer end
			_result_void _t6;
			memcpy(&_t6, &_t5, sizeof(_result));
			return _t6;
		}
		
 ;
			// Defer begin
			if (net__websocket__Server_serve_client_defer_0) {
				log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> End serve client ("), /*115 &string*/0xfe10, {.d_s = c->id}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			}
			// Defer end
		return (_result_void){0};
	}
	_result_int _t7 = net__websocket__Client_socket_write(c, string_bytes(handshake_response));
	if (_t7.is_error) {
		// Defer begin
		if (net__websocket__Server_serve_client_defer_0) {
			log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> End serve client ("), /*115 &string*/0xfe10, {.d_s = c->id}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		}
		// Defer end
		_result_void _t8;
		memcpy(&_t8, &_t7, sizeof(_result));
		return _t8;
	}
	
  (*(int*)_t7.data);
	sync__RwMutex_lock(&s->server_state->mtx);
	/*lock*/ {
		(*(net__websocket__ServerClient**)map_get_and_set((map*)&s->server_state->val.clients, &(string[]){server_client->client->id}, &(net__websocket__ServerClient*[]){ 0 })) = server_client;
	}
	sync__RwMutex_unlock(&s->server_state->mtx);;
	net__websocket__Server_setup_callbacks(s, server_client);
	_result_void _t9 = net__websocket__Client_listen(c);
	if (_t9.is_error) {
		IError err = _t9.err;
		log__Logger_name_table[s->logger->_typ]._method__v_error(s->logger->_object, IError_name_table[err._typ]._method_msg(err._object));
		_result_void _t10 = (_result_void){ .is_error=true, .err=err, .data={EMPTY_STRUCT_INITIALIZATION} };
			// Defer begin
			if (net__websocket__Server_serve_client_defer_0) {
				log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> End serve client ("), /*115 &string*/0xfe10, {.d_s = c->id}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
			}
			// Defer end
		return _t10;
	}
	
 ;
		// Defer begin
		if (net__websocket__Server_serve_client_defer_0) {
			log__Logger_name_table[c->logger->_typ]._method_debug(c->logger->_object,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("server-> End serve client ("), /*115 &string*/0xfe10, {.d_s = c->id}}, {_SLIT(")"), 0, { .d_c = 0 }}})));
		}
		// Defer end
	return (_result_void){0};
}

VV_LOCAL_SYMBOL void net__websocket__Server_setup_callbacks(net__websocket__Server* s, net__websocket__ServerClient* sc) {
	if (s->message_callbacks.len > 0) {
		for (int _t1 = 0; _t1 < s->message_callbacks.len; ++_t1) {
			net__websocket__MessageEventHandler cb = ((net__websocket__MessageEventHandler*)s->message_callbacks.data)[_t1];
			if (cb.is_ref) {
				net__websocket__Client_on_message_ref(sc->client, (voidptr)cb.handler2, cb.ref);
			} else {
				net__websocket__Client_on_message(sc->client, (voidptr)cb.handler);
			}
		}
	}
	if (s->close_callbacks.len > 0) {
		for (int _t2 = 0; _t2 < s->close_callbacks.len; ++_t2) {
			net__websocket__CloseEventHandler cb = ((net__websocket__CloseEventHandler*)s->close_callbacks.data)[_t2];
			if (cb.is_ref) {
				net__websocket__Client_on_close_ref(sc->client, (voidptr)cb.handler2, cb.ref);
			} else {
				net__websocket__Client_on_close(sc->client, (voidptr)cb.handler);
			}
		}
	}
	net__websocket__Client_on_close_ref(sc->client, (voidptr)	anon_fn_f5aad9dbbbe573d0_mut_net__websocket__client_int_string_mut_net__websocket__serverclient__result_void_5147, sc);
}

VV_LOCAL_SYMBOL _result_net__websocket__Client_ptr net__websocket__Server_accept_new_client(net__websocket__Server* s) {
	_result_net__TcpConn_ptr _t1 = net__TcpListener_accept(s->ls);
	if (_t1.is_error) {
		_result_net__websocket__Client_ptr _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__TcpConn* new_conn =  (*(net__TcpConn**)_t1.data);
		_result_net__ssl__SSLConn_ptr _t3 = net__ssl__new_ssl_conn(((net__ssl__SSLConnectConfig){.SSLConnectConfig = ((net__mbedtls__SSLConnectConfig){.verify = (string){.str=(byteptr)"", .is_lit=1},.cert = (string){.str=(byteptr)"", .is_lit=1},.cert_key = (string){.str=(byteptr)"", .is_lit=1},.validate = 0,.in_memory_verification = 0,}),}));
		if (_t3.is_error) {
			_result_net__websocket__Client_ptr _t4;
			memcpy(&_t4, &_t3, sizeof(_result));
			return _t4;
		}
		
 	net__websocket__Client* c = ((net__websocket__Client*)memdup(&(net__websocket__Client){.is_server = true,
		.ssl_conn =  (*(net__ssl__SSLConn**)_t3.data),
		.flags = __new_array_noscan(0, 0, sizeof(net__websocket__Flag)),
		.fragments = __new_array(0, 0, sizeof(net__websocket__Fragment)),
		.message_callbacks = __new_array(0, 0, sizeof(net__websocket__MessageEventHandler)),
		.error_callbacks = __new_array(0, 0, sizeof(net__websocket__ErrorEventHandler)),
		.open_callbacks = __new_array(0, 0, sizeof(net__websocket__OpenEventHandler)),
		.close_callbacks = __new_array(0, 0, sizeof(net__websocket__CloseEventHandler)),
		.is_ssl = 0,
		.uri = (net__websocket__Uri){.url = (string){.str=(byteptr)"", .is_lit=1},.hostname = (string){.str=(byteptr)"", .is_lit=1},.port = (string){.str=(byteptr)"", .is_lit=1},.resource = (string){.str=(byteptr)"", .is_lit=1},.querystring = (string){.str=(byteptr)"", .is_lit=1},},
		.id = rand__uuid_v4(),
		.read_timeout = 0,
		.write_timeout = 0,
		.header = (net__http__Header){.cur_pos = 0,},
		.conn = new_conn,
		.nonce_size = 16,
		.panic_on_callback = 0,
		.client_state = (__shared__net__websocket__ClientState*)__dup__shared__net__websocket__ClientState(&(__shared__net__websocket__ClientState){.mtx = {0}, .val =
		((net__websocket__ClientState){.state = net__websocket__State__open,})}, sizeof(__shared__net__websocket__ClientState))
		,
		.logger = s->logger,
		.resource_name = (string){.str=(byteptr)"", .is_lit=1},
		.last_pong_ut = time__now().__v_unix,
	}, sizeof(net__websocket__Client)));
	_result_net__websocket__Client_ptr _t5;
	_result_ok(&(net__websocket__Client*[]) { c }, (_result*)(&_t5), sizeof(net__websocket__Client*));
	return _t5;
}

void net__websocket__Server_set_state(net__websocket__Server* s, net__websocket__State state) {
	sync__RwMutex_lock(&s->server_state->mtx);
	/*lock*/ {
		s->server_state->val.state = state;
	}
	sync__RwMutex_unlock(&s->server_state->mtx);;
}

net__websocket__State net__websocket__Server_get_state(net__websocket__Server* s) {
net__websocket__State _t2;
	sync__RwMutex_rlock(&s->server_state->mtx);
	/*lock*/ {
		_t2 = s->server_state->val.state;
	;
	}
	sync__RwMutex_runlock(&s->server_state->mtx);
		net__websocket__State _t1 = _t2;
	return _t1;
}

void net__websocket__Server_free(net__websocket__Server* s) {
	sync__RwMutex_lock(&s->server_state->mtx);
	/*lock*/ {
		map_free(&s->server_state->val.clients);
	}
	sync__RwMutex_unlock(&s->server_state->mtx);;
	{ // Unsafe block
		array_free(&s->accept_client_callbacks);
		array_free(&s->message_callbacks);
		array_free(&s->close_callbacks);
	}
}

VV_LOCAL_SYMBOL int net__websocket__error_code(void) {
	int _t1 = WSAGetLastError();
	return _t1;
}

_result_void discord__Client_delete_channel(discord__Client _v_toheap_c, discord__Snowflake id, discord__WithReason config) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t1 = discord__Client_request((*(c)), net__http__Method__delete,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/channels/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(id))}}, {_SLIT0, 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = config.reason,.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(net__http__Response*)_t1.data);
	return (_result_void){0};
}

VV_LOCAL_SYMBOL log__Level discord__ClientConfig_get_level(discord__ClientConfig config) {
	log__Level _t1 = (config.debug ? (log__Level__debug) : (log__Level__info));
	return _t1;
}

discord__GatewayClient discord__bot(string token, discord__BotConfig config) {
	_option_discord__Properties _t2;
	_option_ok(&(discord__Properties[]) { config.properties }, (_option*)(&_t2), sizeof(discord__Properties));
	discord__GatewayClient _t1 = ((discord__GatewayClient){.Client = ((discord__Client){.token =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Bot "), /*115 &string*/0xfe10, {.d_s = token}}, {_SLIT0, 0, { .d_c = 0 }}})),.base_url = _SLIT("https://discord.com/api/v10"),.user_agent = config.ClientConfig.user_agent,.logger = I_log__Log_to_Interface_log__Logger(((log__Log*)memdup(&(log__Log){.level = discord__ClientConfig_get_level(config.ClientConfig),.output_label = _SLIT("discord.v"),.ofile = (os__File){.cfile = 0,.fd = 0,.is_opened = 0,},.output_target = 0,.output_file_name = (string){.str=(byteptr)"", .is_lit=1},}, sizeof(log__Log)))),.user_data = 0,}),.intents = ((int)(config.intents)),.properties = _t2,.gateway_url = _SLIT("wss://gateway.discord.gg"),.ws = ((void*)0),.ready = 0,.sequence = (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.on_raw_event = (discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient){.id = 0,.wait_fors = new_map_noscan_key(sizeof(int), sizeof(discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.listeners = new_map_noscan_key(sizeof(int), sizeof(anon_fn_discord__dispatchevent_t_discord__gatewayclient__result_void), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),},});
	return _t1;
}

discord__Client discord__bearer(string token, discord__ClientConfig config) {
	discord__Client _t1 = ((discord__Client){.token =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("Bearer "), /*115 &string*/0xfe10, {.d_s = token}}, {_SLIT0, 0, { .d_c = 0 }}})),.base_url = _SLIT("https://discord.com/api/v10"),.user_agent = config.user_agent,.logger = I_log__Log_to_Interface_log__Logger(((log__Log*)memdup(&(log__Log){.level = discord__ClientConfig_get_level(config),.output_label = _SLIT("discord.v"),.ofile = (os__File){.cfile = 0,.fd = 0,.is_opened = 0,},.output_target = 0,.output_file_name = (string){.str=(byteptr)"", .is_lit=1},}, sizeof(log__Log)))),.user_data = 0,});
	return _t1;
}

x__json2__Any discord__ComponentType_build(discord__ComponentType ct) {
	x__json2__Any _t1 = int_to_sumtype_x__json2__Any/*KEK*/(ADDR(int, (((int)(ct)))));
	return _t1;
}

VV_LOCAL_SYMBOL void discord__ActionRow_is_component(discord__ActionRow _d1) {
}

x__json2__Any discord__ActionRow_build(discord__ActionRow ar) {
	Array_x__json2__Any _t2 = {0};
	Array_discord__Component _t2_orig = ar.components;
	int _t2_len = _t2_orig.len;
	_t2 = __new_array(0, _t2_len, sizeof(x__json2__Any));

	for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
		discord__Component it = ((discord__Component*) _t2_orig.data)[_t4];
		x__json2__Any _t3 = discord__Component_name_table[it._typ]._method_build(it._object);
		array_push((array*)&_t2, &_t3);
	}
	x__json2__Any _t1 = Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[2]){
				_SLIT("type"), 
				_SLIT("components"), 
			}),
			_MOV((x__json2__Any[2]){
				discord__ComponentType_build(discord__ComponentType__action_row), 
				Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (_t2))), 
			})
		)
	
	)));
	return _t1;
}

x__json2__Any discord__ButtonStyle_build(discord__ButtonStyle bs) {
	x__json2__Any _t1 = int_to_sumtype_x__json2__Any/*KEK*/(ADDR(int, (((int)(bs)))));
	return _t1;
}

VV_LOCAL_SYMBOL void discord__Button_is_component(discord__Button _d2) {
}

x__json2__Any discord__Button_build(discord__Button b) {
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[2]){
				_SLIT("type"), 
				_SLIT("style"), 
			}),
			_MOV((x__json2__Any[2]){
				discord__ComponentType_build(discord__ComponentType__button), 
				discord__ButtonStyle_build(b.style), 
			})
		)
	
	;
	_option_string _t1;
	if (_t1 = b.label, _t1.state == 0) {
		string label = *(string*)_t1.data;
		map_set(&r, &(string[]){_SLIT("label")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&label) });
	}
	_option_discord__PartialEmoji _t2;
	if (_t2 = b.emoji, _t2.state == 0) {
		discord__PartialEmoji emoji = *(discord__PartialEmoji*)_t2.data;
		map_set(&r, &(string[]){_SLIT("emoji")}, &(x__json2__Any[]) { discord__PartialEmoji_build(emoji) });
	}
	_option_string _t3;
	if (_t3 = b.custom_id, _t3.state == 0) {
		string custom_id = *(string*)_t3.data;
		map_set(&r, &(string[]){_SLIT("custom_id")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&custom_id) });
	}
	_option_string _t4;
	if (_t4 = b.url, _t4.state == 0) {
		string url = *(string*)_t4.data;
		map_set(&r, &(string[]){_SLIT("url")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&url) });
	}
	_option_bool _t5;
	if (_t5 = b.disabled, _t5.state == 0) {
		bool disabled = *(bool*)_t5.data;
		map_set(&r, &(string[]){_SLIT("disabled")}, &(x__json2__Any[]) { bool_to_sumtype_x__json2__Any/*KEK*/(&disabled) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

x__json2__Any discord__SelectOption_build(discord__SelectOption so) {
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[2]){
				_SLIT("label"), 
				_SLIT("value"), 
			}),
			_MOV((x__json2__Any[2]){
				string_to_sumtype_x__json2__Any/*KEK*/(&so.label), 
				string_to_sumtype_x__json2__Any/*KEK*/(&so.value), 
			})
		)
	
	;
	_option_string _t1;
	if (_t1 = so.description, _t1.state == 0) {
		string description = *(string*)_t1.data;
		map_set(&r, &(string[]){_SLIT("description")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&description) });
	}
	_option_discord__PartialEmoji _t2;
	if (_t2 = so.emoji, _t2.state == 0) {
		discord__PartialEmoji emoji = *(discord__PartialEmoji*)_t2.data;
		map_set(&r, &(string[]){_SLIT("emoji")}, &(x__json2__Any[]) { discord__PartialEmoji_build(emoji) });
	}
	_option_bool _t3;
	if (_t3 = so.__v_default, _t3.state == 0) {
		bool __v_default = *(bool*)_t3.data;
		map_set(&r, &(string[]){_SLIT("default")}, &(x__json2__Any[]) { bool_to_sumtype_x__json2__Any/*KEK*/(&__v_default) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

VV_LOCAL_SYMBOL void discord__StringSelect_is_component(discord__StringSelect _d3) {
}

x__json2__Any discord__StringSelect_build(discord__StringSelect ss) {
	Array_x__json2__Any _t1 = {0};
	Array_discord__SelectOption _t1_orig = ss.options;
	int _t1_len = _t1_orig.len;
	_t1 = __new_array(0, _t1_len, sizeof(x__json2__Any));

	for (int _t3 = 0; _t3 < _t1_len; ++_t3) {
		discord__SelectOption it = ((discord__SelectOption*) _t1_orig.data)[_t3];
		x__json2__Any _t2 = discord__SelectOption_build(it);
		array_push((array*)&_t1, &_t2);
	}
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 4, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[4]){
				_SLIT("type"), 
				_SLIT("custom_id"), 
				_SLIT("options"), 
				_SLIT("disabled"), 
			}),
			_MOV((x__json2__Any[4]){
				discord__ComponentType_build(discord__ComponentType__string_select), 
				string_to_sumtype_x__json2__Any/*KEK*/(&ss.custom_id), 
				Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (_t1))), 
				bool_to_sumtype_x__json2__Any/*KEK*/(&ss.disabled), 
			})
		)
	
	;
	_option_string _t4;
	if (_t4 = ss.placeholder, _t4.state == 0) {
		string placeholder = *(string*)_t4.data;
		map_set(&r, &(string[]){_SLIT("placeholder")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&placeholder) });
	}
	_option_int _t5;
	if (_t5 = ss.min_values, _t5.state == 0) {
		int min_values = *(int*)_t5.data;
		map_set(&r, &(string[]){_SLIT("min_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&min_values) });
	}
	_option_int _t6;
	if (_t6 = ss.max_values, _t6.state == 0) {
		int max_values = *(int*)_t6.data;
		map_set(&r, &(string[]){_SLIT("max_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&max_values) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

VV_LOCAL_SYMBOL void discord__UserSelect_is_component(discord__UserSelect _d4) {
}

x__json2__Any discord__UserSelect_build(discord__UserSelect us) {
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 3, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[3]){
				_SLIT("type"), 
				_SLIT("custom_id"), 
				_SLIT("disabled"), 
			}),
			_MOV((x__json2__Any[3]){
				discord__ComponentType_build(discord__ComponentType__user_select), 
				string_to_sumtype_x__json2__Any/*KEK*/(&us.custom_id), 
				bool_to_sumtype_x__json2__Any/*KEK*/(&us.disabled), 
			})
		)
	
	;
	_option_string _t1;
	if (_t1 = us.placeholder, _t1.state == 0) {
		string placeholder = *(string*)_t1.data;
		map_set(&r, &(string[]){_SLIT("placeholder")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&placeholder) });
	}
	_option_Array_discord__Snowflake _t2;
	if (_t2 = us.default_values, _t2.state == 0) {
		Array_discord__Snowflake default_values = *(Array_discord__Snowflake*)_t2.data;
		Array_x__json2__Any _t3 = {0};
		Array_discord__Snowflake _t3_orig = default_values;
		int _t3_len = _t3_orig.len;
		_t3 = __new_array(0, _t3_len, sizeof(x__json2__Any));

		for (int _t5 = 0; _t5 < _t3_len; ++_t5) {
			discord__Snowflake it = ((discord__Snowflake*) _t3_orig.data)[_t5];
			x__json2__Any _t4 = Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[2]){
						_SLIT("id"), 
						_SLIT("type"), 
					}),
					_MOV((x__json2__Any[2]){
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (discord__Snowflake_build(it)))), 
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("user")))), 
					})
				)
			
			)));
			array_push((array*)&_t3, &_t4);
		}
		map_set(&r, &(string[]){_SLIT("default_values")}, &(x__json2__Any[]) { Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (_t3))) });
	}
	_option_int _t6;
	if (_t6 = us.min_values, _t6.state == 0) {
		int min_values = *(int*)_t6.data;
		map_set(&r, &(string[]){_SLIT("min_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&min_values) });
	}
	_option_int _t7;
	if (_t7 = us.max_values, _t7.state == 0) {
		int max_values = *(int*)_t7.data;
		map_set(&r, &(string[]){_SLIT("max_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&max_values) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

VV_LOCAL_SYMBOL void discord__RoleSelect_is_component(discord__RoleSelect _d5) {
}

x__json2__Any discord__RoleSelect_build(discord__RoleSelect rs) {
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 3, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[3]){
				_SLIT("type"), 
				_SLIT("custom_id"), 
				_SLIT("disabled"), 
			}),
			_MOV((x__json2__Any[3]){
				discord__ComponentType_build(discord__ComponentType__role_select), 
				string_to_sumtype_x__json2__Any/*KEK*/(&rs.custom_id), 
				bool_to_sumtype_x__json2__Any/*KEK*/(&rs.disabled), 
			})
		)
	
	;
	_option_string _t1;
	if (_t1 = rs.placeholder, _t1.state == 0) {
		string placeholder = *(string*)_t1.data;
		map_set(&r, &(string[]){_SLIT("placeholder")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&placeholder) });
	}
	_option_Array_discord__Snowflake _t2;
	if (_t2 = rs.default_values, _t2.state == 0) {
		Array_discord__Snowflake default_values = *(Array_discord__Snowflake*)_t2.data;
		Array_x__json2__Any _t3 = {0};
		Array_discord__Snowflake _t3_orig = default_values;
		int _t3_len = _t3_orig.len;
		_t3 = __new_array(0, _t3_len, sizeof(x__json2__Any));

		for (int _t5 = 0; _t5 < _t3_len; ++_t5) {
			discord__Snowflake it = ((discord__Snowflake*) _t3_orig.data)[_t5];
			x__json2__Any _t4 = Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[2]){
						_SLIT("id"), 
						_SLIT("type"), 
					}),
					_MOV((x__json2__Any[2]){
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (discord__Snowflake_build(it)))), 
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("role")))), 
					})
				)
			
			)));
			array_push((array*)&_t3, &_t4);
		}
		map_set(&r, &(string[]){_SLIT("default_values")}, &(x__json2__Any[]) { Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (_t3))) });
	}
	_option_int _t6;
	if (_t6 = rs.min_values, _t6.state == 0) {
		int min_values = *(int*)_t6.data;
		map_set(&r, &(string[]){_SLIT("min_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&min_values) });
	}
	_option_int _t7;
	if (_t7 = rs.max_values, _t7.state == 0) {
		int max_values = *(int*)_t7.data;
		map_set(&r, &(string[]){_SLIT("max_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&max_values) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

x__json2__Any discord__DefaultValue_build(discord__DefaultValue dv) {
	x__json2__Any _t2 = {0};
	
	if (dv.typ == (discord__DefaultValueType__user)) {
		_t2 = string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("user"))));
	}
	else if (dv.typ == (discord__DefaultValueType__role)) {
		_t2 = string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("role"))));
	}
	else if (dv.typ == (discord__DefaultValueType__channel)) {
		_t2 = string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("channel"))));
	}x__json2__Any _t1 = Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[2]){
				_SLIT("id"), 
				_SLIT("type"), 
			}),
			_MOV((x__json2__Any[2]){
				string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (discord__Snowflake_build(dv.id)))), 
				_t2, 
			})
		)
	
	)));
	return _t1;
}

VV_LOCAL_SYMBOL void discord__MentionableSelect_is_component(discord__MentionableSelect _d6) {
}

x__json2__Any discord__MentionableSelect_build(discord__MentionableSelect ms) {
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 3, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[3]){
				_SLIT("type"), 
				_SLIT("custom_id"), 
				_SLIT("disabled"), 
			}),
			_MOV((x__json2__Any[3]){
				discord__ComponentType_build(discord__ComponentType__mentionable_select), 
				string_to_sumtype_x__json2__Any/*KEK*/(&ms.custom_id), 
				bool_to_sumtype_x__json2__Any/*KEK*/(&ms.disabled), 
			})
		)
	
	;
	_option_string _t1;
	if (_t1 = ms.placeholder, _t1.state == 0) {
		string placeholder = *(string*)_t1.data;
		map_set(&r, &(string[]){_SLIT("placeholder")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&placeholder) });
	}
	_option_Array_discord__DefaultValue _t2;
	if (_t2 = ms.default_values, _t2.state == 0) {
		Array_discord__DefaultValue default_values = *(Array_discord__DefaultValue*)_t2.data;
		Array_x__json2__Any _t3 = {0};
		Array_discord__DefaultValue _t3_orig = default_values;
		int _t3_len = _t3_orig.len;
		_t3 = __new_array(0, _t3_len, sizeof(x__json2__Any));

		for (int _t5 = 0; _t5 < _t3_len; ++_t5) {
			discord__DefaultValue it = ((discord__DefaultValue*) _t3_orig.data)[_t5];
			x__json2__Any _t4 = discord__DefaultValue_build(it);
			array_push((array*)&_t3, &_t4);
		}
		map_set(&r, &(string[]){_SLIT("default_values")}, &(x__json2__Any[]) { Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (_t3))) });
	}
	_option_int _t6;
	if (_t6 = ms.min_values, _t6.state == 0) {
		int min_values = *(int*)_t6.data;
		map_set(&r, &(string[]){_SLIT("min_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&min_values) });
	}
	_option_int _t7;
	if (_t7 = ms.max_values, _t7.state == 0) {
		int max_values = *(int*)_t7.data;
		map_set(&r, &(string[]){_SLIT("max_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&max_values) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

VV_LOCAL_SYMBOL void discord__ChannelSelect_is_component(discord__ChannelSelect _d7) {
}

x__json2__Any discord__ChannelSelect_build(discord__ChannelSelect cs) {
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 3, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[3]){
				_SLIT("type"), 
				_SLIT("custom_id"), 
				_SLIT("disabled"), 
			}),
			_MOV((x__json2__Any[3]){
				discord__ComponentType_build(discord__ComponentType__channel_select), 
				string_to_sumtype_x__json2__Any/*KEK*/(&cs.custom_id), 
				bool_to_sumtype_x__json2__Any/*KEK*/(&cs.disabled), 
			})
		)
	
	;
	_option_Array_discord__ChannelType _t1;
	if (_t1 = cs.channel_types, _t1.state == 0) {
		Array_discord__ChannelType channel_types = *(Array_discord__ChannelType*)_t1.data;
		Array_x__json2__Any _t2 = {0};
		Array_discord__ChannelType _t2_orig = channel_types;
		int _t2_len = _t2_orig.len;
		_t2 = __new_array(0, _t2_len, sizeof(x__json2__Any));

		for (int _t4 = 0; _t4 < _t2_len; ++_t4) {
			discord__ChannelType it = ((discord__ChannelType*) _t2_orig.data)[_t4];
			x__json2__Any _t3 = int_to_sumtype_x__json2__Any/*KEK*/(ADDR(int, (((int)(it)))));
			array_push((array*)&_t2, &_t3);
		}
		map_set(&r, &(string[]){_SLIT("channel_types")}, &(x__json2__Any[]) { Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (_t2))) });
	}
	_option_string _t5;
	if (_t5 = cs.placeholder, _t5.state == 0) {
		string placeholder = *(string*)_t5.data;
		map_set(&r, &(string[]){_SLIT("placeholder")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&placeholder) });
	}
	_option_Array_discord__Snowflake _t6;
	if (_t6 = cs.default_values, _t6.state == 0) {
		Array_discord__Snowflake default_values = *(Array_discord__Snowflake*)_t6.data;
		Array_x__json2__Any _t7 = {0};
		Array_discord__Snowflake _t7_orig = default_values;
		int _t7_len = _t7_orig.len;
		_t7 = __new_array(0, _t7_len, sizeof(x__json2__Any));

		for (int _t9 = 0; _t9 < _t7_len; ++_t9) {
			discord__Snowflake it = ((discord__Snowflake*) _t7_orig.data)[_t9];
			x__json2__Any _t8 = Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
					_MOV((string[2]){
						_SLIT("id"), 
						_SLIT("type"), 
					}),
					_MOV((x__json2__Any[2]){
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (discord__Snowflake_build(it)))), 
						string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT("channel")))), 
					})
				)
			
			)));
			array_push((array*)&_t7, &_t8);
		}
		map_set(&r, &(string[]){_SLIT("default_values")}, &(x__json2__Any[]) { Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (_t7))) });
	}
	_option_int _t10;
	if (_t10 = cs.min_values, _t10.state == 0) {
		int min_values = *(int*)_t10.data;
		map_set(&r, &(string[]){_SLIT("min_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&min_values) });
	}
	_option_int _t11;
	if (_t11 = cs.max_values, _t11.state == 0) {
		int max_values = *(int*)_t11.data;
		map_set(&r, &(string[]){_SLIT("max_values")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&max_values) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

x__json2__Any discord__TextInputStyle_build(discord__TextInputStyle tis) {
	x__json2__Any _t1 = int_to_sumtype_x__json2__Any/*KEK*/(ADDR(int, (((int)(tis)))));
	return _t1;
}

VV_LOCAL_SYMBOL void discord__TextInput_is_component(discord__TextInput _d8) {
}

x__json2__Any discord__TextInput_build(discord__TextInput ti) {
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 5, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[5]){
				_SLIT("type"), 
				_SLIT("custom_id"), 
				_SLIT("style"), 
				_SLIT("label"), 
				_SLIT("required"), 
			}),
			_MOV((x__json2__Any[5]){
				discord__ComponentType_build(discord__ComponentType__text_input), 
				string_to_sumtype_x__json2__Any/*KEK*/(&ti.custom_id), 
				discord__TextInputStyle_build(ti.style), 
				string_to_sumtype_x__json2__Any/*KEK*/(&ti.label), 
				bool_to_sumtype_x__json2__Any/*KEK*/(&ti.required), 
			})
		)
	
	;
	_option_int _t1;
	if (_t1 = ti.min_length, _t1.state == 0) {
		int min_length = *(int*)_t1.data;
		map_set(&r, &(string[]){_SLIT("min_length")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&min_length) });
	}
	_option_int _t2;
	if (_t2 = ti.max_length, _t2.state == 0) {
		int max_length = *(int*)_t2.data;
		map_set(&r, &(string[]){_SLIT("max_length")}, &(x__json2__Any[]) { int_to_sumtype_x__json2__Any/*KEK*/(&max_length) });
	}
	_option_string _t3;
	if (_t3 = ti.value, _t3.state == 0) {
		string value = *(string*)_t3.data;
		map_set(&r, &(string[]){_SLIT("value")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&value) });
	}
	_option_string _t4;
	if (_t4 = ti.placeholder, _t4.state == 0) {
		string placeholder = *(string*)_t4.data;
		map_set(&r, &(string[]){_SLIT("placeholder")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&placeholder) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

_result_void discord__Client_create_dm(discord__Client _v_toheap_c, discord__Snowflake recipient_id) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_option_x__json2__Any _t2;
	_option_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 1, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[1]){
				_SLIT("recipient_id"), 
			}),
			_MOV((x__json2__Any[1]){
				discord__Snowflake_to_sumtype_x__json2__Any/*KEK*/(&recipient_id), 
			})
		)
	
	))) }, (_option*)(&_t2), sizeof(x__json2__Any));
	_result_net__http__Response _t1 = discord__Client_request((*(c)), net__http__Method__post, _SLIT("/users/@me/channels"), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t2,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t1.is_error) {
		_result_void _t3;
		memcpy(&_t3, &_t1, sizeof(_result));
		return _t3;
	}
	
  (*(net__http__Response*)_t1.data);
	return (_result_void){0};
}

_result_void discord__Client_create_group_dm(discord__Client _v_toheap_c, discord__CreateGroupDMParams params) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	Array_x__json2__Any _t3 = {0};
	Array_string _t3_orig = params.access_tokens;
	int _t3_len = _t3_orig.len;
	_t3 = __new_array(0, _t3_len, sizeof(x__json2__Any));

	for (int _t5 = 0; _t5 < _t3_len; ++_t5) {
		string it = ((string*) _t3_orig.data)[_t5];
		x__json2__Any _t4 = string_to_sumtype_x__json2__Any/*KEK*/(&it);
		array_push((array*)&_t3, &_t4);
	}
	_option_x__json2__Any _t2;
	_option_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[2]){
				_SLIT("access_tokens"), 
				_SLIT("nicks"), 
			}),
			_MOV((x__json2__Any[2]){
				Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (_t3))), 
				Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (maps__to_map_T_discord__Snowflake_string_string_x__json2__Any(params.nicks, (voidptr)	anon_fn_741189b08a0d001a_discord__snowflake_string__multi_return_string_x__json2__Any_630)))), 
			})
		)
	
	))) }, (_option*)(&_t2), sizeof(x__json2__Any));
	_result_net__http__Response _t1 = discord__Client_request((*(c)), net__http__Method__post, _SLIT("/users/@me/channels"), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t2,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t1.is_error) {
		_result_void _t6;
		memcpy(&_t6, &_t1, sizeof(_result));
		return _t6;
	}
	
  (*(net__http__Response*)_t1.data);
	return (_result_void){0};
}

x__json2__Any discord__PartialEmoji_build(discord__PartialEmoji pe) {
	x__json2__Any _t1; /* if prepend */
	_option_discord__Snowflake _t2;
	if (_t2 = pe.id, _t2.state == 0) {
		discord__Snowflake id = *(discord__Snowflake*)_t2.data;
		_t1 = string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (discord__Snowflake_build(id))));
	} else {
		IError err = _t2.err;
		_t1 = x__json2__Null_to_sumtype_x__json2__Any/*KEK*/(ADDR(x__json2__Null, (((x__json2__Null){.is_null = true,}))));
	}
	Map_string_x__json2__Any r = new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[2]){
				_SLIT("id"), 
				_SLIT("name"), 
			}),
			_MOV((x__json2__Any[2]){
				 _t1, 
				string_to_sumtype_x__json2__Any/*KEK*/(&pe.name), 
			})
		)
	
	;
	if (pe.id.state != 2) {
		map_set(&r, &(string[]){_SLIT("animated")}, &(x__json2__Any[]) { bool_to_sumtype_x__json2__Any/*KEK*/(&pe.animated) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

_result_discord__Emoji discord__Emoji__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t2 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("id")}));
		_option_x__json2__Any _t1 = {0};
		if (_t2) {
			*((x__json2__Any*)&_t1.data) = *((x__json2__Any*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t1.state != 0) {
			_result_discord__Emoji _t3;
			memcpy(&_t3, &_t1, sizeof(_result));
			return _t3;
		}
		
		x__json2__Any id = (*(x__json2__Any*)_t1.data);
		x__json2__Any* _t5 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
		_option_x__json2__Any _t4 = {0};
		if (_t5) {
			*((x__json2__Any*)&_t4.data) = *((x__json2__Any*)_t5);
		} else {
			_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t4.state != 0) {
			_result_discord__Emoji _t6;
			memcpy(&_t6, &_t4, sizeof(_result));
			return _t6;
		}
		
		x__json2__Any name = (*(x__json2__Any*)_t4.data);
		x__json2__Any* _t9 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("roles")}));
		_option_x__json2__Any _t8 = {0};
		if (_t9) {
			*((x__json2__Any*)&_t8.data) = *((x__json2__Any*)_t9);
		} else {
			_t8.state = 2; _t8.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_Array_discord__Snowflake _t7; /* if prepend */
		if (_t8.state == 0) {
			x__json2__Any a = (*(x__json2__Any*)_t8.data);
			Array_discord__Snowflake _t11 = {0};
			Array_x__json2__Any _t11_orig = (/* as */ *(Array_x__json2__Any*)__as_cast((a)._Array_x__json2__Any,(a)._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
			int _t11_len = _t11_orig.len;
			_t11 = __new_array_noscan(0, _t11_len, sizeof(discord__Snowflake));

			for (int _t13 = 0; _t13 < _t11_len; ++_t13) {
				x__json2__Any it = ((x__json2__Any*) _t11_orig.data)[_t13];
				_result_discord__Snowflake _t14 = discord__Snowflake__static__parse(it);
				if (_t14.is_error) {
					_result_discord__Emoji _t15;
					memcpy(&_t15, &_t14, sizeof(_result));
					return _t15;
				}
				
 				discord__Snowflake _t12 =  (*(discord__Snowflake*)_t14.data);
				array_push_noscan((array*)&_t11, &_t12);
			}
			_option_Array_discord__Snowflake _t10;
			_option_ok(&(Array_discord__Snowflake[]) {_t11 }, (_option*)(&_t10), sizeof(Array_discord__Snowflake));
			_t7 = _t10;
		} else {
			IError err = _t8.err;
			
			_t7 = (_option_Array_discord__Snowflake){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_option_Array_discord__Snowflake roles =  _t7;
		x__json2__Any* _t18 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("user")}));
		_option_x__json2__Any _t17 = {0};
		if (_t18) {
			*((x__json2__Any*)&_t17.data) = *((x__json2__Any*)_t18);
		} else {
			_t17.state = 2; _t17.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_discord__User _t16; /* if prepend */
		if (_t17.state == 0) {
			x__json2__Any o = (*(x__json2__Any*)_t17.data);
			_result_discord__User _t20 = discord__User__static__parse(o);
			if (_t20.is_error) {
				_result_discord__Emoji _t21;
				memcpy(&_t21, &_t20, sizeof(_result));
				return _t21;
			}
			
 			_option_discord__User _t19;
			_option_ok(&(discord__User[]) {  (*(discord__User*)_t20.data) }, (_option*)(&_t19), sizeof(discord__User));
			_t16 = _t19;
		} else {
			IError err = _t17.err;
			
			_t16 = (_option_discord__User){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		_option_discord__User user =  _t16;
			_option_discord__Snowflake _t23; /* if prepend */
			if ((id)._typ == 170 /* x.json2.Null */) {
				_t23.state = 2;
				_t23.err = _const_none__;
			} else {
				_result_discord__Snowflake _t24 = discord__Snowflake__static__parse(id);
				if (_t24.is_error) {
					_result_discord__Emoji _t25;
					memcpy(&_t25, &_t24, sizeof(_result));
					return _t25;
				}
				
 				_option_ok(&(discord__Emoji[]) {  (*(discord__Snowflake*)_t24.data) }, (_option*)(&_t23), sizeof(discord__Emoji));
			}
			_option_string _t26; /* if prepend */
			if ((name)._typ == 170 /* x.json2.Null */) {
				_t26.state = 2;
				_t26.err = _const_none__;
			} else {
				_option_string _t27;
				_option_ok(&(string[]) { /* as */ *(string*)__as_cast((name)._string,(name)._typ, 21) /*expected idx: 21, name: string */  }, (_option*)(&_t27), sizeof(string));
				_t26 = _t27;
			}
			x__json2__Any* _t30 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("require_colons")}));
			_option_x__json2__Any _t29 = {0};
			if (_t30) {
				*((x__json2__Any*)&_t29.data) = *((x__json2__Any*)_t30);
			} else {
				_t29.state = 2; _t29.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_bool _t28; /* if prepend */
			if (_t29.state == 0) {
				x__json2__Any b = (*(x__json2__Any*)_t29.data);
				_option_ok(&(discord__Emoji[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t28), sizeof(discord__Emoji));
			} else {
				IError err = _t29.err;
				
				_t28 = (_option_bool){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			x__json2__Any* _t33 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("managed")}));
			_option_x__json2__Any _t32 = {0};
			if (_t33) {
				*((x__json2__Any*)&_t32.data) = *((x__json2__Any*)_t33);
			} else {
				_t32.state = 2; _t32.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_bool _t31; /* if prepend */
			if (_t32.state == 0) {
				x__json2__Any b = (*(x__json2__Any*)_t32.data);
				_option_ok(&(discord__Emoji[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t31), sizeof(discord__Emoji));
			} else {
				IError err = _t32.err;
				
				_t31 = (_option_bool){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			x__json2__Any* _t36 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("animated")}));
			_option_x__json2__Any _t35 = {0};
			if (_t36) {
				*((x__json2__Any*)&_t35.data) = *((x__json2__Any*)_t36);
			} else {
				_t35.state = 2; _t35.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_bool _t34; /* if prepend */
			if (_t35.state == 0) {
				x__json2__Any b = (*(x__json2__Any*)_t35.data);
				_option_ok(&(discord__Emoji[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t34), sizeof(discord__Emoji));
			} else {
				IError err = _t35.err;
				
				_t34 = (_option_bool){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			x__json2__Any* _t39 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("available")}));
			_option_x__json2__Any _t38 = {0};
			if (_t39) {
				*((x__json2__Any*)&_t38.data) = *((x__json2__Any*)_t39);
			} else {
				_t38.state = 2; _t38.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_bool _t37; /* if prepend */
			if (_t38.state == 0) {
				x__json2__Any b = (*(x__json2__Any*)_t38.data);
				_option_ok(&(discord__Emoji[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t37), sizeof(discord__Emoji));
			} else {
				IError err = _t38.err;
				
				_t37 = (_option_bool){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		_result_discord__Emoji _t22;
		_result_ok(&(discord__Emoji[]) { ((discord__Emoji){
			.id =  _t23,
			.name =  _t26,
			.roles = roles,
			.user = user,
			.require_colons =  _t28,
			.managed =  _t31,
			.animated =  _t34,
			.available =  _t37,
		}) }, (_result*)(&_t22), sizeof(discord__Emoji));
		return _t22;
	}
	
	else {
		return (_result_discord__Emoji){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected emoji to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__Emoji){0};
}

_result_discord__Entitlement discord__Entitlement__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
			x__json2__Any* _t4 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("id")}));
			_option_x__json2__Any _t3 = {0};
			if (_t4) {
				*((x__json2__Any*)&_t3.data) = *((x__json2__Any*)_t4);
			} else {
				_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t3.state != 0) {
				_result_discord__Entitlement _t5;
				memcpy(&_t5, &_t3, sizeof(_result));
				return _t5;
			}
			
			_result_discord__Snowflake _t2 = discord__Snowflake__static__parse((*(x__json2__Any*)_t3.data));
			if (_t2.is_error) {
				_result_discord__Entitlement _t6;
				memcpy(&_t6, &_t2, sizeof(_result));
				return _t6;
			}
			x__json2__Any* _t9 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("sku_id")}));
			_option_x__json2__Any _t8 = {0};
			if (_t9) {
				*((x__json2__Any*)&_t8.data) = *((x__json2__Any*)_t9);
			} else {
				_t8.state = 2; _t8.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t8.state != 0) {
				_result_discord__Entitlement _t10;
				memcpy(&_t10, &_t8, sizeof(_result));
				return _t10;
			}
			
			_result_discord__Snowflake _t7 = discord__Snowflake__static__parse((*(x__json2__Any*)_t8.data));
			if (_t7.is_error) {
				_result_discord__Entitlement _t11;
				memcpy(&_t11, &_t7, sizeof(_result));
				return _t11;
			}
			x__json2__Any* _t14 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("application_id")}));
			_option_x__json2__Any _t13 = {0};
			if (_t14) {
				*((x__json2__Any*)&_t13.data) = *((x__json2__Any*)_t14);
			} else {
				_t13.state = 2; _t13.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t13.state != 0) {
				_result_discord__Entitlement _t15;
				memcpy(&_t15, &_t13, sizeof(_result));
				return _t15;
			}
			
			_result_discord__Snowflake _t12 = discord__Snowflake__static__parse((*(x__json2__Any*)_t13.data));
			if (_t12.is_error) {
				_result_discord__Entitlement _t16;
				memcpy(&_t16, &_t12, sizeof(_result));
				return _t16;
			}
			x__json2__Any* _t19 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("user_id")}));
			_option_x__json2__Any _t18 = {0};
			if (_t19) {
				*((x__json2__Any*)&_t18.data) = *((x__json2__Any*)_t19);
			} else {
				_t18.state = 2; _t18.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__Snowflake _t17; /* if prepend */
			if (_t18.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t18.data);
				_result_discord__Snowflake _t21 = discord__Snowflake__static__parse(s);
				if (_t21.is_error) {
					_result_discord__Entitlement _t22;
					memcpy(&_t22, &_t21, sizeof(_result));
					return _t22;
				}
				
 				_option_discord__Snowflake _t20;
				_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t21.data) }, (_option*)(&_t20), sizeof(discord__Snowflake));
				_t17 = _t20;
			} else {
				IError err = _t18.err;
				_t17.state = 2;
				_t17.err = _const_none__;
			}
			x__json2__Any* _t24 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("type")}));
			_option_x__json2__Any _t23 = {0};
			if (_t24) {
				*((x__json2__Any*)&_t23.data) = *((x__json2__Any*)_t24);
			} else {
				_t23.state = 2; _t23.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t23.state != 0) {
				_result_discord__Entitlement _t25;
				memcpy(&_t25, &_t23, sizeof(_result));
				return _t25;
			}
			x__json2__Any* _t27 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("type")}));
			_option_x__json2__Any _t26 = {0};
			if (_t27) {
				*((x__json2__Any*)&_t26.data) = *((x__json2__Any*)_t27);
			} else {
				_t26.state = 2; _t26.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t26.state != 0) {
				_result_discord__Entitlement _t28;
				memcpy(&_t28, &_t26, sizeof(_result));
				return _t28;
			}
			x__json2__Any* _t30 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("deleted")}));
			_option_x__json2__Any _t29 = {0};
			if (_t30) {
				*((x__json2__Any*)&_t29.data) = *((x__json2__Any*)_t30);
			} else {
				_t29.state = 2; _t29.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t29.state != 0) {
				_result_discord__Entitlement _t31;
				memcpy(&_t31, &_t29, sizeof(_result));
				return _t31;
			}
			x__json2__Any* _t33 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("deleted")}));
			_option_x__json2__Any _t32 = {0};
			if (_t33) {
				*((x__json2__Any*)&_t32.data) = *((x__json2__Any*)_t33);
			} else {
				_t32.state = 2; _t32.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t32.state != 0) {
				_result_discord__Entitlement _t34;
				memcpy(&_t34, &_t32, sizeof(_result));
				return _t34;
			}
			x__json2__Any* _t37 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("starts_at")}));
			_option_x__json2__Any _t36 = {0};
			if (_t37) {
				*((x__json2__Any*)&_t36.data) = *((x__json2__Any*)_t37);
			} else {
				_t36.state = 2; _t36.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_time__Time _t35; /* if prepend */
			if (_t36.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t36.data);
				_result_time__Time _t39 = time__parse_iso8601(/* as */ *(string*)__as_cast((s)._string,(s)._typ, 21) /*expected idx: 21, name: string */ );
				if (_t39.is_error) {
					_result_discord__Entitlement _t40;
					memcpy(&_t40, &_t39, sizeof(_result));
					return _t40;
				}
				
 				_option_time__Time _t38;
				_option_ok(&(time__Time[]) {  (*(time__Time*)_t39.data) }, (_option*)(&_t38), sizeof(time__Time));
				_t35 = _t38;
			} else {
				IError err = _t36.err;
				_t35.state = 2;
				_t35.err = _const_none__;
			}
			x__json2__Any* _t43 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("ends_at")}));
			_option_x__json2__Any _t42 = {0};
			if (_t43) {
				*((x__json2__Any*)&_t42.data) = *((x__json2__Any*)_t43);
			} else {
				_t42.state = 2; _t42.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_time__Time _t41; /* if prepend */
			if (_t42.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t42.data);
				_result_time__Time _t45 = time__parse_iso8601(/* as */ *(string*)__as_cast((s)._string,(s)._typ, 21) /*expected idx: 21, name: string */ );
				if (_t45.is_error) {
					_result_discord__Entitlement _t46;
					memcpy(&_t46, &_t45, sizeof(_result));
					return _t46;
				}
				
 				_option_time__Time _t44;
				_option_ok(&(time__Time[]) {  (*(time__Time*)_t45.data) }, (_option*)(&_t44), sizeof(time__Time));
				_t41 = _t44;
			} else {
				IError err = _t42.err;
				_t41.state = 2;
				_t41.err = _const_none__;
			}
			x__json2__Any* _t49 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("guild_id")}));
			_option_x__json2__Any _t48 = {0};
			if (_t49) {
				*((x__json2__Any*)&_t48.data) = *((x__json2__Any*)_t49);
			} else {
				_t48.state = 2; _t48.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__Snowflake _t47; /* if prepend */
			if (_t48.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t48.data);
				_result_discord__Snowflake _t51 = discord__Snowflake__static__parse(s);
				if (_t51.is_error) {
					_result_discord__Entitlement _t52;
					memcpy(&_t52, &_t51, sizeof(_result));
					return _t52;
				}
				
 				_option_discord__Snowflake _t50;
				_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t51.data) }, (_option*)(&_t50), sizeof(discord__Snowflake));
				_t47 = _t50;
			} else {
				IError err = _t48.err;
				_t47.state = 2;
				_t47.err = _const_none__;
			}
			
			
			
			
			
 			
 			
 		_result_discord__Entitlement _t1;
		_result_ok(&(discord__Entitlement[]) { ((discord__Entitlement){
			.id =  (*(discord__Snowflake*)_t2.data),
			.sku_id =  (*(discord__Snowflake*)_t7.data),
			.application_id =  (*(discord__Snowflake*)_t12.data),
			.user_id =  _t17,
			.typ = ((discord__EntitlementType)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t23.data))._i64,((*(x__json2__Any*)_t26.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.deleted = /* as */ *(bool*)__as_cast(((*(x__json2__Any*)_t29.data))._bool,((*(x__json2__Any*)_t32.data))._typ, 19) /*expected idx: 19, name: bool */ ,
			.starts_at =  _t35,
			.ends_at =  _t41,
			.guild_id =  _t47,
		}) }, (_result*)(&_t1), sizeof(discord__Entitlement));
		return _t1;
	}
	
	else {
		return (_result_discord__Entitlement){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected entitlement to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__Entitlement){0};
}

_result_Array_discord__Entitlement discord__Client_list_entitlements(discord__Client _v_toheap_c, discord__Snowflake application_id, discord__ListEntitlementParams params) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	net__urllib__Values query_params = net__urllib__new_values();
	_option_discord__Snowflake _t1;
	if (_t1 = params.user_id, _t1.state == 0) {
		discord__Snowflake user_id = *(discord__Snowflake*)_t1.data;
		net__urllib__Values_add(&query_params, _SLIT("user_id"), discord__Snowflake_build(user_id));
	}
	_option_Array_discord__Snowflake _t2;
	if (_t2 = params.sku_ids, _t2.state == 0) {
		Array_discord__Snowflake sku_ids = *(Array_discord__Snowflake*)_t2.data;
		Array_string _t3 = {0};
		Array_discord__Snowflake _t3_orig = sku_ids;
		int _t3_len = _t3_orig.len;
		_t3 = __new_array(0, _t3_len, sizeof(string));

		for (int _t5 = 0; _t5 < _t3_len; ++_t5) {
			discord__Snowflake it = ((discord__Snowflake*) _t3_orig.data)[_t5];
			string _t4 = discord__Snowflake_build(it);
			array_push((array*)&_t3, &_t4);
		}
		net__urllib__Values_add(&query_params, _SLIT("sku_ids"), Array_string_join(_t3, _SLIT(",")));
	}
	_option_discord__Snowflake _t6;
	if (_t6 = params.before, _t6.state == 0) {
		discord__Snowflake before = *(discord__Snowflake*)_t6.data;
		net__urllib__Values_add(&query_params, _SLIT("before"), discord__Snowflake_build(before));
	}
	_option_discord__Snowflake _t7;
	if (_t7 = params.after, _t7.state == 0) {
		discord__Snowflake after = *(discord__Snowflake*)_t7.data;
		net__urllib__Values_add(&query_params, _SLIT("after"), discord__Snowflake_build(after));
	}
	_option_int _t8;
	if (_t8 = params.limit, _t8.state == 0) {
		int limit = *(int*)_t8.data;
		net__urllib__Values_add(&query_params, _SLIT("limit"), int_str(limit));
	}
	_option_discord__Snowflake _t9;
	if (_t9 = params.guild_id, _t9.state == 0) {
		discord__Snowflake guild_id = *(discord__Snowflake*)_t9.data;
		net__urllib__Values_add(&query_params, _SLIT("guild_id"), discord__Snowflake_build(guild_id));
	}
	_option_bool _t10;
	if (_t10 = params.exclude_ended, _t10.state == 0) {
		bool exclude_ended = *(bool*)_t10.data;
		net__urllib__Values_add(&query_params, _SLIT("exclude_ended"), bool_str(exclude_ended));
	}
	string tmp1 = net__urllib__Values_encode(query_params);
	string tmp2 = ((tmp1).len == 0 ? (_SLIT("")) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("?"), /*115 &string*/0xfe10, {.d_s = tmp1}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	_result_net__http__Response _t12 = discord__Client_request((*(c)), net__http__Method__get,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("/applications/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(application_id))}}, {_SLIT("/entitlements"), /*115 &string*/0xfe10, {.d_s = tmp2}}, {_SLIT0, 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t12.is_error) {
		_result_Array_discord__Entitlement _t13;
		memcpy(&_t13, &_t12, sizeof(_result));
		return _t13;
	}
	
 	_result_x__json2__Any _t11 = x__json2__raw_decode( (*(net__http__Response*)_t12.data).body);
	if (_t11.is_error) {
		_result_Array_discord__Entitlement _t14;
		memcpy(&_t14, &_t11, sizeof(_result));
		return _t14;
	}
	
 	x__json2__Any r =  (*(x__json2__Any*)_t11.data);
	Array_discord__Entitlement _t16 = {0};
	Array_x__json2__Any _t16_orig = (/* as */ *(Array_x__json2__Any*)__as_cast((r)._Array_x__json2__Any,(r)._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
	int _t16_len = _t16_orig.len;
	_t16 = __new_array_noscan(0, _t16_len, sizeof(discord__Entitlement));

	for (int _t18 = 0; _t18 < _t16_len; ++_t18) {
		x__json2__Any it = ((x__json2__Any*) _t16_orig.data)[_t18];
		_result_discord__Entitlement _t19 = discord__Entitlement__static__parse(it);
		if (_t19.is_error) {
			_result_Array_discord__Entitlement _t20;
			memcpy(&_t20, &_t19, sizeof(_result));
			return _t20;
		}
		
 		discord__Entitlement _t17 =  (*(discord__Entitlement*)_t19.data);
		array_push_noscan((array*)&_t16, &_t17);
	}
	_result_Array_discord__Entitlement _t15;
	_result_ok(&(Array_discord__Entitlement[]) {_t16 }, (_result*)(&_t15), sizeof(Array_discord__Entitlement));
	return _t15;
}

_result_discord__Entitlement discord__Client_create_test_entitlement(discord__Client _v_toheap_c, discord__Snowflake application_id, discord__CreateTestEntitlementParams params) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_option_x__json2__Any _t5;
	_option_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 3, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[3]){
				_SLIT("sku_id"), 
				_SLIT("owner_id"), 
				_SLIT("owner_type"), 
			}),
			_MOV((x__json2__Any[3]){
				string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (discord__Snowflake_build(params.sku_id)))), 
				string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (discord__Snowflake_build(params.owner_id)))), 
				int_to_sumtype_x__json2__Any/*KEK*/(ADDR(int, (((int)(params.owner_type))))), 
			})
		)
	
	))) }, (_option*)(&_t5), sizeof(x__json2__Any));
	_result_net__http__Response _t4 = discord__Client_request((*(c)), net__http__Method__post,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/applications/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(application_id))}}, {_SLIT("/entitlements"), 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t5,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t4.is_error) {
		_result_discord__Entitlement _t6;
		memcpy(&_t6, &_t4, sizeof(_result));
		return _t6;
	}
	
 	_result_x__json2__Any _t3 = x__json2__raw_decode( (*(net__http__Response*)_t4.data).body);
	if (_t3.is_error) {
		_result_discord__Entitlement _t7;
		memcpy(&_t7, &_t3, sizeof(_result));
		return _t7;
	}
	
 	_result_discord__Entitlement _t2 = discord__Entitlement__static__parse( (*(x__json2__Any*)_t3.data));
	if (_t2.is_error) {
		_result_discord__Entitlement _t8;
		memcpy(&_t8, &_t2, sizeof(_result));
		return _t8;
	}
	
 	_result_discord__Entitlement _t1;
	_result_ok(&(discord__Entitlement[]) {  (*(discord__Entitlement*)_t2.data) }, (_result*)(&_t1), sizeof(discord__Entitlement));
	return _t1;
}

_result_void discord__Client_delete_test_entitlement(discord__Client _v_toheap_c, discord__Snowflake application_id, discord__Snowflake entitlement_id) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t1 = discord__Client_request((*(c)), net__http__Method__delete,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("/applications/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(application_id))}}, {_SLIT("/entitlements/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(entitlement_id))}}, {_SLIT0, 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(net__http__Response*)_t1.data);
	return (_result_void){0};
}

int discord__RestError_code(discord__RestError re) {
	int _t1 = re.code;
	return _t1;
}

VV_LOCAL_SYMBOL Map_string_string discord__flatten_error_dict(Map_string_x__json2__Any d, string key) {
	Map_string_string items = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	int _t2 = d.key_values.len;
	for (int _t1 = 0; _t1 < _t2; ++_t1 ) {
		int _t3 = d.key_values.len - _t2;
		_t2 = d.key_values.len;
		if (_t3 < 0) {
			_t1 = -1;
			continue;
		}
		if (!DenseArray_has_index(&d.key_values, _t1)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&d.key_values, _t1);
		k = string_clone(k);
		x__json2__Any v = (*(x__json2__Any*)DenseArray_value(&d.key_values, _t1));
		string new_key = ((key).len == 0 ? (k) : ( str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = key}}, {_SLIT("."), /*115 &string*/0xfe10, {.d_s = k}}, {_SLIT0, 0, { .d_c = 0 }}}))));
		if (v._typ == 173 /* map[string]x.json2.Any */) {
			if (_IN_MAP(ADDR(string, _SLIT("_errors")), ADDR(map, (*v._Map_string_x__json2__Any)))) {
				x__json2__Any* _t5 = (x__json2__Any*)(map_get_check(ADDR(map, (*v._Map_string_x__json2__Any)), &(string[]){_SLIT("_errors")}));
				_option_x__json2__Any _t4 = {0};
				if (_t5) {
					*((x__json2__Any*)&_t4.data) = *((x__json2__Any*)_t5);
				} else {
					_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
				}
				;
				if (_t4.state != 0) {
					IError err = _t4.err;
					return items;
				}
				x__json2__Any* _t8 = (x__json2__Any*)(map_get_check(ADDR(map, (*v._Map_string_x__json2__Any)), &(string[]){_SLIT("_errors")}));
				_option_x__json2__Any _t7 = {0};
				if (_t8) {
					*((x__json2__Any*)&_t7.data) = *((x__json2__Any*)_t8);
				} else {
					_t7.state = 2; _t7.err = _v_error(_SLIT("array index out of range"));
				}
				;
				if (_t7.state != 0) {
					IError err = _t7.err;
					return items;
				}
				
				
				Array_x__json2__Any errors = /* as */ *(Array_x__json2__Any*)__as_cast(((*(x__json2__Any*)_t4.data))._Array_x__json2__Any,((*(x__json2__Any*)_t7.data))._typ, 174) /*expected idx: 174, name: []x.json2.Any */ ;
				map_set(&items, &(string[]){new_key}, &(string[]) { Array_string_join(arrays__map_indexed_T_x__json2__Any_string(errors, (voidptr)				anon_fn_d9dbe34f3e4698d6_int_x__json2__any__string_753), _SLIT(" ")) });
			} else {
				Map_string_string _t10 = discord__flatten_error_dict((*v._Map_string_x__json2__Any), new_key);
				int _t12 = _t10.key_values.len;
				for (int _t11 = 0; _t11 < _t12; ++_t11 ) {
					int _t13 = _t10.key_values.len - _t12;
					_t12 = _t10.key_values.len;
					if (_t13 < 0) {
						_t11 = -1;
						continue;
					}
					if (!DenseArray_has_index(&_t10.key_values, _t11)) {continue;}
					string k2 = /*key*/ *(string*)DenseArray_key(&_t10.key_values, _t11);
					k2 = string_clone(k2);
					string v2 = (*(string*)DenseArray_value(&_t10.key_values, _t11));
					map_set(&items, &(string[]){k2}, &(string[]) { v2 });
				}
			}
		}
		
		else {
			map_set(&items, &(string[]){new_key}, &(string[]) { x__json2__Any_str(v) });
		}
		
	}
	return items;
}

string discord__RestError_msg(discord__RestError re) {
	string text = _SLIT("");
	if (re.errors.len != 0) {
		Map_string_string errors = discord__flatten_error_dict(re.errors, _SLIT(""));
		string helpful = Array_string_join(maps__to_array_T_string_string_string(errors, (voidptr)		anon_fn_d9dbe34f3e4698d6_string_string__string_1411), _SLIT("\n"));
		text =  str_intp(3, _MOV((StrIntpData[]){{_SLIT0, /*115 &string*/0xfe10, {.d_s = re.message}}, {_SLIT("\n"), /*115 &string*/0xfe10, {.d_s = helpful}}, {_SLIT0, 0, { .d_c = 0 }}}));
	} else {
		text = re.message;
	}
	string base =  str_intp(4, _MOV((StrIntpData[]){{_SLIT0, /*100 &int*/0xfe07, {.d_i32 = net__http__Status_int(re.status)}}, {_SLIT(" "), /*115 &string*/0xfe10, {.d_s = net__http__Status_str(re.status)}}, {_SLIT(" (error code: "), /*100 &int*/0xfe07, {.d_i32 = re.code}}, {_SLIT(")"), 0, { .d_c = 0 }}}));
	string _t1 = ((text).len != 0 ? (string__plus(base,  str_intp(2, _MOV((StrIntpData[]){{_SLIT(": "), /*115 &string*/0xfe10, {.d_s = text}}, {_SLIT0, 0, { .d_c = 0 }}})))) : (base));
	return _t1;
}

// TypeDecl
// TypeDecl
VV_LOCAL_SYMBOL int discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_generate_id_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec) {
	int _t1 = ec->id++;
	return _t1;
}

void discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_emit_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec, discord__DispatchEvent_T_discord__GatewayClient e, discord__EmitOptions options) {
	Map_int_discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient _t1 = ec->wait_fors;
	int _t3 = _t1.key_values.len;
	for (int _t2 = 0; _t2 < _t3; ++_t2 ) {
		int _t4 = _t1.key_values.len - _t3;
		_t3 = _t1.key_values.len;
		if (_t4 < 0) {
			_t2 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t1.key_values, _t2)) {continue;}
		int i = /*key*/ *(int*)DenseArray_key(&_t1.key_values, _t2);
		discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient w = (*(discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient*)DenseArray_value(&_t1.key_values, _t2));
		bool b = false;
		if (w.check.state != 2) {
			_option_anon_fn_discord__dispatchevent_t_discord__gatewayclient__bool _t5 = w.check;
			if (_t5.state != 0) {
				IError err = _t5.err;
				_v_panic(IError_str(err));
				VUNREACHABLE();
			;
			}
			b = ( (*(anon_fn_discord__dispatchevent_t_discord__gatewayclient__bool*)_t5.data));
			e;
		} else {
			b = true;
		}
		if (b) {
			__chan_discord__DispatchEvent_T_discord__GatewayClient_pushval(w.c->c, e);
			map_delete(&ec->wait_fors, &(int[]){i});
			return;
		}
	}
	Array___v_thread ts = __new_array_with_default(0, 0, sizeof(__v_thread), 0);
	Map_int_anon_fn_discord__dispatchevent_t_discord__gatewayclient__result_void _t6 = ec->listeners;
	int _t8 = _t6.key_values.len;
	for (int _t7 = 0; _t7 < _t8; ++_t7 ) {
		int _t9 = _t6.key_values.len - _t8;
		_t8 = _t6.key_values.len;
		if (_t9 < 0) {
			_t7 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t6.key_values, _t7)) {continue;}
		int i = /*key*/ *(int*)DenseArray_key(&_t6.key_values, _t7);
		_result_void (*l) (discord__DispatchEvent_T_discord__GatewayClient ) = (*(voidptr*)DenseArray_value(&_t6.key_values, _t7));
			void (*_t12) (_result_void (*) (discord__DispatchEvent_T_discord__GatewayClient), int, discord__DispatchEvent_T_discord__GatewayClient) = 		__closure_create(anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient, (struct _V_anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient_Ctx*) memdup_uncollectable(&(struct _V_anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient_Ctx){.options = options,
		}, sizeof(struct _V_anon_fn_db76bb91bafd3d17_discord__eventlistener_int_t_843_T_discord__DispatchEvent_T_discord__GatewayClient_Ctx)));
		// start go
		thread_arg_ *arg__t11 = (thread_arg_ *) _v_malloc(sizeof(thread_arg_));
		arg__t11->fn = _t12;
		arg__t11->arg1 = l;
		arg__t11->arg2 = i;
		arg__t11->arg3 = e;
		HANDLE thread__t11 = CreateThread(0, 8388608, (LPTHREAD_START_ROUTINE)_thread_wrapper, arg__t11, 0, 0); // fn: 
		if (!thread__t11) panic_lasterr(tos3("`go ()`: "));
		// end go
		array_push((array*)&ts, _MOV((__v_thread[]){ /*spawn (thread) */
thread__t11 }));
	}
	Array___v_thread_wait(ts);
}

_option_discord__DispatchEvent_T_discord__GatewayClient discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_wait_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec, discord__EventWaitParams_T_discord__DispatchEvent_T_discord__GatewayClient params) {
	bool discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_wait_T_discord__DispatchEvent_T_discord__GatewayClient_defer_0 = false;
	int id;
	discord__Chan_T_discord__DispatchEvent_T_discord__GatewayClient *c = HEAP(discord__Chan_T_discord__DispatchEvent_T_discord__GatewayClient, (((discord__Chan_T_discord__DispatchEvent_T_discord__GatewayClient){.c = sync__new_channel_st(0, sizeof(discord__DispatchEvent_T_discord__GatewayClient)),})));
	id = discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_generate_id_T_discord__DispatchEvent_T_discord__GatewayClient(ec);
	(*(discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient*)map_get_and_set((map*)&ec->wait_fors, &(int[]){id}, &(discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient[]){ (discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient){.c = 0,} })) = ((discord__EventWaiter_T_discord__DispatchEvent_T_discord__GatewayClient){.check = params.check,.c = &(*(c)),});
	discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_wait_T_discord__DispatchEvent_T_discord__GatewayClient_defer_0 = true;
	_option_time__Duration _t1;
	if (_t1 = params.timeout, _t1.state == 0) {
		time__Duration timeout = *(time__Duration*)_t1.data;
		discord__DispatchEvent_T_discord__GatewayClient _t2;
		Array_sync__Channel_ptr _t3 = new_array_from_c_array(1, 1, sizeof(sync__Channel*), _MOV((sync__Channel*[1]){(sync__Channel*)((*(c)).c)}));

		Array_sync__Direction _t4 = new_array_from_c_array(1, 1, sizeof(sync__Direction), _MOV((sync__Direction[1]){sync__Direction__pop}));

		Array_voidptr _t5 = new_array_from_c_array(1, 1, sizeof(voidptr), _MOV((voidptr[1]){&_t2}));

		int _t6 = sync__channel_select(&/*arr*/_t3, _t4, &/*arr*/_t5, time__Duration_nanoseconds(timeout));
		array_free(&_t5);
		array_free(&_t4);
		array_free(&_t3);
		if (_t6 == 0) {
			discord__DispatchEvent_T_discord__GatewayClient e = _t2;
			_option_discord__DispatchEvent_T_discord__GatewayClient _t7;
			_option_ok(&(discord__DispatchEvent_T_discord__GatewayClient[]) { e }, (_option*)(&_t7), sizeof(discord__DispatchEvent_T_discord__GatewayClient));
				// Defer begin
				if (discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_wait_T_discord__DispatchEvent_T_discord__GatewayClient_defer_0) {
					map_delete(&ec->wait_fors, &(int[]){id});
				}
				// Defer end
			return _t7;
		} else if (_t6 == -1) {
			_option_discord__DispatchEvent_T_discord__GatewayClient _t8 = (_option_discord__DispatchEvent_T_discord__GatewayClient){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
				// Defer begin
				if (discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_wait_T_discord__DispatchEvent_T_discord__GatewayClient_defer_0) {
					map_delete(&ec->wait_fors, &(int[]){id});
				}
				// Defer end
			return _t8;
		}
		;
	}
	_option_discord__DispatchEvent_T_discord__GatewayClient _t9;
	_option_ok(&(discord__DispatchEvent_T_discord__GatewayClient[]) { __chan_discord__DispatchEvent_T_discord__GatewayClient_popval((*(c)).c) }, (_option*)(&_t9), sizeof(discord__DispatchEvent_T_discord__GatewayClient));
		// Defer begin
		if (discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_wait_T_discord__DispatchEvent_T_discord__GatewayClient_defer_0) {
			map_delete(&ec->wait_fors, &(int[]){id});
		}
		// Defer end
	return _t9;
}

discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_override_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec, _result_void (*listener)(discord__DispatchEvent_T_discord__GatewayClient )) {
	ec->listeners = new_map_init_noscan_key(&map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop, 1, sizeof(int), sizeof(voidptr),
			_MOV((int[1]){
				discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_generate_id_T_discord__DispatchEvent_T_discord__GatewayClient(ec), 
			}),
			_MOV((voidptr[1]){
				listener, 
			})
		)
	
	;
	return *ec;
}

discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_listen_T_discord__DispatchEvent_T_discord__GatewayClient(discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient* ec, _result_void (*listener)(discord__DispatchEvent_T_discord__GatewayClient )) {
	map_set(&ec->listeners, &(int[]){discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_generate_id_T_discord__DispatchEvent_T_discord__GatewayClient(ec)}, &(voidptr[]) { (voidptr)listener });
	return *ec;
}

VV_LOCAL_SYMBOL _result_discord__WSMessage discord__GatewayClient_recv(discord__GatewayClient* c) {
	_result_discord__WSMessage _t2 = discord__ws_recv_message(c->ws);
	if (_t2.is_error) {
		_result_discord__WSMessage _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_discord__WSMessage _t1;
	_result_ok(&(discord__WSMessage[]) {  (*(discord__WSMessage*)_t2.data) }, (_result*)(&_t1), sizeof(discord__WSMessage));
	return _t1;
}

VV_LOCAL_SYMBOL _result_void discord__GatewayClient_send(discord__GatewayClient* c, discord__WSMessage message) {
	log__Logger_name_table[c->Client.logger._typ]._method_debug(c->Client.logger._object, _SLIT("Sending message: "));
	_result_void _t1 = discord__ws_send_message(c->ws, message);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_void discord__GatewayClient_heartbeat(discord__GatewayClient* c) {
	_result_void _t1 = discord__GatewayClient_send(c, ((discord__WSMessage){.opcode = 1,.data = (c->sequence.state == 2 ? (x__json2__Null_to_sumtype_x__json2__Any/*KEK*/(ADDR(x__json2__Null, (((x__json2__Null){.is_null = true,}))))) : (int_to_sumtype_x__json2__Any/*KEK*/(&c->sequence))),.seq = (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.event = (string){.str=(byteptr)"", .is_lit=1},}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	return (_result_void){0};
}

VV_LOCAL_SYMBOL anon_fn_int_ierror discord__GatewayClient_error_logger(discord__GatewayClient* c) {
	discord__GatewayClient *cr = HEAP(discord__GatewayClient, (*c));
	anon_fn_int_ierror _t1 = (voidptr)	__closure_create(anon_fn_263669e3d870cc7d_int_ierror_862, (struct _V_anon_fn_263669e3d870cc7d_int_ierror_862_Ctx*) memdup_uncollectable(&(struct _V_anon_fn_263669e3d870cc7d_int_ierror_862_Ctx){.cr = cr,
	}, sizeof(struct _V_anon_fn_263669e3d870cc7d_int_ierror_862_Ctx)));
	return _t1;
}

VV_LOCAL_SYMBOL _result_void discord__GatewayClient_raw_dispatch(discord__GatewayClient* c, string name, x__json2__Any data) {
	_option_anon_fn_int_ierror _t1;
	_option_ok(&(anon_fn_int_ierror[]) { discord__GatewayClient_error_logger(c) }, (_option*)(&_t1), sizeof(anon_fn_int_ierror));
	discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_emit_T_discord__DispatchEvent_T_discord__GatewayClient(&c->on_raw_event, ((discord__DispatchEvent_T_discord__GatewayClient){.creator = c,.name = name,.data = data,}), ((discord__EmitOptions){.error_handler = _t1,}));
	return (_result_void){0};
}

VV_LOCAL_SYMBOL void discord__GatewayClient_spawn_heart(discord__GatewayClient* c, i64 interval) {
	// start go
	thread_arg_anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255 *arg__t1 = (thread_arg_anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255 *) _v_malloc(sizeof(thread_arg_anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255));
	arg__t1->fn = anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255;
	arg__t1->arg1 = c;
	arg__t1->arg2 = interval * _const_time__millisecond;
	arg__t1->ret_ptr = (void *) _v_malloc(sizeof(_result_int));
	HANDLE thread__t1 = CreateThread(0, 8388608, (LPTHREAD_START_ROUTINE)anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255_thread_wrapper, arg__t1, 0, 0); // fn: 
	if (!thread__t1) panic_lasterr(tos3("`go anon_fn_263669e3d870cc7d_mut_discord__gatewayclient_time__duration__result_int_1255()`: "));
	CloseHandle(thread__t1);
	// end go
	;
}

_result_void discord__GatewayClient_init(discord__GatewayClient* c) {
	_result_net__websocket__Client_ptr _t1 = net__websocket__new_client(string__plus(string_trim_right(c->gateway_url, _SLIT("/?")), _SLIT("?v=10&encoding=json")), ((net__websocket__ClientOpt){.read_timeout = 30 * _const_time__second,.write_timeout = 30 * _const_time__second,.logger = HEAP(log__Logger, /*&log.Logger*/I_log__Log_to_Interface_log__Logger(((log__Log*)memdup(&(log__Log){.level = log__Level__info,.output_label = (string){.str=(byteptr)"", .is_lit=1},.ofile = (os__File){.cfile = 0,.fd = 0,.is_opened = 0,},.output_target = 0,.output_file_name = (string){.str=(byteptr)"", .is_lit=1},}, sizeof(log__Log))))),}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 	net__websocket__Client* ws =  (*(net__websocket__Client**)_t1.data);
	c->ws = ws;
	c->ready = false;
	net__websocket__Client_on_close_ref(ws, (voidptr)	anon_fn_263669e3d870cc7d_mut_net__websocket__client_int_string_voidptr__result_void_1828, c);
	net__websocket__Client_on_message_ref(ws, (voidptr)	anon_fn_263669e3d870cc7d_mut_net__websocket__client_net__websocket__message_voidptr__result_void_2034, c);
	return (_result_void){0};
}

_result_void discord__GatewayClient_run(discord__GatewayClient* c) {
	log__Logger_name_table[c->Client.logger._typ]._method_info(c->Client.logger._object, _SLIT("a"));
	_result_void _t1 = net__websocket__Client_connect(c->ws);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	log__Logger_name_table[c->Client.logger._typ]._method_info(c->Client.logger._object, _SLIT("b"));
	_result_void _t3 = net__websocket__Client_listen(c->ws);
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	log__Logger_name_table[c->Client.logger._typ]._method_info(c->Client.logger._object, _SLIT("c"));
	return (_result_void){0};
}

_result_void discord__GatewayClient_launch(discord__GatewayClient* c) {
	_result_void _t1 = discord__GatewayClient_init(c);
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
 ;
	_result_void _t3 = discord__GatewayClient_run(c);
	if (_t3.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 ;
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_string discord__Client_fetch_gateway_url(discord__Client _v_toheap_c) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t2 = discord__Client_request((*(c)), net__http__Method__get, _SLIT("/gateway"), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = false,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t2.is_error) {
		_result_string _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_x__json2__Any _t1 = x__json2__raw_decode( (*(net__http__Response*)_t2.data).body);
	if (_t1.is_error) {
		_result_string _t4;
		memcpy(&_t4, &_t1, sizeof(_result));
		return _t4;
	}
	
 	x__json2__Any r1 =  (*(x__json2__Any*)_t1.data);
	_result_string _t6 = {0};
	if (r1._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t8 = (x__json2__Any*)(map_get_check(ADDR(map, (*r1._Map_string_x__json2__Any)), &(string[]){_SLIT("url")}));
		_option_x__json2__Any _t7 = {0};
		if (_t8) {
			*((x__json2__Any*)&_t7.data) = *((x__json2__Any*)_t8);
		} else {
			_t7.state = 2; _t7.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t7.state != 0) {
			_result_string _t9;
			memcpy(&_t9, &_t7, sizeof(_result));
			return _t9;
		}
		
		x__json2__Any r2 = (*(x__json2__Any*)_t7.data);
		_result_string _t10 = {0};
		if (r2._typ == 21 /* string */) {
			_result_ok(&(string[]) { (*r2._string) }, (_result*)(&_t10), sizeof(string));
		}
		
		else {
			_t10.is_error = true;
			_t10.err = _v_error(_SLIT("invalid url from api"));
		}
		
		_t6 = _t10;
	}
	
	else {
		_t6.is_error = true;
		_t6.err = _v_error(_SLIT("invalid response from api"));
	}
	_result_string _t5 = _t6;
	return _t5;
}

// TypeDecl
_result_discord__PartialGuild discord__PartialGuild__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t2 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("icon")}));
		_option_x__json2__Any _t1 = {0};
		if (_t2) {
			*((x__json2__Any*)&_t1.data) = *((x__json2__Any*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t1.state != 0) {
			_result_discord__PartialGuild _t3;
			memcpy(&_t3, &_t1, sizeof(_result));
			return _t3;
		}
		
		x__json2__Any icon = (*(x__json2__Any*)_t1.data);
			x__json2__Any* _t7 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("id")}));
			_option_x__json2__Any _t6 = {0};
			if (_t7) {
				*((x__json2__Any*)&_t6.data) = *((x__json2__Any*)_t7);
			} else {
				_t6.state = 2; _t6.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t6.state != 0) {
				_result_discord__PartialGuild _t8;
				memcpy(&_t8, &_t6, sizeof(_result));
				return _t8;
			}
			
			_result_discord__Snowflake _t5 = discord__Snowflake__static__parse((*(x__json2__Any*)_t6.data));
			if (_t5.is_error) {
				_result_discord__PartialGuild _t9;
				memcpy(&_t9, &_t5, sizeof(_result));
				return _t9;
			}
			x__json2__Any* _t11 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
			_option_x__json2__Any _t10 = {0};
			if (_t11) {
				*((x__json2__Any*)&_t10.data) = *((x__json2__Any*)_t11);
			} else {
				_t10.state = 2; _t10.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t10.state != 0) {
				_result_discord__PartialGuild _t12;
				memcpy(&_t12, &_t10, sizeof(_result));
				return _t12;
			}
			x__json2__Any* _t14 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
			_option_x__json2__Any _t13 = {0};
			if (_t14) {
				*((x__json2__Any*)&_t13.data) = *((x__json2__Any*)_t14);
			} else {
				_t13.state = 2; _t13.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t13.state != 0) {
				_result_discord__PartialGuild _t15;
				memcpy(&_t15, &_t13, sizeof(_result));
				return _t15;
			}
			_option_string _t16; /* if prepend */
			if ((icon)._typ == 21 /* string */) {
				_option_string _t17;
				_option_ok(&(string[]) { (*icon._string) }, (_option*)(&_t17), sizeof(string));
				_t16 = _t17;
			} else {
				_t16.state = 2;
				_t16.err = _const_none__;
			}
			x__json2__Any* _t19 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("owner")}));
			_option_x__json2__Any _t18 = {0};
			if (_t19) {
				*((x__json2__Any*)&_t18.data) = *((x__json2__Any*)_t19);
			} else {
				_t18.state = 2; _t18.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t18.state != 0) {
				_result_discord__PartialGuild _t20;
				memcpy(&_t20, &_t18, sizeof(_result));
				return _t20;
			}
			x__json2__Any* _t22 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("owner")}));
			_option_x__json2__Any _t21 = {0};
			if (_t22) {
				*((x__json2__Any*)&_t21.data) = *((x__json2__Any*)_t22);
			} else {
				_t21.state = 2; _t21.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t21.state != 0) {
				_result_discord__PartialGuild _t23;
				memcpy(&_t23, &_t21, sizeof(_result));
				return _t23;
			}
			x__json2__Any* _t26 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("permissions")}));
			_option_x__json2__Any _t25 = {0};
			if (_t26) {
				*((x__json2__Any*)&_t25.data) = *((x__json2__Any*)_t26);
			} else {
				_t25.state = 2; _t25.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t25.state != 0) {
				_result_discord__PartialGuild _t27;
				memcpy(&_t27, &_t25, sizeof(_result));
				return _t27;
			}
			
			_result_discord__Permissions _t24 = discord__Permissions__static__parse((*(x__json2__Any*)_t25.data));
			if (_t24.is_error) {
				_result_discord__PartialGuild _t28;
				memcpy(&_t28, &_t24, sizeof(_result));
				return _t28;
			}
			x__json2__Any* _t32 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("features")}));
			_option_x__json2__Any _t31 = {0};
			if (_t32) {
				*((x__json2__Any*)&_t31.data) = *((x__json2__Any*)_t32);
			} else {
				_t31.state = 2; _t31.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t31.state != 0) {
				_result_discord__PartialGuild _t33;
				memcpy(&_t33, &_t31, sizeof(_result));
				return _t33;
			}
			x__json2__Any* _t35 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("features")}));
			_option_x__json2__Any _t34 = {0};
			if (_t35) {
				*((x__json2__Any*)&_t34.data) = *((x__json2__Any*)_t35);
			} else {
				_t34.state = 2; _t34.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t34.state != 0) {
				_result_discord__PartialGuild _t36;
				memcpy(&_t36, &_t34, sizeof(_result));
				return _t36;
			}
			
			
			Array_discord__GuildFeature _t29 = {0};
			Array_x__json2__Any _t29_orig = (/* as */ *(Array_x__json2__Any*)__as_cast(((*(x__json2__Any*)_t31.data))._Array_x__json2__Any,((*(x__json2__Any*)_t34.data))._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
			int _t29_len = _t29_orig.len;
			_t29 = __new_array(0, _t29_len, sizeof(discord__GuildFeature));

			for (int _t37 = 0; _t37 < _t29_len; ++_t37) {
				x__json2__Any it = ((x__json2__Any*) _t29_orig.data)[_t37];
				discord__GuildFeature _t30 = ((/* as */ *(string*)__as_cast((it)._string,(it)._typ, 21) /*expected idx: 21, name: string */ ));
				array_push((array*)&_t29, &_t30);
			}
			x__json2__Any* _t40 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("approximate_member_count")}));
			_option_x__json2__Any _t39 = {0};
			if (_t40) {
				*((x__json2__Any*)&_t39.data) = *((x__json2__Any*)_t40);
			} else {
				_t39.state = 2; _t39.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t38; /* if prepend */
			if (_t39.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t39.data);
				_option_int _t41;
				_option_ok(&(int[]) { /* as */ *(int*)__as_cast((i)._int,(i)._typ, 8) /*expected idx: 8, name: int */  }, (_option*)(&_t41), sizeof(int));
				_t38 = _t41;
			} else {
				IError err = _t39.err;
				_t38.state = 2;
				_t38.err = _const_none__;
			}
			x__json2__Any* _t44 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("approximate_presence_count")}));
			_option_x__json2__Any _t43 = {0};
			if (_t44) {
				*((x__json2__Any*)&_t43.data) = *((x__json2__Any*)_t44);
			} else {
				_t43.state = 2; _t43.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t42; /* if prepend */
			if (_t43.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t43.data);
				_option_int _t45;
				_option_ok(&(int[]) { /* as */ *(int*)__as_cast((i)._int,(i)._typ, 8) /*expected idx: 8, name: int */  }, (_option*)(&_t45), sizeof(int));
				_t42 = _t45;
			} else {
				IError err = _t43.err;
				_t42.state = 2;
				_t42.err = _const_none__;
			}
			_result_discord__PartialGuild _t4;
		_result_ok(&(discord__PartialGuild[]) { ((discord__PartialGuild){
			.id =  (*(discord__Snowflake*)_t5.data),
			.name = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t10.data))._string,((*(x__json2__Any*)_t13.data))._typ, 21) /*expected idx: 21, name: string */ ,
			.icon =  _t16,
			.owner = /* as */ *(bool*)__as_cast(((*(x__json2__Any*)_t18.data))._bool,((*(x__json2__Any*)_t21.data))._typ, 19) /*expected idx: 19, name: bool */ ,
			.permissions =  (*(discord__Permissions*)_t24.data),
			.features =_t29,
			.approximate_member_count =  _t38,
			.approximate_presence_count =  _t42,
		}) }, (_result*)(&_t4), sizeof(discord__PartialGuild));
		return _t4;
	}
	
	else {
		return (_result_discord__PartialGuild){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected partial guild to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__PartialGuild){0};
}

_result_Array_discord__PartialGuild discord__Client_fetch_my_guilds(discord__Client _v_toheap_c, discord__FetchMyGuildsParams params) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	net__urllib__Values vs = net__urllib__new_values();
	_option_discord__Snowflake _t1;
	if (_t1 = params.before, _t1.state == 0) {
		discord__Snowflake before = *(discord__Snowflake*)_t1.data;
		net__urllib__Values_add(&vs, _SLIT("before"), discord__Snowflake_build(before));
	}
	_option_discord__Snowflake _t2;
	if (_t2 = params.after, _t2.state == 0) {
		discord__Snowflake after = *(discord__Snowflake*)_t2.data;
		net__urllib__Values_add(&vs, _SLIT("after"), discord__Snowflake_build(after));
	}
	_option_int _t3;
	if (_t3 = params.limit, _t3.state == 0) {
		int limit = *(int*)_t3.data;
		net__urllib__Values_add(&vs, _SLIT("limit"), int_str(limit));
	}
	_option_bool _t4;
	if (_t4 = params.with_counts, _t4.state == 0) {
		bool with_counts = *(bool*)_t4.data;
		net__urllib__Values_add(&vs, _SLIT("with_counts"), bool_str(with_counts));
	}
	string tmp1 = net__urllib__Values_encode(vs);
	string tmp2 = ((tmp1).len == 0 ? (_SLIT("")) : ( str_intp(2, _MOV((StrIntpData[]){{_SLIT("?"), /*115 &string*/0xfe10, {.d_s = tmp1}}, {_SLIT0, 0, { .d_c = 0 }}}))));
	_result_net__http__Response _t10 = discord__Client_request((*(c)), net__http__Method__get,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/users/@me/guilds"), /*115 &string*/0xfe10, {.d_s = tmp2}}, {_SLIT0, 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t10.is_error) {
		_result_Array_discord__PartialGuild _t11;
		memcpy(&_t11, &_t10, sizeof(_result));
		return _t11;
	}
	
 	_result_x__json2__Any _t9 = x__json2__raw_decode( (*(net__http__Response*)_t10.data).body);
	if (_t9.is_error) {
		_result_Array_discord__PartialGuild _t12;
		memcpy(&_t12, &_t9, sizeof(_result));
		return _t12;
	}
	
 	Array_discord__PartialGuild _t6 = {0};
	Array_x__json2__Any _t6_orig = (({ x__json2__Any _t8 =  (*(x__json2__Any*)_t9.data); /* as */ *(Array_x__json2__Any*)__as_cast(_t8._Array_x__json2__Any,_t8._typ, 174); }) /*expected idx: 174, name: []x.json2.Any */ );
	int _t6_len = _t6_orig.len;
	_t6 = __new_array(0, _t6_len, sizeof(discord__PartialGuild));

	for (int _t13 = 0; _t13 < _t6_len; ++_t13) {
		x__json2__Any it = ((x__json2__Any*) _t6_orig.data)[_t13];
		_result_discord__PartialGuild _t14 = discord__PartialGuild__static__parse(it);
		if (_t14.is_error) {
			_result_Array_discord__PartialGuild _t15;
			memcpy(&_t15, &_t14, sizeof(_result));
			return _t15;
		}
		
 		discord__PartialGuild _t7 =  (*(discord__PartialGuild*)_t14.data);
		array_push((array*)&_t6, &_t7);
	}
	_result_Array_discord__PartialGuild _t5;
	_result_ok(&(Array_discord__PartialGuild[]) {_t6 }, (_result*)(&_t5), sizeof(Array_discord__PartialGuild));
	return _t5;
}

_result_discord__RoleTags discord__RoleTags__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
			x__json2__Any* _t4 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("bot_id")}));
			_option_x__json2__Any _t3 = {0};
			if (_t4) {
				*((x__json2__Any*)&_t3.data) = *((x__json2__Any*)_t4);
			} else {
				_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__Snowflake _t2; /* if prepend */
			if (_t3.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t3.data);
				_result_discord__Snowflake _t5 = discord__Snowflake__static__parse(s);
				if (_t5.is_error) {
					_result_discord__RoleTags _t6;
					memcpy(&_t6, &_t5, sizeof(_result));
					return _t6;
				}
				
 				_option_ok(&(discord__RoleTags[]) {  (*(discord__Snowflake*)_t5.data) }, (_option*)(&_t2), sizeof(discord__RoleTags));
			} else {
				IError err = _t3.err;
				_t2.state = 2;
				_t2.err = _const_none__;
			}
			x__json2__Any* _t9 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("integration_id")}));
			_option_x__json2__Any _t8 = {0};
			if (_t9) {
				*((x__json2__Any*)&_t8.data) = *((x__json2__Any*)_t9);
			} else {
				_t8.state = 2; _t8.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__Snowflake _t7; /* if prepend */
			if (_t8.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t8.data);
				_result_discord__Snowflake _t10 = discord__Snowflake__static__parse(s);
				if (_t10.is_error) {
					_result_discord__RoleTags _t11;
					memcpy(&_t11, &_t10, sizeof(_result));
					return _t11;
				}
				
 				_option_ok(&(discord__RoleTags[]) {  (*(discord__Snowflake*)_t10.data) }, (_option*)(&_t7), sizeof(discord__RoleTags));
			} else {
				IError err = _t8.err;
				_t7.state = 2;
				_t7.err = _const_none__;
			}
			x__json2__Any* _t14 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("subscription_listing_id")}));
			_option_x__json2__Any _t13 = {0};
			if (_t14) {
				*((x__json2__Any*)&_t13.data) = *((x__json2__Any*)_t14);
			} else {
				_t13.state = 2; _t13.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__Snowflake _t12; /* if prepend */
			if (_t13.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t13.data);
				_result_discord__Snowflake _t15 = discord__Snowflake__static__parse(s);
				if (_t15.is_error) {
					_result_discord__RoleTags _t16;
					memcpy(&_t16, &_t15, sizeof(_result));
					return _t16;
				}
				
 				_option_ok(&(discord__RoleTags[]) {  (*(discord__Snowflake*)_t15.data) }, (_option*)(&_t12), sizeof(discord__RoleTags));
			} else {
				IError err = _t13.err;
				_t12.state = 2;
				_t12.err = _const_none__;
			}
		_result_discord__RoleTags _t1;
		_result_ok(&(discord__RoleTags[]) { ((discord__RoleTags){
			.bot_id =  _t2,
			.integration_id =  _t7,
			.premium_subscriber = _IN_MAP(ADDR(string, _SLIT("premium_subscriber")), ADDR(map, (*j._Map_string_x__json2__Any))),
			.subscription_listing_id =  _t12,
			.available_for_purchase = _IN_MAP(ADDR(string, _SLIT("available_for_purchase")), ADDR(map, (*j._Map_string_x__json2__Any))),
			.guild_connections = _IN_MAP(ADDR(string, _SLIT("guild_connections")), ADDR(map, (*j._Map_string_x__json2__Any))),
		}) }, (_result*)(&_t1), sizeof(discord__RoleTags));
		return _t1;
	}
	
	else {
		return (_result_discord__RoleTags){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected role tags to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__RoleTags){0};
}

_result_discord__Role discord__Role__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
			x__json2__Any* _t4 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("id")}));
			_option_x__json2__Any _t3 = {0};
			if (_t4) {
				*((x__json2__Any*)&_t3.data) = *((x__json2__Any*)_t4);
			} else {
				_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t3.state != 0) {
				_result_discord__Role _t5;
				memcpy(&_t5, &_t3, sizeof(_result));
				return _t5;
			}
			
			_result_discord__Snowflake _t2 = discord__Snowflake__static__parse((*(x__json2__Any*)_t3.data));
			if (_t2.is_error) {
				_result_discord__Role _t6;
				memcpy(&_t6, &_t2, sizeof(_result));
				return _t6;
			}
			x__json2__Any* _t8 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
			_option_x__json2__Any _t7 = {0};
			if (_t8) {
				*((x__json2__Any*)&_t7.data) = *((x__json2__Any*)_t8);
			} else {
				_t7.state = 2; _t7.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t7.state != 0) {
				_result_discord__Role _t9;
				memcpy(&_t9, &_t7, sizeof(_result));
				return _t9;
			}
			x__json2__Any* _t11 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
			_option_x__json2__Any _t10 = {0};
			if (_t11) {
				*((x__json2__Any*)&_t10.data) = *((x__json2__Any*)_t11);
			} else {
				_t10.state = 2; _t10.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t10.state != 0) {
				_result_discord__Role _t12;
				memcpy(&_t12, &_t10, sizeof(_result));
				return _t12;
			}
			x__json2__Any* _t14 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("color")}));
			_option_x__json2__Any _t13 = {0};
			if (_t14) {
				*((x__json2__Any*)&_t13.data) = *((x__json2__Any*)_t14);
			} else {
				_t13.state = 2; _t13.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t13.state != 0) {
				_result_discord__Role _t15;
				memcpy(&_t15, &_t13, sizeof(_result));
				return _t15;
			}
			x__json2__Any* _t17 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("color")}));
			_option_x__json2__Any _t16 = {0};
			if (_t17) {
				*((x__json2__Any*)&_t16.data) = *((x__json2__Any*)_t17);
			} else {
				_t16.state = 2; _t16.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t16.state != 0) {
				_result_discord__Role _t18;
				memcpy(&_t18, &_t16, sizeof(_result));
				return _t18;
			}
			x__json2__Any* _t20 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("hoist")}));
			_option_x__json2__Any _t19 = {0};
			if (_t20) {
				*((x__json2__Any*)&_t19.data) = *((x__json2__Any*)_t20);
			} else {
				_t19.state = 2; _t19.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t19.state != 0) {
				_result_discord__Role _t21;
				memcpy(&_t21, &_t19, sizeof(_result));
				return _t21;
			}
			x__json2__Any* _t23 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("hoist")}));
			_option_x__json2__Any _t22 = {0};
			if (_t23) {
				*((x__json2__Any*)&_t22.data) = *((x__json2__Any*)_t23);
			} else {
				_t22.state = 2; _t22.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t22.state != 0) {
				_result_discord__Role _t24;
				memcpy(&_t24, &_t22, sizeof(_result));
				return _t24;
			}
			x__json2__Any* _t27 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("icon")}));
			_option_x__json2__Any _t26 = {0};
			if (_t27) {
				*((x__json2__Any*)&_t26.data) = *((x__json2__Any*)_t27);
			} else {
				_t26.state = 2; _t26.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_string _t25; /* if prepend */
			if (_t26.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t26.data);
				_option_string _t28; /* if prepend */
				if ((s)._typ == 21 /* string */) {
					_option_string _t29;
					_option_ok(&(string[]) { (*s._string) }, (_option*)(&_t29), sizeof(string));
					_t28 = _t29;
				} else {
					_t28.state = 2;
					_t28.err = _const_none__;
				}
				
				_t25 =  _t28;
			} else {
				IError err = _t26.err;
				_t25.state = 2;
				_t25.err = _const_none__;
			}
			x__json2__Any* _t32 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("unicode_emoji")}));
			_option_x__json2__Any _t31 = {0};
			if (_t32) {
				*((x__json2__Any*)&_t31.data) = *((x__json2__Any*)_t32);
			} else {
				_t31.state = 2; _t31.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_string _t30; /* if prepend */
			if (_t31.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t31.data);
				_option_string _t33; /* if prepend */
				if ((s)._typ == 21 /* string */) {
					_option_string _t34;
					_option_ok(&(string[]) { (*s._string) }, (_option*)(&_t34), sizeof(string));
					_t33 = _t34;
				} else {
					_t33.state = 2;
					_t33.err = _const_none__;
				}
				
				_t30 =  _t33;
			} else {
				IError err = _t31.err;
				_t30.state = 2;
				_t30.err = _const_none__;
			}
			x__json2__Any* _t36 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("position")}));
			_option_x__json2__Any _t35 = {0};
			if (_t36) {
				*((x__json2__Any*)&_t35.data) = *((x__json2__Any*)_t36);
			} else {
				_t35.state = 2; _t35.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t35.state != 0) {
				_result_discord__Role _t37;
				memcpy(&_t37, &_t35, sizeof(_result));
				return _t37;
			}
			x__json2__Any* _t39 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("position")}));
			_option_x__json2__Any _t38 = {0};
			if (_t39) {
				*((x__json2__Any*)&_t38.data) = *((x__json2__Any*)_t39);
			} else {
				_t38.state = 2; _t38.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t38.state != 0) {
				_result_discord__Role _t40;
				memcpy(&_t40, &_t38, sizeof(_result));
				return _t40;
			}
			x__json2__Any* _t43 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("permissions")}));
			_option_x__json2__Any _t42 = {0};
			if (_t43) {
				*((x__json2__Any*)&_t42.data) = *((x__json2__Any*)_t43);
			} else {
				_t42.state = 2; _t42.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t42.state != 0) {
				_result_discord__Role _t44;
				memcpy(&_t44, &_t42, sizeof(_result));
				return _t44;
			}
			
			_result_discord__Permissions _t41 = discord__Permissions__static__parse((*(x__json2__Any*)_t42.data));
			if (_t41.is_error) {
				_result_discord__Role _t45;
				memcpy(&_t45, &_t41, sizeof(_result));
				return _t45;
			}
			x__json2__Any* _t47 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("managed")}));
			_option_x__json2__Any _t46 = {0};
			if (_t47) {
				*((x__json2__Any*)&_t46.data) = *((x__json2__Any*)_t47);
			} else {
				_t46.state = 2; _t46.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t46.state != 0) {
				_result_discord__Role _t48;
				memcpy(&_t48, &_t46, sizeof(_result));
				return _t48;
			}
			x__json2__Any* _t50 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("managed")}));
			_option_x__json2__Any _t49 = {0};
			if (_t50) {
				*((x__json2__Any*)&_t49.data) = *((x__json2__Any*)_t50);
			} else {
				_t49.state = 2; _t49.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t49.state != 0) {
				_result_discord__Role _t51;
				memcpy(&_t51, &_t49, sizeof(_result));
				return _t51;
			}
			x__json2__Any* _t53 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("mentionable")}));
			_option_x__json2__Any _t52 = {0};
			if (_t53) {
				*((x__json2__Any*)&_t52.data) = *((x__json2__Any*)_t53);
			} else {
				_t52.state = 2; _t52.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t52.state != 0) {
				_result_discord__Role _t54;
				memcpy(&_t54, &_t52, sizeof(_result));
				return _t54;
			}
			x__json2__Any* _t56 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("mentionable")}));
			_option_x__json2__Any _t55 = {0};
			if (_t56) {
				*((x__json2__Any*)&_t55.data) = *((x__json2__Any*)_t56);
			} else {
				_t55.state = 2; _t55.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t55.state != 0) {
				_result_discord__Role _t57;
				memcpy(&_t57, &_t55, sizeof(_result));
				return _t57;
			}
			x__json2__Any* _t60 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("tags")}));
			_option_x__json2__Any _t59 = {0};
			if (_t60) {
				*((x__json2__Any*)&_t59.data) = *((x__json2__Any*)_t60);
			} else {
				_t59.state = 2; _t59.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__RoleTags _t58; /* if prepend */
			if (_t59.state == 0) {
				x__json2__Any o = (*(x__json2__Any*)_t59.data);
				_result_discord__RoleTags _t62 = discord__RoleTags__static__parse(o);
				if (_t62.is_error) {
					_result_discord__Role _t63;
					memcpy(&_t63, &_t62, sizeof(_result));
					return _t63;
				}
				
 				_option_discord__RoleTags _t61;
				_option_ok(&(discord__RoleTags[]) {  (*(discord__RoleTags*)_t62.data) }, (_option*)(&_t61), sizeof(discord__RoleTags));
				_t58 = _t61;
			} else {
				IError err = _t59.err;
				_t58.state = 2;
				_t58.err = _const_none__;
			}
			x__json2__Any* _t65 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("flags")}));
			_option_x__json2__Any _t64 = {0};
			if (_t65) {
				*((x__json2__Any*)&_t64.data) = *((x__json2__Any*)_t65);
			} else {
				_t64.state = 2; _t64.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t64.state != 0) {
				_result_discord__Role _t66;
				memcpy(&_t66, &_t64, sizeof(_result));
				return _t66;
			}
			x__json2__Any* _t68 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("flags")}));
			_option_x__json2__Any _t67 = {0};
			if (_t68) {
				*((x__json2__Any*)&_t67.data) = *((x__json2__Any*)_t68);
			} else {
				_t67.state = 2; _t67.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t67.state != 0) {
				_result_discord__Role _t69;
				memcpy(&_t69, &_t67, sizeof(_result));
				return _t69;
			}
			
			
			
			
			
			
			
 			
			
			
			
			
			
			
			
			
 		_result_discord__Role _t1;
		_result_ok(&(discord__Role[]) { ((discord__Role){
			.id =  (*(discord__Snowflake*)_t2.data),
			.name = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t7.data))._string,((*(x__json2__Any*)_t10.data))._typ, 21) /*expected idx: 21, name: string */ ,
			.color = ((int)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t13.data))._i64,((*(x__json2__Any*)_t16.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.hoist = /* as */ *(bool*)__as_cast(((*(x__json2__Any*)_t19.data))._bool,((*(x__json2__Any*)_t22.data))._typ, 19) /*expected idx: 19, name: bool */ ,
			.icon =  _t25,
			.unicode_emoji =  _t30,
			.position = ((int)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t35.data))._i64,((*(x__json2__Any*)_t38.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.permissions =  (*(discord__Permissions*)_t41.data),
			.managed = /* as */ *(bool*)__as_cast(((*(x__json2__Any*)_t46.data))._bool,((*(x__json2__Any*)_t49.data))._typ, 19) /*expected idx: 19, name: bool */ ,
			.mentionable = /* as */ *(bool*)__as_cast(((*(x__json2__Any*)_t52.data))._bool,((*(x__json2__Any*)_t55.data))._typ, 19) /*expected idx: 19, name: bool */ ,
			.tags =  _t58,
			.flags = ((discord__RoleFlags)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t64.data))._i64,((*(x__json2__Any*)_t67.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
		}) }, (_result*)(&_t1), sizeof(discord__Role));
		return _t1;
	}
	
	else {
		return (_result_discord__Role){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected role to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__Role){0};
}

_result_discord__WelcomeChannel discord__WelcomeChannel__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t2 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("emoji_id")}));
		_option_x__json2__Any _t1 = {0};
		if (_t2) {
			*((x__json2__Any*)&_t1.data) = *((x__json2__Any*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t1.state != 0) {
			_result_discord__WelcomeChannel _t3;
			memcpy(&_t3, &_t1, sizeof(_result));
			return _t3;
		}
		
		x__json2__Any emoji_id = (*(x__json2__Any*)_t1.data);
		x__json2__Any* _t5 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("emoji_name")}));
		_option_x__json2__Any _t4 = {0};
		if (_t5) {
			*((x__json2__Any*)&_t4.data) = *((x__json2__Any*)_t5);
		} else {
			_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t4.state != 0) {
			_result_discord__WelcomeChannel _t6;
			memcpy(&_t6, &_t4, sizeof(_result));
			return _t6;
		}
		
		x__json2__Any emoji_name = (*(x__json2__Any*)_t4.data);
		x__json2__Any* _t11 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("channel_id")}));
		_option_x__json2__Any _t10 = {0};
		if (_t11) {
			*((x__json2__Any*)&_t10.data) = *((x__json2__Any*)_t11);
		} else {
			_t10.state = 2; _t10.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t10.state != 0) {
			_result_discord__WelcomeChannel _t12;
			memcpy(&_t12, &_t10, sizeof(_result));
			return _t12;
		}
		
		_result_discord__Snowflake _t9 = discord__Snowflake__static__parse((*(x__json2__Any*)_t10.data));
		if (_t9.is_error) {
			_result_discord__WelcomeChannel _t13;
			memcpy(&_t13, &_t9, sizeof(_result));
			return _t13;
		}
		
 		_option_discord__Snowflake _t8;
		_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t9.data) }, (_option*)(&_t8), sizeof(discord__Snowflake));
		x__json2__Any* _t15 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("description")}));
		_option_x__json2__Any _t14 = {0};
		if (_t15) {
			*((x__json2__Any*)&_t14.data) = *((x__json2__Any*)_t15);
		} else {
			_t14.state = 2; _t14.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t14.state != 0) {
			_result_discord__WelcomeChannel _t16;
			memcpy(&_t16, &_t14, sizeof(_result));
			return _t16;
		}
		x__json2__Any* _t18 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("description")}));
		_option_x__json2__Any _t17 = {0};
		if (_t18) {
			*((x__json2__Any*)&_t17.data) = *((x__json2__Any*)_t18);
		} else {
			_t17.state = 2; _t17.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t17.state != 0) {
			_result_discord__WelcomeChannel _t19;
			memcpy(&_t19, &_t17, sizeof(_result));
			return _t19;
		}
		_option_discord__Snowflake _t20; /* if prepend */
		if ((emoji_id)._typ != 170 /* x.json2.Null */) {
			_result_discord__Snowflake _t22 = discord__Snowflake__static__parse(emoji_id);
			if (_t22.is_error) {
				_result_discord__WelcomeChannel _t23;
				memcpy(&_t23, &_t22, sizeof(_result));
				return _t23;
			}
			
 			_option_discord__Snowflake _t21;
			_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t22.data) }, (_option*)(&_t21), sizeof(discord__Snowflake));
			_t20 = _t21;
		} else {
			_t20.state = 2;
			_t20.err = _const_none__;
		}
		_option_string _t24; /* if prepend */
		if ((emoji_name)._typ != 170 /* x.json2.Null */) {
			_option_string _t25;
			_option_ok(&(string[]) { /* as */ *(string*)__as_cast((emoji_name)._string,(emoji_name)._typ, 21) /*expected idx: 21, name: string */  }, (_option*)(&_t25), sizeof(string));
			_t24 = _t25;
		} else {
			_t24.state = 2;
			_t24.err = _const_none__;
		}
		
		
		_result_discord__WelcomeChannel _t7;
		_result_ok(&(discord__WelcomeChannel[]) { ((discord__WelcomeChannel){.channel_id = _t8,.description = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t14.data))._string,((*(x__json2__Any*)_t17.data))._typ, 21) /*expected idx: 21, name: string */ ,.emoji_id =  _t20,.emoji_name =  _t24,}) }, (_result*)(&_t7), sizeof(discord__WelcomeChannel));
		return _t7;
	}
	
	else {
		return (_result_discord__WelcomeChannel){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected welcome channel to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__WelcomeChannel){0};
}

_result_discord__WelcomeScreen discord__WelcomeScreen__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t2 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("description")}));
		_option_x__json2__Any _t1 = {0};
		if (_t2) {
			*((x__json2__Any*)&_t1.data) = *((x__json2__Any*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t1.state != 0) {
			_result_discord__WelcomeScreen _t3;
			memcpy(&_t3, &_t1, sizeof(_result));
			return _t3;
		}
		
		x__json2__Any description = (*(x__json2__Any*)_t1.data);
		_option_string _t5; /* if prepend */
		if ((description)._typ == 21 /* string */) {
			_option_string _t6;
			_option_ok(&(string[]) { (*description._string) }, (_option*)(&_t6), sizeof(string));
			_t5 = _t6;
		} else {
			_t5.state = 2;
			_t5.err = _const_none__;
		}
		x__json2__Any* _t10 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("welcome_channels")}));
		_option_x__json2__Any _t9 = {0};
		if (_t10) {
			*((x__json2__Any*)&_t9.data) = *((x__json2__Any*)_t10);
		} else {
			_t9.state = 2; _t9.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t9.state != 0) {
			_result_discord__WelcomeScreen _t11;
			memcpy(&_t11, &_t9, sizeof(_result));
			return _t11;
		}
		x__json2__Any* _t13 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("welcome_channels")}));
		_option_x__json2__Any _t12 = {0};
		if (_t13) {
			*((x__json2__Any*)&_t12.data) = *((x__json2__Any*)_t13);
		} else {
			_t12.state = 2; _t12.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t12.state != 0) {
			_result_discord__WelcomeScreen _t14;
			memcpy(&_t14, &_t12, sizeof(_result));
			return _t14;
		}
		
		
		Array_discord__WelcomeChannel _t7 = {0};
		Array_x__json2__Any _t7_orig = (/* as */ *(Array_x__json2__Any*)__as_cast(((*(x__json2__Any*)_t9.data))._Array_x__json2__Any,((*(x__json2__Any*)_t12.data))._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
		int _t7_len = _t7_orig.len;
		_t7 = __new_array(0, _t7_len, sizeof(discord__WelcomeChannel));

		for (int _t15 = 0; _t15 < _t7_len; ++_t15) {
			x__json2__Any it = ((x__json2__Any*) _t7_orig.data)[_t15];
			_result_discord__WelcomeChannel _t16 = discord__WelcomeChannel__static__parse(it);
			if (_t16.is_error) {
				_result_discord__WelcomeScreen _t17;
				memcpy(&_t17, &_t16, sizeof(_result));
				return _t17;
			}
			
 			discord__WelcomeChannel _t8 =  (*(discord__WelcomeChannel*)_t16.data);
			array_push((array*)&_t7, &_t8);
		}
		_result_discord__WelcomeScreen _t4;
		_result_ok(&(discord__WelcomeScreen[]) { ((discord__WelcomeScreen){.description =  _t5,.welcome_channels =_t7,}) }, (_result*)(&_t4), sizeof(discord__WelcomeScreen));
		return _t4;
	}
	
	else {
		return (_result_discord__WelcomeScreen){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected welcome screen to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__WelcomeScreen){0};
}

_result_discord__Guild discord__Guild__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t2 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("icon")}));
		_option_x__json2__Any _t1 = {0};
		if (_t2) {
			*((x__json2__Any*)&_t1.data) = *((x__json2__Any*)_t2);
		} else {
			_t1.state = 2; _t1.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t1.state != 0) {
			_result_discord__Guild _t3;
			memcpy(&_t3, &_t1, sizeof(_result));
			return _t3;
		}
		
		x__json2__Any icon = (*(x__json2__Any*)_t1.data);
		x__json2__Any* _t5 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("icon_hash")}));
		_option_x__json2__Any _t4 = {0};
		if (_t5) {
			*((x__json2__Any*)&_t4.data) = *((x__json2__Any*)_t5);
		} else {
			_t4.state = 2; _t4.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t4.state != 0) {
			_result_discord__Guild _t6;
			memcpy(&_t6, &_t4, sizeof(_result));
			return _t6;
		}
		
		x__json2__Any icon_hash = (*(x__json2__Any*)_t4.data);
		x__json2__Any* _t8 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("splash")}));
		_option_x__json2__Any _t7 = {0};
		if (_t8) {
			*((x__json2__Any*)&_t7.data) = *((x__json2__Any*)_t8);
		} else {
			_t7.state = 2; _t7.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t7.state != 0) {
			_result_discord__Guild _t9;
			memcpy(&_t9, &_t7, sizeof(_result));
			return _t9;
		}
		
		x__json2__Any splash = (*(x__json2__Any*)_t7.data);
		x__json2__Any* _t11 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("discovery_splash")}));
		_option_x__json2__Any _t10 = {0};
		if (_t11) {
			*((x__json2__Any*)&_t10.data) = *((x__json2__Any*)_t11);
		} else {
			_t10.state = 2; _t10.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t10.state != 0) {
			_result_discord__Guild _t12;
			memcpy(&_t12, &_t10, sizeof(_result));
			return _t12;
		}
		
		x__json2__Any discovery_splash = (*(x__json2__Any*)_t10.data);
		x__json2__Any* _t14 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("afk_channel_id")}));
		_option_x__json2__Any _t13 = {0};
		if (_t14) {
			*((x__json2__Any*)&_t13.data) = *((x__json2__Any*)_t14);
		} else {
			_t13.state = 2; _t13.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t13.state != 0) {
			_result_discord__Guild _t15;
			memcpy(&_t15, &_t13, sizeof(_result));
			return _t15;
		}
		
		x__json2__Any afk_channel_id = (*(x__json2__Any*)_t13.data);
		x__json2__Any* _t17 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("application_id")}));
		_option_x__json2__Any _t16 = {0};
		if (_t17) {
			*((x__json2__Any*)&_t16.data) = *((x__json2__Any*)_t17);
		} else {
			_t16.state = 2; _t16.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t16.state != 0) {
			_result_discord__Guild _t18;
			memcpy(&_t18, &_t16, sizeof(_result));
			return _t18;
		}
		
		x__json2__Any application_id = (*(x__json2__Any*)_t16.data);
		x__json2__Any* _t20 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("system_channel_id")}));
		_option_x__json2__Any _t19 = {0};
		if (_t20) {
			*((x__json2__Any*)&_t19.data) = *((x__json2__Any*)_t20);
		} else {
			_t19.state = 2; _t19.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t19.state != 0) {
			_result_discord__Guild _t21;
			memcpy(&_t21, &_t19, sizeof(_result));
			return _t21;
		}
		
		x__json2__Any system_channel_id = (*(x__json2__Any*)_t19.data);
		x__json2__Any* _t23 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("rules_channel_id")}));
		_option_x__json2__Any _t22 = {0};
		if (_t23) {
			*((x__json2__Any*)&_t22.data) = *((x__json2__Any*)_t23);
		} else {
			_t22.state = 2; _t22.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t22.state != 0) {
			_result_discord__Guild _t24;
			memcpy(&_t24, &_t22, sizeof(_result));
			return _t24;
		}
		
		x__json2__Any rules_channel_id = (*(x__json2__Any*)_t22.data);
		x__json2__Any* _t26 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("vanity_url_code")}));
		_option_x__json2__Any _t25 = {0};
		if (_t26) {
			*((x__json2__Any*)&_t25.data) = *((x__json2__Any*)_t26);
		} else {
			_t25.state = 2; _t25.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t25.state != 0) {
			_result_discord__Guild _t27;
			memcpy(&_t27, &_t25, sizeof(_result));
			return _t27;
		}
		
		x__json2__Any vanity_url_code = (*(x__json2__Any*)_t25.data);
		x__json2__Any* _t29 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("description")}));
		_option_x__json2__Any _t28 = {0};
		if (_t29) {
			*((x__json2__Any*)&_t28.data) = *((x__json2__Any*)_t29);
		} else {
			_t28.state = 2; _t28.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t28.state != 0) {
			_result_discord__Guild _t30;
			memcpy(&_t30, &_t28, sizeof(_result));
			return _t30;
		}
		
		x__json2__Any description = (*(x__json2__Any*)_t28.data);
		x__json2__Any* _t32 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("banner")}));
		_option_x__json2__Any _t31 = {0};
		if (_t32) {
			*((x__json2__Any*)&_t31.data) = *((x__json2__Any*)_t32);
		} else {
			_t31.state = 2; _t31.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t31.state != 0) {
			_result_discord__Guild _t33;
			memcpy(&_t33, &_t31, sizeof(_result));
			return _t33;
		}
		
		x__json2__Any banner = (*(x__json2__Any*)_t31.data);
		x__json2__Any* _t35 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("public_updates_channel_id")}));
		_option_x__json2__Any _t34 = {0};
		if (_t35) {
			*((x__json2__Any*)&_t34.data) = *((x__json2__Any*)_t35);
		} else {
			_t34.state = 2; _t34.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t34.state != 0) {
			_result_discord__Guild _t36;
			memcpy(&_t36, &_t34, sizeof(_result));
			return _t36;
		}
		
		x__json2__Any public_updates_channel_id = (*(x__json2__Any*)_t34.data);
		x__json2__Any* _t38 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("safety_alerts_channel_id")}));
		_option_x__json2__Any _t37 = {0};
		if (_t38) {
			*((x__json2__Any*)&_t37.data) = *((x__json2__Any*)_t38);
		} else {
			_t37.state = 2; _t37.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t37.state != 0) {
			_result_discord__Guild _t39;
			memcpy(&_t39, &_t37, sizeof(_result));
			return _t39;
		}
		
		x__json2__Any safety_alerts_channel_id = (*(x__json2__Any*)_t37.data);
			x__json2__Any* _t43 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("id")}));
			_option_x__json2__Any _t42 = {0};
			if (_t43) {
				*((x__json2__Any*)&_t42.data) = *((x__json2__Any*)_t43);
			} else {
				_t42.state = 2; _t42.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t42.state != 0) {
				_result_discord__Guild _t44;
				memcpy(&_t44, &_t42, sizeof(_result));
				return _t44;
			}
			
			_result_discord__Snowflake _t41 = discord__Snowflake__static__parse((*(x__json2__Any*)_t42.data));
			if (_t41.is_error) {
				_result_discord__Guild _t45;
				memcpy(&_t45, &_t41, sizeof(_result));
				return _t45;
			}
			x__json2__Any* _t47 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
			_option_x__json2__Any _t46 = {0};
			if (_t47) {
				*((x__json2__Any*)&_t46.data) = *((x__json2__Any*)_t47);
			} else {
				_t46.state = 2; _t46.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t46.state != 0) {
				_result_discord__Guild _t48;
				memcpy(&_t48, &_t46, sizeof(_result));
				return _t48;
			}
			x__json2__Any* _t50 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
			_option_x__json2__Any _t49 = {0};
			if (_t50) {
				*((x__json2__Any*)&_t49.data) = *((x__json2__Any*)_t50);
			} else {
				_t49.state = 2; _t49.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t49.state != 0) {
				_result_discord__Guild _t51;
				memcpy(&_t51, &_t49, sizeof(_result));
				return _t51;
			}
			_option_string _t52; /* if prepend */
			if ((icon)._typ == 21 /* string */) {
				_option_string _t53;
				_option_ok(&(string[]) { (*icon._string) }, (_option*)(&_t53), sizeof(string));
				_t52 = _t53;
			} else {
				_t52.state = 2;
				_t52.err = _const_none__;
			}
			_option_string _t54; /* if prepend */
			if ((icon_hash)._typ == 21 /* string */) {
				_option_string _t55;
				_option_ok(&(string[]) { (*icon_hash._string) }, (_option*)(&_t55), sizeof(string));
				_t54 = _t55;
			} else {
				_t54.state = 2;
				_t54.err = _const_none__;
			}
			_option_string _t56; /* if prepend */
			if ((splash)._typ == 21 /* string */) {
				_option_string _t57;
				_option_ok(&(string[]) { (*splash._string) }, (_option*)(&_t57), sizeof(string));
				_t56 = _t57;
			} else {
				_t56.state = 2;
				_t56.err = _const_none__;
			}
			_option_string _t58; /* if prepend */
			if ((discovery_splash)._typ == 21 /* string */) {
				_option_string _t59;
				_option_ok(&(string[]) { (*discovery_splash._string) }, (_option*)(&_t59), sizeof(string));
				_t58 = _t59;
			} else {
				_t58.state = 2;
				_t58.err = _const_none__;
			}
			x__json2__Any* _t62 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("owner_id")}));
			_option_x__json2__Any _t61 = {0};
			if (_t62) {
				*((x__json2__Any*)&_t61.data) = *((x__json2__Any*)_t62);
			} else {
				_t61.state = 2; _t61.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t61.state != 0) {
				_result_discord__Guild _t63;
				memcpy(&_t63, &_t61, sizeof(_result));
				return _t63;
			}
			
			_result_discord__Snowflake _t60 = discord__Snowflake__static__parse((*(x__json2__Any*)_t61.data));
			if (_t60.is_error) {
				_result_discord__Guild _t64;
				memcpy(&_t64, &_t60, sizeof(_result));
				return _t64;
			}
			_option_discord__Snowflake _t65; /* if prepend */
			if ((afk_channel_id)._typ != 170 /* x.json2.Null */) {
				_result_discord__Snowflake _t67 = discord__Snowflake__static__parse(afk_channel_id);
				if (_t67.is_error) {
					_result_discord__Guild _t68;
					memcpy(&_t68, &_t67, sizeof(_result));
					return _t68;
				}
				
 				_option_discord__Snowflake _t66;
				_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t67.data) }, (_option*)(&_t66), sizeof(discord__Snowflake));
				_t65 = _t66;
			} else {
				_t65.state = 2;
				_t65.err = _const_none__;
			}
			x__json2__Any* _t70 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("afk_timeout")}));
			_option_x__json2__Any _t69 = {0};
			if (_t70) {
				*((x__json2__Any*)&_t69.data) = *((x__json2__Any*)_t70);
			} else {
				_t69.state = 2; _t69.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t69.state != 0) {
				_result_discord__Guild _t71;
				memcpy(&_t71, &_t69, sizeof(_result));
				return _t71;
			}
			x__json2__Any* _t73 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("afk_timeout")}));
			_option_x__json2__Any _t72 = {0};
			if (_t73) {
				*((x__json2__Any*)&_t72.data) = *((x__json2__Any*)_t73);
			} else {
				_t72.state = 2; _t72.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t72.state != 0) {
				_result_discord__Guild _t74;
				memcpy(&_t74, &_t72, sizeof(_result));
				return _t74;
			}
			x__json2__Any* _t77 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("widget_enabled")}));
			_option_x__json2__Any _t76 = {0};
			if (_t77) {
				*((x__json2__Any*)&_t76.data) = *((x__json2__Any*)_t77);
			} else {
				_t76.state = 2; _t76.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_bool _t75; /* if prepend */
			if (_t76.state == 0) {
				x__json2__Any b = (*(x__json2__Any*)_t76.data);
				_option_bool _t78;
				_option_ok(&(bool[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t78), sizeof(bool));
				_t75 = _t78;
			} else {
				IError err = _t76.err;
				_t75.state = 2;
				_t75.err = _const_none__;
			}
			x__json2__Any* _t81 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("widget_channel_id")}));
			_option_x__json2__Any _t80 = {0};
			if (_t81) {
				*((x__json2__Any*)&_t80.data) = *((x__json2__Any*)_t81);
			} else {
				_t80.state = 2; _t80.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__Snowflake _t79; /* if prepend */
			if (_t80.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t80.data);
				_option_discord__Snowflake _t82; /* if prepend */
				if ((s)._typ != 170 /* x.json2.Null */) {
					_result_discord__Snowflake _t83 = discord__Snowflake__static__parse(s);
					if (_t83.is_error) {
						_result_discord__Guild _t84;
						memcpy(&_t84, &_t83, sizeof(_result));
						return _t84;
					}
					
 					_option_ok(&(discord__Guild[]) {  (*(discord__Snowflake*)_t83.data) }, (_option*)(&_t82), sizeof(discord__Guild));
				} else {
					_t82.state = 2;
					_t82.err = _const_none__;
				}
				
				_t79 =  _t82;
			} else {
				IError err = _t80.err;
				_t79.state = 2;
				_t79.err = _const_none__;
			}
			x__json2__Any* _t86 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("verification_level")}));
			_option_x__json2__Any _t85 = {0};
			if (_t86) {
				*((x__json2__Any*)&_t85.data) = *((x__json2__Any*)_t86);
			} else {
				_t85.state = 2; _t85.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t85.state != 0) {
				_result_discord__Guild _t87;
				memcpy(&_t87, &_t85, sizeof(_result));
				return _t87;
			}
			x__json2__Any* _t89 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("verification_level")}));
			_option_x__json2__Any _t88 = {0};
			if (_t89) {
				*((x__json2__Any*)&_t88.data) = *((x__json2__Any*)_t89);
			} else {
				_t88.state = 2; _t88.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t88.state != 0) {
				_result_discord__Guild _t90;
				memcpy(&_t90, &_t88, sizeof(_result));
				return _t90;
			}
			x__json2__Any* _t92 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("explicit_content_filter")}));
			_option_x__json2__Any _t91 = {0};
			if (_t92) {
				*((x__json2__Any*)&_t91.data) = *((x__json2__Any*)_t92);
			} else {
				_t91.state = 2; _t91.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t91.state != 0) {
				_result_discord__Guild _t93;
				memcpy(&_t93, &_t91, sizeof(_result));
				return _t93;
			}
			x__json2__Any* _t95 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("explicit_content_filter")}));
			_option_x__json2__Any _t94 = {0};
			if (_t95) {
				*((x__json2__Any*)&_t94.data) = *((x__json2__Any*)_t95);
			} else {
				_t94.state = 2; _t94.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t94.state != 0) {
				_result_discord__Guild _t96;
				memcpy(&_t96, &_t94, sizeof(_result));
				return _t96;
			}
			x__json2__Any* _t100 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("roles")}));
			_option_x__json2__Any _t99 = {0};
			if (_t100) {
				*((x__json2__Any*)&_t99.data) = *((x__json2__Any*)_t100);
			} else {
				_t99.state = 2; _t99.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t99.state != 0) {
				_result_discord__Guild _t101;
				memcpy(&_t101, &_t99, sizeof(_result));
				return _t101;
			}
			x__json2__Any* _t103 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("roles")}));
			_option_x__json2__Any _t102 = {0};
			if (_t103) {
				*((x__json2__Any*)&_t102.data) = *((x__json2__Any*)_t103);
			} else {
				_t102.state = 2; _t102.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t102.state != 0) {
				_result_discord__Guild _t104;
				memcpy(&_t104, &_t102, sizeof(_result));
				return _t104;
			}
			
			
			Array_discord__Role _t97 = {0};
			Array_x__json2__Any _t97_orig = (/* as */ *(Array_x__json2__Any*)__as_cast(((*(x__json2__Any*)_t99.data))._Array_x__json2__Any,((*(x__json2__Any*)_t102.data))._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
			int _t97_len = _t97_orig.len;
			_t97 = __new_array(0, _t97_len, sizeof(discord__Role));

			for (int _t105 = 0; _t105 < _t97_len; ++_t105) {
				x__json2__Any it = ((x__json2__Any*) _t97_orig.data)[_t105];
				_result_discord__Role _t106 = discord__Role__static__parse(it);
				if (_t106.is_error) {
					_result_discord__Guild _t107;
					memcpy(&_t107, &_t106, sizeof(_result));
					return _t107;
				}
				
 				discord__Role _t98 =  (*(discord__Role*)_t106.data);
				array_push((array*)&_t97, &_t98);
			}
			x__json2__Any* _t111 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("emojis")}));
			_option_x__json2__Any _t110 = {0};
			if (_t111) {
				*((x__json2__Any*)&_t110.data) = *((x__json2__Any*)_t111);
			} else {
				_t110.state = 2; _t110.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t110.state != 0) {
				_result_discord__Guild _t112;
				memcpy(&_t112, &_t110, sizeof(_result));
				return _t112;
			}
			x__json2__Any* _t114 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("emojis")}));
			_option_x__json2__Any _t113 = {0};
			if (_t114) {
				*((x__json2__Any*)&_t113.data) = *((x__json2__Any*)_t114);
			} else {
				_t113.state = 2; _t113.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t113.state != 0) {
				_result_discord__Guild _t115;
				memcpy(&_t115, &_t113, sizeof(_result));
				return _t115;
			}
			
			
			Array_discord__Emoji _t108 = {0};
			Array_x__json2__Any _t108_orig = (/* as */ *(Array_x__json2__Any*)__as_cast(((*(x__json2__Any*)_t110.data))._Array_x__json2__Any,((*(x__json2__Any*)_t113.data))._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
			int _t108_len = _t108_orig.len;
			_t108 = __new_array(0, _t108_len, sizeof(discord__Emoji));

			for (int _t116 = 0; _t116 < _t108_len; ++_t116) {
				x__json2__Any it = ((x__json2__Any*) _t108_orig.data)[_t116];
				_result_discord__Emoji _t117 = discord__Emoji__static__parse(it);
				if (_t117.is_error) {
					_result_discord__Guild _t118;
					memcpy(&_t118, &_t117, sizeof(_result));
					return _t118;
				}
				
 				discord__Emoji _t109 =  (*(discord__Emoji*)_t117.data);
				array_push((array*)&_t108, &_t109);
			}
			x__json2__Any* _t122 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("features")}));
			_option_x__json2__Any _t121 = {0};
			if (_t122) {
				*((x__json2__Any*)&_t121.data) = *((x__json2__Any*)_t122);
			} else {
				_t121.state = 2; _t121.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t121.state != 0) {
				_result_discord__Guild _t123;
				memcpy(&_t123, &_t121, sizeof(_result));
				return _t123;
			}
			x__json2__Any* _t125 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("features")}));
			_option_x__json2__Any _t124 = {0};
			if (_t125) {
				*((x__json2__Any*)&_t124.data) = *((x__json2__Any*)_t125);
			} else {
				_t124.state = 2; _t124.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t124.state != 0) {
				_result_discord__Guild _t126;
				memcpy(&_t126, &_t124, sizeof(_result));
				return _t126;
			}
			
			
			Array_discord__GuildFeature _t119 = {0};
			Array_x__json2__Any _t119_orig = (/* as */ *(Array_x__json2__Any*)__as_cast(((*(x__json2__Any*)_t121.data))._Array_x__json2__Any,((*(x__json2__Any*)_t124.data))._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
			int _t119_len = _t119_orig.len;
			_t119 = __new_array(0, _t119_len, sizeof(discord__GuildFeature));

			for (int _t127 = 0; _t127 < _t119_len; ++_t127) {
				x__json2__Any it = ((x__json2__Any*) _t119_orig.data)[_t127];
				discord__GuildFeature _t120 = ((/* as */ *(string*)__as_cast((it)._string,(it)._typ, 21) /*expected idx: 21, name: string */ ));
				array_push((array*)&_t119, &_t120);
			}
			x__json2__Any* _t129 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("mfa_level")}));
			_option_x__json2__Any _t128 = {0};
			if (_t129) {
				*((x__json2__Any*)&_t128.data) = *((x__json2__Any*)_t129);
			} else {
				_t128.state = 2; _t128.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t128.state != 0) {
				_result_discord__Guild _t130;
				memcpy(&_t130, &_t128, sizeof(_result));
				return _t130;
			}
			x__json2__Any* _t132 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("mfa_level")}));
			_option_x__json2__Any _t131 = {0};
			if (_t132) {
				*((x__json2__Any*)&_t131.data) = *((x__json2__Any*)_t132);
			} else {
				_t131.state = 2; _t131.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t131.state != 0) {
				_result_discord__Guild _t133;
				memcpy(&_t133, &_t131, sizeof(_result));
				return _t133;
			}
			_option_discord__Snowflake _t134; /* if prepend */
			if ((application_id)._typ != 170 /* x.json2.Null */) {
				_result_discord__Snowflake _t136 = discord__Snowflake__static__parse(application_id);
				if (_t136.is_error) {
					_result_discord__Guild _t137;
					memcpy(&_t137, &_t136, sizeof(_result));
					return _t137;
				}
				
 				_option_discord__Snowflake _t135;
				_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t136.data) }, (_option*)(&_t135), sizeof(discord__Snowflake));
				_t134 = _t135;
			} else {
				_t134.state = 2;
				_t134.err = _const_none__;
			}
			_option_discord__Snowflake _t138; /* if prepend */
			if ((system_channel_id)._typ != 170 /* x.json2.Null */) {
				_result_discord__Snowflake _t140 = discord__Snowflake__static__parse(system_channel_id);
				if (_t140.is_error) {
					_result_discord__Guild _t141;
					memcpy(&_t141, &_t140, sizeof(_result));
					return _t141;
				}
				
 				_option_discord__Snowflake _t139;
				_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t140.data) }, (_option*)(&_t139), sizeof(discord__Snowflake));
				_t138 = _t139;
			} else {
				_t138.state = 2;
				_t138.err = _const_none__;
			}
			x__json2__Any* _t143 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("system_channel_flags")}));
			_option_x__json2__Any _t142 = {0};
			if (_t143) {
				*((x__json2__Any*)&_t142.data) = *((x__json2__Any*)_t143);
			} else {
				_t142.state = 2; _t142.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t142.state != 0) {
				_result_discord__Guild _t144;
				memcpy(&_t144, &_t142, sizeof(_result));
				return _t144;
			}
			x__json2__Any* _t146 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("system_channel_flags")}));
			_option_x__json2__Any _t145 = {0};
			if (_t146) {
				*((x__json2__Any*)&_t145.data) = *((x__json2__Any*)_t146);
			} else {
				_t145.state = 2; _t145.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t145.state != 0) {
				_result_discord__Guild _t147;
				memcpy(&_t147, &_t145, sizeof(_result));
				return _t147;
			}
			_option_discord__Snowflake _t148; /* if prepend */
			if ((rules_channel_id)._typ != 170 /* x.json2.Null */) {
				_result_discord__Snowflake _t150 = discord__Snowflake__static__parse(rules_channel_id);
				if (_t150.is_error) {
					_result_discord__Guild _t151;
					memcpy(&_t151, &_t150, sizeof(_result));
					return _t151;
				}
				
 				_option_discord__Snowflake _t149;
				_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t150.data) }, (_option*)(&_t149), sizeof(discord__Snowflake));
				_t148 = _t149;
			} else {
				_t148.state = 2;
				_t148.err = _const_none__;
			}
			x__json2__Any* _t154 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("max_presences")}));
			_option_x__json2__Any _t153 = {0};
			if (_t154) {
				*((x__json2__Any*)&_t153.data) = *((x__json2__Any*)_t154);
			} else {
				_t153.state = 2; _t153.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t152; /* if prepend */
			if (_t153.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t153.data);
				_option_int _t155; /* if prepend */
				if ((i)._typ == 8 /* int */) {
					_option_int _t156;
					_option_ok(&(int[]) { (*i._int) }, (_option*)(&_t156), sizeof(int));
					_t155 = _t156;
				} else {
					_t155.state = 2;
					_t155.err = _const_none__;
				}
				
				_t152 =  _t155;
			} else {
				IError err = _t153.err;
				_t152.state = 2;
				_t152.err = _const_none__;
			}
			x__json2__Any* _t159 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("max_members")}));
			_option_x__json2__Any _t158 = {0};
			if (_t159) {
				*((x__json2__Any*)&_t158.data) = *((x__json2__Any*)_t159);
			} else {
				_t158.state = 2; _t158.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t157; /* if prepend */
			if (_t158.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t158.data);
				_option_int _t160; /* if prepend */
				if ((i)._typ == 8 /* int */) {
					_option_int _t161;
					_option_ok(&(int[]) { (*i._int) }, (_option*)(&_t161), sizeof(int));
					_t160 = _t161;
				} else {
					_t160.state = 2;
					_t160.err = _const_none__;
				}
				
				_t157 =  _t160;
			} else {
				IError err = _t158.err;
				_t157.state = 2;
				_t157.err = _const_none__;
			}
			_option_string _t162; /* if prepend */
			if ((vanity_url_code)._typ != 170 /* x.json2.Null */) {
				_option_string _t163;
				_option_ok(&(string[]) { /* as */ *(string*)__as_cast((vanity_url_code)._string,(vanity_url_code)._typ, 21) /*expected idx: 21, name: string */  }, (_option*)(&_t163), sizeof(string));
				_t162 = _t163;
			} else {
				_t162.state = 2;
				_t162.err = _const_none__;
			}
			_option_string _t164; /* if prepend */
			if ((description)._typ != 170 /* x.json2.Null */) {
				_option_string _t165;
				_option_ok(&(string[]) { /* as */ *(string*)__as_cast((description)._string,(description)._typ, 21) /*expected idx: 21, name: string */  }, (_option*)(&_t165), sizeof(string));
				_t164 = _t165;
			} else {
				_t164.state = 2;
				_t164.err = _const_none__;
			}
			_option_string _t166; /* if prepend */
			if ((banner)._typ != 170 /* x.json2.Null */) {
				_option_string _t167;
				_option_ok(&(string[]) { /* as */ *(string*)__as_cast((banner)._string,(banner)._typ, 21) /*expected idx: 21, name: string */  }, (_option*)(&_t167), sizeof(string));
				_t166 = _t167;
			} else {
				_t166.state = 2;
				_t166.err = _const_none__;
			}
			x__json2__Any* _t169 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("premium_tier")}));
			_option_x__json2__Any _t168 = {0};
			if (_t169) {
				*((x__json2__Any*)&_t168.data) = *((x__json2__Any*)_t169);
			} else {
				_t168.state = 2; _t168.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t168.state != 0) {
				_result_discord__Guild _t170;
				memcpy(&_t170, &_t168, sizeof(_result));
				return _t170;
			}
			x__json2__Any* _t172 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("premium_tier")}));
			_option_x__json2__Any _t171 = {0};
			if (_t172) {
				*((x__json2__Any*)&_t171.data) = *((x__json2__Any*)_t172);
			} else {
				_t171.state = 2; _t171.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t171.state != 0) {
				_result_discord__Guild _t173;
				memcpy(&_t173, &_t171, sizeof(_result));
				return _t173;
			}
			x__json2__Any* _t176 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("premium_subscription_count")}));
			_option_x__json2__Any _t175 = {0};
			if (_t176) {
				*((x__json2__Any*)&_t175.data) = *((x__json2__Any*)_t176);
			} else {
				_t175.state = 2; _t175.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t174; /* if prepend */
			if (_t175.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t175.data);
				_option_int _t177;
				_option_ok(&(int[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t177), sizeof(int));
				_t174 = _t177;
			} else {
				IError err = _t175.err;
				_t174.state = 2;
				_t174.err = _const_none__;
			}
			x__json2__Any* _t179 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("preferred_locale")}));
			_option_x__json2__Any _t178 = {0};
			if (_t179) {
				*((x__json2__Any*)&_t178.data) = *((x__json2__Any*)_t179);
			} else {
				_t178.state = 2; _t178.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t178.state != 0) {
				_result_discord__Guild _t180;
				memcpy(&_t180, &_t178, sizeof(_result));
				return _t180;
			}
			x__json2__Any* _t182 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("preferred_locale")}));
			_option_x__json2__Any _t181 = {0};
			if (_t182) {
				*((x__json2__Any*)&_t181.data) = *((x__json2__Any*)_t182);
			} else {
				_t181.state = 2; _t181.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t181.state != 0) {
				_result_discord__Guild _t183;
				memcpy(&_t183, &_t181, sizeof(_result));
				return _t183;
			}
			_option_discord__Snowflake _t184; /* if prepend */
			if ((public_updates_channel_id)._typ != 170 /* x.json2.Null */) {
				_result_discord__Snowflake _t186 = discord__Snowflake__static__parse(public_updates_channel_id);
				if (_t186.is_error) {
					_result_discord__Guild _t187;
					memcpy(&_t187, &_t186, sizeof(_result));
					return _t187;
				}
				
 				_option_discord__Snowflake _t185;
				_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t186.data) }, (_option*)(&_t185), sizeof(discord__Snowflake));
				_t184 = _t185;
			} else {
				_t184.state = 2;
				_t184.err = _const_none__;
			}
			x__json2__Any* _t190 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("max_video_channel_users")}));
			_option_x__json2__Any _t189 = {0};
			if (_t190) {
				*((x__json2__Any*)&_t189.data) = *((x__json2__Any*)_t190);
			} else {
				_t189.state = 2; _t189.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t188; /* if prepend */
			if (_t189.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t189.data);
				_option_int _t191;
				_option_ok(&(int[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t191), sizeof(int));
				_t188 = _t191;
			} else {
				IError err = _t189.err;
				_t188.state = 2;
				_t188.err = _const_none__;
			}
			x__json2__Any* _t194 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("max_stage_video_channel_users")}));
			_option_x__json2__Any _t193 = {0};
			if (_t194) {
				*((x__json2__Any*)&_t193.data) = *((x__json2__Any*)_t194);
			} else {
				_t193.state = 2; _t193.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t192; /* if prepend */
			if (_t193.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t193.data);
				_option_int _t195;
				_option_ok(&(int[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t195), sizeof(int));
				_t192 = _t195;
			} else {
				IError err = _t193.err;
				_t192.state = 2;
				_t192.err = _const_none__;
			}
			x__json2__Any* _t198 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("approximate_member_count")}));
			_option_x__json2__Any _t197 = {0};
			if (_t198) {
				*((x__json2__Any*)&_t197.data) = *((x__json2__Any*)_t198);
			} else {
				_t197.state = 2; _t197.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t196; /* if prepend */
			if (_t197.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t197.data);
				_option_int _t199;
				_option_ok(&(int[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t199), sizeof(int));
				_t196 = _t199;
			} else {
				IError err = _t197.err;
				_t196.state = 2;
				_t196.err = _const_none__;
			}
			x__json2__Any* _t202 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("approximate_presence_count")}));
			_option_x__json2__Any _t201 = {0};
			if (_t202) {
				*((x__json2__Any*)&_t201.data) = *((x__json2__Any*)_t202);
			} else {
				_t201.state = 2; _t201.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_int _t200; /* if prepend */
			if (_t201.state == 0) {
				x__json2__Any i = (*(x__json2__Any*)_t201.data);
				_option_int _t203;
				_option_ok(&(int[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t203), sizeof(int));
				_t200 = _t203;
			} else {
				IError err = _t201.err;
				_t200.state = 2;
				_t200.err = _const_none__;
			}
			x__json2__Any* _t206 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("welcome_screen")}));
			_option_x__json2__Any _t205 = {0};
			if (_t206) {
				*((x__json2__Any*)&_t205.data) = *((x__json2__Any*)_t206);
			} else {
				_t205.state = 2; _t205.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__WelcomeScreen _t204; /* if prepend */
			if (_t205.state == 0) {
				x__json2__Any o = (*(x__json2__Any*)_t205.data);
				_result_discord__WelcomeScreen _t208 = discord__WelcomeScreen__static__parse(o);
				if (_t208.is_error) {
					_result_discord__Guild _t209;
					memcpy(&_t209, &_t208, sizeof(_result));
					return _t209;
				}
				
 				_option_discord__WelcomeScreen _t207;
				_option_ok(&(discord__WelcomeScreen[]) {  (*(discord__WelcomeScreen*)_t208.data) }, (_option*)(&_t207), sizeof(discord__WelcomeScreen));
				_t204 = _t207;
			} else {
				IError err = _t205.err;
				_t204.state = 2;
				_t204.err = _const_none__;
			}
			x__json2__Any* _t211 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("nsfw_level")}));
			_option_x__json2__Any _t210 = {0};
			if (_t211) {
				*((x__json2__Any*)&_t210.data) = *((x__json2__Any*)_t211);
			} else {
				_t210.state = 2; _t210.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t210.state != 0) {
				_result_discord__Guild _t212;
				memcpy(&_t212, &_t210, sizeof(_result));
				return _t212;
			}
			x__json2__Any* _t214 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("nsfw_level")}));
			_option_x__json2__Any _t213 = {0};
			if (_t214) {
				*((x__json2__Any*)&_t213.data) = *((x__json2__Any*)_t214);
			} else {
				_t213.state = 2; _t213.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t213.state != 0) {
				_result_discord__Guild _t215;
				memcpy(&_t215, &_t213, sizeof(_result));
				return _t215;
			}
			x__json2__Any* _t219 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("stickers")}));
			_option_x__json2__Any _t218 = {0};
			if (_t219) {
				*((x__json2__Any*)&_t218.data) = *((x__json2__Any*)_t219);
			} else {
				_t218.state = 2; _t218.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t218.state != 0) {
				IError err = _t218.err;
				*(x__json2__Any*) _t218.data = Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (__new_array_with_default(0, 0, sizeof(x__json2__Any), 0))));
			}
			x__json2__Any* _t221 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("stickers")}));
			_option_x__json2__Any _t220 = {0};
			if (_t221) {
				*((x__json2__Any*)&_t220.data) = *((x__json2__Any*)_t221);
			} else {
				_t220.state = 2; _t220.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t220.state != 0) {
				IError err = _t220.err;
				*(x__json2__Any*) _t220.data = Array_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Array_x__json2__Any, (__new_array_with_default(0, 0, sizeof(x__json2__Any), 0))));
			}
			
			
			Array_discord__Sticker _t216 = {0};
			Array_x__json2__Any _t216_orig = (/* as */ *(Array_x__json2__Any*)__as_cast((((*(x__json2__Any*)_t218.data)))._Array_x__json2__Any,(((*(x__json2__Any*)_t220.data)))._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
			int _t216_len = _t216_orig.len;
			_t216 = __new_array(0, _t216_len, sizeof(discord__Sticker));

			for (int _t222 = 0; _t222 < _t216_len; ++_t222) {
				x__json2__Any it = ((x__json2__Any*) _t216_orig.data)[_t222];
				_result_discord__Sticker _t223 = discord__Sticker__static__parse(it);
				if (_t223.is_error) {
					_result_discord__Guild _t224;
					memcpy(&_t224, &_t223, sizeof(_result));
					return _t224;
				}
				
 				discord__Sticker _t217 =  (*(discord__Sticker*)_t223.data);
				array_push((array*)&_t216, &_t217);
			}
			x__json2__Any* _t226 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("premium_progress_bar_enabled")}));
			_option_x__json2__Any _t225 = {0};
			if (_t226) {
				*((x__json2__Any*)&_t225.data) = *((x__json2__Any*)_t226);
			} else {
				_t225.state = 2; _t225.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t225.state != 0) {
				_result_discord__Guild _t227;
				memcpy(&_t227, &_t225, sizeof(_result));
				return _t227;
			}
			x__json2__Any* _t229 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("premium_progress_bar_enabled")}));
			_option_x__json2__Any _t228 = {0};
			if (_t229) {
				*((x__json2__Any*)&_t228.data) = *((x__json2__Any*)_t229);
			} else {
				_t228.state = 2; _t228.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t228.state != 0) {
				_result_discord__Guild _t230;
				memcpy(&_t230, &_t228, sizeof(_result));
				return _t230;
			}
			_option_discord__Snowflake _t231; /* if prepend */
			if ((safety_alerts_channel_id)._typ != 170 /* x.json2.Null */) {
				_result_discord__Snowflake _t233 = discord__Snowflake__static__parse(safety_alerts_channel_id);
				if (_t233.is_error) {
					_result_discord__Guild _t234;
					memcpy(&_t234, &_t233, sizeof(_result));
					return _t234;
				}
				
 				_option_discord__Snowflake _t232;
				_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t233.data) }, (_option*)(&_t232), sizeof(discord__Snowflake));
				_t231 = _t232;
			} else {
				_t231.state = 2;
				_t231.err = _const_none__;
			}
			
			
			_result_discord__Guild _t40;
		_result_ok(&(discord__Guild[]) { ((discord__Guild){
			.id =  (*(discord__Snowflake*)_t41.data),
			.name = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t46.data))._string,((*(x__json2__Any*)_t49.data))._typ, 21) /*expected idx: 21, name: string */ ,
			.icon =  _t52,
			.icon_hash =  _t54,
			.splash =  _t56,
			.discovery_splash =  _t58,
			.owner_id =  (*(discord__Snowflake*)_t60.data),
			.afk_channel_id =  _t65,
			.afk_timeout = /* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t69.data))._i64,((*(x__json2__Any*)_t72.data))._typ, 9) /*expected idx: 9, name: i64 */  * _const_time__second,
			.widget_enabled =  _t75,
			.widget_channel_id =  _t79,
			.verification_level = ((discord__VerificationLevel)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t85.data))._i64,((*(x__json2__Any*)_t88.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.default_message_notifications = 0,
			.explicit_content_filter = ((discord__ExplicitContentFilterLevel)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t91.data))._i64,((*(x__json2__Any*)_t94.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.roles =_t97,
			.emojis =_t108,
			.features =_t119,
			.mfa_level = ((discord__MFALevel)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t128.data))._i64,((*(x__json2__Any*)_t131.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.application_id =  _t134,
			.system_channel_id =  _t138,
			.system_channel_flags = ((discord__SystemChannelFlags)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t142.data))._i64,((*(x__json2__Any*)_t145.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.rules_channel_id =  _t148,
			.max_presences =  _t152,
			.max_members =  _t157,
			.vanity_url_code =  _t162,
			.description =  _t164,
			.banner =  _t166,
			.premium_tier = ((discord__PremiumTier)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t168.data))._i64,((*(x__json2__Any*)_t171.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.premium_subscription_count =  _t174,
			.preferred_locale = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t178.data))._string,((*(x__json2__Any*)_t181.data))._typ, 21) /*expected idx: 21, name: string */ ,
			.public_updates_channel_id =  _t184,
			.max_video_channel_users =  _t188,
			.max_stage_video_channel_users =  _t192,
			.approximate_member_count =  _t196,
			.approximate_presence_count =  _t200,
			.welcome_screen =  _t204,
			.nsfw_level = ((discord__NSFWLevel)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t210.data))._i64,((*(x__json2__Any*)_t213.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.stickers =_t216,
			.premium_progress_bar_enabled = /* as */ *(bool*)__as_cast(((*(x__json2__Any*)_t225.data))._bool,((*(x__json2__Any*)_t228.data))._typ, 19) /*expected idx: 19, name: bool */ ,
			.safety_alerts_channel_id =  _t231,
		}) }, (_result*)(&_t40), sizeof(discord__Guild));
		return _t40;
	}
	
	else {
		return (_result_discord__Guild){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected guild to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__Guild){0};
}

_result_discord__Guild discord__Client_fetch_guild(discord__Client _v_toheap_c, discord__Snowflake guild_id) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t4 = discord__Client_request((*(c)), net__http__Method__get,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/guilds/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(guild_id))}}, {_SLIT0, 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t4.is_error) {
		_result_discord__Guild _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	_result_x__json2__Any _t3 = x__json2__raw_decode( (*(net__http__Response*)_t4.data).body);
	if (_t3.is_error) {
		_result_discord__Guild _t6;
		memcpy(&_t6, &_t3, sizeof(_result));
		return _t6;
	}
	
 	_result_discord__Guild _t2 = discord__Guild__static__parse( (*(x__json2__Any*)_t3.data));
	if (_t2.is_error) {
		_result_discord__Guild _t7;
		memcpy(&_t7, &_t2, sizeof(_result));
		return _t7;
	}
	
 	_result_discord__Guild _t1;
	_result_ok(&(discord__Guild[]) {  (*(discord__Guild*)_t2.data) }, (_result*)(&_t1), sizeof(discord__Guild));
	return _t1;
}

_result_discord__GuildMember discord__GuildMember__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
			x__json2__Any* _t4 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("user")}));
			_option_x__json2__Any _t3 = {0};
			if (_t4) {
				*((x__json2__Any*)&_t3.data) = *((x__json2__Any*)_t4);
			} else {
				_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__User _t2; /* if prepend */
			if (_t3.state == 0) {
				x__json2__Any o = (*(x__json2__Any*)_t3.data);
				_result_discord__User _t6 = discord__User__static__parse(o);
				if (_t6.is_error) {
					_result_discord__GuildMember _t7;
					memcpy(&_t7, &_t6, sizeof(_result));
					return _t7;
				}
				
 				_option_discord__User _t5;
				_option_ok(&(discord__User[]) {  (*(discord__User*)_t6.data) }, (_option*)(&_t5), sizeof(discord__User));
				_t2 = _t5;
			} else {
				IError err = _t3.err;
				_t2.state = 2;
				_t2.err = _const_none__;
			}
			x__json2__Any* _t10 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("nick")}));
			_option_x__json2__Any _t9 = {0};
			if (_t10) {
				*((x__json2__Any*)&_t9.data) = *((x__json2__Any*)_t10);
			} else {
				_t9.state = 2; _t9.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_string _t8; /* if prepend */
			if (_t9.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t9.data);
				_option_string _t11; /* if prepend */
				if ((s)._typ != 170 /* x.json2.Null */) {
					_option_string _t12;
					_option_ok(&(string[]) { /* as */ *(string*)__as_cast((s)._string,(s)._typ, 21) /*expected idx: 21, name: string */  }, (_option*)(&_t12), sizeof(string));
					_t11 = _t12;
				} else {
					_t11.state = 2;
					_t11.err = _const_none__;
				}
				
				_t8 =  _t11;
			} else {
				IError err = _t9.err;
				_t8.state = 2;
				_t8.err = _const_none__;
			}
			x__json2__Any* _t15 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("avatar")}));
			_option_x__json2__Any _t14 = {0};
			if (_t15) {
				*((x__json2__Any*)&_t14.data) = *((x__json2__Any*)_t15);
			} else {
				_t14.state = 2; _t14.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_string _t13; /* if prepend */
			if (_t14.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t14.data);
				_option_string _t16; /* if prepend */
				if ((s)._typ != 170 /* x.json2.Null */) {
					_option_string _t17;
					_option_ok(&(string[]) { /* as */ *(string*)__as_cast((s)._string,(s)._typ, 21) /*expected idx: 21, name: string */  }, (_option*)(&_t17), sizeof(string));
					_t16 = _t17;
				} else {
					_t16.state = 2;
					_t16.err = _const_none__;
				}
				
				_t13 =  _t16;
			} else {
				IError err = _t14.err;
				_t13.state = 2;
				_t13.err = _const_none__;
			}
			x__json2__Any* _t21 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("roles")}));
			_option_x__json2__Any _t20 = {0};
			if (_t21) {
				*((x__json2__Any*)&_t20.data) = *((x__json2__Any*)_t21);
			} else {
				_t20.state = 2; _t20.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t20.state != 0) {
				_result_discord__GuildMember _t22;
				memcpy(&_t22, &_t20, sizeof(_result));
				return _t22;
			}
			x__json2__Any* _t24 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("roles")}));
			_option_x__json2__Any _t23 = {0};
			if (_t24) {
				*((x__json2__Any*)&_t23.data) = *((x__json2__Any*)_t24);
			} else {
				_t23.state = 2; _t23.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t23.state != 0) {
				_result_discord__GuildMember _t25;
				memcpy(&_t25, &_t23, sizeof(_result));
				return _t25;
			}
			
			
			Array_discord__Snowflake _t18 = {0};
			Array_x__json2__Any _t18_orig = (/* as */ *(Array_x__json2__Any*)__as_cast(((*(x__json2__Any*)_t20.data))._Array_x__json2__Any,((*(x__json2__Any*)_t23.data))._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
			int _t18_len = _t18_orig.len;
			_t18 = __new_array_noscan(0, _t18_len, sizeof(discord__Snowflake));

			for (int _t26 = 0; _t26 < _t18_len; ++_t26) {
				x__json2__Any it = ((x__json2__Any*) _t18_orig.data)[_t26];
				_result_discord__Snowflake _t27 = discord__Snowflake__static__parse(it);
				if (_t27.is_error) {
					_result_discord__GuildMember _t28;
					memcpy(&_t28, &_t27, sizeof(_result));
					return _t28;
				}
				
 				discord__Snowflake _t19 =  (*(discord__Snowflake*)_t27.data);
				array_push_noscan((array*)&_t18, &_t19);
			}
			x__json2__Any* _t31 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("joined_at")}));
			_option_x__json2__Any _t30 = {0};
			if (_t31) {
				*((x__json2__Any*)&_t30.data) = *((x__json2__Any*)_t31);
			} else {
				_t30.state = 2; _t30.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t30.state != 0) {
				_result_discord__GuildMember _t32;
				memcpy(&_t32, &_t30, sizeof(_result));
				return _t32;
			}
			x__json2__Any* _t34 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("joined_at")}));
			_option_x__json2__Any _t33 = {0};
			if (_t34) {
				*((x__json2__Any*)&_t33.data) = *((x__json2__Any*)_t34);
			} else {
				_t33.state = 2; _t33.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t33.state != 0) {
				_result_discord__GuildMember _t35;
				memcpy(&_t35, &_t33, sizeof(_result));
				return _t35;
			}
			
			
			_result_time__Time _t29 = time__parse_iso8601(/* as */ *(string*)__as_cast(((*(x__json2__Any*)_t30.data))._string,((*(x__json2__Any*)_t33.data))._typ, 21) /*expected idx: 21, name: string */ );
			if (_t29.is_error) {
				_result_discord__GuildMember _t36;
				memcpy(&_t36, &_t29, sizeof(_result));
				return _t36;
			}
			x__json2__Any* _t39 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("premium_since")}));
			_option_x__json2__Any _t38 = {0};
			if (_t39) {
				*((x__json2__Any*)&_t38.data) = *((x__json2__Any*)_t39);
			} else {
				_t38.state = 2; _t38.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_time__Time _t37; /* if prepend */
			if (_t38.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t38.data);
				_option_time__Time _t40; /* if prepend */
				if ((s)._typ != 170 /* x.json2.Null */) {
					_result_time__Time _t42 = time__parse_iso8601(/* as */ *(string*)__as_cast((s)._string,(s)._typ, 21) /*expected idx: 21, name: string */ );
					if (_t42.is_error) {
						_result_discord__GuildMember _t43;
						memcpy(&_t43, &_t42, sizeof(_result));
						return _t43;
					}
					
 					_option_time__Time _t41;
					_option_ok(&(time__Time[]) {  (*(time__Time*)_t42.data) }, (_option*)(&_t41), sizeof(time__Time));
					_t40 = _t41;
				} else {
					_t40.state = 2;
					_t40.err = _const_none__;
				}
				
				_t37 =  _t40;
			} else {
				IError err = _t38.err;
				_t37.state = 2;
				_t37.err = _const_none__;
			}
			x__json2__Any* _t45 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("deaf")}));
			_option_x__json2__Any _t44 = {0};
			if (_t45) {
				*((x__json2__Any*)&_t44.data) = *((x__json2__Any*)_t45);
			} else {
				_t44.state = 2; _t44.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t44.state != 0) {
				_result_discord__GuildMember _t46;
				memcpy(&_t46, &_t44, sizeof(_result));
				return _t46;
			}
			x__json2__Any* _t48 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("deaf")}));
			_option_x__json2__Any _t47 = {0};
			if (_t48) {
				*((x__json2__Any*)&_t47.data) = *((x__json2__Any*)_t48);
			} else {
				_t47.state = 2; _t47.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t47.state != 0) {
				_result_discord__GuildMember _t49;
				memcpy(&_t49, &_t47, sizeof(_result));
				return _t49;
			}
			x__json2__Any* _t51 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("mute")}));
			_option_x__json2__Any _t50 = {0};
			if (_t51) {
				*((x__json2__Any*)&_t50.data) = *((x__json2__Any*)_t51);
			} else {
				_t50.state = 2; _t50.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t50.state != 0) {
				_result_discord__GuildMember _t52;
				memcpy(&_t52, &_t50, sizeof(_result));
				return _t52;
			}
			x__json2__Any* _t54 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("mute")}));
			_option_x__json2__Any _t53 = {0};
			if (_t54) {
				*((x__json2__Any*)&_t53.data) = *((x__json2__Any*)_t54);
			} else {
				_t53.state = 2; _t53.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t53.state != 0) {
				_result_discord__GuildMember _t55;
				memcpy(&_t55, &_t53, sizeof(_result));
				return _t55;
			}
			x__json2__Any* _t57 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("flags")}));
			_option_x__json2__Any _t56 = {0};
			if (_t57) {
				*((x__json2__Any*)&_t56.data) = *((x__json2__Any*)_t57);
			} else {
				_t56.state = 2; _t56.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t56.state != 0) {
				_result_discord__GuildMember _t58;
				memcpy(&_t58, &_t56, sizeof(_result));
				return _t58;
			}
			x__json2__Any* _t60 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("flags")}));
			_option_x__json2__Any _t59 = {0};
			if (_t60) {
				*((x__json2__Any*)&_t59.data) = *((x__json2__Any*)_t60);
			} else {
				_t59.state = 2; _t59.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t59.state != 0) {
				_result_discord__GuildMember _t61;
				memcpy(&_t61, &_t59, sizeof(_result));
				return _t61;
			}
			x__json2__Any* _t64 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("pending")}));
			_option_x__json2__Any _t63 = {0};
			if (_t64) {
				*((x__json2__Any*)&_t63.data) = *((x__json2__Any*)_t64);
			} else {
				_t63.state = 2; _t63.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_bool _t62; /* if prepend */
			if (_t63.state == 0) {
				x__json2__Any b = (*(x__json2__Any*)_t63.data);
				_option_bool _t65;
				_option_ok(&(bool[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t65), sizeof(bool));
				_t62 = _t65;
			} else {
				IError err = _t63.err;
				_t62.state = 2;
				_t62.err = _const_none__;
			}
			x__json2__Any* _t68 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("permissions")}));
			_option_x__json2__Any _t67 = {0};
			if (_t68) {
				*((x__json2__Any*)&_t67.data) = *((x__json2__Any*)_t68);
			} else {
				_t67.state = 2; _t67.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_discord__Permissions _t66; /* if prepend */
			if (_t67.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t67.data);
				_result_discord__Permissions _t70 = discord__Permissions__static__parse(s);
				if (_t70.is_error) {
					_result_discord__GuildMember _t71;
					memcpy(&_t71, &_t70, sizeof(_result));
					return _t71;
				}
				
 				_option_discord__Permissions _t69;
				_option_ok(&(discord__Permissions[]) {  (*(discord__Permissions*)_t70.data) }, (_option*)(&_t69), sizeof(discord__Permissions));
				_t66 = _t69;
			} else {
				IError err = _t67.err;
				_t66.state = 2;
				_t66.err = _const_none__;
			}
			x__json2__Any* _t74 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("communication_disabled_until")}));
			_option_x__json2__Any _t73 = {0};
			if (_t74) {
				*((x__json2__Any*)&_t73.data) = *((x__json2__Any*)_t74);
			} else {
				_t73.state = 2; _t73.err = _v_error(_SLIT("array index out of range"));
			}
			
			_option_time__Time _t72; /* if prepend */
			if (_t73.state == 0) {
				x__json2__Any s = (*(x__json2__Any*)_t73.data);
				_option_time__Time _t75; /* if prepend */
				if ((s)._typ != 170 /* x.json2.Null */) {
					_result_time__Time _t77 = time__parse_iso8601(/* as */ *(string*)__as_cast((s)._string,(s)._typ, 21) /*expected idx: 21, name: string */ );
					if (_t77.is_error) {
						_result_discord__GuildMember _t78;
						memcpy(&_t78, &_t77, sizeof(_result));
						return _t78;
					}
					
 					_option_time__Time _t76;
					_option_ok(&(time__Time[]) {  (*(time__Time*)_t77.data) }, (_option*)(&_t76), sizeof(time__Time));
					_t75 = _t76;
				} else {
					_t75.state = 2;
					_t75.err = _const_none__;
				}
				
				_t72 =  _t75;
			} else {
				IError err = _t73.err;
				_t72.state = 2;
				_t72.err = _const_none__;
			}
			
			
			
			
			
			
			
 			_result_discord__GuildMember _t1;
		_result_ok(&(discord__GuildMember[]) { ((discord__GuildMember){
			.user =  _t2,
			.nick =  _t8,
			.avatar =  _t13,
			.roles =_t18,
			.joined_at =  (*(time__Time*)_t29.data),
			.premium_since =  _t37,
			.deaf = /* as */ *(bool*)__as_cast(((*(x__json2__Any*)_t44.data))._bool,((*(x__json2__Any*)_t47.data))._typ, 19) /*expected idx: 19, name: bool */ ,
			.mute = /* as */ *(bool*)__as_cast(((*(x__json2__Any*)_t50.data))._bool,((*(x__json2__Any*)_t53.data))._typ, 19) /*expected idx: 19, name: bool */ ,
			.flags = ((discord__GuildMemberFlags)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t56.data))._i64,((*(x__json2__Any*)_t59.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.pending =  _t62,
			.permissions =  _t66,
			.communication_disabled_until =  _t72,
		}) }, (_result*)(&_t1), sizeof(discord__GuildMember));
		return _t1;
	}
	
	else {
		return (_result_discord__GuildMember){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected guild member to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__GuildMember){0};
}

// TypeDecl
_result_net__http__Response discord__Client_request(discord__Client _v_toheap_c, net__http__Method method, string route, discord__RequestOptions options) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	if (options.json.state != 2 && options.body.state != 2) {
		return (_result_net__http__Response){ .is_error=true, .err=_v_error(_SLIT("cannot have json and body")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	string _t2; /* if prepend */
	_option_x__json2__Any _t3;
	_option_string _t4;
	if (_t3 = options.json, _t3.state == 0) {
		x__json2__Any json = *(x__json2__Any*)_t3.data;
		_t2 = x__json2__Any_json_str(json);
	} else if (_t4 = options.body, _t4.state == 0) {
		string body = *(string*)_t4.data;
		_t2 = body;
	} else {
		_t2 = _SLIT("");
	}
	net__http__Request req = net__http__new_request(method, string__plus(string__plus(string_trim_right((*(c)).base_url, _SLIT("/")), _SLIT("/")), route),  _t2);
	req.user_agent = (*(c)).user_agent;
	req.header = ((net__http__Header){.data = {(net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}, (net__http__HeaderKV){.key = (string){.str=(byteptr)"", .is_lit=1},.value = (string){.str=(byteptr)"", .is_lit=1},}},.cur_pos = 0,});
	if (options.authenticate) {
		net__http__Header_add(&req.header, net__http__CommonHeader__authorization, (*(c)).token);
	}
	if (options.json.state != 2) {
		net__http__Header_add(&req.header, net__http__CommonHeader__content_type, _SLIT("application/json"));
	}
	_option_string _t5;
	if (_t5 = options.reason, _t5.state == 0) {
		string reason = *(string*)_t5.data;
		_result_void _t6 = net__http__Header_add_custom(&req.header, _SLIT("X-Audit-Log-Reason"), reason);
		if (_t6.is_error) {
			_result_net__http__Response _t7;
			memcpy(&_t7, &_t6, sizeof(_result));
			return _t7;
		}
		
 ;
	}
	Map_net__http__CommonHeader_string _t8 = options.common_headers;
	int _t10 = _t8.key_values.len;
	for (int _t9 = 0; _t9 < _t10; ++_t9 ) {
		int _t11 = _t8.key_values.len - _t10;
		_t10 = _t8.key_values.len;
		if (_t11 < 0) {
			_t9 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t8.key_values, _t9)) {continue;}
		net__http__CommonHeader k = /*key*/ *(net__http__CommonHeader*)DenseArray_key(&_t8.key_values, _t9);
		string v = (*(string*)DenseArray_value(&_t8.key_values, _t9));
		net__http__Header_add(&req.header, k, v);
	}
	Map_string_string _t12 = options.headers;
	int _t14 = _t12.key_values.len;
	for (int _t13 = 0; _t13 < _t14; ++_t13 ) {
		int _t15 = _t12.key_values.len - _t14;
		_t14 = _t12.key_values.len;
		if (_t15 < 0) {
			_t13 = -1;
			continue;
		}
		if (!DenseArray_has_index(&_t12.key_values, _t13)) {continue;}
		string k = /*key*/ *(string*)DenseArray_key(&_t12.key_values, _t13);
		k = string_clone(k);
		string v = (*(string*)DenseArray_value(&_t12.key_values, _t13));
		_result_void _t16 = net__http__Header_add_custom(&req.header, k, v);
		if (_t16.is_error) {
			_result_net__http__Response _t17;
			memcpy(&_t17, &_t16, sizeof(_result));
			return _t17;
		}
		
 ;
	}
	_option_anon_fn_mut_net__http__request__result_void _t18;
	if (_t18 = options.prepare, _t18.state == 0) {
		discord__Prepare f = *(discord__Prepare*)_t18.data;
		_result_void _t19 = f(&req);
		if (_t19.is_error) {
			_result_net__http__Response _t20;
			memcpy(&_t20, &_t19, sizeof(_result));
			return _t20;
		}
		
 ;
	}
	_result_net__http__Response _t21 = net__http__Request_do(&req);
	if (_t21.is_error) {
		_result_net__http__Response _t22;
		memcpy(&_t22, &_t21, sizeof(_result));
		return _t22;
	}
	
 	net__http__Response res =  (*(net__http__Response*)_t21.data);
	if (res.status_code >= 400) {
		net__http__Status status = net__http__Response_status(res);
		_result_x__json2__Any _t24 = x__json2__raw_decode(res.body);
		if (_t24.is_error) {
			_result_net__http__Response _t25;
			memcpy(&_t25, &_t24, sizeof(_result));
			return _t25;
		}
		
 		Map_string_x__json2__Any er = ({ x__json2__Any _t23 =  (*(x__json2__Any*)_t24.data); /* as */ *(Map_string_x__json2__Any*)__as_cast(_t23._Map_string_x__json2__Any,_t23._typ, 173); }) /*expected idx: 173, name: map[string]x.json2.Any */ ;
		x__json2__Any* _t27 = (x__json2__Any*)(map_get_check(ADDR(map, er), &(string[]){_SLIT("code")}));
		_option_x__json2__Any _t26 = {0};
		if (_t27) {
			*((x__json2__Any*)&_t26.data) = *((x__json2__Any*)_t27);
		} else {
			_t26.state = 2; _t26.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t26.state != 0) {
			IError err = _t26.err;
			*(x__json2__Any*) _t26.data = int_to_sumtype_x__json2__Any/*KEK*/(ADDR(int, (0)));
		}
		x__json2__Any* _t29 = (x__json2__Any*)(map_get_check(ADDR(map, er), &(string[]){_SLIT("code")}));
		_option_x__json2__Any _t28 = {0};
		if (_t29) {
			*((x__json2__Any*)&_t28.data) = *((x__json2__Any*)_t29);
		} else {
			_t28.state = 2; _t28.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t28.state != 0) {
			IError err = _t28.err;
			*(x__json2__Any*) _t28.data = int_to_sumtype_x__json2__Any/*KEK*/(ADDR(int, (0)));
		}
		
		
		int code = ((int)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t26.data))._i64,((*(x__json2__Any*)_t28.data))._typ, 9) /*expected idx: 9, name: i64 */ ));
		x__json2__Any* _t31 = (x__json2__Any*)(map_get_check(ADDR(map, er), &(string[]){_SLIT("message")}));
		_option_x__json2__Any _t30 = {0};
		if (_t31) {
			*((x__json2__Any*)&_t30.data) = *((x__json2__Any*)_t31);
		} else {
			_t30.state = 2; _t30.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t30.state != 0) {
			IError err = _t30.err;
			*(x__json2__Any*) _t30.data = string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT(""))));
		}
		x__json2__Any* _t33 = (x__json2__Any*)(map_get_check(ADDR(map, er), &(string[]){_SLIT("message")}));
		_option_x__json2__Any _t32 = {0};
		if (_t33) {
			*((x__json2__Any*)&_t32.data) = *((x__json2__Any*)_t33);
		} else {
			_t32.state = 2; _t32.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t32.state != 0) {
			IError err = _t32.err;
			*(x__json2__Any*) _t32.data = string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (_SLIT(""))));
		}
		
		
		string message = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t30.data))._string,((*(x__json2__Any*)_t32.data))._typ, 21) /*expected idx: 21, name: string */ ;
		x__json2__Any* _t35 = (x__json2__Any*)(map_get_check(ADDR(map, er), &(string[]){_SLIT("errors")}));
		_option_x__json2__Any _t34 = {0};
		if (_t35) {
			*((x__json2__Any*)&_t34.data) = *((x__json2__Any*)_t35);
		} else {
			_t34.state = 2; _t34.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t34.state != 0) {
			IError err = _t34.err;
			*(x__json2__Any*) _t34.data = Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map(sizeof(string), sizeof(x__json2__Any), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
			)));
		}
		x__json2__Any* _t37 = (x__json2__Any*)(map_get_check(ADDR(map, er), &(string[]){_SLIT("errors")}));
		_option_x__json2__Any _t36 = {0};
		if (_t37) {
			*((x__json2__Any*)&_t36.data) = *((x__json2__Any*)_t37);
		} else {
			_t36.state = 2; _t36.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t36.state != 0) {
			IError err = _t36.err;
			*(x__json2__Any*) _t36.data = Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map(sizeof(string), sizeof(x__json2__Any), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
			)));
		}
		
		
		Map_string_x__json2__Any errors = /* as */ *(Map_string_x__json2__Any*)__as_cast(((*(x__json2__Any*)_t34.data))._Map_string_x__json2__Any,((*(x__json2__Any*)_t36.data))._typ, 173) /*expected idx: 173, name: map[string]x.json2.Any */ ;
		if (res.status_code >= 500) {
			return (_result_net__http__Response){ .is_error=true, .err=I_discord__InternalServerError_to_Interface_IError(((discord__InternalServerError*)memdup(&(discord__InternalServerError){.RestError = ((discord__RestError){.code = code,.errors = errors,.message = message,.status = status,}),}, sizeof(discord__InternalServerError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		switch (res.status_code) {
			case 401: {
					return (_result_net__http__Response){ .is_error=true, .err=I_discord__Unauthorized_to_Interface_IError(((discord__Unauthorized*)memdup(&(discord__Unauthorized){.RestError = ((discord__RestError){.code = code,.errors = errors,.message = message,.status = status,}),}, sizeof(discord__Unauthorized)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			case 403: {
					return (_result_net__http__Response){ .is_error=true, .err=I_discord__Forbidden_to_Interface_IError(((discord__Forbidden*)memdup(&(discord__Forbidden){.RestError = ((discord__RestError){.code = code,.errors = errors,.message = message,.status = status,}),}, sizeof(discord__Forbidden)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			case 404: {
					return (_result_net__http__Response){ .is_error=true, .err=I_discord__NotFound_to_Interface_IError(((discord__NotFound*)memdup(&(discord__NotFound){.RestError = ((discord__RestError){.code = code,.errors = errors,.message = message,.status = status,}),}, sizeof(discord__NotFound)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			case 429: {
					x__json2__Any* _t44 = (x__json2__Any*)(map_get_check(ADDR(map, er), &(string[]){_SLIT("retry_after")}));
					_option_x__json2__Any _t43 = {0};
					if (_t44) {
						*((x__json2__Any*)&_t43.data) = *((x__json2__Any*)_t44);
					} else {
						_t43.state = 2; _t43.err = _v_error(_SLIT("array index out of range"));
					}
					;
					if (_t43.state != 0) {
						_result_net__http__Response _t45;
						memcpy(&_t45, &_t43, sizeof(_result));
						return _t45;
					}
					x__json2__Any* _t47 = (x__json2__Any*)(map_get_check(ADDR(map, er), &(string[]){_SLIT("retry_after")}));
					_option_x__json2__Any _t46 = {0};
					if (_t47) {
						*((x__json2__Any*)&_t46.data) = *((x__json2__Any*)_t47);
					} else {
						_t46.state = 2; _t46.err = _v_error(_SLIT("array index out of range"));
					}
					;
					if (_t46.state != 0) {
						_result_net__http__Response _t48;
						memcpy(&_t48, &_t46, sizeof(_result));
						return _t48;
					}
					
					
					return (_result_net__http__Response){ .is_error=true, .err=I_discord__Ratelimit_to_Interface_IError(((discord__Ratelimit*)memdup(&(discord__Ratelimit){.RestError = ((discord__RestError){.code = code,.errors = errors,.message = message,.status = status,}),.retry_after = /* as */ *(f32*)__as_cast(((*(x__json2__Any*)_t43.data))._f32,((*(x__json2__Any*)_t46.data))._typ, 16) /*expected idx: 16, name: f32 */ ,}, sizeof(discord__Ratelimit)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
			default: {
					return (_result_net__http__Response){ .is_error=true, .err=I_discord__RestError_to_Interface_IError(((discord__RestError*)memdup(&(discord__RestError){.code = code,.errors = errors,.message = message,.status = status,}, sizeof(discord__RestError)))), .data={EMPTY_STRUCT_INITIALIZATION} };
			}
		}
		
	}
	_result_net__http__Response _t50;
	_result_ok(&(net__http__Response[]) { res }, (_result*)(&_t50), sizeof(net__http__Response));
	return _t50;
}

VV_LOCAL_SYMBOL void discord__JpegImage_is_image(discord__JpegImage _d1) {
}

string discord__JpegImage_build(discord__JpegImage ji) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("data:image/jpeg;base64,"), /*115 &string*/0xfe10, {.d_s = encoding__base64__encode(ji.data)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL void discord__PngImage_is_image(discord__PngImage _d2) {
}

string discord__PngImage_build(discord__PngImage pi) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("data:image/png;base64,"), /*115 &string*/0xfe10, {.d_s = encoding__base64__encode(pi.data)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

VV_LOCAL_SYMBOL void discord__GifImage_is_image(discord__GifImage _d3) {
}

string discord__GifImage_build(discord__GifImage gi) {
	string _t1 =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("data:image/gif;base64,"), /*115 &string*/0xfe10, {.d_s = encoding__base64__encode(gi.data)}}, {_SLIT0, 0, { .d_c = 0 }}}));
	return _t1;
}

int discord__combine_intents(Array_discord__Intents list) {
	int _t1 = arrays__fold_T_discord__Intents_int(list, 0, (voidptr)	anon_fn_8ca92943f0af0818_int_discord__intents__int_585);
	return _t1;
}

_result_discord__Interaction discord__Interaction__static__parse(x__json2__Any j) {
	_v_panic(_SLIT("TODO"));
	VUNREACHABLE();
	return (_result_discord__Interaction){0};
}

_result_void discord__Client_delete_message(discord__Client _v_toheap_c, discord__Snowflake channel_id, discord__Snowflake id, discord__WithReason config) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t1 = discord__Client_request((*(c)), net__http__Method__delete,  str_intp(3, _MOV((StrIntpData[]){{_SLIT("/channels/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(channel_id))}}, {_SLIT("/messages/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(id))}}, {_SLIT0, 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = config.reason,.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(net__http__Response*)_t1.data);
	return (_result_void){0};
}

discord__Permissions discord__Permissions__static__zero(void) {
	discord__Permissions _t1 = ((discord__Permissions)(0));
	return _t1;
}

discord__Permissions discord__Permissions__static__all(void) {
	discord__Permissions part1 = (((((((((((((((((((((((((((((((((((((((discord__Permissions__create_instant_invite | discord__Permissions__kick_members) | discord__Permissions__ban_members) | discord__Permissions__administrator) | discord__Permissions__manage_channels) | discord__Permissions__manage_guild) | discord__Permissions__add_reactions) | discord__Permissions__view_audit_log) | discord__Permissions__priority_speaker) | discord__Permissions__stream) | discord__Permissions__view_channel) | discord__Permissions__send_messages) | discord__Permissions__send_tts_messages) | discord__Permissions__manage_messages) | discord__Permissions__embed_links) | discord__Permissions__attach_files) | discord__Permissions__read_message_history) | discord__Permissions__mention_everyone) | discord__Permissions__use_external_emojis) | discord__Permissions__view_guild_insights) | discord__Permissions__connect) | discord__Permissions__speak) | discord__Permissions__mute_members) | discord__Permissions__deafen_members) | discord__Permissions__move_members) | discord__Permissions__use_vad) | discord__Permissions__change_nickname) | discord__Permissions__manage_nicknames) | discord__Permissions__manage_roles) | discord__Permissions__manage_webhooks) | discord__Permissions__manage_guild_expressions) | discord__Permissions__use_application_commands) | discord__Permissions__request_to_speak) | discord__Permissions__manage_events) | discord__Permissions__manage_threads) | discord__Permissions__create_public_threads) | discord__Permissions__create_private_threads) | discord__Permissions__use_external_stickers) | discord__Permissions__send_messages_in_threads));
	discord__Permissions part2 = ((((((((discord__Permissions__use_embedded_activities | discord__Permissions__moderate_members) | discord__Permissions__view_creator_monetization_analytics) | discord__Permissions__use_soundboard) | discord__Permissions__create_guild_expressions) | discord__Permissions__create_events) | discord__Permissions__use_external_sounds) | discord__Permissions__send_voice_messages));
	discord__Permissions _t1 = (part1 | part2);
	return _t1;
}

discord__Permissions discord__Permissions__static__all_except(discord__Permissions permissions) {
	discord__Permissions _t1 = ((discord__Permissions)((((u64)(discord__Permissions__static__all())) & ~((u64)(permissions)))));
	return _t1;
}

_result_discord__Permissions discord__Permissions__static__parse(x__json2__Any j) {
	if (j._typ == 21 /* string */) {
		_result_discord__Permissions _t1;
		_result_ok(&(discord__Permissions[]) { ((discord__Permissions)(string_u64((*j._string)))) }, (_result*)(&_t1), sizeof(discord__Permissions));
		return _t1;
	}
	
	else {
		return (_result_discord__Permissions){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected permissions to be string, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__Permissions){0};
}

_result_discord__Sku discord__Sku__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
			x__json2__Any* _t4 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("id")}));
			_option_x__json2__Any _t3 = {0};
			if (_t4) {
				*((x__json2__Any*)&_t3.data) = *((x__json2__Any*)_t4);
			} else {
				_t3.state = 2; _t3.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t3.state != 0) {
				_result_discord__Sku _t5;
				memcpy(&_t5, &_t3, sizeof(_result));
				return _t5;
			}
			
			_result_discord__Snowflake _t2 = discord__Snowflake__static__parse((*(x__json2__Any*)_t3.data));
			if (_t2.is_error) {
				_result_discord__Sku _t6;
				memcpy(&_t6, &_t2, sizeof(_result));
				return _t6;
			}
			x__json2__Any* _t8 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("type")}));
			_option_x__json2__Any _t7 = {0};
			if (_t8) {
				*((x__json2__Any*)&_t7.data) = *((x__json2__Any*)_t8);
			} else {
				_t7.state = 2; _t7.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t7.state != 0) {
				_result_discord__Sku _t9;
				memcpy(&_t9, &_t7, sizeof(_result));
				return _t9;
			}
			x__json2__Any* _t11 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("type")}));
			_option_x__json2__Any _t10 = {0};
			if (_t11) {
				*((x__json2__Any*)&_t10.data) = *((x__json2__Any*)_t11);
			} else {
				_t10.state = 2; _t10.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t10.state != 0) {
				_result_discord__Sku _t12;
				memcpy(&_t12, &_t10, sizeof(_result));
				return _t12;
			}
			x__json2__Any* _t15 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("application_id")}));
			_option_x__json2__Any _t14 = {0};
			if (_t15) {
				*((x__json2__Any*)&_t14.data) = *((x__json2__Any*)_t15);
			} else {
				_t14.state = 2; _t14.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t14.state != 0) {
				_result_discord__Sku _t16;
				memcpy(&_t16, &_t14, sizeof(_result));
				return _t16;
			}
			
			_result_discord__Snowflake _t13 = discord__Snowflake__static__parse((*(x__json2__Any*)_t14.data));
			if (_t13.is_error) {
				_result_discord__Sku _t17;
				memcpy(&_t17, &_t13, sizeof(_result));
				return _t17;
			}
			x__json2__Any* _t19 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
			_option_x__json2__Any _t18 = {0};
			if (_t19) {
				*((x__json2__Any*)&_t18.data) = *((x__json2__Any*)_t19);
			} else {
				_t18.state = 2; _t18.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t18.state != 0) {
				_result_discord__Sku _t20;
				memcpy(&_t20, &_t18, sizeof(_result));
				return _t20;
			}
			x__json2__Any* _t22 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
			_option_x__json2__Any _t21 = {0};
			if (_t22) {
				*((x__json2__Any*)&_t21.data) = *((x__json2__Any*)_t22);
			} else {
				_t21.state = 2; _t21.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t21.state != 0) {
				_result_discord__Sku _t23;
				memcpy(&_t23, &_t21, sizeof(_result));
				return _t23;
			}
			x__json2__Any* _t25 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("slug")}));
			_option_x__json2__Any _t24 = {0};
			if (_t25) {
				*((x__json2__Any*)&_t24.data) = *((x__json2__Any*)_t25);
			} else {
				_t24.state = 2; _t24.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t24.state != 0) {
				_result_discord__Sku _t26;
				memcpy(&_t26, &_t24, sizeof(_result));
				return _t26;
			}
			x__json2__Any* _t28 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("slug")}));
			_option_x__json2__Any _t27 = {0};
			if (_t28) {
				*((x__json2__Any*)&_t27.data) = *((x__json2__Any*)_t28);
			} else {
				_t27.state = 2; _t27.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t27.state != 0) {
				_result_discord__Sku _t29;
				memcpy(&_t29, &_t27, sizeof(_result));
				return _t29;
			}
			x__json2__Any* _t31 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("flags")}));
			_option_x__json2__Any _t30 = {0};
			if (_t31) {
				*((x__json2__Any*)&_t30.data) = *((x__json2__Any*)_t31);
			} else {
				_t30.state = 2; _t30.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t30.state != 0) {
				_result_discord__Sku _t32;
				memcpy(&_t32, &_t30, sizeof(_result));
				return _t32;
			}
			x__json2__Any* _t34 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("flags")}));
			_option_x__json2__Any _t33 = {0};
			if (_t34) {
				*((x__json2__Any*)&_t33.data) = *((x__json2__Any*)_t34);
			} else {
				_t33.state = 2; _t33.err = _v_error(_SLIT("array index out of range"));
			}
			;
			if (_t33.state != 0) {
				_result_discord__Sku _t35;
				memcpy(&_t35, &_t33, sizeof(_result));
				return _t35;
			}
			
			
			
			
			
			
			
 			
			
			
 		_result_discord__Sku _t1;
		_result_ok(&(discord__Sku[]) { ((discord__Sku){
			.id =  (*(discord__Snowflake*)_t2.data),
			.typ = ((discord__SkuType)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t7.data))._i64,((*(x__json2__Any*)_t10.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
			.application_id =  (*(discord__Snowflake*)_t13.data),
			.name = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t18.data))._string,((*(x__json2__Any*)_t21.data))._typ, 21) /*expected idx: 21, name: string */ ,
			.slug = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t24.data))._string,((*(x__json2__Any*)_t27.data))._typ, 21) /*expected idx: 21, name: string */ ,
			.flags = ((discord__SkuFlags)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t30.data))._i64,((*(x__json2__Any*)_t33.data))._typ, 9) /*expected idx: 9, name: i64 */ )),
		}) }, (_result*)(&_t1), sizeof(discord__Sku));
		return _t1;
	}
	
	else {
		return (_result_discord__Sku){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected sku to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__Sku){0};
}

_result_Array_discord__Sku discord__Client_list_skus(discord__Client _v_toheap_c, discord__Snowflake application_id) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t2 = discord__Client_request((*(c)), net__http__Method__get,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/applications/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(application_id))}}, {_SLIT("/skus"), 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t2.is_error) {
		_result_Array_discord__Sku _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_x__json2__Any _t1 = x__json2__raw_decode( (*(net__http__Response*)_t2.data).body);
	if (_t1.is_error) {
		_result_Array_discord__Sku _t4;
		memcpy(&_t4, &_t1, sizeof(_result));
		return _t4;
	}
	
 	x__json2__Any r =  (*(x__json2__Any*)_t1.data);
	Array_discord__Sku _t6 = {0};
	Array_x__json2__Any _t6_orig = (/* as */ *(Array_x__json2__Any*)__as_cast((r)._Array_x__json2__Any,(r)._typ, 174) /*expected idx: 174, name: []x.json2.Any */ );
	int _t6_len = _t6_orig.len;
	_t6 = __new_array(0, _t6_len, sizeof(discord__Sku));

	for (int _t8 = 0; _t8 < _t6_len; ++_t8) {
		x__json2__Any it = ((x__json2__Any*) _t6_orig.data)[_t8];
		_result_discord__Sku _t9 = discord__Sku__static__parse(it);
		if (_t9.is_error) {
			_result_Array_discord__Sku _t10;
			memcpy(&_t10, &_t9, sizeof(_result));
			return _t10;
		}
		
 		discord__Sku _t7 =  (*(discord__Sku*)_t9.data);
		array_push((array*)&_t6, &_t7);
	}
	_result_Array_discord__Sku _t5;
	_result_ok(&(Array_discord__Sku[]) {_t6 }, (_result*)(&_t5), sizeof(Array_discord__Sku));
	return _t5;
}

// TypeDecl
u64 discord__Snowflake_raw_timestamp(discord__Snowflake s) {
	u64 _t1 = ((s >> 22)) + _const_discord__snowflake_epoch;
	return _t1;
}

time__Time discord__Snowflake_timestamp(discord__Snowflake s) {
	u64 ts = discord__Snowflake_raw_timestamp(s);
	time__Time _t1 = time__Time_as_utc(ADDR(time__Time, time__unix_microsecond((u64)(ts / 1000U), (int)(((int)((u64)(ts % 1000U))) * 1000))));
	return _t1;
}

discord__Snowflake discord__Snowflake__static__from(time__Time t) {
	discord__Snowflake _t1 = (((u64)((i64)(time__Time_unix_time_milli(&t) - _const_discord__snowflake_epoch))) << 22U);
	return _t1;
}

discord__Snowflake discord__Snowflake__static__now(void) {
	discord__Snowflake _t1 = discord__Snowflake__static__from(time__now());
	return _t1;
}

string discord__Snowflake_build(discord__Snowflake s) {
	string _t1 = u64_str(s);
	return _t1;
}

_result_discord__Snowflake discord__Snowflake__static__parse(x__json2__Any j) {
	if (j._typ == 21 /* string */) {
		_result_discord__Snowflake _t1;
		_result_ok(&(discord__Snowflake[]) { string_u64((*j._string)) }, (_result*)(&_t1), sizeof(discord__Snowflake));
		return _t1;
	}
	
	else {
		return (_result_discord__Snowflake){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected snowflake to be string, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__Snowflake){0};
}

_result_discord__Sticker discord__Sticker__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t3 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("id")}));
		_option_x__json2__Any _t2 = {0};
		if (_t3) {
			*((x__json2__Any*)&_t2.data) = *((x__json2__Any*)_t3);
		} else {
			_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t2.state != 0) {
			_result_discord__Sticker _t4;
			memcpy(&_t4, &_t2, sizeof(_result));
			return _t4;
		}
		
		_result_discord__Snowflake _t1 = discord__Snowflake__static__parse((*(x__json2__Any*)_t2.data));
		if (_t1.is_error) {
			_result_discord__Sticker _t5;
			memcpy(&_t5, &_t1, sizeof(_result));
			return _t5;
		}
		
 		discord__Snowflake id =  (*(discord__Snowflake*)_t1.data);
		x__json2__Any* _t8 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("pack_id")}));
		_option_x__json2__Any _t7 = {0};
		if (_t8) {
			*((x__json2__Any*)&_t7.data) = *((x__json2__Any*)_t8);
		} else {
			_t7.state = 2; _t7.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_discord__Snowflake _t6; /* if prepend */
		if (_t7.state == 0) {
			x__json2__Any s = (*(x__json2__Any*)_t7.data);
			_result_discord__Snowflake _t10 = discord__Snowflake__static__parse(s);
			if (_t10.is_error) {
				_result_discord__Sticker _t11;
				memcpy(&_t11, &_t10, sizeof(_result));
				return _t11;
			}
			
 			_option_discord__Snowflake _t9;
			_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t10.data) }, (_option*)(&_t9), sizeof(discord__Snowflake));
			_t6 = _t9;
		} else {
			IError err = _t7.err;
			_t6.state = 2;
			_t6.err = _const_none__;
		}
		_option_discord__Snowflake pack_id =  _t6;
		x__json2__Any* _t13 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
		_option_x__json2__Any _t12 = {0};
		if (_t13) {
			*((x__json2__Any*)&_t12.data) = *((x__json2__Any*)_t13);
		} else {
			_t12.state = 2; _t12.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t12.state != 0) {
			_result_discord__Sticker _t14;
			memcpy(&_t14, &_t12, sizeof(_result));
			return _t14;
		}
		x__json2__Any* _t16 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("name")}));
		_option_x__json2__Any _t15 = {0};
		if (_t16) {
			*((x__json2__Any*)&_t15.data) = *((x__json2__Any*)_t16);
		} else {
			_t15.state = 2; _t15.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t15.state != 0) {
			_result_discord__Sticker _t17;
			memcpy(&_t17, &_t15, sizeof(_result));
			return _t17;
		}
		
		
		string name = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t12.data))._string,((*(x__json2__Any*)_t15.data))._typ, 21) /*expected idx: 21, name: string */ ;
		x__json2__Any* _t19 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("description")}));
		_option_x__json2__Any _t18 = {0};
		if (_t19) {
			*((x__json2__Any*)&_t18.data) = *((x__json2__Any*)_t19);
		} else {
			_t18.state = 2; _t18.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t18.state != 0) {
			_result_discord__Sticker _t20;
			memcpy(&_t20, &_t18, sizeof(_result));
			return _t20;
		}
		
		x__json2__Any description = (*(x__json2__Any*)_t18.data);
		x__json2__Any* _t22 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("tags")}));
		_option_x__json2__Any _t21 = {0};
		if (_t22) {
			*((x__json2__Any*)&_t21.data) = *((x__json2__Any*)_t22);
		} else {
			_t21.state = 2; _t21.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t21.state != 0) {
			_result_discord__Sticker _t23;
			memcpy(&_t23, &_t21, sizeof(_result));
			return _t23;
		}
		x__json2__Any* _t25 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("tags")}));
		_option_x__json2__Any _t24 = {0};
		if (_t25) {
			*((x__json2__Any*)&_t24.data) = *((x__json2__Any*)_t25);
		} else {
			_t24.state = 2; _t24.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t24.state != 0) {
			_result_discord__Sticker _t26;
			memcpy(&_t26, &_t24, sizeof(_result));
			return _t26;
		}
		
		
		string tags = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t21.data))._string,((*(x__json2__Any*)_t24.data))._typ, 21) /*expected idx: 21, name: string */ ;
		x__json2__Any* _t28 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("type")}));
		_option_x__json2__Any _t27 = {0};
		if (_t28) {
			*((x__json2__Any*)&_t27.data) = *((x__json2__Any*)_t28);
		} else {
			_t27.state = 2; _t27.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t27.state != 0) {
			_result_discord__Sticker _t29;
			memcpy(&_t29, &_t27, sizeof(_result));
			return _t29;
		}
		x__json2__Any* _t31 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("type")}));
		_option_x__json2__Any _t30 = {0};
		if (_t31) {
			*((x__json2__Any*)&_t30.data) = *((x__json2__Any*)_t31);
		} else {
			_t30.state = 2; _t30.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t30.state != 0) {
			_result_discord__Sticker _t32;
			memcpy(&_t32, &_t30, sizeof(_result));
			return _t32;
		}
		
		
		discord__StickerType typ = ((discord__StickerType)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t27.data))._i64,((*(x__json2__Any*)_t30.data))._typ, 9) /*expected idx: 9, name: i64 */ ));
		x__json2__Any* _t34 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("format_type")}));
		_option_x__json2__Any _t33 = {0};
		if (_t34) {
			*((x__json2__Any*)&_t33.data) = *((x__json2__Any*)_t34);
		} else {
			_t33.state = 2; _t33.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t33.state != 0) {
			_result_discord__Sticker _t35;
			memcpy(&_t35, &_t33, sizeof(_result));
			return _t35;
		}
		x__json2__Any* _t37 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("format_type")}));
		_option_x__json2__Any _t36 = {0};
		if (_t37) {
			*((x__json2__Any*)&_t36.data) = *((x__json2__Any*)_t37);
		} else {
			_t36.state = 2; _t36.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t36.state != 0) {
			_result_discord__Sticker _t38;
			memcpy(&_t38, &_t36, sizeof(_result));
			return _t38;
		}
		
		
		discord__StickerFormatType format_type = ((discord__StickerFormatType)(/* as */ *(i64*)__as_cast(((*(x__json2__Any*)_t33.data))._i64,((*(x__json2__Any*)_t36.data))._typ, 9) /*expected idx: 9, name: i64 */ ));
		x__json2__Any* _t41 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("available")}));
		_option_x__json2__Any _t40 = {0};
		if (_t41) {
			*((x__json2__Any*)&_t40.data) = *((x__json2__Any*)_t41);
		} else {
			_t40.state = 2; _t40.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_bool _t39; /* if prepend */
		if (_t40.state == 0) {
			x__json2__Any b = (*(x__json2__Any*)_t40.data);
			_option_bool _t42;
			_option_ok(&(bool[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t42), sizeof(bool));
			_t39 = _t42;
		} else {
			IError err = _t40.err;
			_t39.state = 2;
			_t39.err = _const_none__;
		}
		_option_bool available =  _t39;
		x__json2__Any* _t45 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("guild_id")}));
		_option_x__json2__Any _t44 = {0};
		if (_t45) {
			*((x__json2__Any*)&_t44.data) = *((x__json2__Any*)_t45);
		} else {
			_t44.state = 2; _t44.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_discord__Snowflake _t43; /* if prepend */
		if (_t44.state == 0) {
			x__json2__Any s = (*(x__json2__Any*)_t44.data);
			_result_discord__Snowflake _t47 = discord__Snowflake__static__parse(s);
			if (_t47.is_error) {
				_result_discord__Sticker _t48;
				memcpy(&_t48, &_t47, sizeof(_result));
				return _t48;
			}
			
 			_option_discord__Snowflake _t46;
			_option_ok(&(discord__Snowflake[]) {  (*(discord__Snowflake*)_t47.data) }, (_option*)(&_t46), sizeof(discord__Snowflake));
			_t43 = _t46;
		} else {
			IError err = _t44.err;
			_t43.state = 2;
			_t43.err = _const_none__;
		}
		_option_discord__Snowflake guild_id =  _t43;
		x__json2__Any* _t51 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("user")}));
		_option_x__json2__Any _t50 = {0};
		if (_t51) {
			*((x__json2__Any*)&_t50.data) = *((x__json2__Any*)_t51);
		} else {
			_t50.state = 2; _t50.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_discord__User _t49; /* if prepend */
		if (_t50.state == 0) {
			x__json2__Any o = (*(x__json2__Any*)_t50.data);
			_result_discord__User _t53 = discord__User__static__parse(o);
			if (_t53.is_error) {
				_result_discord__Sticker _t54;
				memcpy(&_t54, &_t53, sizeof(_result));
				return _t54;
			}
			
 			_option_discord__User _t52;
			_option_ok(&(discord__User[]) {  (*(discord__User*)_t53.data) }, (_option*)(&_t52), sizeof(discord__User));
			_t49 = _t52;
		} else {
			IError err = _t50.err;
			_t49.state = 2;
			_t49.err = _const_none__;
		}
		_option_discord__User user =  _t49;
		x__json2__Any* _t57 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("sort_value")}));
		_option_x__json2__Any _t56 = {0};
		if (_t57) {
			*((x__json2__Any*)&_t56.data) = *((x__json2__Any*)_t57);
		} else {
			_t56.state = 2; _t56.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_int _t55; /* if prepend */
		if (_t56.state == 0) {
			x__json2__Any i = (*(x__json2__Any*)_t56.data);
			_option_int _t58;
			_option_ok(&(int[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t58), sizeof(int));
			_t55 = _t58;
		} else {
			IError err = _t56.err;
			_t55.state = 2;
			_t55.err = _const_none__;
		}
		_option_int sort_value =  _t55;
			_option_string _t60; /* if prepend */
			if ((description)._typ == 21 /* string */) {
				_option_string _t61;
				_option_ok(&(string[]) { (*description._string) }, (_option*)(&_t61), sizeof(string));
				_t60 = _t61;
			} else {
				_t60.state = 2;
				_t60.err = _const_none__;
			}
			_option_string _t62;
			_option_ok(&(string[]) { tags }, (_option*)(&_t62), sizeof(string));
			_result_discord__Sticker _t59;
		_result_ok(&(discord__Sticker[]) { ((discord__Sticker){
			.id = id,
			.pack_id = pack_id,
			.name = name,
			.description =  _t60,
			.tags = _t62,
			.typ = typ,
			.format_type = format_type,
			.available = available,
			.guild_id = guild_id,
			.user = user,
			.sort_value = sort_value,
		}) }, (_result*)(&_t59), sizeof(discord__Sticker));
		return _t59;
	}
	
	else {
		return (_result_discord__Sticker){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected sticker to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__Sticker){0};
}

_result_discord__AvatarDecorationData discord__AvatarDecorationData__static__parse(x__json2__Any j) {
	if (j._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t3 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("asset")}));
		_option_x__json2__Any _t2 = {0};
		if (_t3) {
			*((x__json2__Any*)&_t2.data) = *((x__json2__Any*)_t3);
		} else {
			_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t2.state != 0) {
			_result_discord__AvatarDecorationData _t4;
			memcpy(&_t4, &_t2, sizeof(_result));
			return _t4;
		}
		x__json2__Any* _t6 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("asset")}));
		_option_x__json2__Any _t5 = {0};
		if (_t6) {
			*((x__json2__Any*)&_t5.data) = *((x__json2__Any*)_t6);
		} else {
			_t5.state = 2; _t5.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t5.state != 0) {
			_result_discord__AvatarDecorationData _t7;
			memcpy(&_t7, &_t5, sizeof(_result));
			return _t7;
		}
		x__json2__Any* _t10 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("sku_id")}));
		_option_x__json2__Any _t9 = {0};
		if (_t10) {
			*((x__json2__Any*)&_t9.data) = *((x__json2__Any*)_t10);
		} else {
			_t9.state = 2; _t9.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t9.state != 0) {
			_result_discord__AvatarDecorationData _t11;
			memcpy(&_t11, &_t9, sizeof(_result));
			return _t11;
		}
		
		_result_discord__Snowflake _t8 = discord__Snowflake__static__parse((*(x__json2__Any*)_t9.data));
		if (_t8.is_error) {
			_result_discord__AvatarDecorationData _t12;
			memcpy(&_t12, &_t8, sizeof(_result));
			return _t12;
		}
		
 		
		
		_result_discord__AvatarDecorationData _t1;
		_result_ok(&(discord__AvatarDecorationData[]) { ((discord__AvatarDecorationData){.asset = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t2.data))._string,((*(x__json2__Any*)_t5.data))._typ, 21) /*expected idx: 21, name: string */ ,.sku_id =  (*(discord__Snowflake*)_t8.data),}) }, (_result*)(&_t1), sizeof(discord__AvatarDecorationData));
		return _t1;
	}
	
	else {
		return (_result_discord__AvatarDecorationData){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected avatar decoration data to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__AvatarDecorationData){0};
}

_result_discord__User discord__User__static__parse(x__json2__Any j) {
	 _v_dump_expr_x__json2__Any(_SLIT("D:\\\\Games\\\\Proekti\\\\V\\\\interactions\\\\discord\\\\user.v"), 114, _SLIT("j"), j);
	if (j._typ == 173 /* map[string]x.json2.Any */) {
		x__json2__Any* _t3 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("id")}));
		_option_x__json2__Any _t2 = {0};
		if (_t3) {
			*((x__json2__Any*)&_t2.data) = *((x__json2__Any*)_t3);
		} else {
			_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t2.state != 0) {
			_result_discord__User _t4;
			memcpy(&_t4, &_t2, sizeof(_result));
			return _t4;
		}
		
		_result_discord__Snowflake _t1 = discord__Snowflake__static__parse((*(x__json2__Any*)_t2.data));
		if (_t1.is_error) {
			_result_discord__User _t5;
			memcpy(&_t5, &_t1, sizeof(_result));
			return _t5;
		}
		
 		discord__Snowflake id =  (*(discord__Snowflake*)_t1.data);
		x__json2__Any* _t7 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("username")}));
		_option_x__json2__Any _t6 = {0};
		if (_t7) {
			*((x__json2__Any*)&_t6.data) = *((x__json2__Any*)_t7);
		} else {
			_t6.state = 2; _t6.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t6.state != 0) {
			_result_discord__User _t8;
			memcpy(&_t8, &_t6, sizeof(_result));
			return _t8;
		}
		x__json2__Any* _t10 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("username")}));
		_option_x__json2__Any _t9 = {0};
		if (_t10) {
			*((x__json2__Any*)&_t9.data) = *((x__json2__Any*)_t10);
		} else {
			_t9.state = 2; _t9.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t9.state != 0) {
			_result_discord__User _t11;
			memcpy(&_t11, &_t9, sizeof(_result));
			return _t11;
		}
		
		
		string username = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t6.data))._string,((*(x__json2__Any*)_t9.data))._typ, 21) /*expected idx: 21, name: string */ ;
		x__json2__Any* _t13 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("discriminator")}));
		_option_x__json2__Any _t12 = {0};
		if (_t13) {
			*((x__json2__Any*)&_t12.data) = *((x__json2__Any*)_t13);
		} else {
			_t12.state = 2; _t12.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t12.state != 0) {
			_result_discord__User _t14;
			memcpy(&_t14, &_t12, sizeof(_result));
			return _t14;
		}
		x__json2__Any* _t16 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("discriminator")}));
		_option_x__json2__Any _t15 = {0};
		if (_t16) {
			*((x__json2__Any*)&_t15.data) = *((x__json2__Any*)_t16);
		} else {
			_t15.state = 2; _t15.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t15.state != 0) {
			_result_discord__User _t17;
			memcpy(&_t17, &_t15, sizeof(_result));
			return _t17;
		}
		
		
		string discriminator = /* as */ *(string*)__as_cast(((*(x__json2__Any*)_t12.data))._string,((*(x__json2__Any*)_t15.data))._typ, 21) /*expected idx: 21, name: string */ ;
		x__json2__Any* _t19 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("global_name")}));
		_option_x__json2__Any _t18 = {0};
		if (_t19) {
			*((x__json2__Any*)&_t18.data) = *((x__json2__Any*)_t19);
		} else {
			_t18.state = 2; _t18.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t18.state != 0) {
			_result_discord__User _t20;
			memcpy(&_t20, &_t18, sizeof(_result));
			return _t20;
		}
		
		x__json2__Any tmp1 = (*(x__json2__Any*)_t18.data);
		_option_string _t21; /* if prepend */
		if ((tmp1)._typ == 21 /* string */) {
			_option_string _t22;
			_option_ok(&(string[]) { (*tmp1._string) }, (_option*)(&_t22), sizeof(string));
			_t21 = _t22;
		} else {
			_t21.state = 2;
			_t21.err = _const_none__;
		}
		_option_string global_name =  _t21;
		x__json2__Any* _t24 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("avatar")}));
		_option_x__json2__Any _t23 = {0};
		if (_t24) {
			*((x__json2__Any*)&_t23.data) = *((x__json2__Any*)_t24);
		} else {
			_t23.state = 2; _t23.err = _v_error(_SLIT("array index out of range"));
		}
		;
		if (_t23.state != 0) {
			_result_discord__User _t25;
			memcpy(&_t25, &_t23, sizeof(_result));
			return _t25;
		}
		
		x__json2__Any tmp2 = (*(x__json2__Any*)_t23.data);
		_option_string _t26; /* if prepend */
		if ((tmp2)._typ == 21 /* string */) {
			_option_string _t27;
			_option_ok(&(string[]) { (*tmp2._string) }, (_option*)(&_t27), sizeof(string));
			_t26 = _t27;
		} else {
			_t26.state = 2;
			_t26.err = _const_none__;
		}
		_option_string avatar =  _t26;
		x__json2__Any* _t30 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("bot")}));
		_option_x__json2__Any _t29 = {0};
		if (_t30) {
			*((x__json2__Any*)&_t29.data) = *((x__json2__Any*)_t30);
		} else {
			_t29.state = 2; _t29.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_bool _t28; /* if prepend */
		if (_t29.state == 0) {
			x__json2__Any b = (*(x__json2__Any*)_t29.data);
			_option_bool _t31;
			_option_ok(&(bool[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t31), sizeof(bool));
			_t28 = _t31;
		} else {
			IError err = _t29.err;
			_t28.state = 2;
			_t28.err = _const_none__;
		}
		_option_bool bot =  _t28;
		x__json2__Any* _t34 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("system")}));
		_option_x__json2__Any _t33 = {0};
		if (_t34) {
			*((x__json2__Any*)&_t33.data) = *((x__json2__Any*)_t34);
		} else {
			_t33.state = 2; _t33.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_bool _t32; /* if prepend */
		if (_t33.state == 0) {
			x__json2__Any b = (*(x__json2__Any*)_t33.data);
			_option_bool _t35;
			_option_ok(&(bool[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t35), sizeof(bool));
			_t32 = _t35;
		} else {
			IError err = _t33.err;
			_t32.state = 2;
			_t32.err = _const_none__;
		}
		_option_bool system =  _t32;
		x__json2__Any* _t38 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("mfa_enabled")}));
		_option_x__json2__Any _t37 = {0};
		if (_t38) {
			*((x__json2__Any*)&_t37.data) = *((x__json2__Any*)_t38);
		} else {
			_t37.state = 2; _t37.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_bool _t36; /* if prepend */
		if (_t37.state == 0) {
			x__json2__Any b = (*(x__json2__Any*)_t37.data);
			_option_bool _t39;
			_option_ok(&(bool[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t39), sizeof(bool));
			_t36 = _t39;
		} else {
			IError err = _t37.err;
			_t36.state = 2;
			_t36.err = _const_none__;
		}
		_option_bool mfa_enabled =  _t36;
		x__json2__Any* _t42 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("banner")}));
		_option_x__json2__Any _t41 = {0};
		if (_t42) {
			*((x__json2__Any*)&_t41.data) = *((x__json2__Any*)_t42);
		} else {
			_t41.state = 2; _t41.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_string _t40; /* if prepend */
		if (_t41.state == 0) {
			x__json2__Any s = (*(x__json2__Any*)_t41.data);
			_option_string _t43; /* if prepend */
			if ((s)._typ == 21 /* string */) {
				_option_string _t44;
				_option_ok(&(string[]) { (*s._string) }, (_option*)(&_t44), sizeof(string));
				_t43 = _t44;
			} else {
				_t43.state = 2;
				_t43.err = _const_none__;
			}
			
			_t40 =  _t43;
		} else {
			IError err = _t41.err;
			_t40.state = 2;
			_t40.err = _const_none__;
		}
		_option_string banner =  _t40;
		x__json2__Any* _t47 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("accent_color")}));
		_option_x__json2__Any _t46 = {0};
		if (_t47) {
			*((x__json2__Any*)&_t46.data) = *((x__json2__Any*)_t47);
		} else {
			_t46.state = 2; _t46.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_int _t45; /* if prepend */
		if (_t46.state == 0) {
			x__json2__Any i = (*(x__json2__Any*)_t46.data);
			_option_int _t48; /* if prepend */
			if ((i)._typ == 9 /* i64 */) {
				_option_int _t49;
				_option_ok(&(int[]) { (*i._i64) }, (_option*)(&_t49), sizeof(int));
				_t48 = _t49;
			} else {
				_t48.state = 2;
				_t48.err = _const_none__;
			}
			
			_t45 =  _t48;
		} else {
			IError err = _t46.err;
			_t45.state = 2;
			_t45.err = _const_none__;
		}
		_option_int accent_color =  _t45;
		x__json2__Any* _t52 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("locale")}));
		_option_x__json2__Any _t51 = {0};
		if (_t52) {
			*((x__json2__Any*)&_t51.data) = *((x__json2__Any*)_t52);
		} else {
			_t51.state = 2; _t51.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_string _t50; /* if prepend */
		if (_t51.state == 0) {
			x__json2__Any s = (*(x__json2__Any*)_t51.data);
			_option_string _t53;
			_option_ok(&(string[]) { /* as */ *(string*)__as_cast((s)._string,(s)._typ, 21) /*expected idx: 21, name: string */  }, (_option*)(&_t53), sizeof(string));
			_t50 = _t53;
		} else {
			IError err = _t51.err;
			_t50.state = 2;
			_t50.err = _const_none__;
		}
		_option_string locale =  _t50;
		x__json2__Any* _t56 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("verified")}));
		_option_x__json2__Any _t55 = {0};
		if (_t56) {
			*((x__json2__Any*)&_t55.data) = *((x__json2__Any*)_t56);
		} else {
			_t55.state = 2; _t55.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_bool _t54; /* if prepend */
		if (_t55.state == 0) {
			x__json2__Any b = (*(x__json2__Any*)_t55.data);
			_option_bool _t57;
			_option_ok(&(bool[]) { /* as */ *(bool*)__as_cast((b)._bool,(b)._typ, 19) /*expected idx: 19, name: bool */  }, (_option*)(&_t57), sizeof(bool));
			_t54 = _t57;
		} else {
			IError err = _t55.err;
			_t54.state = 2;
			_t54.err = _const_none__;
		}
		_option_bool verified =  _t54;
		x__json2__Any* _t60 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("email")}));
		_option_x__json2__Any _t59 = {0};
		if (_t60) {
			*((x__json2__Any*)&_t59.data) = *((x__json2__Any*)_t60);
		} else {
			_t59.state = 2; _t59.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_string _t58; /* if prepend */
		if (_t59.state == 0) {
			x__json2__Any s = (*(x__json2__Any*)_t59.data);
			_option_string _t61; /* if prepend */
			if ((s)._typ == 21 /* string */) {
				_option_string _t62;
				_option_ok(&(string[]) { (*s._string) }, (_option*)(&_t62), sizeof(string));
				_t61 = _t62;
			} else {
				_t61.state = 2;
				_t61.err = _const_none__;
			}
			
			_t58 =  _t61;
		} else {
			IError err = _t59.err;
			_t58.state = 2;
			_t58.err = _const_none__;
		}
		_option_string email =  _t58;
		x__json2__Any* _t65 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("flags")}));
		_option_x__json2__Any _t64 = {0};
		if (_t65) {
			*((x__json2__Any*)&_t64.data) = *((x__json2__Any*)_t65);
		} else {
			_t64.state = 2; _t64.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_discord__UserFlags _t63; /* if prepend */
		if (_t64.state == 0) {
			x__json2__Any i = (*(x__json2__Any*)_t64.data);
			_option_discord__UserFlags _t66;
			_option_ok(&(discord__UserFlags[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t66), sizeof(discord__UserFlags));
			_t63 = _t66;
		} else {
			IError err = _t64.err;
			_t63.state = 2;
			_t63.err = _const_none__;
		}
		_option_discord__UserFlags flags =  _t63;
		x__json2__Any* _t69 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("premium_type")}));
		_option_x__json2__Any _t68 = {0};
		if (_t69) {
			*((x__json2__Any*)&_t68.data) = *((x__json2__Any*)_t69);
		} else {
			_t68.state = 2; _t68.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_discord__PremiumType _t67; /* if prepend */
		if (_t68.state == 0) {
			x__json2__Any i = (*(x__json2__Any*)_t68.data);
			_option_discord__PremiumType _t70;
			_option_ok(&(discord__PremiumType[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t70), sizeof(discord__PremiumType));
			_t67 = _t70;
		} else {
			IError err = _t68.err;
			_t67.state = 2;
			_t67.err = _const_none__;
		}
		_option_discord__PremiumType premium_type =  _t67;
		x__json2__Any* _t73 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("public_flags")}));
		_option_x__json2__Any _t72 = {0};
		if (_t73) {
			*((x__json2__Any*)&_t72.data) = *((x__json2__Any*)_t73);
		} else {
			_t72.state = 2; _t72.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_discord__UserFlags _t71; /* if prepend */
		if (_t72.state == 0) {
			x__json2__Any i = (*(x__json2__Any*)_t72.data);
			_option_discord__UserFlags _t74;
			_option_ok(&(discord__UserFlags[]) { /* as */ *(i64*)__as_cast((i)._i64,(i)._typ, 9) /*expected idx: 9, name: i64 */  }, (_option*)(&_t74), sizeof(discord__UserFlags));
			_t71 = _t74;
		} else {
			IError err = _t72.err;
			_t71.state = 2;
			_t71.err = _const_none__;
		}
		_option_discord__UserFlags public_flags =  _t71;
		x__json2__Any* _t77 = (x__json2__Any*)(map_get_check(ADDR(map, (*j._Map_string_x__json2__Any)), &(string[]){_SLIT("avatar_decoration_data")}));
		_option_x__json2__Any _t76 = {0};
		if (_t77) {
			*((x__json2__Any*)&_t76.data) = *((x__json2__Any*)_t77);
		} else {
			_t76.state = 2; _t76.err = _v_error(_SLIT("array index out of range"));
		}
		
		_option_discord__AvatarDecorationData _t75; /* if prepend */
		if (_t76.state == 0) {
			x__json2__Any o = (*(x__json2__Any*)_t76.data);
			_option_discord__AvatarDecorationData _t78; /* if prepend */
			if ((o)._typ == 170 /* x.json2.Null */) {
				
				_t78 = (_option_discord__AvatarDecorationData){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
			} else {
				_result_discord__AvatarDecorationData _t79 = discord__AvatarDecorationData__static__parse(o);
				if (_t79.is_error) {
					_result_discord__User _t80;
					memcpy(&_t80, &_t79, sizeof(_result));
					return _t80;
				}
				
 				_option_ok(&(discord__AvatarDecorationData[]) {  (*(discord__AvatarDecorationData*)_t79.data) }, (_option*)(&_t78), sizeof(discord__AvatarDecorationData));
			}
			
			_t75 =  _t78;
		} else {
			IError err = _t76.err;
			_t75.state = 2;
			_t75.err = _const_none__;
		}
		_option_discord__AvatarDecorationData avatar_decoration =  _t75;
		_result_discord__User _t81;
		_result_ok(&(discord__User[]) { ((discord__User){
			.id = id,
			.username = username,
			.discriminator = discriminator,
			.global_name = global_name,
			.avatar = avatar,
			.bot = bot,
			.system = system,
			.mfa_enabled = mfa_enabled,
			.banner = banner,
			.accent_color = accent_color,
			.locale = locale,
			.verified = verified,
			.email = email,
			.flags = flags,
			.premium_type = premium_type,
			.public_flags = public_flags,
			.avatar_decoration = avatar_decoration,
		}) }, (_result*)(&_t81), sizeof(discord__User));
		return _t81;
	}
	
	else {
		return (_result_discord__User){ .is_error=true, .err=_v_error( str_intp(2, _MOV((StrIntpData[]){{_SLIT("expected user to be object, got "), /*115 &string*/0xfe10, {.d_s = charptr_vstring_literal( /* x.json2.Any */ v_typeof_sumtype_x__json2__Any( (j)._typ ))}}, {_SLIT0, 0, { .d_c = 0 }}}))), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	
	return (_result_discord__User){0};
}

_result_discord__User discord__Client_fetch_my_user(discord__Client _v_toheap_c) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t4 = discord__Client_request((*(c)), net__http__Method__get, _SLIT("/users/@me"), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t4.is_error) {
		_result_discord__User _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	_result_x__json2__Any _t3 = x__json2__raw_decode( (*(net__http__Response*)_t4.data).body);
	if (_t3.is_error) {
		_result_discord__User _t6;
		memcpy(&_t6, &_t3, sizeof(_result));
		return _t6;
	}
	
 	_result_discord__User _t2 = discord__User__static__parse( (*(x__json2__Any*)_t3.data));
	if (_t2.is_error) {
		_result_discord__User _t7;
		memcpy(&_t7, &_t2, sizeof(_result));
		return _t7;
	}
	
 	_result_discord__User _t1;
	_result_ok(&(discord__User[]) {  (*(discord__User*)_t2.data) }, (_result*)(&_t1), sizeof(discord__User));
	return _t1;
}

_result_discord__User discord__Client_fetch_user(discord__Client _v_toheap_c, discord__Snowflake user_id) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t4 = discord__Client_request((*(c)), net__http__Method__get,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/users/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(user_id))}}, {_SLIT0, 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t4.is_error) {
		_result_discord__User _t5;
		memcpy(&_t5, &_t4, sizeof(_result));
		return _t5;
	}
	
 	_result_x__json2__Any _t3 = x__json2__raw_decode( (*(net__http__Response*)_t4.data).body);
	if (_t3.is_error) {
		_result_discord__User _t6;
		memcpy(&_t6, &_t3, sizeof(_result));
		return _t6;
	}
	
 	_result_discord__User _t2 = discord__User__static__parse( (*(x__json2__Any*)_t3.data));
	if (_t2.is_error) {
		_result_discord__User _t7;
		memcpy(&_t7, &_t2, sizeof(_result));
		return _t7;
	}
	
 	_result_discord__User _t1;
	_result_ok(&(discord__User[]) {  (*(discord__User*)_t2.data) }, (_result*)(&_t1), sizeof(discord__User));
	return _t1;
}

x__json2__Any discord__MyUserEdit_build(discord__MyUserEdit mue) {
	Map_string_x__json2__Any r = new_map(sizeof(string), sizeof(x__json2__Any), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string)
	;
	_option_string _t1;
	if (_t1 = mue.username, _t1.state == 0) {
		string username = *(string*)_t1.data;
		map_set(&r, &(string[]){_SLIT("username")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(&username) });
	}
	_option_discord__Image _t2;
	if (_t2 = mue.avatar, _t2.state == 0) {
		discord__Image avatar = *(discord__Image*)_t2.data;
		map_set(&r, &(string[]){_SLIT("avatar")}, &(x__json2__Any[]) { string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, (discord__Image_name_table[avatar._typ]._method_build(avatar._object)))) });
	}
	return Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(&r);
}

_result_discord__User discord__Client_edit_my_user(discord__Client _v_toheap_c, discord__MyUserEdit params) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_option_x__json2__Any _t5;
	_option_ok(&(x__json2__Any[]) { discord__MyUserEdit_build(params) }, (_option*)(&_t5), sizeof(x__json2__Any));
	_result_net__http__Response _t4 = discord__Client_request((*(c)), net__http__Method__patch, _SLIT("/users/@me"), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = _t5,.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t4.is_error) {
		_result_discord__User _t6;
		memcpy(&_t6, &_t4, sizeof(_result));
		return _t6;
	}
	
 	_result_x__json2__Any _t3 = x__json2__raw_decode( (*(net__http__Response*)_t4.data).body);
	if (_t3.is_error) {
		_result_discord__User _t7;
		memcpy(&_t7, &_t3, sizeof(_result));
		return _t7;
	}
	
 	_result_discord__User _t2 = discord__User__static__parse( (*(x__json2__Any*)_t3.data));
	if (_t2.is_error) {
		_result_discord__User _t8;
		memcpy(&_t8, &_t2, sizeof(_result));
		return _t8;
	}
	
 	_result_discord__User _t1;
	_result_ok(&(discord__User[]) {  (*(discord__User*)_t2.data) }, (_result*)(&_t1), sizeof(discord__User));
	return _t1;
}

_result_discord__GuildMember discord__Client_fetch_my_guild_member(discord__Client _v_toheap_c, discord__Snowflake guild_id) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t3 = discord__Client_request((*(c)), net__http__Method__get,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/users/@me/guilds/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(guild_id))}}, {_SLIT("/member"), 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t3.is_error) {
		_result_discord__GuildMember _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_discord__GuildMember _t2 = discord__GuildMember__static__parse(string_to_sumtype_x__json2__Any/*KEK*/(ADDR(string, ( (*(net__http__Response*)_t3.data).body))));
	if (_t2.is_error) {
		_result_discord__GuildMember _t5;
		memcpy(&_t5, &_t2, sizeof(_result));
		return _t5;
	}
	
 	_result_discord__GuildMember _t1;
	_result_ok(&(discord__GuildMember[]) {  (*(discord__GuildMember*)_t2.data) }, (_result*)(&_t1), sizeof(discord__GuildMember));
	return _t1;
}

_result_void discord__Client_leave_guild(discord__Client _v_toheap_c, discord__Snowflake guild_id) {
discord__Client* c = HEAP(discord__Client, _v_toheap_c);
	_result_net__http__Response _t1 = discord__Client_request((*(c)), net__http__Method__delete,  str_intp(2, _MOV((StrIntpData[]){{_SLIT("/users/@me/guilds/"), /*115 &string*/0xfe10, {.d_s = net__urllib__path_escape(discord__Snowflake_build(guild_id))}}, {_SLIT0, 0, { .d_c = 0 }}})), ((discord__RequestOptions){.prepare = (_option_anon_fn_mut_net__http__request__result_void){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.authenticate = true,.reason = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.json = (_option_x__json2__Any){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.body = (_option_string){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} },.common_headers = new_map_noscan_key(sizeof(net__http__CommonHeader), sizeof(string), &map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop),.headers = new_map(sizeof(string), sizeof(string), &map_hash_string, &map_eq_string, &map_clone_string, &map_free_string),}));
	if (_t1.is_error) {
		_result_void _t2;
		memcpy(&_t2, &_t1, sizeof(_result));
		return _t2;
	}
	
  (*(net__http__Response*)_t1.data);
	return (_result_void){0};
}

VV_LOCAL_SYMBOL _result_discord__WSMessage discord__decode_message(x__json2__Any payload) {
	if ((payload)._typ != 173 /* map[string]x.json2.Any */) {
		return (_result_discord__WSMessage){ .is_error=true, .err=_v_error(_SLIT("expected object")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	int opcode = 0;
	Map_string_x__json2__Any m = x__json2__Any_as_map(payload);
	x__json2__Any* _t3 = (x__json2__Any*)(map_get_check(ADDR(map, m), &(string[]){_SLIT("op")}));
	_option_x__json2__Any _t2 = {0};
	if (_t3) {
		*((x__json2__Any*)&_t2.data) = *((x__json2__Any*)_t3);
	} else {
		_t2.state = 2; _t2.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t2.state == 0) {
		x__json2__Any op = (*(x__json2__Any*)_t2.data);
		if (op._typ == 9 /* i64 */) {
			opcode = ((int)((*op._i64)));
		}
		
		else {
			return (_result_discord__WSMessage){ .is_error=true, .err=_v_error(_SLIT("opcode is not in")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
	} else {
		IError err = _t2.err;
		return (_result_discord__WSMessage){ .is_error=true, .err=_v_error(_SLIT("no op")), .data={EMPTY_STRUCT_INITIALIZATION} };
	}
	_option_int seq = (_option_int){ .state=2, .err=_const_none__, .data={EMPTY_STRUCT_INITIALIZATION} };
	x__json2__Any* _t7 = (x__json2__Any*)(map_get_check(ADDR(map, m), &(string[]){_SLIT("s")}));
	_option_x__json2__Any _t6 = {0};
	if (_t7) {
		*((x__json2__Any*)&_t6.data) = *((x__json2__Any*)_t7);
	} else {
		_t6.state = 2; _t6.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t6.state == 0) {
		x__json2__Any s = (*(x__json2__Any*)_t6.data);
		if (s._typ == 170 /* x.json2.Null */) {
		}
		else if (s._typ == 9 /* i64 */) {
			_option_int _t8;
			_option_ok(&(int[]) { ((int)((*s._i64))) }, (_option*)(&_t8), sizeof(int));
			seq = _t8;
		}
		
		else {
			return (_result_discord__WSMessage){ .is_error=true, .err=_v_error(_SLIT("seq is not int")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
	}
	string event = _SLIT("");
	x__json2__Any* _t11 = (x__json2__Any*)(map_get_check(ADDR(map, m), &(string[]){_SLIT("t")}));
	_option_x__json2__Any _t10 = {0};
	if (_t11) {
		*((x__json2__Any*)&_t10.data) = *((x__json2__Any*)_t11);
	} else {
		_t10.state = 2; _t10.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t10.state == 0) {
		x__json2__Any t = (*(x__json2__Any*)_t10.data);
		if (t._typ == 170 /* x.json2.Null */) {
		}
		else if (t._typ == 21 /* string */) {
			event = (*t._string);
		}
		
		else {
			return (_result_discord__WSMessage){ .is_error=true, .err=_v_error(_SLIT("event is not string")), .data={EMPTY_STRUCT_INITIALIZATION} };
		}
		
	}
	x__json2__Any data = x__json2__Null_to_sumtype_x__json2__Any/*KEK*/(ADDR(x__json2__Null, (((x__json2__Null){.is_null = true,}))));
	x__json2__Any* _t14 = (x__json2__Any*)(map_get_check(ADDR(map, m), &(string[]){_SLIT("d")}));
	_option_x__json2__Any _t13 = {0};
	if (_t14) {
		*((x__json2__Any*)&_t13.data) = *((x__json2__Any*)_t14);
	} else {
		_t13.state = 2; _t13.err = _v_error(_SLIT("array index out of range"));
	}
	
	if (_t13.state == 0) {
		x__json2__Any d = (*(x__json2__Any*)_t13.data);
		data = d;
	}
	_result_discord__WSMessage _t15;
	_result_ok(&(discord__WSMessage[]) { ((discord__WSMessage){.opcode = opcode,.data = data,.seq = seq,.event = event,}) }, (_result*)(&_t15), sizeof(discord__WSMessage));
	return _t15;
}

VV_LOCAL_SYMBOL _result_x__json2__Any discord__encode_message(discord__WSMessage message) {
	_result_x__json2__Any _t1;
	_result_ok(&(x__json2__Any[]) { Map_string_x__json2__Any_to_sumtype_x__json2__Any/*KEK*/(ADDR(Map_string_x__json2__Any, (new_map_init(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 2, sizeof(string), sizeof(x__json2__Any),
			_MOV((string[2]){
				_SLIT("op"), 
				_SLIT("d"), 
			}),
			_MOV((x__json2__Any[2]){
				int_to_sumtype_x__json2__Any/*KEK*/(&message.opcode), 
				message.data, 
			})
		)
	
	))) }, (_result*)(&_t1), sizeof(x__json2__Any));
	return _t1;
}

VV_LOCAL_SYMBOL _result_discord__WSMessage discord__decode_websocket_message(net__websocket__Message message) {
	_result_x__json2__Any _t3 = x__json2__raw_decode(Array_u8_bytestr(message.payload));
	if (_t3.is_error) {
		_result_discord__WSMessage _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_discord__WSMessage _t2 = discord__decode_message( (*(x__json2__Any*)_t3.data));
	if (_t2.is_error) {
		_result_discord__WSMessage _t5;
		memcpy(&_t5, &_t2, sizeof(_result));
		return _t5;
	}
	
 	_result_discord__WSMessage _t1;
	_result_ok(&(discord__WSMessage[]) {  (*(discord__WSMessage*)_t2.data) }, (_result*)(&_t1), sizeof(discord__WSMessage));
	return _t1;
}

VV_LOCAL_SYMBOL _result_discord__WSMessage discord__ws_recv_message(net__websocket__Client* client) {
	_result_net__websocket__Message _t3 = net__websocket__Client_read_next_message(client);
	if (_t3.is_error) {
		_result_discord__WSMessage _t4;
		memcpy(&_t4, &_t3, sizeof(_result));
		return _t4;
	}
	
 	_result_discord__WSMessage _t2 = discord__decode_websocket_message( (*(net__websocket__Message*)_t3.data));
	if (_t2.is_error) {
		_result_discord__WSMessage _t5;
		memcpy(&_t5, &_t2, sizeof(_result));
		return _t5;
	}
	
 	_result_discord__WSMessage _t1;
	_result_ok(&(discord__WSMessage[]) {  (*(discord__WSMessage*)_t2.data) }, (_result*)(&_t1), sizeof(discord__WSMessage));
	return _t1;
}

VV_LOCAL_SYMBOL _result_void discord__ws_send_message(net__websocket__Client* client, discord__WSMessage message) {
	_result_x__json2__Any _t2 = discord__encode_message(message);
	if (_t2.is_error) {
		_result_void _t3;
		memcpy(&_t3, &_t2, sizeof(_result));
		return _t3;
	}
	
 	_result_int _t1 = net__websocket__Client_write(client, string_bytes(x__json2__Any_json_str( (*(x__json2__Any*)_t2.data))), net__websocket__OPCode__text_frame);
	if (_t1.is_error) {
		_result_void _t4;
		memcpy(&_t4, &_t1, sizeof(_result));
		return _t4;
	}
	
  (*(int*)_t1.data);
	return (_result_void){0};
}

// Attr: [inline]
inline bool discord__RoleFlags_is_empty(discord__RoleFlags* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__RoleFlags_has(discord__RoleFlags* e, discord__RoleFlags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__RoleFlags_all(discord__RoleFlags* e, discord__RoleFlags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void discord__RoleFlags_set(discord__RoleFlags* e, discord__RoleFlags flag) {
	{ // Unsafe block
		*e = ((discord__RoleFlags)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__RoleFlags_set_all(discord__RoleFlags* e) {
	{ // Unsafe block
		*e = ((discord__RoleFlags)(0b1));
	}
}

// Attr: [inline]
inline void discord__RoleFlags_clear(discord__RoleFlags* e, discord__RoleFlags flag) {
	{ // Unsafe block
		*e = ((discord__RoleFlags)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__RoleFlags_clear_all(discord__RoleFlags* e) {
	{ // Unsafe block
		*e = ((discord__RoleFlags)(0));
	}
}

// Attr: [inline]
inline void discord__RoleFlags_toggle(discord__RoleFlags* e, discord__RoleFlags flag) {
	{ // Unsafe block
		*e = ((discord__RoleFlags)((((int)(*e)) ^ (((int)(flag))))));
	}
}

// Attr: [inline]
inline bool discord__SystemChannelFlags_is_empty(discord__SystemChannelFlags* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__SystemChannelFlags_has(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__SystemChannelFlags_all(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void discord__SystemChannelFlags_set(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag) {
	{ // Unsafe block
		*e = ((discord__SystemChannelFlags)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__SystemChannelFlags_set_all(discord__SystemChannelFlags* e) {
	{ // Unsafe block
		*e = ((discord__SystemChannelFlags)(0b111111));
	}
}

// Attr: [inline]
inline void discord__SystemChannelFlags_clear(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag) {
	{ // Unsafe block
		*e = ((discord__SystemChannelFlags)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__SystemChannelFlags_clear_all(discord__SystemChannelFlags* e) {
	{ // Unsafe block
		*e = ((discord__SystemChannelFlags)(0));
	}
}

// Attr: [inline]
inline void discord__SystemChannelFlags_toggle(discord__SystemChannelFlags* e, discord__SystemChannelFlags flag) {
	{ // Unsafe block
		*e = ((discord__SystemChannelFlags)((((int)(*e)) ^ (((int)(flag))))));
	}
}

// Attr: [inline]
inline bool discord__GuildMemberFlags_is_empty(discord__GuildMemberFlags* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__GuildMemberFlags_has(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__GuildMemberFlags_all(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void discord__GuildMemberFlags_set(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag) {
	{ // Unsafe block
		*e = ((discord__GuildMemberFlags)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__GuildMemberFlags_set_all(discord__GuildMemberFlags* e) {
	{ // Unsafe block
		*e = ((discord__GuildMemberFlags)(0b1111));
	}
}

// Attr: [inline]
inline void discord__GuildMemberFlags_clear(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag) {
	{ // Unsafe block
		*e = ((discord__GuildMemberFlags)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__GuildMemberFlags_clear_all(discord__GuildMemberFlags* e) {
	{ // Unsafe block
		*e = ((discord__GuildMemberFlags)(0));
	}
}

// Attr: [inline]
inline void discord__GuildMemberFlags_toggle(discord__GuildMemberFlags* e, discord__GuildMemberFlags flag) {
	{ // Unsafe block
		*e = ((discord__GuildMemberFlags)((((int)(*e)) ^ (((int)(flag))))));
	}
}

// Attr: [inline]
inline bool discord__Intents_is_empty(discord__Intents* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__Intents_has(discord__Intents* e, discord__Intents flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__Intents_all(discord__Intents* e, discord__Intents flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void discord__Intents_set(discord__Intents* e, discord__Intents flag) {
	{ // Unsafe block
		*e = ((discord__Intents)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__Intents_set_all(discord__Intents* e) {
	{ // Unsafe block
		*e = ((discord__Intents)(0b1111111111111111111111));
	}
}

// Attr: [inline]
inline void discord__Intents_clear(discord__Intents* e, discord__Intents flag) {
	{ // Unsafe block
		*e = ((discord__Intents)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__Intents_clear_all(discord__Intents* e) {
	{ // Unsafe block
		*e = ((discord__Intents)(0));
	}
}

// Attr: [inline]
inline void discord__Intents_toggle(discord__Intents* e, discord__Intents flag) {
	{ // Unsafe block
		*e = ((discord__Intents)((((int)(*e)) ^ (((int)(flag))))));
	}
}

// Attr: [inline]
inline bool discord__Permissions_is_empty(discord__Permissions* e) {
	bool _t1 = ((u64)(*e)) == 0U;
	return _t1;
}

// Attr: [inline]
inline bool discord__Permissions_has(discord__Permissions* e, discord__Permissions flag) {
	bool _t1 = ((((u64)(*e)) & (((u64)(flag))))) != 0U;
	return _t1;
}

// Attr: [inline]
inline bool discord__Permissions_all(discord__Permissions* e, discord__Permissions flag) {
	bool _t1 = ((((u64)(*e)) & (((u64)(flag))))) == ((u64)(flag));
	return _t1;
}

// Attr: [inline]
inline void discord__Permissions_set(discord__Permissions* e, discord__Permissions flag) {
	{ // Unsafe block
		*e = ((discord__Permissions)((((u64)(*e)) | (((u64)(flag))))));
	}
}

// Attr: [inline]
inline void discord__Permissions_set_all(discord__Permissions* e) {
	{ // Unsafe block
		*e = ((discord__Permissions)(0b11111111111111111111111111111111111111111111111));
	}
}

// Attr: [inline]
inline void discord__Permissions_clear(discord__Permissions* e, discord__Permissions flag) {
	{ // Unsafe block
		*e = ((discord__Permissions)((((u64)(*e)) & ~(((u64)(flag))))));
	}
}

// Attr: [inline]
inline void discord__Permissions_clear_all(discord__Permissions* e) {
	{ // Unsafe block
		*e = ((discord__Permissions)(0));
	}
}

// Attr: [inline]
inline void discord__Permissions_toggle(discord__Permissions* e, discord__Permissions flag) {
	{ // Unsafe block
		*e = ((discord__Permissions)((((u64)(*e)) ^ (((u64)(flag))))));
	}
}

// Attr: [inline]
inline bool discord__UserFlags_is_empty(discord__UserFlags* e) {
	bool _t1 = ((int)(*e)) == 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__UserFlags_has(discord__UserFlags* e, discord__UserFlags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) != 0;
	return _t1;
}

// Attr: [inline]
inline bool discord__UserFlags_all(discord__UserFlags* e, discord__UserFlags flag) {
	bool _t1 = ((((int)(*e)) & (((int)(flag))))) == ((int)(flag));
	return _t1;
}

// Attr: [inline]
inline void discord__UserFlags_set(discord__UserFlags* e, discord__UserFlags flag) {
	{ // Unsafe block
		*e = ((discord__UserFlags)((((int)(*e)) | (((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__UserFlags_set_all(discord__UserFlags* e) {
	{ // Unsafe block
		*e = ((discord__UserFlags)(0b11111111111111111111111));
	}
}

// Attr: [inline]
inline void discord__UserFlags_clear(discord__UserFlags* e, discord__UserFlags flag) {
	{ // Unsafe block
		*e = ((discord__UserFlags)((((int)(*e)) & ~(((int)(flag))))));
	}
}

// Attr: [inline]
inline void discord__UserFlags_clear_all(discord__UserFlags* e) {
	{ // Unsafe block
		*e = ((discord__UserFlags)(0));
	}
}

// Attr: [inline]
inline void discord__UserFlags_toggle(discord__UserFlags* e, discord__UserFlags flag) {
	{ // Unsafe block
		*e = ((discord__UserFlags)((((int)(*e)) ^ (((int)(flag))))));
	}
}

VV_LOCAL_SYMBOL void main__main(void) {
	_result_string _t1 = os__read_file(_SLIT("token.txt"));
	if (_t1.is_error) {
		panic_result_not_set(IError_name_table[_t1.err._typ]._method_msg(_t1.err._object));
	}
	
 	string token =  (*(string*)_t1.data);
	discord__GatewayClient *c = HEAP(discord__GatewayClient, (discord__bot(token, ((discord__BotConfig){.ClientConfig = ((discord__ClientConfig){.user_agent = _const_discord__default_user_agent,.debug = 0,}),.properties = ((discord__Properties){.os = os__user_os(),.browser = _SLIT("Discord Android"),.device = _SLIT("discord.v"),}),.intents = (discord__Intents__guild_messages | discord__Intents__message_content),}))));
	discord__EventController_T_discord__DispatchEvent_T_discord__GatewayClient_listen_T_discord__DispatchEvent_T_discord__GatewayClient(&(*(c)).on_raw_event, (voidptr)	anon_fn_f860512d614a01ac_discord__dispatchevent_t_discord__gatewayclient__result_void_345);
	_result_void _t2 = discord__GatewayClient_launch(&(*(c)));
	if (_t2.is_error) {
		panic_result_not_set(IError_name_table[_t2.err._typ]._method_msg(_t2.err._object));
	}
	
 ;
}

void _vinit(int ___argc, voidptr ___argv) {
#if __STDC_HOSTED__ == 1
	signal(11, v_segmentation_fault_handler);
#endif
	as_cast_type_indexes = new_array_from_c_array(17, 17, sizeof(VCastTypeIndexName), _MOV((VCastTypeIndexName[17]){
		  (VCastTypeIndexName){.tindex = 0, .tname = _SLIT("unknown")}
		, (VCastTypeIndexName){.tindex = 170, .tname = _SLIT("x.json2.Null")}
		, (VCastTypeIndexName){.tindex = 174, .tname = _SLIT("[]x.json2.Any")}
		, (VCastTypeIndexName){.tindex = 19, .tname = _SLIT("bool")}
		, (VCastTypeIndexName){.tindex = 16, .tname = _SLIT("f32")}
		, (VCastTypeIndexName){.tindex = 17, .tname = _SLIT("f64")}
		, (VCastTypeIndexName){.tindex = 6, .tname = _SLIT("i16")}
		, (VCastTypeIndexName){.tindex = 9, .tname = _SLIT("i64")}
		, (VCastTypeIndexName){.tindex = 5, .tname = _SLIT("i8")}
		, (VCastTypeIndexName){.tindex = 8, .tname = _SLIT("int")}
		, (VCastTypeIndexName){.tindex = 173, .tname = _SLIT("map[string]x.json2.Any")}
		, (VCastTypeIndexName){.tindex = 21, .tname = _SLIT("string")}
		, (VCastTypeIndexName){.tindex = 176, .tname = _SLIT("time.Time")}
		, (VCastTypeIndexName){.tindex = 12, .tname = _SLIT("u16")}
		, (VCastTypeIndexName){.tindex = 13, .tname = _SLIT("u32")}
		, (VCastTypeIndexName){.tindex = 14, .tname = _SLIT("u64")}
		, (VCastTypeIndexName){.tindex = 11, .tname = _SLIT("u8")}
	}));


	builtin_init();
	_closure_mtx_init();
	// Initializations of consts for module math.bits
	_const_math__bits__overflow_error = _SLIT("Overflow Error");
	_const_math__bits__divide_error = _SLIT("Divide Error");
	// Initializations of consts for module strconv
	_const_strconv__digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_strconv__base_digits = _SLIT("0123456789abcdefghijklmnopqrstuvwxyz");
	// Initializations of consts for module builtin
	_const_digit_pairs = _SLIT("00102030405060708090011121314151617181910212223242526272829203132333435363738393041424344454647484940515253545556575859506162636465666768696071727374757677787970818283848586878889809192939495969798999");
	_const_si_s_code = _SLIT("0xfe10");
	_const_si_g32_code = _SLIT("0xfe0e");
	_const_si_g64_code = _SLIT("0xfe0f");
	_const_min_i64 = ((i64)((int_literal)(-9223372036854775807 - 1)));
	_const_max_i64 = ((i64)(9223372036854775807));
	_const_none__ = /*&IError*/I_None___to_Interface_IError(((None__*)memdup(&(None__){.Error = ((Error){EMPTY_STRUCT_INITIALIZATION}),}, sizeof(None__))));
	// Initializations of consts for module net.urllib
	_const_net__urllib__err_msg_escape = _SLIT("unescape: invalid URL escape");
	_const_net__urllib__err_msg_parse = _SLIT("parse: failed parsing url");
	// Initializations of consts for module time
	_const_time__days_string = _SLIT("MonTueWedThuFriSatSun");
	_const_time__months_string = _SLIT("JanFebMarAprMayJunJulAugSepOctNovDec");
	_const_time__tokens_2 = new_array_from_c_array(18, 18, sizeof(string), _MOV((string[18]){
		_SLIT("MM"), _SLIT("Mo"), _SLIT("DD"), _SLIT("Do"), _SLIT("YY"), _SLIT("ss"), _SLIT("kk"), _SLIT("NN"), _SLIT("mm"),
		_SLIT("hh"), _SLIT("HH"), _SLIT("ii"), _SLIT("ZZ"), _SLIT("dd"), _SLIT("Qo"), _SLIT("QQ"), _SLIT("wo"),
		_SLIT("ww")}));
	_const_time__tokens_3 = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT("MMM"), _SLIT("DDD"), _SLIT("ZZZ"), _SLIT("ddd")}));
	_const_time__tokens_4 = new_array_from_c_array(5, 5, sizeof(string), _MOV((string[5]){_SLIT("MMMM"), _SLIT("DDDD"), _SLIT("DDDo"), _SLIT("dddd"), _SLIT("YYYY")}));
	_const_time__long_days = new_array_from_c_array(7, 7, sizeof(string), _MOV((string[7]){_SLIT("Monday"), _SLIT("Tuesday"), _SLIT("Wednesday"), _SLIT("Thursday"), _SLIT("Friday"), _SLIT("Saturday"), _SLIT("Sunday")}));
	_const_time__month_days = new_array_from_c_array_noscan(12, 12, sizeof(int), _MOV((int[12]){
		31, 28, 31, 30, 31, 30, 31, 31, 30,
		31, 30, 31}));
	_const_time__long_months = new_array_from_c_array(12, 12, sizeof(string), _MOV((string[12]){
		_SLIT("January"), _SLIT("February"), _SLIT("March"), _SLIT("April"), _SLIT("May"), _SLIT("June"), _SLIT("July"), _SLIT("August"), _SLIT("September"),
		_SLIT("October"), _SLIT("November"), _SLIT("December")}));
	_const_time__absolute_zero_year = ((i64)(-292277022399));
	_const_time__days_before = new_array_from_c_array_noscan(13, 13, sizeof(int), _MOV((int[13]){
		0, 31, 59, 90, 120, 151, 181, 212, 243,
		273, 304, 334, 365}));
	_const_time__nanosecond = ((time__Duration)(1));
	_const_time__infinite = ((((i64)(9223372036854775807))));
	_const_time__start_time = time__init_win_time_start();
	_const_time__freq_time = time__init_win_time_freq();
	_const_time__start_local_time = time__local_as_unix_time();
	_const_time__microsecond = ((1000 * _const_time__nanosecond));
	_const_time__millisecond = ((1000 * _const_time__microsecond));
	_const_time__second = ((1000 * _const_time__millisecond));
	_const_time__minute = ((60 * _const_time__second));
	_const_time__hour = ((60 * _const_time__minute));
	// Initializations of consts for module arrays
	_const_arrays__extra_size = (isize)(32 * ((isize)(sizeof(usize))));
	// Initializations of consts for module encoding.base64
	_const_encoding__base64__enc_table = _SLIT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
	// Initializations of consts for module dl
	_const_dl__dl_ext = dl__get_shared_library_extension();
	// Initializations of consts for module encoding.utf8
	_const_encoding__utf8__max_latin_1 = ((rune)(0x00ff));
	_const_encoding__utf8__letter_table = ((encoding__utf8__RangeTable){.r16 = new_array_from_c_array_noscan(359, 359, sizeof(encoding__utf8__Range16), _MOV((encoding__utf8__Range16[359]){
		((encoding__utf8__Range16){.lo = 0x0041U,.hi = 0x005aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0061U,.hi = 0x007aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x00aaU,.hi = 0x00b5U,.stride = 11U,}), ((encoding__utf8__Range16){.lo = 0x00baU,.hi = 0x00c0U,.stride = 6U,}), ((encoding__utf8__Range16){.lo = 0x00c1U,.hi = 0x00d6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x00d8U,.hi = 0x00f6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x00f8U,.hi = 0x02c1U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x02c6U,.hi = 0x02d1U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x02e0U,.hi = 0x02e4U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x02ecU,.hi = 0x02eeU,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0x0370U,.hi = 0x0374U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0376U,.hi = 0x0377U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x037aU,.hi = 0x037dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x037fU,.hi = 0x0386U,.stride = 7U,}), ((encoding__utf8__Range16){.lo = 0x0388U,.hi = 0x038aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x038cU,.hi = 0x038eU,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0x038fU,.hi = 0x03a1U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x03a3U,.hi = 0x03f5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x03f7U,.hi = 0x0481U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x048aU,.hi = 0x052fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0531U,.hi = 0x0556U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0559U,.hi = 0x0560U,.stride = 7U,}), ((encoding__utf8__Range16){.lo = 0x0561U,.hi = 0x0588U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x05d0U,.hi = 0x05eaU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x05efU,.hi = 0x05f2U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0620U,.hi = 0x064aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x066eU,.hi = 0x066fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0671U,.hi = 0x06d3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x06d5U,.hi = 0x06e5U,.stride = 16U,}), ((encoding__utf8__Range16){.lo = 0x06e6U,.hi = 0x06eeU,.stride = 8U,}), ((encoding__utf8__Range16){.lo = 0x06efU,.hi = 0x06faU,.stride = 11U,}), ((encoding__utf8__Range16){.lo = 0x06fbU,.hi = 0x06fcU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x06ffU,.hi = 0x0710U,.stride = 17U,}),
		((encoding__utf8__Range16){.lo = 0x0712U,.hi = 0x072fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x074dU,.hi = 0x07a5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x07b1U,.hi = 0x07caU,.stride = 25U,}), ((encoding__utf8__Range16){.lo = 0x07cbU,.hi = 0x07eaU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x07f4U,.hi = 0x07f5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x07faU,.hi = 0x0800U,.stride = 6U,}), ((encoding__utf8__Range16){.lo = 0x0801U,.hi = 0x0815U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x081aU,.hi = 0x0824U,.stride = 10U,}),
		((encoding__utf8__Range16){.lo = 0x0828U,.hi = 0x0840U,.stride = 24U,}), ((encoding__utf8__Range16){.lo = 0x0841U,.hi = 0x0858U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0860U,.hi = 0x086aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x08a0U,.hi = 0x08b4U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x08b6U,.hi = 0x08c7U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0904U,.hi = 0x0939U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x093dU,.hi = 0x0950U,.stride = 19U,}), ((encoding__utf8__Range16){.lo = 0x0958U,.hi = 0x0961U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0971U,.hi = 0x0980U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0985U,.hi = 0x098cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x098fU,.hi = 0x0990U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0993U,.hi = 0x09a8U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x09aaU,.hi = 0x09b0U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x09b2U,.hi = 0x09b6U,.stride = 4U,}), ((encoding__utf8__Range16){.lo = 0x09b7U,.hi = 0x09b9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x09bdU,.hi = 0x09ceU,.stride = 17U,}),
		((encoding__utf8__Range16){.lo = 0x09dcU,.hi = 0x09ddU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x09dfU,.hi = 0x09e1U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x09f0U,.hi = 0x09f1U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x09fcU,.hi = 0x0a05U,.stride = 9U,}), ((encoding__utf8__Range16){.lo = 0x0a06U,.hi = 0x0a0aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a0fU,.hi = 0x0a10U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a13U,.hi = 0x0a28U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a2aU,.hi = 0x0a30U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0a32U,.hi = 0x0a33U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a35U,.hi = 0x0a36U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a38U,.hi = 0x0a39U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a59U,.hi = 0x0a5cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a5eU,.hi = 0x0a72U,.stride = 20U,}), ((encoding__utf8__Range16){.lo = 0x0a73U,.hi = 0x0a74U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a85U,.hi = 0x0a8dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a8fU,.hi = 0x0a91U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0a93U,.hi = 0x0aa8U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0aaaU,.hi = 0x0ab0U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0ab2U,.hi = 0x0ab3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0ab5U,.hi = 0x0ab9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0abdU,.hi = 0x0ad0U,.stride = 19U,}), ((encoding__utf8__Range16){.lo = 0x0ae0U,.hi = 0x0ae1U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0af9U,.hi = 0x0b05U,.stride = 12U,}), ((encoding__utf8__Range16){.lo = 0x0b06U,.hi = 0x0b0cU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0b0fU,.hi = 0x0b10U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b13U,.hi = 0x0b28U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b2aU,.hi = 0x0b30U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b32U,.hi = 0x0b33U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b35U,.hi = 0x0b39U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b3dU,.hi = 0x0b5cU,.stride = 31U,}), ((encoding__utf8__Range16){.lo = 0x0b5dU,.hi = 0x0b5fU,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0x0b60U,.hi = 0x0b61U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0b71U,.hi = 0x0b83U,.stride = 18U,}), ((encoding__utf8__Range16){.lo = 0x0b85U,.hi = 0x0b8aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b8eU,.hi = 0x0b90U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b92U,.hi = 0x0b95U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b99U,.hi = 0x0b9aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b9cU,.hi = 0x0b9eU,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0x0b9fU,.hi = 0x0ba3U,.stride = 4U,}), ((encoding__utf8__Range16){.lo = 0x0ba4U,.hi = 0x0ba8U,.stride = 4U,}),
		((encoding__utf8__Range16){.lo = 0x0ba9U,.hi = 0x0baaU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0baeU,.hi = 0x0bb9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0bd0U,.hi = 0x0c05U,.stride = 53U,}), ((encoding__utf8__Range16){.lo = 0x0c06U,.hi = 0x0c0cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c0eU,.hi = 0x0c10U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c12U,.hi = 0x0c28U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c2aU,.hi = 0x0c39U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c3dU,.hi = 0x0c58U,.stride = 27U,}),
		((encoding__utf8__Range16){.lo = 0x0c59U,.hi = 0x0c5aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c60U,.hi = 0x0c61U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c80U,.hi = 0x0c85U,.stride = 5U,}), ((encoding__utf8__Range16){.lo = 0x0c86U,.hi = 0x0c8cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c8eU,.hi = 0x0c90U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c92U,.hi = 0x0ca8U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0caaU,.hi = 0x0cb3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0cb5U,.hi = 0x0cb9U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0cbdU,.hi = 0x0cdeU,.stride = 33U,}), ((encoding__utf8__Range16){.lo = 0x0ce0U,.hi = 0x0ce1U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0cf1U,.hi = 0x0cf2U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d04U,.hi = 0x0d0cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d0eU,.hi = 0x0d10U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d12U,.hi = 0x0d3aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d3dU,.hi = 0x0d4eU,.stride = 17U,}), ((encoding__utf8__Range16){.lo = 0x0d54U,.hi = 0x0d56U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0d5fU,.hi = 0x0d61U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d7aU,.hi = 0x0d7fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d85U,.hi = 0x0d96U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d9aU,.hi = 0x0db1U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0db3U,.hi = 0x0dbbU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0dbdU,.hi = 0x0dc0U,.stride = 3U,}), ((encoding__utf8__Range16){.lo = 0x0dc1U,.hi = 0x0dc6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0e01U,.hi = 0x0e30U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0e32U,.hi = 0x0e33U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0e40U,.hi = 0x0e46U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0e81U,.hi = 0x0e82U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0e84U,.hi = 0x0e86U,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0x0e87U,.hi = 0x0e8aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0e8cU,.hi = 0x0ea3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0ea5U,.hi = 0x0ea7U,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0x0ea8U,.hi = 0x0eb0U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0eb2U,.hi = 0x0eb3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0ebdU,.hi = 0x0ec0U,.stride = 3U,}), ((encoding__utf8__Range16){.lo = 0x0ec1U,.hi = 0x0ec4U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0ec6U,.hi = 0x0edcU,.stride = 22U,}), ((encoding__utf8__Range16){.lo = 0x0eddU,.hi = 0x0edfU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0f00U,.hi = 0x0f40U,.stride = 64U,}), ((encoding__utf8__Range16){.lo = 0x0f41U,.hi = 0x0f47U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0f49U,.hi = 0x0f6cU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0f88U,.hi = 0x0f8cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1000U,.hi = 0x102aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x103fU,.hi = 0x1050U,.stride = 17U,}), ((encoding__utf8__Range16){.lo = 0x1051U,.hi = 0x1055U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x105aU,.hi = 0x105dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1061U,.hi = 0x1065U,.stride = 4U,}), ((encoding__utf8__Range16){.lo = 0x1066U,.hi = 0x106eU,.stride = 8U,}), ((encoding__utf8__Range16){.lo = 0x106fU,.hi = 0x1070U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1075U,.hi = 0x1081U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x108eU,.hi = 0x10a0U,.stride = 18U,}), ((encoding__utf8__Range16){.lo = 0x10a1U,.hi = 0x10c5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x10c7U,.hi = 0x10cdU,.stride = 6U,}), ((encoding__utf8__Range16){.lo = 0x10d0U,.hi = 0x10faU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x10fcU,.hi = 0x1248U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x124aU,.hi = 0x124dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1250U,.hi = 0x1256U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1258U,.hi = 0x125aU,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0x125bU,.hi = 0x125dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1260U,.hi = 0x1288U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x128aU,.hi = 0x128dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1290U,.hi = 0x12b0U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x12b2U,.hi = 0x12b5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x12b8U,.hi = 0x12beU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x12c0U,.hi = 0x12c2U,.stride = 2U,}),
		((encoding__utf8__Range16){.lo = 0x12c3U,.hi = 0x12c5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x12c8U,.hi = 0x12d6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x12d8U,.hi = 0x1310U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1312U,.hi = 0x1315U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1318U,.hi = 0x135aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1380U,.hi = 0x138fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x13a0U,.hi = 0x13f5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x13f8U,.hi = 0x13fdU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1401U,.hi = 0x166cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x166fU,.hi = 0x167fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1681U,.hi = 0x169aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x16a0U,.hi = 0x16eaU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x16f1U,.hi = 0x16f8U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1700U,.hi = 0x170cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x170eU,.hi = 0x1711U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1720U,.hi = 0x1731U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1740U,.hi = 0x1751U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1760U,.hi = 0x176cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x176eU,.hi = 0x1770U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1780U,.hi = 0x17b3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x17d7U,.hi = 0x17dcU,.stride = 5U,}), ((encoding__utf8__Range16){.lo = 0x1820U,.hi = 0x1878U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1880U,.hi = 0x1884U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1887U,.hi = 0x18a8U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x18aaU,.hi = 0x18b0U,.stride = 6U,}), ((encoding__utf8__Range16){.lo = 0x18b1U,.hi = 0x18f5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1900U,.hi = 0x191eU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1950U,.hi = 0x196dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1970U,.hi = 0x1974U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1980U,.hi = 0x19abU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x19b0U,.hi = 0x19c9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1a00U,.hi = 0x1a16U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1a20U,.hi = 0x1a54U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1aa7U,.hi = 0x1b05U,.stride = 94U,}), ((encoding__utf8__Range16){.lo = 0x1b06U,.hi = 0x1b33U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1b45U,.hi = 0x1b4bU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1b83U,.hi = 0x1ba0U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1baeU,.hi = 0x1bafU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1bbaU,.hi = 0x1be5U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1c00U,.hi = 0x1c23U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1c4dU,.hi = 0x1c4fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1c5aU,.hi = 0x1c7dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1c80U,.hi = 0x1c88U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1c90U,.hi = 0x1cbaU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1cbdU,.hi = 0x1cbfU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1ce9U,.hi = 0x1cecU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1ceeU,.hi = 0x1cf3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1cf5U,.hi = 0x1cf6U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1cfaU,.hi = 0x1d00U,.stride = 6U,}), ((encoding__utf8__Range16){.lo = 0x1d01U,.hi = 0x1dbfU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1e00U,.hi = 0x1f15U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1f18U,.hi = 0x1f1dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1f20U,.hi = 0x1f45U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1f48U,.hi = 0x1f4dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1f50U,.hi = 0x1f57U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1f59U,.hi = 0x1f5fU,.stride = 2U,}),
		((encoding__utf8__Range16){.lo = 0x1f60U,.hi = 0x1f7dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1f80U,.hi = 0x1fb4U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1fb6U,.hi = 0x1fbcU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1fbeU,.hi = 0x1fc2U,.stride = 4U,}), ((encoding__utf8__Range16){.lo = 0x1fc3U,.hi = 0x1fc4U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1fc6U,.hi = 0x1fccU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1fd0U,.hi = 0x1fd3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1fd6U,.hi = 0x1fdbU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1fe0U,.hi = 0x1fecU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1ff2U,.hi = 0x1ff4U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1ff6U,.hi = 0x1ffcU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2071U,.hi = 0x207fU,.stride = 14U,}), ((encoding__utf8__Range16){.lo = 0x2090U,.hi = 0x209cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2102U,.hi = 0x2107U,.stride = 5U,}), ((encoding__utf8__Range16){.lo = 0x210aU,.hi = 0x2113U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2115U,.hi = 0x2119U,.stride = 4U,}),
		((encoding__utf8__Range16){.lo = 0x211aU,.hi = 0x211dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2124U,.hi = 0x212aU,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0x212bU,.hi = 0x212dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x212fU,.hi = 0x2139U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x213cU,.hi = 0x213fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2145U,.hi = 0x2149U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x214eU,.hi = 0x2183U,.stride = 53U,}), ((encoding__utf8__Range16){.lo = 0x2184U,.hi = 0x2c00U,.stride = 2684U,}),
		((encoding__utf8__Range16){.lo = 0x2c01U,.hi = 0x2c2eU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2c30U,.hi = 0x2c5eU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2c60U,.hi = 0x2ce4U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2cebU,.hi = 0x2ceeU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2cf2U,.hi = 0x2cf3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2d00U,.hi = 0x2d25U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2d27U,.hi = 0x2d2dU,.stride = 6U,}), ((encoding__utf8__Range16){.lo = 0x2d30U,.hi = 0x2d67U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x2d6fU,.hi = 0x2d80U,.stride = 17U,}), ((encoding__utf8__Range16){.lo = 0x2d81U,.hi = 0x2d96U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2da0U,.hi = 0x2da6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2da8U,.hi = 0x2daeU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2db0U,.hi = 0x2db6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2db8U,.hi = 0x2dbeU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2dc0U,.hi = 0x2dc6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2dc8U,.hi = 0x2dceU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x2dd0U,.hi = 0x2dd6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2dd8U,.hi = 0x2ddeU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2e2fU,.hi = 0x3005U,.stride = 470U,}), ((encoding__utf8__Range16){.lo = 0x3006U,.hi = 0x3031U,.stride = 43U,}), ((encoding__utf8__Range16){.lo = 0x3032U,.hi = 0x3035U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x303bU,.hi = 0x303cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3041U,.hi = 0x3096U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x309dU,.hi = 0x309fU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x30a1U,.hi = 0x30faU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x30fcU,.hi = 0x30ffU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3105U,.hi = 0x312fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3131U,.hi = 0x318eU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x31a0U,.hi = 0x31bfU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x31f0U,.hi = 0x31ffU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3400U,.hi = 0x4dbfU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x4e00U,.hi = 0x9ffcU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xa000U,.hi = 0xa48cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa4d0U,.hi = 0xa4fdU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa500U,.hi = 0xa60cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa610U,.hi = 0xa61fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa62aU,.hi = 0xa62bU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa640U,.hi = 0xa66eU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa67fU,.hi = 0xa69dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa6a0U,.hi = 0xa6e5U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xa717U,.hi = 0xa71fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa722U,.hi = 0xa788U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa78bU,.hi = 0xa7bfU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa7c2U,.hi = 0xa7caU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa7f5U,.hi = 0xa801U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa803U,.hi = 0xa805U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa807U,.hi = 0xa80aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa80cU,.hi = 0xa822U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xa840U,.hi = 0xa873U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa882U,.hi = 0xa8b3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa8f2U,.hi = 0xa8f7U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa8fbU,.hi = 0xa8fdU,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0xa8feU,.hi = 0xa90aU,.stride = 12U,}), ((encoding__utf8__Range16){.lo = 0xa90bU,.hi = 0xa925U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa930U,.hi = 0xa946U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa960U,.hi = 0xa97cU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xa984U,.hi = 0xa9b2U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa9cfU,.hi = 0xa9e0U,.stride = 17U,}), ((encoding__utf8__Range16){.lo = 0xa9e1U,.hi = 0xa9e4U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa9e6U,.hi = 0xa9efU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa9faU,.hi = 0xa9feU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xaa00U,.hi = 0xaa28U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xaa40U,.hi = 0xaa42U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xaa44U,.hi = 0xaa4bU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xaa60U,.hi = 0xaa76U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xaa7aU,.hi = 0xaa7eU,.stride = 4U,}), ((encoding__utf8__Range16){.lo = 0xaa7fU,.hi = 0xaaafU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xaab1U,.hi = 0xaab5U,.stride = 4U,}), ((encoding__utf8__Range16){.lo = 0xaab6U,.hi = 0xaab9U,.stride = 3U,}), ((encoding__utf8__Range16){.lo = 0xaabaU,.hi = 0xaabdU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xaac0U,.hi = 0xaac2U,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0xaadbU,.hi = 0xaaddU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xaae0U,.hi = 0xaaeaU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xaaf2U,.hi = 0xaaf4U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xab01U,.hi = 0xab06U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xab09U,.hi = 0xab0eU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xab11U,.hi = 0xab16U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xab20U,.hi = 0xab26U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xab28U,.hi = 0xab2eU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xab30U,.hi = 0xab5aU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xab5cU,.hi = 0xab69U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xab70U,.hi = 0xabe2U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xac00U,.hi = 0xd7a3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xd7b0U,.hi = 0xd7c6U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xd7cbU,.hi = 0xd7fbU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xf900U,.hi = 0xfa6dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfa70U,.hi = 0xfad9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfb00U,.hi = 0xfb06U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xfb13U,.hi = 0xfb17U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfb1dU,.hi = 0xfb1fU,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0xfb20U,.hi = 0xfb28U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfb2aU,.hi = 0xfb36U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfb38U,.hi = 0xfb3cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfb3eU,.hi = 0xfb40U,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0xfb41U,.hi = 0xfb43U,.stride = 2U,}), ((encoding__utf8__Range16){.lo = 0xfb44U,.hi = 0xfb46U,.stride = 2U,}),
		((encoding__utf8__Range16){.lo = 0xfb47U,.hi = 0xfbb1U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfbd3U,.hi = 0xfd3dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfd50U,.hi = 0xfd8fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfd92U,.hi = 0xfdc7U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfdf0U,.hi = 0xfdfbU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfe70U,.hi = 0xfe74U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xfe76U,.hi = 0xfefcU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xff21U,.hi = 0xff3aU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xff41U,.hi = 0xff5aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xff66U,.hi = 0xffbeU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xffc2U,.hi = 0xffc7U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xffcaU,.hi = 0xffcfU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xffd2U,.hi = 0xffd7U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xffdaU,.hi = 0xffdcU,.stride = 1U,})})),.r32 = new_array_from_c_array_noscan(227, 227, sizeof(encoding__utf8__Range32), _MOV((encoding__utf8__Range32[227]){
		((encoding__utf8__Range32){.lo = 0x10000U,.hi = 0x1000bU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1000dU,.hi = 0x10026U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10028U,.hi = 0x1003aU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1003cU,.hi = 0x1003dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1003fU,.hi = 0x1004dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10050U,.hi = 0x1005dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10080U,.hi = 0x100faU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10280U,.hi = 0x1029cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x102a0U,.hi = 0x102d0U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x10300U,.hi = 0x1031fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1032dU,.hi = 0x10340U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10342U,.hi = 0x10349U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10350U,.hi = 0x10375U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10380U,.hi = 0x1039dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x103a0U,.hi = 0x103c3U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x103c8U,.hi = 0x103cfU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10400U,.hi = 0x1049dU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x104b0U,.hi = 0x104d3U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x104d8U,.hi = 0x104fbU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10500U,.hi = 0x10527U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10530U,.hi = 0x10563U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10600U,.hi = 0x10736U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10740U,.hi = 0x10755U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10760U,.hi = 0x10767U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10800U,.hi = 0x10805U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x10808U,.hi = 0x1080aU,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x1080bU,.hi = 0x10835U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10837U,.hi = 0x10838U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1083cU,.hi = 0x1083fU,.stride = 3U,}), ((encoding__utf8__Range32){.lo = 0x10840U,.hi = 0x10855U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10860U,.hi = 0x10876U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10880U,.hi = 0x1089eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x108e0U,.hi = 0x108f2U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x108f4U,.hi = 0x108f5U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10900U,.hi = 0x10915U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10920U,.hi = 0x10939U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10980U,.hi = 0x109b7U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x109beU,.hi = 0x109bfU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10a00U,.hi = 0x10a10U,.stride = 16U,}), ((encoding__utf8__Range32){.lo = 0x10a11U,.hi = 0x10a13U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10a15U,.hi = 0x10a17U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x10a19U,.hi = 0x10a35U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10a60U,.hi = 0x10a7cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10a80U,.hi = 0x10a9cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10ac0U,.hi = 0x10ac7U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10ac9U,.hi = 0x10ae4U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10b00U,.hi = 0x10b35U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10b40U,.hi = 0x10b55U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10b60U,.hi = 0x10b72U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x10b80U,.hi = 0x10b91U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10c00U,.hi = 0x10c48U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10c80U,.hi = 0x10cb2U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10cc0U,.hi = 0x10cf2U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10d00U,.hi = 0x10d23U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10e80U,.hi = 0x10ea9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10eb0U,.hi = 0x10eb1U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10f00U,.hi = 0x10f1cU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x10f27U,.hi = 0x10f30U,.stride = 9U,}), ((encoding__utf8__Range32){.lo = 0x10f31U,.hi = 0x10f45U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10fb0U,.hi = 0x10fc4U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10fe0U,.hi = 0x10ff6U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11003U,.hi = 0x11037U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11083U,.hi = 0x110afU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x110d0U,.hi = 0x110e8U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11103U,.hi = 0x11126U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x11144U,.hi = 0x11147U,.stride = 3U,}), ((encoding__utf8__Range32){.lo = 0x11150U,.hi = 0x11172U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11176U,.hi = 0x11183U,.stride = 13U,}), ((encoding__utf8__Range32){.lo = 0x11184U,.hi = 0x111b2U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x111c1U,.hi = 0x111c4U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x111daU,.hi = 0x111dcU,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x11200U,.hi = 0x11211U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11213U,.hi = 0x1122bU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x11280U,.hi = 0x11286U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11288U,.hi = 0x1128aU,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x1128bU,.hi = 0x1128dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1128fU,.hi = 0x1129dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1129fU,.hi = 0x112a8U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x112b0U,.hi = 0x112deU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11305U,.hi = 0x1130cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1130fU,.hi = 0x11310U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x11313U,.hi = 0x11328U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1132aU,.hi = 0x11330U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11332U,.hi = 0x11333U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11335U,.hi = 0x11339U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1133dU,.hi = 0x11350U,.stride = 19U,}), ((encoding__utf8__Range32){.lo = 0x1135dU,.hi = 0x11361U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11400U,.hi = 0x11434U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11447U,.hi = 0x1144aU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1145fU,.hi = 0x11461U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11480U,.hi = 0x114afU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x114c4U,.hi = 0x114c5U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x114c7U,.hi = 0x11580U,.stride = 185U,}), ((encoding__utf8__Range32){.lo = 0x11581U,.hi = 0x115aeU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x115d8U,.hi = 0x115dbU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11600U,.hi = 0x1162fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11644U,.hi = 0x11680U,.stride = 60U,}),
		((encoding__utf8__Range32){.lo = 0x11681U,.hi = 0x116aaU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x116b8U,.hi = 0x11700U,.stride = 72U,}), ((encoding__utf8__Range32){.lo = 0x11701U,.hi = 0x1171aU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11800U,.hi = 0x1182bU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x118a0U,.hi = 0x118dfU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x118ffU,.hi = 0x11906U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11909U,.hi = 0x1190cU,.stride = 3U,}), ((encoding__utf8__Range32){.lo = 0x1190dU,.hi = 0x11913U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x11915U,.hi = 0x11916U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11918U,.hi = 0x1192fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1193fU,.hi = 0x11941U,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x119a0U,.hi = 0x119a7U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x119aaU,.hi = 0x119d0U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x119e1U,.hi = 0x119e3U,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x11a00U,.hi = 0x11a0bU,.stride = 11U,}), ((encoding__utf8__Range32){.lo = 0x11a0cU,.hi = 0x11a32U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x11a3aU,.hi = 0x11a50U,.stride = 22U,}), ((encoding__utf8__Range32){.lo = 0x11a5cU,.hi = 0x11a89U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11a9dU,.hi = 0x11ac0U,.stride = 35U,}), ((encoding__utf8__Range32){.lo = 0x11ac1U,.hi = 0x11af8U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11c00U,.hi = 0x11c08U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11c0aU,.hi = 0x11c2eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11c40U,.hi = 0x11c72U,.stride = 50U,}), ((encoding__utf8__Range32){.lo = 0x11c73U,.hi = 0x11c8fU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x11d00U,.hi = 0x11d06U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11d08U,.hi = 0x11d09U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11d0bU,.hi = 0x11d30U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11d46U,.hi = 0x11d60U,.stride = 26U,}), ((encoding__utf8__Range32){.lo = 0x11d61U,.hi = 0x11d65U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11d67U,.hi = 0x11d68U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11d6aU,.hi = 0x11d89U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11d98U,.hi = 0x11ee0U,.stride = 328U,}),
		((encoding__utf8__Range32){.lo = 0x11ee1U,.hi = 0x11ef2U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11fb0U,.hi = 0x12000U,.stride = 80U,}), ((encoding__utf8__Range32){.lo = 0x12001U,.hi = 0x12399U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x12480U,.hi = 0x12543U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x13000U,.hi = 0x1342eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x14400U,.hi = 0x14646U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16800U,.hi = 0x16a38U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16a40U,.hi = 0x16a5eU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x16ad0U,.hi = 0x16aedU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16b00U,.hi = 0x16b2fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16b40U,.hi = 0x16b43U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16b63U,.hi = 0x16b77U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16b7dU,.hi = 0x16b8fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16e40U,.hi = 0x16e7fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16f00U,.hi = 0x16f4aU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16f50U,.hi = 0x16f93U,.stride = 67U,}),
		((encoding__utf8__Range32){.lo = 0x16f94U,.hi = 0x16f9fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16fe0U,.hi = 0x16fe1U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16fe3U,.hi = 0x17000U,.stride = 29U,}), ((encoding__utf8__Range32){.lo = 0x17001U,.hi = 0x187f7U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x18800U,.hi = 0x18cd5U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x18d00U,.hi = 0x18d08U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1b000U,.hi = 0x1b11eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1b150U,.hi = 0x1b152U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1b164U,.hi = 0x1b167U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1b170U,.hi = 0x1b2fbU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1bc00U,.hi = 0x1bc6aU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1bc70U,.hi = 0x1bc7cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1bc80U,.hi = 0x1bc88U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1bc90U,.hi = 0x1bc99U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d400U,.hi = 0x1d454U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d456U,.hi = 0x1d49cU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1d49eU,.hi = 0x1d49fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d4a2U,.hi = 0x1d4a5U,.stride = 3U,}), ((encoding__utf8__Range32){.lo = 0x1d4a6U,.hi = 0x1d4a9U,.stride = 3U,}), ((encoding__utf8__Range32){.lo = 0x1d4aaU,.hi = 0x1d4acU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d4aeU,.hi = 0x1d4b9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d4bbU,.hi = 0x1d4bdU,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x1d4beU,.hi = 0x1d4c3U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d4c5U,.hi = 0x1d505U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1d507U,.hi = 0x1d50aU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d50dU,.hi = 0x1d514U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d516U,.hi = 0x1d51cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d51eU,.hi = 0x1d539U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d53bU,.hi = 0x1d53eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d540U,.hi = 0x1d544U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d546U,.hi = 0x1d54aU,.stride = 4U,}), ((encoding__utf8__Range32){.lo = 0x1d54bU,.hi = 0x1d550U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1d552U,.hi = 0x1d6a5U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d6a8U,.hi = 0x1d6c0U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d6c2U,.hi = 0x1d6daU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d6dcU,.hi = 0x1d6faU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d6fcU,.hi = 0x1d714U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d716U,.hi = 0x1d734U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d736U,.hi = 0x1d74eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d750U,.hi = 0x1d76eU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1d770U,.hi = 0x1d788U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d78aU,.hi = 0x1d7a8U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d7aaU,.hi = 0x1d7c2U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d7c4U,.hi = 0x1d7cbU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1e100U,.hi = 0x1e12cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1e137U,.hi = 0x1e13dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1e14eU,.hi = 0x1e2c0U,.stride = 370U,}), ((encoding__utf8__Range32){.lo = 0x1e2c1U,.hi = 0x1e2ebU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1e800U,.hi = 0x1e8c4U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1e900U,.hi = 0x1e943U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1e94bU,.hi = 0x1ee00U,.stride = 1205U,}), ((encoding__utf8__Range32){.lo = 0x1ee01U,.hi = 0x1ee03U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee05U,.hi = 0x1ee1fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee21U,.hi = 0x1ee22U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee24U,.hi = 0x1ee27U,.stride = 3U,}), ((encoding__utf8__Range32){.lo = 0x1ee29U,.hi = 0x1ee32U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1ee34U,.hi = 0x1ee37U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee39U,.hi = 0x1ee3bU,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x1ee42U,.hi = 0x1ee47U,.stride = 5U,}), ((encoding__utf8__Range32){.lo = 0x1ee49U,.hi = 0x1ee4dU,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x1ee4eU,.hi = 0x1ee4fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee51U,.hi = 0x1ee52U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee54U,.hi = 0x1ee57U,.stride = 3U,}), ((encoding__utf8__Range32){.lo = 0x1ee59U,.hi = 0x1ee61U,.stride = 2U,}),
		((encoding__utf8__Range32){.lo = 0x1ee62U,.hi = 0x1ee64U,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x1ee67U,.hi = 0x1ee6aU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee6cU,.hi = 0x1ee72U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee74U,.hi = 0x1ee77U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee79U,.hi = 0x1ee7cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee7eU,.hi = 0x1ee80U,.stride = 2U,}), ((encoding__utf8__Range32){.lo = 0x1ee81U,.hi = 0x1ee89U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ee8bU,.hi = 0x1ee9bU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1eea1U,.hi = 0x1eea3U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1eea5U,.hi = 0x1eea9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1eeabU,.hi = 0x1eebbU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x20000U,.hi = 0x2a6ddU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x2a700U,.hi = 0x2b734U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x2b740U,.hi = 0x2b81dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x2b820U,.hi = 0x2cea1U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x2ceb0U,.hi = 0x2ebe0U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x2f800U,.hi = 0x2fa1dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x30000U,.hi = 0x3134aU,.stride = 1U,})})),.latin_offset = 6,});
	_const_encoding__utf8__white_space_table = ((encoding__utf8__RangeTable){.r16 = new_array_from_c_array_noscan(7, 7, sizeof(encoding__utf8__Range16), _MOV((encoding__utf8__Range16[7]){((encoding__utf8__Range16){.lo = 0x0009U,.hi = 0x000dU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0020U,.hi = 0x0085U,.stride = 101U,}), ((encoding__utf8__Range16){.lo = 0x00a0U,.hi = 0x1680U,.stride = 5600U,}), ((encoding__utf8__Range16){.lo = 0x2000U,.hi = 0x200aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2028U,.hi = 0x2029U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x202fU,.hi = 0x205fU,.stride = 48U,}), ((encoding__utf8__Range16){.lo = 0x3000U,.hi = 0x3000U,.stride = 1U,})})),.r32 = __new_array_with_default_noscan(0, 0, sizeof(encoding__utf8__Range32), 0),.latin_offset = 2,});
	_const_encoding__utf8__number_table = ((encoding__utf8__RangeTable){.r16 = new_array_from_c_array_noscan(66, 66, sizeof(encoding__utf8__Range16), _MOV((encoding__utf8__Range16[66]){
		((encoding__utf8__Range16){.lo = 0x0030U,.hi = 0x0039U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x00b2U,.hi = 0x00b3U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x00b9U,.hi = 0x00bcU,.stride = 3U,}), ((encoding__utf8__Range16){.lo = 0x00bdU,.hi = 0x00beU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0660U,.hi = 0x0669U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x06f0U,.hi = 0x06f9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x07c0U,.hi = 0x07c9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0966U,.hi = 0x096fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x09e6U,.hi = 0x09efU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x09f4U,.hi = 0x09f9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0a66U,.hi = 0x0a6fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0ae6U,.hi = 0x0aefU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b66U,.hi = 0x0b6fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0b72U,.hi = 0x0b77U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0be6U,.hi = 0x0bf2U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c66U,.hi = 0x0c6fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0c78U,.hi = 0x0c7eU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x0ce6U,.hi = 0x0cefU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d58U,.hi = 0x0d5eU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0d66U,.hi = 0x0d78U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0de6U,.hi = 0x0defU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0e50U,.hi = 0x0e59U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0ed0U,.hi = 0x0ed9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x0f20U,.hi = 0x0f33U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1040U,.hi = 0x1049U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1090U,.hi = 0x1099U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1369U,.hi = 0x137cU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x16eeU,.hi = 0x16f0U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x17e0U,.hi = 0x17e9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x17f0U,.hi = 0x17f9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1810U,.hi = 0x1819U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1946U,.hi = 0x194fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x19d0U,.hi = 0x19daU,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x1a80U,.hi = 0x1a89U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1a90U,.hi = 0x1a99U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1b50U,.hi = 0x1b59U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1bb0U,.hi = 0x1bb9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1c40U,.hi = 0x1c49U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x1c50U,.hi = 0x1c59U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2070U,.hi = 0x2074U,.stride = 4U,}), ((encoding__utf8__Range16){.lo = 0x2075U,.hi = 0x2079U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x2080U,.hi = 0x2089U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2150U,.hi = 0x2182U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2185U,.hi = 0x2189U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2460U,.hi = 0x249bU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x24eaU,.hi = 0x24ffU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2776U,.hi = 0x2793U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x2cfdU,.hi = 0x3007U,.stride = 778U,}), ((encoding__utf8__Range16){.lo = 0x3021U,.hi = 0x3029U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0x3038U,.hi = 0x303aU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3192U,.hi = 0x3195U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3220U,.hi = 0x3229U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3248U,.hi = 0x324fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3251U,.hi = 0x325fU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x3280U,.hi = 0x3289U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0x32b1U,.hi = 0x32bfU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa620U,.hi = 0xa629U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xa6e6U,.hi = 0xa6efU,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa830U,.hi = 0xa835U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa8d0U,.hi = 0xa8d9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa900U,.hi = 0xa909U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa9d0U,.hi = 0xa9d9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xa9f0U,.hi = 0xa9f9U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xaa50U,.hi = 0xaa59U,.stride = 1U,}), ((encoding__utf8__Range16){.lo = 0xabf0U,.hi = 0xabf9U,.stride = 1U,}),
		((encoding__utf8__Range16){.lo = 0xff10U,.hi = 0xff19U,.stride = 1U,})})),.r32 = new_array_from_c_array_noscan(65, 65, sizeof(encoding__utf8__Range32), _MOV((encoding__utf8__Range32[65]){
		((encoding__utf8__Range32){.lo = 0x10107U,.hi = 0x10133U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10140U,.hi = 0x10178U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1018aU,.hi = 0x1018bU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x102e1U,.hi = 0x102fbU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10320U,.hi = 0x10323U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10341U,.hi = 0x1034aU,.stride = 9U,}), ((encoding__utf8__Range32){.lo = 0x103d1U,.hi = 0x103d5U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x104a0U,.hi = 0x104a9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10858U,.hi = 0x1085fU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x10879U,.hi = 0x1087fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x108a7U,.hi = 0x108afU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x108fbU,.hi = 0x108ffU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10916U,.hi = 0x1091bU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x109bcU,.hi = 0x109bdU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x109c0U,.hi = 0x109cfU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x109d2U,.hi = 0x109ffU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10a40U,.hi = 0x10a48U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x10a7dU,.hi = 0x10a7eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10a9dU,.hi = 0x10a9fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10aebU,.hi = 0x10aefU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10b58U,.hi = 0x10b5fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10b78U,.hi = 0x10b7fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10ba9U,.hi = 0x10bafU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10cfaU,.hi = 0x10cffU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10d30U,.hi = 0x10d39U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x10e60U,.hi = 0x10e7eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10f1dU,.hi = 0x10f26U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10f51U,.hi = 0x10f54U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x10fc5U,.hi = 0x10fcbU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11052U,.hi = 0x1106fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x110f0U,.hi = 0x110f9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11136U,.hi = 0x1113fU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x111d0U,.hi = 0x111d9U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x111e1U,.hi = 0x111f4U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x112f0U,.hi = 0x112f9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11450U,.hi = 0x11459U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x114d0U,.hi = 0x114d9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11650U,.hi = 0x11659U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x116c0U,.hi = 0x116c9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11730U,.hi = 0x1173bU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x118e0U,.hi = 0x118f2U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x11950U,.hi = 0x11959U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11c50U,.hi = 0x11c6cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11d50U,.hi = 0x11d59U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11da0U,.hi = 0x11da9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x11fc0U,.hi = 0x11fd4U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x12400U,.hi = 0x1246eU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16a60U,.hi = 0x16a69U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16b50U,.hi = 0x16b59U,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x16b5bU,.hi = 0x16b61U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x16e80U,.hi = 0x16e96U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d2e0U,.hi = 0x1d2f3U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d360U,.hi = 0x1d378U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1d7ceU,.hi = 0x1d7ffU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1e140U,.hi = 0x1e149U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1e2f0U,.hi = 0x1e2f9U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1e8c7U,.hi = 0x1e8cfU,.stride = 1U,}),
		((encoding__utf8__Range32){.lo = 0x1e950U,.hi = 0x1e959U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ec71U,.hi = 0x1ecabU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ecadU,.hi = 0x1ecafU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ecb1U,.hi = 0x1ecb4U,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ed01U,.hi = 0x1ed2dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1ed2fU,.hi = 0x1ed3dU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1f100U,.hi = 0x1f10cU,.stride = 1U,}), ((encoding__utf8__Range32){.lo = 0x1fbf0U,.hi = 0x1fbf9U,.stride = 1U,})})),.latin_offset = 4,});
	_const_encoding__utf8__unicode_punct_western = new_array_from_c_array_noscan(29, 29, sizeof(int), _MOV((int[29]){
		0x0021, 0x0022, 0x0027, 0x002A, 0x002C, 0x002E, 0x002F, 0x003A, 0x003B,
		0x003F, 0x00A1, 0x00A7, 0x00B6, 0x00B7, 0x00BF, 0x037E, 0x0387,
		0x055A, 0x055B, 0x055C, 0x055D, 0x055E, 0x055F, 0x0589, 0x05C0,
		0x05C3, 0x05C6, 0x05F3, 0x05F4}));
	_const_encoding__utf8__unicode_punct = new_array_from_c_array_noscan(588, 588, sizeof(int), _MOV((int[588]){
		0x0021, 0x0022, 0x0023, 0x0025, 0x0026, 0x0027, 0x002A, 0x002C, 0x002E,
		0x002F, 0x003A, 0x003B, 0x003F, 0x0040, 0x005C, 0x00A1, 0x00A7,
		0x00B6, 0x00B7, 0x00BF, 0x037E, 0x0387, 0x055A, 0x055B, 0x055C,
		0x055D, 0x055E, 0x055F, 0x0589, 0x05C0, 0x05C3, 0x05C6, 0x05F3,
		0x05F4, 0x0609, 0x060A, 0x060C, 0x060D, 0x061B, 0x061E, 0x061F,
		0x066A, 0x066B, 0x066C, 0x066D, 0x06D4, 0x0700, 0x0701, 0x0702,
		0x0703, 0x0704, 0x0705, 0x0706, 0x0707, 0x0708, 0x0709, 0x070A,
		0x070B, 0x070C, 0x070D, 0x07F7, 0x07F8, 0x07F9, 0x0830, 0x0831,
		0x0832, 0x0833, 0x0834, 0x0835, 0x0836, 0x0837, 0x0838, 0x0839,
		0x083A, 0x083B, 0x083C, 0x083D, 0x083E, 0x085E, 0x0964, 0x0965,
		0x0970, 0x09FD, 0x0A76, 0x0AF0, 0x0C77, 0x0C84, 0x0DF4, 0x0E4F,
		0x0E5A, 0x0E5B, 0x0F04, 0x0F05, 0x0F06, 0x0F07, 0x0F08, 0x0F09,
		0x0F0A, 0x0F0B, 0x0F0C, 0x0F0D, 0x0F0E, 0x0F0F, 0x0F10, 0x0F11,
		0x0F12, 0x0F14, 0x0F85, 0x0FD0, 0x0FD1, 0x0FD2, 0x0FD3, 0x0FD4,
		0x0FD9, 0x0FDA, 0x104A, 0x104B, 0x104C, 0x104D, 0x104E, 0x104F,
		0x10FB, 0x1360, 0x1361, 0x1362, 0x1363, 0x1364, 0x1365, 0x1366,
		0x1367, 0x1368, 0x166E, 0x16EB, 0x16EC, 0x16ED, 0x1735, 0x1736,
		0x17D4, 0x17D5, 0x17D6, 0x17D8, 0x17D9, 0x17DA, 0x1800, 0x1801,
		0x1802, 0x1803, 0x1804, 0x1805, 0x1807, 0x1808, 0x1809, 0x180A,
		0x1944, 0x1945, 0x1A1E, 0x1A1F, 0x1AA0, 0x1AA1, 0x1AA2, 0x1AA3,
		0x1AA4, 0x1AA5, 0x1AA6, 0x1AA8, 0x1AA9, 0x1AAA, 0x1AAB, 0x1AAC,
		0x1AAD, 0x1B5A, 0x1B5B, 0x1B5C, 0x1B5D, 0x1B5E, 0x1B5F, 0x1B60,
		0x1BFC, 0x1BFD, 0x1BFE, 0x1BFF, 0x1C3B, 0x1C3C, 0x1C3D, 0x1C3E,
		0x1C3F, 0x1C7E, 0x1C7F, 0x1CC0, 0x1CC1, 0x1CC2, 0x1CC3, 0x1CC4,
		0x1CC5, 0x1CC6, 0x1CC7, 0x1CD3, 0x2016, 0x2017, 0x2020, 0x2021,
		0x2022, 0x2023, 0x2024, 0x2025, 0x2026, 0x2027, 0x2030, 0x2031,
		0x2032, 0x2033, 0x2034, 0x2035, 0x2036, 0x2037, 0x2038, 0x203B,
		0x203C, 0x203D, 0x203E, 0x2041, 0x2042, 0x2043, 0x2047, 0x2048,
		0x2049, 0x204A, 0x204B, 0x204C, 0x204D, 0x204E, 0x204F, 0x2050,
		0x2051, 0x2053, 0x2055, 0x2056, 0x2057, 0x2058, 0x2059, 0x205A,
		0x205B, 0x205C, 0x205D, 0x205E, 0x2CF9, 0x2CFA, 0x2CFB, 0x2CFC,
		0x2CFE, 0x2CFF, 0x2D70, 0x2E00, 0x2E01, 0x2E06, 0x2E07, 0x2E08,
		0x2E0B, 0x2E0E, 0x2E0F, 0x2E10, 0x2E11, 0x2E12, 0x2E13, 0x2E14,
		0x2E15, 0x2E16, 0x2E18, 0x2E19, 0x2E1B, 0x2E1E, 0x2E1F, 0x2E2A,
		0x2E2B, 0x2E2C, 0x2E2D, 0x2E2E, 0x2E30, 0x2E31, 0x2E32, 0x2E33,
		0x2E34, 0x2E35, 0x2E36, 0x2E37, 0x2E38, 0x2E39, 0x2E3C, 0x2E3D,
		0x2E3E, 0x2E3F, 0x2E41, 0x2E43, 0x2E44, 0x2E45, 0x2E46, 0x2E47,
		0x2E48, 0x2E49, 0x2E4A, 0x2E4B, 0x2E4C, 0x2E4D, 0x2E4E, 0x2E4F,
		0x3001, 0x3002, 0x3003, 0x303D, 0x30FB, 0xA4FE, 0xA4FF, 0xA60D,
		0xA60E, 0xA60F, 0xA673, 0xA67E, 0xA6F2, 0xA6F3, 0xA6F4, 0xA6F5,
		0xA6F6, 0xA6F7, 0xA874, 0xA875, 0xA876, 0xA877, 0xA8CE, 0xA8CF,
		0xA8F8, 0xA8F9, 0xA8FA, 0xA8FC, 0xA92E, 0xA92F, 0xA95F, 0xA9C1,
		0xA9C2, 0xA9C3, 0xA9C4, 0xA9C5, 0xA9C6, 0xA9C7, 0xA9C8, 0xA9C9,
		0xA9CA, 0xA9CB, 0xA9CC, 0xA9CD, 0xA9DE, 0xA9DF, 0xAA5C, 0xAA5D,
		0xAA5E, 0xAA5F, 0xAADE, 0xAADF, 0xAAF0, 0xAAF1, 0xABEB, 0xFE10,
		0xFE11, 0xFE12, 0xFE13, 0xFE14, 0xFE15, 0xFE16, 0xFE19, 0xFE30,
		0xFE45, 0xFE46, 0xFE49, 0xFE4A, 0xFE4B, 0xFE4C, 0xFE50, 0xFE51,
		0xFE52, 0xFE54, 0xFE55, 0xFE56, 0xFE57, 0xFE5F, 0xFE60, 0xFE61,
		0xFE68, 0xFE6A, 0xFE6B, 0xFF01, 0xFF02, 0xFF03, 0xFF05, 0xFF06,
		0xFF07, 0xFF0A, 0xFF0C, 0xFF0E, 0xFF0F, 0xFF1A, 0xFF1B, 0xFF1F,
		0xFF20, 0xFF3C, 0xFF61, 0xFF64, 0xFF65, 0x10100, 0x10101, 0x10102,
		0x1039F, 0x103D0, 0x1056F, 0x10857, 0x1091F, 0x1093F, 0x10A50, 0x10A51,
		0x10A52, 0x10A53, 0x10A54, 0x10A55, 0x10A56, 0x10A57, 0x10A58, 0x10A7F,
		0x10AF0, 0x10AF1, 0x10AF2, 0x10AF3, 0x10AF4, 0x10AF5, 0x10AF6, 0x10B39,
		0x10B3A, 0x10B3B, 0x10B3C, 0x10B3D, 0x10B3E, 0x10B3F, 0x10B99, 0x10B9A,
		0x10B9B, 0x10B9C, 0x10F55, 0x10F56, 0x10F57, 0x10F58, 0x10F59, 0x11047,
		0x11048, 0x11049, 0x1104A, 0x1104B, 0x1104C, 0x1104D, 0x110BB, 0x110BC,
		0x110BE, 0x110BF, 0x110C0, 0x110C1, 0x11140, 0x11141, 0x11142, 0x11143,
		0x11174, 0x11175, 0x111C5, 0x111C6, 0x111C7, 0x111C8, 0x111CD, 0x111DB,
		0x111DD, 0x111DE, 0x111DF, 0x11238, 0x11239, 0x1123A, 0x1123B, 0x1123C,
		0x1123D, 0x112A9, 0x1144B, 0x1144C, 0x1144D, 0x1144E, 0x1144F, 0x1145B,
		0x1145D, 0x114C6, 0x115C1, 0x115C2, 0x115C3, 0x115C4, 0x115C5, 0x115C6,
		0x115C7, 0x115C8, 0x115C9, 0x115CA, 0x115CB, 0x115CC, 0x115CD, 0x115CE,
		0x115CF, 0x115D0, 0x115D1, 0x115D2, 0x115D3, 0x115D4, 0x115D5, 0x115D6,
		0x115D7, 0x11641, 0x11642, 0x11643, 0x11660, 0x11661, 0x11662, 0x11663,
		0x11664, 0x11665, 0x11666, 0x11667, 0x11668, 0x11669, 0x1166A, 0x1166B,
		0x1166C, 0x1173C, 0x1173D, 0x1173E, 0x1183B, 0x119E2, 0x11A3F, 0x11A40,
		0x11A41, 0x11A42, 0x11A43, 0x11A44, 0x11A45, 0x11A46, 0x11A9A, 0x11A9B,
		0x11A9C, 0x11A9E, 0x11A9F, 0x11AA0, 0x11AA1, 0x11AA2, 0x11C41, 0x11C42,
		0x11C43, 0x11C44, 0x11C45, 0x11C70, 0x11C71, 0x11EF7, 0x11EF8, 0x11FFF,
		0x12470, 0x12471, 0x12472, 0x12473, 0x12474, 0x16A6E, 0x16A6F, 0x16AF5,
		0x16B37, 0x16B38, 0x16B39, 0x16B3A, 0x16B3B, 0x16B44, 0x16E97, 0x16E98,
		0x16E99, 0x16E9A, 0x16FE2, 0x1BC9F, 0x1DA87, 0x1DA88, 0x1DA89, 0x1DA8A,
		0x1DA8B, 0x1E95E, 0x1E95F}));
	// Initializations of consts for module rand.constants
	_const_rand__constants__ieee754_mantissa_f32_mask = (u32)(((((u32)(1U)) << 23U)) - 1U);
	_const_rand__constants__reciprocal_2_23rd = (f64)(((f64)(1.0)) / ((f64)((((u32)(1U)) << 23U))));
	_const_rand__constants__reciprocal_2_52nd = (f64)(((f64)(1.0)) / ((f64)((((u64)(1U)) << 52U))));
	// Initializations of consts for module os
	_const_os__fslash_str = _SLIT("/");
	_const_os__dot_dot = _SLIT("..");
	_const_os__empty_str = _SLIT("");
	_const_os__dot_str = _SLIT(".");
	_const_os__path_separator = _SLIT("\\");
	_const_os__path_delimiter = _SLIT(";");
	_const_os__args = os__init_os_args_wide(___argc, (byteptr*)___argv);
	_const_os__wd_at_startup = os__getwd();
	_const_os__executable_suffixes = new_array_from_c_array(4, 4, sizeof(string), _MOV((string[4]){_SLIT(".exe"), _SLIT(".bat"), _SLIT(".cmd"), _SLIT("")}));
	g_main_thread_id = ((u64)(GetCurrentThreadId())); // 3global
	// Initializations of consts for module x.json2
	_const_x__json2__default_encoder = ((x__json2__Encoder){.newline = 0,.newline_spaces_count = 0,.escape_unicode = true,});
	_const_x__json2__null_in_bytes = string_bytes(_SLIT("null"));
	_const_x__json2__true_in_bytes = string_bytes(_SLIT("true"));
	_const_x__json2__false_in_bytes = string_bytes(_SLIT("false"));
	_const_x__json2__zero_in_bytes = new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)('0'))}));
	_const_x__json2__comma_bytes = new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)(','))}));
	_const_x__json2__colon_bytes = new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)(':'))}));
	_const_x__json2__space_bytes = new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)(' '))}));
	_const_x__json2__unicode_escape_chars = new_array_from_c_array_noscan(2, 2, sizeof(u8), _MOV((u8[2]){((u8)('\\')), 'u'}));
	_const_x__json2__quote_bytes = new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)('"'))}));
	_const_x__json2__escaped_chars = new_array_from_c_array(5, 5, sizeof(Array_u8), _MOV((Array_u8[5]){string_bytes((_SLIT("\\b"))), string_bytes((_SLIT("\\f"))), string_bytes((_SLIT("\\n"))), string_bytes((_SLIT("\\r"))), string_bytes((_SLIT("\\t")))}));
	_const_x__json2__curly_open = new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)('{'))}));
	_const_x__json2__curly_close = new_array_from_c_array_noscan(1, 1, sizeof(u8), _MOV((u8[1]){((u8)('}'))}));
	_const_x__json2__char_list = new_array_from_c_array_noscan(6, 6, sizeof(rune), _MOV((rune[6]){'{', '}', '[', ']', ',', ':'}));
	_const_x__json2__newlines = new_array_from_c_array_noscan(3, 3, sizeof(rune), _MOV((rune[3]){'\r', '\n', '\t'}));
	_const_x__json2__important_escapable_chars = new_array_from_c_array_noscan(5, 5, sizeof(rune), _MOV((rune[5]){'\b', '\f', '\n', '\r', '\t'}));
	_const_x__json2__valid_unicode_escapes = new_array_from_c_array_noscan(8, 8, sizeof(rune), _MOV((rune[8]){'b', 'f', 'n', 'r', 't', '\\', '"', '/'}));
	_const_x__json2__unicode_transform_escapes = new_map_init_noscan_key_value(&map_hash_int_4, &map_eq_int_4, &map_clone_int_4, &map_free_nop, 8, sizeof(int), sizeof(rune),
		_MOV((int[8]){
			98, 
			102, 
			110, 
			114, 
			116, 
			92, 
			34, 
			47, 
		}),
		_MOV((rune[8]){
			'\b', 
			'\f', 
			'\n', 
			'\r', 
			'\t', 
			'\\', 
			'"', 
			'/', 
		})
	)

;
	_const_x__json2__exp_signs = new_array_from_c_array_noscan(2, 2, sizeof(u8), _MOV((u8[2]){((u8)('-')), '+'}));
	_const_x__json2__null = ((x__json2__Null){.is_null = true,});
	// Initializations of consts for module rand
	_const_rand__ulid_encoding = _SLIT("0123456789ABCDEFGHJKMNPQRSTVWXYZ");
	_const_rand__english_letters = _SLIT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
	_const_rand__hex_chars = _SLIT("abcdef0123456789");
	_const_rand__ascii_chars = _SLIT("!\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\^_`abcdefghijklmnopqrstuvwxyz{|}~");
	_const_rand__clock_seq_hi_and_reserved_valid_values = new_array_from_c_array_noscan(4, 4, sizeof(rune), _MOV((rune[4]){'8', '9', 'a', 'b'}));
	default_rng = *(rand__PRNG**)&((rand__PRNG*[]){0}[0]); // global
	// Calling fn init() for module rand
	rand__init();
	// Initializations of consts for module log
	default_logger = *(log__Logger**)&((log__Logger*[]){0}[0]); // global
	// Calling fn init() for module log
	log__init();
	// Initializations of consts for module net
	_const_net__crlf = _SLIT("\r\n");
	_const_net__aoffset = /*OffsetOf*/ (u32)(__offsetof(net__Addr, addr));
	_const_net__no_deadline = ((time__Time){.year = 0,.month = 0,.day = 0,.hour = 0,.minute = 0,.second = 0,.nanosecond = 0,.__v_unix = 0,.is_local = 0,.microsecond = 0,});
	_const_net__no_timeout = ((time__Duration)(0));
	_const_net__is_windows = true;
	_const_net__fionbio = FIONBIO;
	_const_net__opts_bool = new_array_from_c_array_noscan(6, 6, sizeof(net__SocketOption), _MOV((net__SocketOption[6]){net__SocketOption__broadcast, net__SocketOption__debug, net__SocketOption__dont_route, net__SocketOption__error, net__SocketOption__keep_alive, net__SocketOption__oob_inline}));
	_const_net__opts_int = new_array_from_c_array_noscan(6, 6, sizeof(net__SocketOption), _MOV((net__SocketOption[6]){net__SocketOption__receive_buf_size, net__SocketOption__receive_low_size, net__SocketOption__receive_timeout, net__SocketOption__send_buf_size, net__SocketOption__send_low_size, net__SocketOption__send_timeout}));
	_const_net__opts_can_set = new_array_from_c_array_noscan(13, 13, sizeof(net__SocketOption), _MOV((net__SocketOption[13]){
		net__SocketOption__broadcast, net__SocketOption__debug, net__SocketOption__dont_route, net__SocketOption__keep_alive, net__SocketOption__linger, net__SocketOption__oob_inline, net__SocketOption__receive_buf_size, net__SocketOption__receive_low_size, net__SocketOption__receive_timeout,
		net__SocketOption__send_buf_size, net__SocketOption__send_low_size, net__SocketOption__send_timeout, net__SocketOption__ipv6_only}));
	_const_net__infinite_timeout = _const_time__infinite;
	_const_net__err_new_socket_failed = error_with_code(_SLIT("net: new_socket failed to create socket"), (int_literal)(_const_net__errors_base + 1));
	_const_net__err_option_not_settable = error_with_code(_SLIT("net: set_option_xxx option not settable"), (int_literal)(_const_net__errors_base + 2));
	_const_net__err_option_wrong_type = error_with_code(_SLIT("net: set_option_xxx option wrong type"), (int_literal)(_const_net__errors_base + 3));
	_const_net__err_port_out_of_range = error_with_code(_SLIT("net: port out of range"), (int_literal)(_const_net__errors_base + 5));
	_const_net__err_no_udp_remote = error_with_code(_SLIT("net: no udp remote"), (int_literal)(_const_net__errors_base + 6));
	_const_net__err_connect_failed = error_with_code(_SLIT("net: connect failed"), (int_literal)(_const_net__errors_base + 7));
	_const_net__err_connect_timed_out = error_with_code(_SLIT("net: connect timed out"), (int_literal)(_const_net__errors_base + 8));
	_const_net__err_timed_out = error_with_code(_SLIT("net: op timed out"), (int_literal)(_const_net__errors_base + 9));
	_const_net__err_connection_refused = error_with_code(_SLIT("net: connection refused"), (int_literal)(_const_net__errors_base + 10));
	_const_net__tcp_default_read_timeout = 30 * _const_time__second;
	_const_net__tcp_default_write_timeout = 30 * _const_time__second;
	_const_net__connect_timeout = 5 * _const_time__second;
	_const_net__udp_default_read_timeout = _const_time__second / 10;
	_const_net__udp_default_write_timeout = _const_time__second / 10;
	// Calling fn init() for module net
	net__init();
	// Initializations of consts for module net.mbedtls
	_const_net__mbedtls__ctr_drbg = ((mbedtls_ctr_drbg_context){EMPTY_STRUCT_INITIALIZATION});
	_const_net__mbedtls__entropy = ((mbedtls_entropy_context){EMPTY_STRUCT_INITIALIZATION});
	// Calling fn init() for module net.mbedtls
	net__mbedtls__init();
	// Initializations of consts for module net.http
	_const_net__http__content_type_default = _SLIT("text/plain");
	_const_net__http__common_header_map = new_map_init_noscan_value(&map_hash_string, &map_eq_string, &map_clone_string, &map_free_string, 101, sizeof(string), sizeof(net__http__CommonHeader),
		_MOV((string[101]){
			_SLIT("accept"), 
			_SLIT("accept-ch"), 
			_SLIT("accept-charset"), 
			_SLIT("accept-ch-lifetime"), 
			_SLIT("accept-encoding"), 
			_SLIT("accept-language"), 
			_SLIT("accept-patch"), 
			_SLIT("accept-post"), 
			_SLIT("accept-ranges"), 
			_SLIT("access-control-allow-credentials"), 
			_SLIT("access-control-allow-headers"), 
			_SLIT("access-control-allow-methods"), 
			_SLIT("access-control-allow-origin"), 
			_SLIT("access-control-expose-headers"), 
			_SLIT("access-control-max-age"), 
			_SLIT("access-control-request-headers"), 
			_SLIT("access-control-request-method"), 
			_SLIT("age"), 
			_SLIT("allow"), 
			_SLIT("alt-svc"), 
			_SLIT("authorization"), 
			_SLIT("cache-control"), 
			_SLIT("clear-site-data"), 
			_SLIT("connection"), 
			_SLIT("content-disposition"), 
			_SLIT("content-encoding"), 
			_SLIT("content-language"), 
			_SLIT("content-length"), 
			_SLIT("content-location"), 
			_SLIT("content-range"), 
			_SLIT("content-security-policy"), 
			_SLIT("content-security-policy-report-only"), 
			_SLIT("content-type"), 
			_SLIT("cookie"), 
			_SLIT("cross-origin-embedder-policy"), 
			_SLIT("cross-origin-opener-policy"), 
			_SLIT("cross-origin-resource-policy"), 
			_SLIT("date"), 
			_SLIT("device-memory"), 
			_SLIT("digest"), 
			_SLIT("dnt"), 
			_SLIT("early-data"), 
			_SLIT("etag"), 
			_SLIT("expect"), 
			_SLIT("expect-ct"), 
			_SLIT("expires"), 
			_SLIT("feature-policy"), 
			_SLIT("forwarded"), 
			_SLIT("from"), 
			_SLIT("host"), 
			_SLIT("if-match"), 
			_SLIT("if-modified-since"), 
			_SLIT("if-none-match"), 
			_SLIT("if-range"), 
			_SLIT("if-unmodified-since"), 
			_SLIT("index"), 
			_SLIT("keep-alive"), 
			_SLIT("large-allocation"), 
			_SLIT("last-modified"), 
			_SLIT("link"), 
			_SLIT("location"), 
			_SLIT("nel"), 
			_SLIT("origin"), 
			_SLIT("pragma"), 
			_SLIT("proxy-authenticate"), 
			_SLIT("proxy-authorization"), 
			_SLIT("range"), 
			_SLIT("referer"), 
			_SLIT("referrer-policy"), 
			_SLIT("retry-after"), 
			_SLIT("save-data"), 
			_SLIT("sec-fetch-dest"), 
			_SLIT("sec-fetch-mode"), 
			_SLIT("sec-fetch-site"), 
			_SLIT("sec-fetch-user"), 
			_SLIT("sec-websocket-accept"), 
			_SLIT("server"), 
			_SLIT("server-timing"), 
			_SLIT("set-cookie"), 
			_SLIT("sourcemap"), 
			_SLIT("strict-transport-security"), 
			_SLIT("te"), 
			_SLIT("timing-allow-origin"), 
			_SLIT("tk"), 
			_SLIT("trailer"), 
			_SLIT("transfer-encoding"), 
			_SLIT("upgrade"), 
			_SLIT("upgrade-insecure-requests"), 
			_SLIT("user-agent"), 
			_SLIT("vary"), 
			_SLIT("via"), 
			_SLIT("want-digest"), 
			_SLIT("warning"), 
			_SLIT("www-authenticate"), 
			_SLIT("x-content-type-options"), 
			_SLIT("x-dns-prefetch-control"), 
			_SLIT("x-forwarded-for"), 
			_SLIT("x-forwarded-host"), 
			_SLIT("x-forwarded-proto"), 
			_SLIT("x-frame-options"), 
			_SLIT("x-xss-protection"), 
		}),
		_MOV((net__http__CommonHeader[101]){
			net__http__CommonHeader__accept, 
			net__http__CommonHeader__accept_ch, 
			net__http__CommonHeader__accept_charset, 
			net__http__CommonHeader__accept_ch_lifetime, 
			net__http__CommonHeader__accept_encoding, 
			net__http__CommonHeader__accept_language, 
			net__http__CommonHeader__accept_patch, 
			net__http__CommonHeader__accept_post, 
			net__http__CommonHeader__accept_ranges, 
			net__http__CommonHeader__access_control_allow_credentials, 
			net__http__CommonHeader__access_control_allow_headers, 
			net__http__CommonHeader__access_control_allow_methods, 
			net__http__CommonHeader__access_control_allow_origin, 
			net__http__CommonHeader__access_control_expose_headers, 
			net__http__CommonHeader__access_control_max_age, 
			net__http__CommonHeader__access_control_request_headers, 
			net__http__CommonHeader__access_control_request_method, 
			net__http__CommonHeader__age, 
			net__http__CommonHeader__allow, 
			net__http__CommonHeader__alt_svc, 
			net__http__CommonHeader__authorization, 
			net__http__CommonHeader__cache_control, 
			net__http__CommonHeader__clear_site_data, 
			net__http__CommonHeader__connection, 
			net__http__CommonHeader__content_disposition, 
			net__http__CommonHeader__content_encoding, 
			net__http__CommonHeader__content_language, 
			net__http__CommonHeader__content_length, 
			net__http__CommonHeader__content_location, 
			net__http__CommonHeader__content_range, 
			net__http__CommonHeader__content_security_policy, 
			net__http__CommonHeader__content_security_policy_report_only, 
			net__http__CommonHeader__content_type, 
			net__http__CommonHeader__cookie, 
			net__http__CommonHeader__cross_origin_embedder_policy, 
			net__http__CommonHeader__cross_origin_opener_policy, 
			net__http__CommonHeader__cross_origin_resource_policy, 
			net__http__CommonHeader__date, 
			net__http__CommonHeader__device_memory, 
			net__http__CommonHeader__digest, 
			net__http__CommonHeader__dnt, 
			net__http__CommonHeader__early_data, 
			net__http__CommonHeader__etag, 
			net__http__CommonHeader__expect, 
			net__http__CommonHeader__expect_ct, 
			net__http__CommonHeader__expires, 
			net__http__CommonHeader__feature_policy, 
			net__http__CommonHeader__forwarded, 
			net__http__CommonHeader__from, 
			net__http__CommonHeader__host, 
			net__http__CommonHeader__if_match, 
			net__http__CommonHeader__if_modified_since, 
			net__http__CommonHeader__if_none_match, 
			net__http__CommonHeader__if_range, 
			net__http__CommonHeader__if_unmodified_since, 
			net__http__CommonHeader__index, 
			net__http__CommonHeader__keep_alive, 
			net__http__CommonHeader__large_allocation, 
			net__http__CommonHeader__last_modified, 
			net__http__CommonHeader__link, 
			net__http__CommonHeader__location, 
			net__http__CommonHeader__nel, 
			net__http__CommonHeader__origin, 
			net__http__CommonHeader__pragma, 
			net__http__CommonHeader__proxy_authenticate, 
			net__http__CommonHeader__proxy_authorization, 
			net__http__CommonHeader__range, 
			net__http__CommonHeader__referer, 
			net__http__CommonHeader__referrer_policy, 
			net__http__CommonHeader__retry_after, 
			net__http__CommonHeader__save_data, 
			net__http__CommonHeader__sec_fetch_dest, 
			net__http__CommonHeader__sec_fetch_mode, 
			net__http__CommonHeader__sec_fetch_site, 
			net__http__CommonHeader__sec_fetch_user, 
			net__http__CommonHeader__sec_websocket_accept, 
			net__http__CommonHeader__server, 
			net__http__CommonHeader__server_timing, 
			net__http__CommonHeader__set_cookie, 
			net__http__CommonHeader__sourcemap, 
			net__http__CommonHeader__strict_transport_security, 
			net__http__CommonHeader__te, 
			net__http__CommonHeader__timing_allow_origin, 
			net__http__CommonHeader__tk, 
			net__http__CommonHeader__trailer, 
			net__http__CommonHeader__transfer_encoding, 
			net__http__CommonHeader__upgrade, 
			net__http__CommonHeader__upgrade_insecure_requests, 
			net__http__CommonHeader__user_agent, 
			net__http__CommonHeader__vary, 
			net__http__CommonHeader__via, 
			net__http__CommonHeader__want_digest, 
			net__http__CommonHeader__warning, 
			net__http__CommonHeader__www_authenticate, 
			net__http__CommonHeader__x_content_type_options, 
			net__http__CommonHeader__x_dns_prefetch_control, 
			net__http__CommonHeader__x_forwarded_for, 
			net__http__CommonHeader__x_forwarded_host, 
			net__http__CommonHeader__x_forwarded_proto, 
			net__http__CommonHeader__x_frame_options, 
			net__http__CommonHeader__x_xss_protection, 
		})
	)

;
	// Initializations of consts for module net.websocket
	_const_net__websocket__invalid_close_codes = new_array_from_c_array_noscan(12, 12, sizeof(int), _MOV((int[12]){
		999, 1004, 1005, 1006, 1014, 1015, 1016, 1100, 2000,
		2999, 5000, 65536}));
	_const_net__websocket__empty_bytearr = __new_array_with_default_noscan(0, 0, sizeof(u8), 0);
	// Initializations of consts for module discord
	_const_discord__default_user_agent =  str_intp(2, _MOV((StrIntpData[]){{_SLIT("DiscordBot (https://github.com/DarpHome/discord.v, 10.0.0) V "), /*115 &string*/0xfe10, {.d_s = _SLIT("140c838")}}, {_SLIT0, 0, { .d_c = 0 }}}));
	_const_discord__all_intents = discord__combine_intents(new_array_from_c_array_noscan(19, 19, sizeof(discord__Intents), _MOV((discord__Intents[19]){discord__Intents__guilds, discord__Intents__guild_members, discord__Intents__guild_moderation, discord__Intents__guild_emojis_and_stickers, discord__Intents__guild_integrations, discord__Intents__guild_webhooks, discord__Intents__guild_invites, discord__Intents__guild_voice_states, discord__Intents__guild_presences, discord__Intents__guild_messages, discord__Intents__guild_message_reactions, discord__Intents__guild_message_typing, discord__Intents__direct_messages, discord__Intents__direct_message_reactions, discord__Intents__direct_message_typing, discord__Intents__message_content, discord__Intents__guild_scheduled_events, discord__Intents__auto_moderation_configuration, discord__Intents__auto_moderation_execution})));
}
void _vcleanup(void) {
}

int wmain(int ___argc, wchar_t* ___argv[], wchar_t* ___envp[]){
	g_main_argc = ___argc;
	g_main_argv = ___argv;
__closure_init();
#if defined(_VGCBOEHM)
	GC_set_pages_executable(0);
	GC_INIT();
#endif
	_vinit(___argc, (voidptr)___argv);
	main__main();
	_vcleanup();
	return 0;
}

// THE END.
